<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-Regex-Engine 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269#include "stdafx.h"#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;#define TYPE intenum ColorFlag &#123;RED, BLACK&#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode *left; RBTreeNode *right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;left; RBTreeNode&lt;T&gt; *q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;right; RBTreeNode&lt;T&gt; *q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt; *&amp;ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt; *root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt; *p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt; *p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt; *ptr = root; RBTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt; *DelRB(RBTreeNode&lt;T&gt; *root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt; *p = root; stack&lt;RBTreeNode&lt;T&gt; *&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt; *parent = nullptr; RBTreeNode&lt;T&gt; *q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt; *InsertRB(RBTreeNode&lt;T&gt; *root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt; *&gt; stackforflashback; RBTreeNode&lt;T&gt; *p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt; *q = nullptr; RBTreeNode&lt;T&gt; *g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt; *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt; *ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt; *p; int direction; int last; memory(RBTreeNode&lt;T&gt; *p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt; *root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入"&lt;&lt; *p &lt;&lt;endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt; *&gt; *keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt; *&gt; *keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt; *leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt; *root, BPlusTreeNode&lt;T&gt; *head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt; *p; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first ) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt; * ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt; * root, BPlusTreeNode&lt;T&gt; * head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008#include "stdafx.h"#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode *left; AVLNode *right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;left; AVLNode&lt;T&gt; *q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;right; AVLNode&lt;T&gt; *q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt; *&amp;ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt; *root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt; *p; int direction; temp minmax; int lh= 0; //节点左子树高度 int rh= 0; //节点右子树高度 memory(AVLNode&lt;T&gt; *p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt; *ptr = root; AVLNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt; *DelAVL(AVLNode&lt;T&gt; *root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt; *p = root; stack&lt;AVLNode&lt;T&gt; *&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt; *parent = nullptr; AVLNode&lt;T&gt; *q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; //情形b &#125; else &#123; return root; &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; //情形b &#125; else &#123; return root; &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt; *InsertAVL(AVLNode&lt;T&gt; *root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt; *&gt; stackforflashback; AVLNode&lt;T&gt; *p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = new AVLNode&lt;T&gt;(0, key); //新节点插入并调整父节点平衡因子 --stackforflashback.top()-&gt;bf; &#125; else &#123; stackforflashback.top()-&gt;right = new AVLNode&lt;T&gt;(0, key); ++stackforflashback.top()-&gt;bf; &#125; if (stackforflashback.top()-&gt;bf == 0) &#123; return root; //已平衡结束,返回根节点 &#125; else &#123; p = stackforflashback.top(); stackforflashback.pop(); if (stackforflashback.empty() == false) &#123; AVLNode&lt;T&gt; *parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if(parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt; *q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt; *q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125; else &#123; return p; //原AVL树已平衡,返回根节点,结束 &#125; &#125; &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt; *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt; *ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt; *p; int direction; int last; memory(AVLNode&lt;T&gt; *p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt;ptr-&gt;data&lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last ==2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt;"("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data&lt;&lt;"("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; AVLNode&lt;TYPE&gt; *root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; a[i]=temp; number[a[i]-1]=1; &#125; else &#123; a[i]=temp; number[a[i]-1]=1; &#125; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
