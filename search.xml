<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-Regex-Engine 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269#include "stdafx.h"#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;#define TYPE intenum ColorFlag &#123;RED, BLACK&#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode *left; RBTreeNode *right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;left; RBTreeNode&lt;T&gt; *q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;right; RBTreeNode&lt;T&gt; *q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt; *&amp;ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt; *root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt; *p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt; *p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt; *ptr = root; RBTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt; *DelRB(RBTreeNode&lt;T&gt; *root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt; *p = root; stack&lt;RBTreeNode&lt;T&gt; *&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt; *parent = nullptr; RBTreeNode&lt;T&gt; *q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt; *InsertRB(RBTreeNode&lt;T&gt; *root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt; *&gt; stackforflashback; RBTreeNode&lt;T&gt; *p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt; *q = nullptr; RBTreeNode&lt;T&gt; *g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt; *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt; *ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt; *p; int direction; int last; memory(RBTreeNode&lt;T&gt; *p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt; *root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入"&lt;&lt; *p &lt;&lt;endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt; *&gt; *keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt; *&gt; *keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt; *leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt; *root, BPlusTreeNode&lt;T&gt; *head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt; *p; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first ) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt; * ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt; * root, BPlusTreeNode&lt;T&gt; * head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008#include "stdafx.h"#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode *left; AVLNode *right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;left; AVLNode&lt;T&gt; *q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;right; AVLNode&lt;T&gt; *q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt; *&amp;ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt; *root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt; *p; int direction; temp minmax; int lh= 0; //节点左子树高度 int rh= 0; //节点右子树高度 memory(AVLNode&lt;T&gt; *p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt; *ptr = root; AVLNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt; *DelAVL(AVLNode&lt;T&gt; *root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt; *p = root; stack&lt;AVLNode&lt;T&gt; *&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt; *parent = nullptr; AVLNode&lt;T&gt; *q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; //情形b &#125; else &#123; return root; &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; //情形b &#125; else &#123; return root; &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt; *InsertAVL(AVLNode&lt;T&gt; *root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt; *&gt; stackforflashback; AVLNode&lt;T&gt; *p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = new AVLNode&lt;T&gt;(0, key); //新节点插入并调整父节点平衡因子 --stackforflashback.top()-&gt;bf; &#125; else &#123; stackforflashback.top()-&gt;right = new AVLNode&lt;T&gt;(0, key); ++stackforflashback.top()-&gt;bf; &#125; if (stackforflashback.top()-&gt;bf == 0) &#123; return root; //已平衡结束,返回根节点 &#125; else &#123; p = stackforflashback.top(); stackforflashback.pop(); if (stackforflashback.empty() == false) &#123; AVLNode&lt;T&gt; *parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if(parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt; *q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt; *q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125; else &#123; return p; //原AVL树已平衡,返回根节点,结束 &#125; &#125; &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt; *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt; *ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt; *p; int direction; int last; memory(AVLNode&lt;T&gt; *p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt;ptr-&gt;data&lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last ==2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt;"("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data&lt;&lt;"("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; AVLNode&lt;TYPE&gt; *root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
