<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fnaturerun%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fnaturerun%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; if (cur_value == *cur-&gt;max) &#123; return true; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fnaturerun%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fnaturerun%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fnaturerun%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fnaturerun%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fnaturerun%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fnaturerun%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fnaturerun%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fnaturerun%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fnaturerun%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fnaturerun%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fnaturerun%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fnaturerun%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-RE-ENGINE 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fnaturerun%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R(根据深度优先搜索的白色路径定理,R必定存在)，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fnaturerun%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fnaturerun%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;random&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode* p = nullptr; vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt;* ptr, pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt;* root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt;* p; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt;* p, const pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt;* ptr = root; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; result; if ((result = SerachBTreeNode(ptr, d)) == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* interval = nullptr; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (result != pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = result.first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;bool compare(const pair&lt;T, BTreeNode&lt;T&gt;*&gt; &amp;left, const pair&lt;T, BTreeNode&lt;T&gt;*&gt; &amp;right)&#123; return left.first &lt; right.first;&#125;template &lt;typename T&gt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator Upper_Bound(const T&amp; key, vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;&amp; list)&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = list.begin(); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator right = list.end() - 1; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt;= (*mid).first) &#123; if (mid == list.begin()) &#123; return left; &#125; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* InsertBTree(BTreeNode&lt;T&gt;* root, const T &amp;key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.push_back(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;keyptrmap); if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(scankey, make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.push_back(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt;* ptr = new BTreeNode&lt;T&gt;; ptr-&gt;keyptrmap.insert(ptr-&gt;keyptrmap.end(), current-&gt;keyptrmap.end() - M / 2, current-&gt;keyptrmap.end()); current-&gt;keyptrmap.erase(current-&gt;keyptrmap.end() - M / 2, current-&gt;keyptrmap.end()); ptr-&gt;p = current-&gt;keyptrmap.back().second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = current; root-&gt;keyptrmap.push_back(make_pair(current-&gt;keyptrmap.back().first, ptr)); current-&gt;keyptrmap.pop_back(); return root; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = stackforback.top().first-&gt;keyptrmap.insert(stackforback.top().second, make_pair(current-&gt;keyptrmap.back().first, ptr)); current-&gt;keyptrmap.pop_back(); if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* DelBTree(BTreeNode&lt;T&gt;* root, const T &amp;key) //B树删除函数&#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;keyptrmap); if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt;* q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; scankey-&gt;first = q-&gt;keyptrmap.front().first; q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt;* ptr = temp-&gt;second; temp-&gt;first = ptr-&gt;keyptrmap.front().first; ptr-&gt;p = ptr-&gt;keyptrmap.front().second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(current-&gt;keyptrmap.end(), temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; delete root; return current; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt;* ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator before = temp - 1; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), make_pair(temp-&gt;first, current-&gt;p)); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = ptr-&gt;keyptrmap.end() - 1; current-&gt;p = left-&gt;second; temp-&gt;first = left-&gt;first; ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(ptr-&gt;keyptrmap.end(), current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; delete root; return ptr; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; const int N = 45; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fnaturerun%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则同样交换g和p,r的颜色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则同样交换g和p,r颜色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (q == g-&gt;left) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 10; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fnaturerun%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;random&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;vector&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;* keyandptr; //叶节点指针域和数据域 vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;* keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;vector&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(vector&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt;* leaf)&#123; typename vector&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end() - 1; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt;* p; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename vector&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;bool compare(const pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&amp; left, const pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&amp; right)&#123; return left.first &lt; right.first;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; temp-&gt;first = key; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; BinarySearch(vector&lt;T&gt; &amp;list, typename vector&lt;T&gt;::iterator left, typename vector&lt;T&gt;::iterator right, const T&amp; key)&#123; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;T&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt; *mid) &#123; if (mid == list.begin()) &#123; return &#123; false, left &#125;; &#125; right = mid - 1; &#125; else if (key &gt; * mid) &#123; left = mid + 1; &#125; else &#123; return &#123; true, mid &#125;; &#125; &#125; return &#123; false, left &#125;;&#125;template &lt;typename T&gt; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator Upper_Bound(const T &amp;key, vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt; &amp;list)&#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator left = list.begin(); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator right = list.end() - 1; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt;= (*mid).first) &#123; if (mid == list.begin()) &#123; return left; &#125; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, const T &amp;key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.push_back(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, *(current-&gt;keyptrmap)); if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = scankey-&gt;second; &#125; &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; result = BinarySearch(current-&gt;keyandptr-&gt;first, current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end() - 1, key); if (result.first == false) &#123; current-&gt;keyandptr-&gt;first.insert(result.second, key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; if (current != root &amp;&amp; key == current-&gt;keyandptr-&gt;first.back()) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); ptr-&gt;keyandptr-&gt;first.insert(ptr-&gt;keyandptr-&gt;first.end(), current-&gt;keyandptr-&gt;first.end() - (M + 1) / 2, current-&gt;keyandptr-&gt;first.end()); current-&gt;keyandptr-&gt;first.erase(current-&gt;keyandptr-&gt;first.end() - (M + 1) / 2, current-&gt;keyandptr-&gt;first.end()); ptr-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; current-&gt;keyandptr-&gt;second = ptr; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); root-&gt;keyptrmap-&gt;push_back(make_pair(current-&gt;keyandptr-&gt;first.back(), current)); root-&gt;keyptrmap-&gt;push_back(make_pair(ptr-&gt;keyandptr-&gt;first.back(), ptr)); return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;T&gt;::iterator temp = ptr-&gt;keyandptr-&gt;first.end() - 1; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second, make_pair(*temp, ptr)); stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;end(); (stackforback.top().second - 2)-&gt;first = *(current-&gt;keyandptr-&gt;first.end() - 1); &#125; else &#123; stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second + 1, make_pair(*temp, ptr)); --stackforback.top().second; stackforback.top().second-&gt;first = *(current-&gt;keyandptr-&gt;first.end() - 1); &#125; if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.pop(); updatemax(stackforback, ptr-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); ptr-&gt;keyptrmap-&gt;insert(ptr-&gt;keyptrmap-&gt;end(), current-&gt;keyptrmap-&gt;end() - (M + 1) / 2, current-&gt;keyptrmap-&gt;end()); current-&gt;keyptrmap-&gt;erase(current-&gt;keyptrmap-&gt;end() - (M + 1) / 2, current-&gt;keyptrmap-&gt;end()); if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); root-&gt;keyptrmap-&gt;push_back(make_pair(current-&gt;keyptrmap-&gt;back().first, current)); root-&gt;keyptrmap-&gt;push_back(make_pair(ptr-&gt;keyptrmap-&gt;back().first, ptr)); return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end() - 1; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second, make_pair(temp-&gt;first, ptr)); stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;end(); (stackforback.top().second - 2)-&gt;first = current-&gt;keyptrmap-&gt;back().first; &#125; else &#123; stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second + 1, make_pair(temp-&gt;first, ptr)); --stackforback.top().second; stackforback.top().second-&gt;first = current-&gt;keyptrmap-&gt;back().first; &#125; if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.pop(); updatemax(stackforback, ptr-&gt;keyptrmap-&gt;back().first); &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, const T &amp;key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, *(current-&gt;keyptrmap)); if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; stackforback.push(make_pair(current, scankey)); current = scankey-&gt;second; &#125; &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; result = BinarySearch(current-&gt;keyandptr-&gt;first, current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end() - 1, key); if (result.first == false) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(result.second); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; if (current-&gt;keyandptr-&gt;first.back() &lt; key) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.push_back(temp-&gt;second-&gt;keyandptr-&gt;first.front()); stackforback.top().second-&gt;first = temp-&gt;second-&gt;keyandptr-&gt;first.front(); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.end(), temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); current-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); stackforback.top().second-&gt;first = current-&gt;keyandptr-&gt;first.back(); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; temp = temp - 2; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.back()); BPlusTreeNode&lt;T&gt;* pre = temp-&gt;second; pre-&gt;keyandptr-&gt;first.pop_back(); temp-&gt;first = pre-&gt;keyandptr-&gt;first.back(); if (current-&gt;keyandptr-&gt;first.back() &lt; key) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.end(), current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); temp-&gt;second-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; temp-&gt;first = temp-&gt;second-&gt;keyandptr-&gt;first.back(); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; else &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.back() &lt; key) &#123; stackforback.pop(); updatemax(stackforback, temp-&gt;second-&gt;keyandptr-&gt;first.back()); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; while (true) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;push_back(temp-&gt;second-&gt;keyptrmap-&gt;front()); stackforback.top().second-&gt;first = temp-&gt;second-&gt;keyptrmap-&gt;front().first; temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;end(), temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().second-&gt;first = current-&gt;keyptrmap-&gt;back().first; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; temp = temp - 2; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;back()); BPlusTreeNode&lt;T&gt;* pre = temp-&gt;second; pre-&gt;keyptrmap-&gt;pop_back(); temp-&gt;first = pre-&gt;keyptrmap-&gt;back().first; if (current-&gt;keyptrmap-&gt;back().first &lt; key) &#123; updatemax(stackforback, current-&gt;keyptrmap-&gt;back().first); &#125; return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;end(), current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); temp-&gt;first = temp-&gt;second-&gt;keyptrmap-&gt;back().first; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator it = temp-&gt;second-&gt;keyptrmap-&gt;end() - 1; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; else &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;back().first &lt; key) &#123; stackforback.pop(); updatemax(stackforback, temp-&gt;second-&gt;keyptrmap-&gt;back().first); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; const int N = 56; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; else &#123; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fnaturerun%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fnaturerun%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fnaturerun%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fnaturerun%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fnaturerun%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fnaturerun%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fnaturerun%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fnaturerun%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fnaturerun%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，但是仍然可以继续化简，注意到代码四第25行k==0为真时完全可以继续执行k=next[k],最后会在21行执行next[++j]==0,效果和第25行为真时执行next[++j]=0完全相同，故25-28行可统一写为k=next[k],从而得到形式最为简洁的代码五 1234567891011121314151617181920212223242526272829303132333435package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 这(代码五)就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fnaturerun%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fnaturerun%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fnaturerun%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fnaturerun%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fnaturerun%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fnaturerun%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fnaturerun%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fnaturerun%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fnaturerun%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fnaturerun%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fnaturerun%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fnaturerun%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fnaturerun%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fnaturerun%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fnaturerun%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fnaturerun%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fnaturerun%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个2的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void selectPushedObject(int &amp;x1, int &amp;x2, int ScaleOfProblems, int *&amp;p, int &amp;i)&#123; if ((x1 != ScaleOfProblems) &amp;&amp; (x1 + x2 + 1 != 2 * ScaleOfProblems)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125;&#125;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int* p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int*)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = 0; x1 = 1; x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count p[i] = 1; //首次入栈，栈空,关键变量值已在上方确定,1首先入栈,x1自增1 while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; //非首次入栈栈不空 if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; selectPushedObject(x1, x2, n, p, i); &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; selectPushedObject(x1, x2, n, p, i); &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fnaturerun%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
</search>
