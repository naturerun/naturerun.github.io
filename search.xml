<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-Regex-Engine 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269#include "stdafx.h"#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;#define TYPE intenum ColorFlag &#123;RED, BLACK&#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode *left; RBTreeNode *right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;left; RBTreeNode&lt;T&gt; *q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;right; RBTreeNode&lt;T&gt; *q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt; *&amp;ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt; *root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt; *p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt; *p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt; *ptr = root; RBTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt; *DelRB(RBTreeNode&lt;T&gt; *root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt; *p = root; stack&lt;RBTreeNode&lt;T&gt; *&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt; *parent = nullptr; RBTreeNode&lt;T&gt; *q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt; *InsertRB(RBTreeNode&lt;T&gt; *root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt; *&gt; stackforflashback; RBTreeNode&lt;T&gt; *p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt; *q = nullptr; RBTreeNode&lt;T&gt; *g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt; *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt; *ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt; *p; int direction; int last; memory(RBTreeNode&lt;T&gt; *p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt; *root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入"&lt;&lt; *p &lt;&lt;endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt; *&gt; *keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt; *&gt; *keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt; *leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt; *root, BPlusTreeNode&lt;T&gt; *head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt; *p; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first ) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt; * ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt; * root, BPlusTreeNode&lt;T&gt; * head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008#include "stdafx.h"#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode *left; AVLNode *right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;left; AVLNode&lt;T&gt; *q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;right; AVLNode&lt;T&gt; *q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt; *&amp;ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt; *root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt; *p; int direction; temp minmax; int lh= 0; //节点左子树高度 int rh= 0; //节点右子树高度 memory(AVLNode&lt;T&gt; *p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt; *ptr = root; AVLNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt; *DelAVL(AVLNode&lt;T&gt; *root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt; *p = root; stack&lt;AVLNode&lt;T&gt; *&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt; *parent = nullptr; AVLNode&lt;T&gt; *q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; //情形b &#125; else &#123; return root; &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; //情形b &#125; else &#123; return root; &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt; *InsertAVL(AVLNode&lt;T&gt; *root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt; *&gt; stackforflashback; AVLNode&lt;T&gt; *p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = new AVLNode&lt;T&gt;(0, key); //新节点插入并调整父节点平衡因子 --stackforflashback.top()-&gt;bf; &#125; else &#123; stackforflashback.top()-&gt;right = new AVLNode&lt;T&gt;(0, key); ++stackforflashback.top()-&gt;bf; &#125; if (stackforflashback.top()-&gt;bf == 0) &#123; return root; //已平衡结束,返回根节点 &#125; else &#123; p = stackforflashback.top(); stackforflashback.pop(); if (stackforflashback.empty() == false) &#123; AVLNode&lt;T&gt; *parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if(parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt; *q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt; *q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125; else &#123; return p; //原AVL树已平衡,返回根节点,结束 &#125; &#125; &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt; *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt; *ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt; *p; int direction; int last; memory(AVLNode&lt;T&gt; *p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt;ptr-&gt;data&lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last ==2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt;"("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data&lt;&lt;"("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; AVLNode&lt;TYPE&gt; *root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
