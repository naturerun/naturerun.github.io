<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-RE-ENGINE 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;random&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode* p = nullptr; vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt;* ptr, pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt;* root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt;* p; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt;* p, const pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt;* ptr = root; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; result; if ((result = SerachBTreeNode(ptr, d)) == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* interval = nullptr; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (result != pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = result.first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;bool compare(const pair&lt;T, BTreeNode&lt;T&gt;*&gt; &amp;left, const pair&lt;T, BTreeNode&lt;T&gt;*&gt; &amp;right)&#123; return left.first &lt; right.first;&#125;template &lt;typename T&gt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator Upper_Bound(const T&amp; key, vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;&amp; list)&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = list.begin(); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator right = list.end() - 1; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt;= (*mid).first) &#123; if (mid == list.begin()) &#123; return left; &#125; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* InsertBTree(BTreeNode&lt;T&gt;* root, const T &amp;key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.push_back(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;keyptrmap); if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(scankey, make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.push_back(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt;* ptr = new BTreeNode&lt;T&gt;; ptr-&gt;keyptrmap.insert(ptr-&gt;keyptrmap.end(), current-&gt;keyptrmap.end() - M / 2, current-&gt;keyptrmap.end()); current-&gt;keyptrmap.erase(current-&gt;keyptrmap.end() - M / 2, current-&gt;keyptrmap.end()); ptr-&gt;p = current-&gt;keyptrmap.back().second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = current; root-&gt;keyptrmap.push_back(make_pair(current-&gt;keyptrmap.back().first, ptr)); current-&gt;keyptrmap.pop_back(); return root; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator it = stackforback.top().first-&gt;keyptrmap.insert(stackforback.top().second, make_pair(current-&gt;keyptrmap.back().first, ptr)); current-&gt;keyptrmap.pop_back(); if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* DelBTree(BTreeNode&lt;T&gt;* root, const T &amp;key) //B树删除函数&#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;keyptrmap); if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt;* q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; scankey-&gt;first = q-&gt;keyptrmap.front().first; q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt;* ptr = temp-&gt;second; temp-&gt;first = ptr-&gt;keyptrmap.front().first; ptr-&gt;p = ptr-&gt;keyptrmap.front().second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(current-&gt;keyptrmap.end(), temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; delete root; return current; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt;* ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator before = temp - 1; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), make_pair(temp-&gt;first, current-&gt;p)); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = ptr-&gt;keyptrmap.end() - 1; current-&gt;p = left-&gt;second; temp-&gt;first = left-&gt;first; ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(ptr-&gt;keyptrmap.end(), current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; delete root; return ptr; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; const int N = 45; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (q == g-&gt;left) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 10; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;random&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;vector&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;* keyandptr; //叶节点指针域和数据域 vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;* keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;vector&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(vector&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt;* leaf)&#123; typename vector&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end() - 1; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt;* p; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename vector&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;bool compare(const pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&amp; left, const pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&amp; right)&#123; return left.first &lt; right.first;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; temp-&gt;first = key; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; BinarySearch(vector&lt;T&gt; &amp;list, typename vector&lt;T&gt;::iterator left, typename vector&lt;T&gt;::iterator right, const T&amp; key)&#123; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;T&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt; *mid) &#123; if (mid == list.begin()) &#123; return &#123; false, left &#125;; &#125; right = mid - 1; &#125; else if (key &gt; * mid) &#123; left = mid + 1; &#125; else &#123; return &#123; true, mid &#125;; &#125; &#125; return &#123; false, left &#125;;&#125;template &lt;typename T&gt; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator Upper_Bound(const T &amp;key, vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt; &amp;list)&#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator left = list.begin(); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator right = list.end() - 1; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt;= (*mid).first) &#123; if (mid == list.begin()) &#123; return left; &#125; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, const T &amp;key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.push_back(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, *(current-&gt;keyptrmap)); if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = scankey-&gt;second; &#125; &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; result = BinarySearch(current-&gt;keyandptr-&gt;first, current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end() - 1, key); if (result.first == false) &#123; current-&gt;keyandptr-&gt;first.insert(result.second, key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; if (current != root &amp;&amp; key == current-&gt;keyandptr-&gt;first.back()) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); ptr-&gt;keyandptr-&gt;first.insert(ptr-&gt;keyandptr-&gt;first.end(), current-&gt;keyandptr-&gt;first.end() - (M + 1) / 2, current-&gt;keyandptr-&gt;first.end()); current-&gt;keyandptr-&gt;first.erase(current-&gt;keyandptr-&gt;first.end() - (M + 1) / 2, current-&gt;keyandptr-&gt;first.end()); ptr-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; current-&gt;keyandptr-&gt;second = ptr; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); root-&gt;keyptrmap-&gt;push_back(make_pair(current-&gt;keyandptr-&gt;first.back(), current)); root-&gt;keyptrmap-&gt;push_back(make_pair(ptr-&gt;keyandptr-&gt;first.back(), ptr)); return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;T&gt;::iterator temp = ptr-&gt;keyandptr-&gt;first.end() - 1; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second, make_pair(*temp, ptr)); stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;end(); (stackforback.top().second - 2)-&gt;first = *(current-&gt;keyandptr-&gt;first.end() - 1); &#125; else &#123; stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second + 1, make_pair(*temp, ptr)); --stackforback.top().second; stackforback.top().second-&gt;first = *(current-&gt;keyandptr-&gt;first.end() - 1); &#125; if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.pop(); updatemax(stackforback, ptr-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); ptr-&gt;keyptrmap-&gt;insert(ptr-&gt;keyptrmap-&gt;end(), current-&gt;keyptrmap-&gt;end() - (M + 1) / 2, current-&gt;keyptrmap-&gt;end()); current-&gt;keyptrmap-&gt;erase(current-&gt;keyptrmap-&gt;end() - (M + 1) / 2, current-&gt;keyptrmap-&gt;end()); if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); root-&gt;keyptrmap-&gt;push_back(make_pair(current-&gt;keyptrmap-&gt;back().first, current)); root-&gt;keyptrmap-&gt;push_back(make_pair(ptr-&gt;keyptrmap-&gt;back().first, ptr)); return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end() - 1; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second, make_pair(temp-&gt;first, ptr)); stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;end(); (stackforback.top().second - 2)-&gt;first = current-&gt;keyptrmap-&gt;back().first; &#125; else &#123; stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second + 1, make_pair(temp-&gt;first, ptr)); --stackforback.top().second; stackforback.top().second-&gt;first = current-&gt;keyptrmap-&gt;back().first; &#125; if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.pop(); updatemax(stackforback, ptr-&gt;keyptrmap-&gt;back().first); &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, const T &amp;key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, *(current-&gt;keyptrmap)); if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; stackforback.push(make_pair(current, scankey)); current = scankey-&gt;second; &#125; &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; result = BinarySearch(current-&gt;keyandptr-&gt;first, current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end() - 1, key); if (result.first == false) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(result.second); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; if (current-&gt;keyandptr-&gt;first.back() &lt; key) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.push_back(temp-&gt;second-&gt;keyandptr-&gt;first.front()); stackforback.top().second-&gt;first = temp-&gt;second-&gt;keyandptr-&gt;first.front(); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.end(), temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); current-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); stackforback.top().second-&gt;first = current-&gt;keyandptr-&gt;first.back(); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; temp = temp - 2; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.back()); BPlusTreeNode&lt;T&gt;* pre = temp-&gt;second; pre-&gt;keyandptr-&gt;first.pop_back(); temp-&gt;first = pre-&gt;keyandptr-&gt;first.back(); if (current-&gt;keyandptr-&gt;first.back() &lt; key) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.end(), current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); temp-&gt;second-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; temp-&gt;first = temp-&gt;second-&gt;keyandptr-&gt;first.back(); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; else &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.back() &lt; key) &#123; stackforback.pop(); updatemax(stackforback, temp-&gt;second-&gt;keyandptr-&gt;first.back()); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; while (true) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;push_back(temp-&gt;second-&gt;keyptrmap-&gt;front()); stackforback.top().second-&gt;first = temp-&gt;second-&gt;keyptrmap-&gt;front().first; temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;end(), temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().second-&gt;first = current-&gt;keyptrmap-&gt;back().first; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; temp = temp - 2; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;back()); BPlusTreeNode&lt;T&gt;* pre = temp-&gt;second; pre-&gt;keyptrmap-&gt;pop_back(); temp-&gt;first = pre-&gt;keyptrmap-&gt;back().first; if (current-&gt;keyptrmap-&gt;back().first &lt; key) &#123; updatemax(stackforback, current-&gt;keyptrmap-&gt;back().first); &#125; return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;end(), current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); temp-&gt;first = temp-&gt;second-&gt;keyptrmap-&gt;back().first; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator it = temp-&gt;second-&gt;keyptrmap-&gt;end() - 1; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; else &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;back().first &lt; key) &#123; stackforback.pop(); updatemax(stackforback, temp-&gt;second-&gt;keyptrmap-&gt;back().first); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; const int N = 56; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; else &#123; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
