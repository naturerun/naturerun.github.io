<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-Regex-Engine 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt; *&gt; *keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt; *&gt; *keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt; *leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt; *root, BPlusTreeNode&lt;T&gt; *head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt; *p; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first ) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt; * ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt; * root, BPlusTreeNode&lt;T&gt; * head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
