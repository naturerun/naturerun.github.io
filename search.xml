<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; if (cur_value == *cur-&gt;max) &#123; return true; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-RE-ENGINE 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R(根据深度优先搜索的白色路径定理,R必定存在)，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;random&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; struct BranchNode &#123; BTreeNode* p; vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt; keyptrmap; //节点数据域和指针域 BranchNode() :keyptrmap(), p(nullptr) &#123;&#125; &#125;; union &#123; vector&lt;T&gt; *leaf_data; BranchNode* branch_data; &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BTreeNode(flag type_of_node) &#123; NodeFlag = type_of_node; if (type_of_node == branch) &#123; branch_data = new BranchNode(); &#125; else &#123; leaf_data = new vector&lt;T&gt;(); &#125; &#125; ~BTreeNode() &#123; if (NodeFlag == branch) &#123; delete branch_data; &#125; else &#123; delete leaf_data; &#125; &#125;&#125;;template &lt;typename T&gt;pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; SearchBTreeNode(BTreeNode&lt;T&gt;* ptr, pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;branch_data-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;branch_data-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;branch_data-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;branch_data-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt;* root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt;* p; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt;* p, const pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt;* ptr = root; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d; if (ptr-&gt;NodeFlag != BTreeNode&lt;T&gt;::flag::leaf) &#123; d.first = ptr-&gt;branch_data-&gt;keyptrmap.end(); d.second = true; &#125; BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; result; if (ptr-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::leaf ? true : (result = SearchBTreeNode(ptr, d)) == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;leaf_data-&gt;size() &amp;&amp; ptr-&gt;leaf_data-&gt;size() &lt;= M - 1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;branch_data-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;branch_data-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;branch_data-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;leaf_data-&gt;size() &amp;&amp; ptr-&gt;leaf_data-&gt;size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;branch_data-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;branch_data-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;leaf_data-&gt;begin()); arrange.top().minmax.min = *(ptr-&gt;leaf_data-&gt;begin()); typename vector&lt;T&gt;::iterator it = ptr-&gt;leaf_data-&gt;end(); --it; arrange.top().minmax.max = *it; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; typename vector&lt;T&gt;::iterator it = ptr-&gt;leaf_data-&gt;end(); --it; arrange.top().minmax.nodemax = *(it); arrange.top().minmax.min = *(ptr-&gt;leaf_data-&gt;begin()); arrange.top().minmax.max = *it; &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;leaf_data-&gt;begin()); typename vector&lt;T&gt;::iterator it = ptr-&gt;leaf_data-&gt;end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;branch_data-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;branch_data-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;branch_data-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;branch_data-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;branch_data-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* interval = nullptr; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), true)) &#123; if (result != pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SearchBTreeNode(ptr, d))); interval = ptr-&gt;branch_data-&gt;p; ++level; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = result.first; if (d.first == ptr-&gt;branch_data-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;branch_data-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BTreeNode&lt;T&gt;::flag::leaf) &#123; d = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), true); &#125; &#125; &#125;&#125;template &lt;typename T&gt;bool compare(const pair&lt;T, BTreeNode&lt;T&gt;*&gt;&amp; left, const pair&lt;T, BTreeNode&lt;T&gt;*&gt;&amp; right)&#123; return left.first &lt; right.first;&#125;template &lt;typename T&gt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator Upper_Bound(const T&amp; key, vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;&amp; list)&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = list.begin(); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator right = list.end() - 1; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt;= (*mid).first) &#123; if (mid == list.begin()) &#123; return left; &#125; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;template &lt;typename T&gt;pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; BinarySearch(vector&lt;T&gt;&amp; list, typename vector&lt;T&gt;::iterator left, typename vector&lt;T&gt;::iterator right, const T&amp; key)&#123; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;T&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt; *mid) &#123; if (mid == list.begin()) &#123; return &#123; false, left &#125;; &#125; right = mid - 1; &#125; else if (key &gt; * mid) &#123; left = mid + 1; &#125; else &#123; return &#123; true, mid &#125;; &#125; &#125; return &#123; false, left &#125;;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* InsertBTree(BTreeNode&lt;T&gt;* root, const T&amp; key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;(BTreeNode&lt;T&gt;::flag::leaf); root-&gt;leaf_data-&gt;push_back(key); return root; &#125; else &#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::branch) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;branch_data-&gt;keyptrmap); if (scankey != current-&gt;branch_data-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;branch_data-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;branch_data-&gt;p; &#125; &#125; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; scankey = BinarySearch(*current-&gt;leaf_data, current-&gt;leaf_data-&gt;begin(), current-&gt;leaf_data-&gt;end() - 1, key); if (scankey.first) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; current-&gt;leaf_data-&gt;insert(scankey.second, key); &#125; if (current-&gt;leaf_data-&gt;size() &lt;= M - 1) &#123; return root; &#125; else &#123; BTreeNode&lt;T&gt;* ptr = new BTreeNode&lt;T&gt;(BTreeNode&lt;T&gt;::flag::leaf); ptr-&gt;leaf_data-&gt;insert(ptr-&gt;leaf_data-&gt;end(), current-&gt;leaf_data-&gt;end() - M / 2, current-&gt;leaf_data-&gt;end()); current-&gt;leaf_data-&gt;erase(current-&gt;leaf_data-&gt;end() - M / 2, current-&gt;leaf_data-&gt;end()); if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;(BTreeNode&lt;T&gt;::flag::branch); root-&gt;branch_data-&gt;p = current; root-&gt;branch_data-&gt;keyptrmap.push_back(make_pair(current-&gt;leaf_data-&gt;back(), ptr)); current-&gt;leaf_data-&gt;pop_back(); return root; &#125; else &#123; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.insert(stackforback.top().second, make_pair(current-&gt;leaf_data-&gt;back(), ptr)); current-&gt;leaf_data-&gt;pop_back(); if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; while (true) &#123; BTreeNode&lt;T&gt;* ptr = new BTreeNode&lt;T&gt;(BTreeNode&lt;T&gt;::flag::branch); ptr-&gt;branch_data-&gt;keyptrmap.insert(ptr-&gt;branch_data-&gt;keyptrmap.end(), current-&gt;branch_data-&gt;keyptrmap.end() - M / 2, current-&gt;branch_data-&gt;keyptrmap.end()); current-&gt;branch_data-&gt;keyptrmap.erase(current-&gt;branch_data-&gt;keyptrmap.end() - M / 2, current-&gt;branch_data-&gt;keyptrmap.end()); ptr-&gt;branch_data-&gt;p = current-&gt;branch_data-&gt;keyptrmap.back().second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;(BTreeNode&lt;T&gt;::flag::branch); root-&gt;branch_data-&gt;p = current; root-&gt;branch_data-&gt;keyptrmap.push_back(make_pair(current-&gt;branch_data-&gt;keyptrmap.back().first, ptr)); current-&gt;branch_data-&gt;keyptrmap.pop_back(); return root; &#125; else &#123; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.insert(stackforback.top().second, make_pair(current-&gt;branch_data-&gt;keyptrmap.back().first, ptr)); current-&gt;branch_data-&gt;keyptrmap.pop_back(); if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* DelBTree(BTreeNode&lt;T&gt;* root, const T&amp; key) //B树删除函数&#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; bool replace = false; while (current-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::branch) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;branch_data-&gt;keyptrmap); if (scankey != current-&gt;branch_data-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt;* q = scankey-&gt;second; while (q-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::branch) &#123; stackforback.push(make_pair(q, q-&gt;branch_data-&gt;keyptrmap.begin())); q = q-&gt;branch_data-&gt;p; &#125; scankey-&gt;first = q-&gt;leaf_data-&gt;front(); q-&gt;leaf_data-&gt;erase(q-&gt;leaf_data-&gt;begin()); current = q; replace = true; break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;branch_data-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;branch_data-&gt;p; &#125; &#125; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; if (replace == false) &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; scankey = BinarySearch(*current-&gt;leaf_data, current-&gt;leaf_data-&gt;begin(), current-&gt;leaf_data-&gt;end() - 1, key); if (scankey.first == true) &#123; current-&gt;leaf_data-&gt;erase(scankey.second); &#125; else &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; &#125; if (current == root) &#123; if (current-&gt;leaf_data-&gt;empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;leaf_data-&gt;size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;branch_data-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;leaf_data-&gt;size() &gt;= (M + 1) / 2) &#123; current-&gt;leaf_data-&gt;push_back(temp-&gt;first); BTreeNode&lt;T&gt;* ptr = temp-&gt;second; temp-&gt;first = ptr-&gt;leaf_data-&gt;front(); ptr-&gt;leaf_data-&gt;erase(ptr-&gt;leaf_data-&gt;begin()); return root; &#125; else &#123; current-&gt;leaf_data-&gt;push_back(temp-&gt;first); current-&gt;leaf_data-&gt;insert(current-&gt;leaf_data-&gt;end(), temp-&gt;second-&gt;leaf_data-&gt;begin(), temp-&gt;second-&gt;leaf_data-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() == 0) &#123; delete root; return current; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt;* ptr = nullptr; if (temp != stackforback.top().first-&gt;branch_data-&gt;keyptrmap.begin()) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator before = temp - 1; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;branch_data-&gt;p; &#125; if (ptr-&gt;leaf_data-&gt;size() &gt;= (M + 1) / 2) &#123; current-&gt;leaf_data-&gt;insert(current-&gt;leaf_data-&gt;begin(), temp-&gt;first); typename vector&lt;T&gt;::iterator left = ptr-&gt;leaf_data-&gt;end() - 1; temp-&gt;first = *left; ptr-&gt;leaf_data-&gt;erase(left); return root; &#125; else &#123; ptr-&gt;leaf_data-&gt;push_back(temp-&gt;first); ptr-&gt;leaf_data-&gt;insert(ptr-&gt;leaf_data-&gt;end(), current-&gt;leaf_data-&gt;begin(), current-&gt;leaf_data-&gt;end()); delete current; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() == 0) &#123; delete root; return ptr; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;branch_data-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;branch_data-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;branch_data-&gt;p)); BTreeNode&lt;T&gt;* ptr = temp-&gt;second; temp-&gt;first = ptr-&gt;branch_data-&gt;keyptrmap.front().first; ptr-&gt;branch_data-&gt;p = ptr-&gt;branch_data-&gt;keyptrmap.front().second; ptr-&gt;branch_data-&gt;keyptrmap.erase(ptr-&gt;branch_data-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;branch_data-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;branch_data-&gt;p)); current-&gt;branch_data-&gt;keyptrmap.insert(current-&gt;branch_data-&gt;keyptrmap.end(), temp-&gt;second-&gt;branch_data-&gt;keyptrmap.begin(), temp-&gt;second-&gt;branch_data-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() == 0) &#123; delete root; return current; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt;* ptr = nullptr; if (temp != stackforback.top().first-&gt;branch_data-&gt;keyptrmap.begin()) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator before = temp - 1; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;branch_data-&gt;p; &#125; if (ptr-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;branch_data-&gt;keyptrmap.insert(current-&gt;branch_data-&gt;keyptrmap.begin(), make_pair(temp-&gt;first, current-&gt;branch_data-&gt;p)); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = ptr-&gt;branch_data-&gt;keyptrmap.end() - 1; current-&gt;branch_data-&gt;p = left-&gt;second; temp-&gt;first = left-&gt;first; ptr-&gt;branch_data-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;branch_data-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, current-&gt;branch_data-&gt;p)); ptr-&gt;branch_data-&gt;keyptrmap.insert(ptr-&gt;branch_data-&gt;keyptrmap.end(), current-&gt;branch_data-&gt;keyptrmap.begin(), current-&gt;branch_data-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() == 0) &#123; delete root; return ptr; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; const int N = 45; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则同样交换g和p,r的颜色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则同样交换g和p,r颜色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (q == g-&gt;left) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 10; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;random&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;vector&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;* keyandptr; //叶节点指针域和数据域 vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;* keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;vector&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(vector&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt;* leaf)&#123; typename vector&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end() - 1; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt;* p; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename vector&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;bool compare(const pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&amp; left, const pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&amp; right)&#123; return left.first &lt; right.first;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; temp-&gt;first = key; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; BinarySearch(vector&lt;T&gt; &amp;list, typename vector&lt;T&gt;::iterator left, typename vector&lt;T&gt;::iterator right, const T&amp; key)&#123; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;T&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt; *mid) &#123; if (mid == list.begin()) &#123; return &#123; false, left &#125;; &#125; right = mid - 1; &#125; else if (key &gt; * mid) &#123; left = mid + 1; &#125; else &#123; return &#123; true, mid &#125;; &#125; &#125; return &#123; false, left &#125;;&#125;template &lt;typename T&gt; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator Upper_Bound(const T &amp;key, vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt; &amp;list)&#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator left = list.begin(); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator right = list.end() - 1; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt;= (*mid).first) &#123; if (mid == list.begin()) &#123; return left; &#125; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, const T &amp;key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.push_back(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, *(current-&gt;keyptrmap)); if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = scankey-&gt;second; &#125; &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; result = BinarySearch(current-&gt;keyandptr-&gt;first, current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end() - 1, key); if (result.first == false) &#123; current-&gt;keyandptr-&gt;first.insert(result.second, key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; if (current != root &amp;&amp; key == current-&gt;keyandptr-&gt;first.back()) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); ptr-&gt;keyandptr-&gt;first.insert(ptr-&gt;keyandptr-&gt;first.end(), current-&gt;keyandptr-&gt;first.end() - (M + 1) / 2, current-&gt;keyandptr-&gt;first.end()); current-&gt;keyandptr-&gt;first.erase(current-&gt;keyandptr-&gt;first.end() - (M + 1) / 2, current-&gt;keyandptr-&gt;first.end()); ptr-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; current-&gt;keyandptr-&gt;second = ptr; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); root-&gt;keyptrmap-&gt;push_back(make_pair(current-&gt;keyandptr-&gt;first.back(), current)); root-&gt;keyptrmap-&gt;push_back(make_pair(ptr-&gt;keyandptr-&gt;first.back(), ptr)); return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;T&gt;::iterator temp = ptr-&gt;keyandptr-&gt;first.end() - 1; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second, make_pair(*temp, ptr)); stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;end(); (stackforback.top().second - 2)-&gt;first = *(current-&gt;keyandptr-&gt;first.end() - 1); &#125; else &#123; stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second + 1, make_pair(*temp, ptr)); --stackforback.top().second; stackforback.top().second-&gt;first = *(current-&gt;keyandptr-&gt;first.end() - 1); &#125; if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.pop(); updatemax(stackforback, ptr-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); ptr-&gt;keyptrmap-&gt;insert(ptr-&gt;keyptrmap-&gt;end(), current-&gt;keyptrmap-&gt;end() - (M + 1) / 2, current-&gt;keyptrmap-&gt;end()); current-&gt;keyptrmap-&gt;erase(current-&gt;keyptrmap-&gt;end() - (M + 1) / 2, current-&gt;keyptrmap-&gt;end()); if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); root-&gt;keyptrmap-&gt;push_back(make_pair(current-&gt;keyptrmap-&gt;back().first, current)); root-&gt;keyptrmap-&gt;push_back(make_pair(ptr-&gt;keyptrmap-&gt;back().first, ptr)); return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end() - 1; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second, make_pair(temp-&gt;first, ptr)); stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;end(); (stackforback.top().second - 2)-&gt;first = current-&gt;keyptrmap-&gt;back().first; &#125; else &#123; stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second + 1, make_pair(temp-&gt;first, ptr)); --stackforback.top().second; stackforback.top().second-&gt;first = current-&gt;keyptrmap-&gt;back().first; &#125; if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.pop(); updatemax(stackforback, ptr-&gt;keyptrmap-&gt;back().first); &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, const T &amp;key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, *(current-&gt;keyptrmap)); if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; stackforback.push(make_pair(current, scankey)); current = scankey-&gt;second; &#125; &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; result = BinarySearch(current-&gt;keyandptr-&gt;first, current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end() - 1, key); if (result.first == false) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(result.second); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; if (current-&gt;keyandptr-&gt;first.back() &lt; key) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.push_back(temp-&gt;second-&gt;keyandptr-&gt;first.front()); stackforback.top().second-&gt;first = temp-&gt;second-&gt;keyandptr-&gt;first.front(); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.end(), temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); current-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); stackforback.top().second-&gt;first = current-&gt;keyandptr-&gt;first.back(); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; temp = temp - 2; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.back()); BPlusTreeNode&lt;T&gt;* pre = temp-&gt;second; pre-&gt;keyandptr-&gt;first.pop_back(); temp-&gt;first = pre-&gt;keyandptr-&gt;first.back(); if (current-&gt;keyandptr-&gt;first.back() &lt; key) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.end(), current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); temp-&gt;second-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; temp-&gt;first = temp-&gt;second-&gt;keyandptr-&gt;first.back(); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; else &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.back() &lt; key) &#123; stackforback.pop(); updatemax(stackforback, temp-&gt;second-&gt;keyandptr-&gt;first.back()); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; while (true) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;push_back(temp-&gt;second-&gt;keyptrmap-&gt;front()); stackforback.top().second-&gt;first = temp-&gt;second-&gt;keyptrmap-&gt;front().first; temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;end(), temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().second-&gt;first = current-&gt;keyptrmap-&gt;back().first; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; temp = temp - 2; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;back()); BPlusTreeNode&lt;T&gt;* pre = temp-&gt;second; pre-&gt;keyptrmap-&gt;pop_back(); temp-&gt;first = pre-&gt;keyptrmap-&gt;back().first; if (current-&gt;keyptrmap-&gt;back().first &lt; key) &#123; updatemax(stackforback, current-&gt;keyptrmap-&gt;back().first); &#125; return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;end(), current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); temp-&gt;first = temp-&gt;second-&gt;keyptrmap-&gt;back().first; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator it = temp-&gt;second-&gt;keyptrmap-&gt;end() - 1; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; else &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;back().first &lt; key) &#123; stackforback.pop(); updatemax(stackforback, temp-&gt;second-&gt;keyptrmap-&gt;back().first); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; const int N = 56; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; else &#123; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，但是仍然可以继续化简，注意到代码四第25行k==0为真时完全可以继续执行k=next[k],最后会在21行执行next[++j]==0,效果和第25行为真时执行next[++j]=0完全相同，故25-28行可统一写为k=next[k],从而得到形式最为简洁的代码五 1234567891011121314151617181920212223242526272829303132333435package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 这(代码五)就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个2的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void selectPushedObject(int &amp;x1, int &amp;x2, int ScaleOfProblems, int *&amp;p, int &amp;i)&#123; if ((x1 != ScaleOfProblems) &amp;&amp; (x1 + x2 + 1 != 2 * ScaleOfProblems)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125;&#125;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int* p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int*)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = 0; x1 = 1; x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count p[i] = 1; //首次入栈，栈空,关键变量值已在上方确定,1首先入栈,x1自增1 while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; //非首次入栈栈不空 if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; selectPushedObject(x1, x2, n, p, i); &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; selectPushedObject(x1, x2, n, p, i); &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
</search>
