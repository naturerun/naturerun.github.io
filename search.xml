<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! U2FsdGVkX186i1Oaxc6rVu0icD/awhmOiAn6MxhbbMq0ZZz3cONhNgJjnN1SddNabyvAKWa+KhLeIm0d2ZoYJ9Qwjm8VhI3ybyq79kDbpDtuRvzZVk2NSXmO8Gq3dKduMl4bQiBG6FGWFfJEMyeGLgiZX0QMcgH5Ss0IsYh+bCH/l8sGDvAU07CglwruK5Cx1UcTJmr/Y55bnC+H6dqNcqPq/hi94jD8uij1yqDvxy9y8Y1tzVFbuONtzD7iqHL9VAknuenIRVTh5Y6fw1KQk/yref0TWJ4xb5GH4tupfGdp1u8Zy2qbHfnMC2Iym06aO6yTS5M8mfWfDzn87LMwCgRLiVdayFtHKUxwaHFSzVKEAkNDZq+JcpTKEqj87+cn4DhasaAt8iQuN1A6ldxM8b5pafmAx8p6pWyge99mZgz+VdqCpdhJ/FLWQiPK/c0jT623/yN38OkrflLXTRmqG8hLnfhRhxqRDtxxijwJbh0SCe6aCD/9qyBTzFCjwU7sVYURYWm+fslXlvgh4A0oLdtEzQJoMVYLjS1t/QZB/tUUTmDOW1PNKeUx3LpehG6BZm2H6mamflxMxlPa8H6WLJHkM40XdeOkiFOCeyNilUh1ZR+4YQqW8UBVuy+LOC+TnlPYa92kDq2TxyuIiZnjGfCV9h3Y+Ot2zE5ICE4fNj4oNdi6p3vZ8RknAKxqIUBXnszhfNq5/N7YhzBfuBMAMlnVoBqPd7oVU5DEMYp5s4GkrHwTUolJrvATXztxgB8EcAJLHOC6gDu1OfIs6Pocps9Q96s82f47BsNF/dNi2FVHKImbzuPV1vpMQfZ/2RojQWZOD8JvXD/NtALLGBwSVhhMai+TddTZizxikYlayTVy8p0l5ESim6eOKHTZYebK55FQHMduOkshkg7Hw2/d8usdf/GYPjV5VFAUUQbXN+FYRTS3eJubuThiKPUsb9N5vRHoeoycSoaOLlfRvIXamPb+NOEGUchEZhLucGqF44qT2SVBApjJ1cRnt157EEHHo8uRjF1/5yOo2d7ymvYjPR4KTp+cFqMq0S+9ag/yDE/0whw7rNFiLWuq1m23fYRTeg+wobYrxgr0jL+ScSuS7hKQhxp7AvPl0xCF1gczcZOD73lU73MW+TWUCkCsAGbzLcMZuWkY29YG+jCDma1wwoO0/OV+LXFjNWwndfkfFIxhI+hVWjtv9R+NsG3k9HHqzQLcs6Q7UcfO4iINqj0cQMHrl+A5I5+rIAtRx3TKVyyligrQvkvR9OVfVI+y0Yk72ecB2edb9l2qenXUzcDzi//MpaJ0WEduW5GjMb42rNsY+hu3DaK7CHpwCHhMur5LdSRJhuhM5xrEY94Q+lksIJ2ab3kGrsijDqautI/qQbEAeoKYYABZ18lTIwd7lyK/po5iLsPVOBy8TI9ckAc8p1VRA35WLVDtlsPJyfJKrUSxcNW8SFvxuxd8DNpCumpwD/eWbR+YHXh+V7tx1xsmPWM8Vct/HdLnz4sso8/QOWesT/xyQFDgjQi/e2SJhVATq0T/J6WlNqOq7oA2G6DL1vfnCL9zUT6RMZxMNwQQolP7XBTNSLJJT3RrvcxtBP2OEFjVr1c4/tkOEhCywviBfXniESUYUllU4zbtJCPUSXFi3MKfP2UBG9UxBBTi5hBQv9djRIni/zGwB3NujVpiC0CBfojTsssNloLkrlmAE59Yp797ffUJlLee3l//FDgX/GGQOTSmgZZ580x8GI/rGCRtoCN7K77hunelCKYe+A7Vn4OQnwXSiNU76bOndT8rXKjLNytWYB92LrmcJDH5CqhMrP/j5vCtw8aZkqAYKaR0GFA9ZsBzsjgUwvxnRGEPnWwTK7lTzUWFhRC8k6nIAK79bUnhxvNPjDndbJQbw+0soh/zW6rKTTKhUSgbZ6CDjmAKw94Ps9XanoBdmRjS0ywNChE7RBVgIbKlGxsX4mEUB5+yM+d40xOWmeQ0sFy4vMcfd/ZG1/hNRmNRV86gNw8/dvC0IRpDONAbVhYo5dVf89Y/NkuPeA6XAxaKSn/QhG16S+Pb1zh+x3bjQ4swufRPFNiPllAZCrpZ3xZqerbaGTCJkzgIngGqLf92B9tAUYw8PItt1fuIARmpBvFNc91tTHLtuyijpMMs2OGldkpNxsBPgFttfV7wFcAjuWBY/zpT1gDy2SiOsyxlXi1Ug1LXhhY7JB2HPdYfz/Vkamd98EN/7QSBn01Rdvl15/u5aHqAHAbmQC6URvhWyrzsDAR2SoCIUr6hZi/uxne9mg065NYV2iNb92UUP4ncYTnE4gyJuZLuiFfbiMs62Um1jSqRVpJrbkbfD4zeoX2j2mcxmqfLl41UkfQnclBI63oJar5e2jH2EfiXX7cti1Geen+gK9eoaebiFSdeDq0N5+WhhbhFtIjMzH1vH+XQq1Yia23q1o7ErRWJ/+g5aCiiQBj8Q7qUn4v3Kegnj8KYIFovnnEktAIVrK5zBlYzIGaTPUjKeRqKE3Dy6UQZ25w2R44gXf1B0P8ZbHrn9VP39iT6eVeNUyPpIOJtUBBBrdmVvnSAx6cb1f1kitQVDpGLOnxhc+KR+kq6Z3QYWeFaHTXzohqiuUriZu1sH/5u0uQfZc/CJvmtYxn7YWGBKuQb2XS8q5UEsZ3L3wlGbUr10S6n2+G7bLuEa4apJHBjVafYHk6/nM4CjVDRTow/EDbE4oc3a2C6VsPMw2xXIFNRpPbwgRqBV6G8Dlwuu8xCCciWBiJ9FZENVF6tJIY1F0fTGqvnYa5aAkddQt3k8KXsZ90yx2q3Xi9jhwXuI5Kn9EcLhKYSLfm9J5Q2M0z61lu4Wdj7eM+r2IThE6lFnbAnfIxy847zBsCEhWUw78xb7fNtVj/2q6iYYfripHSHcutBTRQjO78rOGve1/OGBzz5K2deaC/rRbYJPSgQYyuGevS5umpXD2aLxOnHX72wLDR4TLBfGe9N/hsMPImlekCT/EA03J8o/1Z6GrE6xhZg2sAjzleSdQO9AExyTVNWS/T1gLvhFbQTPizl2BVwCDU6O7ljFAZ1NoyqBeJQbbr4i6asK6y8vWEBN7FyE/QD2Ngak/VoXMtpzSG/WiL2AQbzDFUg8NcDB21zjpkPhpxTWw+jGVAtl8dGUvTmUVLmwFVRDyjZ5xxONp0Vb3BmG18SN9ucXzJh2T0239hrxJYSlfVIkqCgL6CjsUbbfYztygZY4k7daw8SkYvgFRn5uoOxoo67PLwntCzVlniNXsbjQNFan6ZtmA2xYbWjklPoC/ibZcRxKaODwrZg8KRIS16WdOm8ZN4KUYHJXjYn42tXXOrPgRHqS6JLBeTJqAz4vDGdzi5hfG4amqj8pheuiGdeloCxnZJT3UsG6n0HWyFNXmle/QdVSrdoXt1pX4cm1aYOtcnk7R9LIYDWq6Z5q+IMG6DqBP3aiTAAB9KgYgh4H8nFAlFZS5SWqSdpjn/w0fGf5XoFj47fEWHJRl5yfLsijkcYIbqEyKiKkwDjy+FP8zH+/hiLkB0J/PJbndhcD5iE6+xRQ1LZ5zH7aDb8pkcF6JVO6wdKuhOHmaQw5nrKSFrw+xyBLJvmOP/GK33RrXAUyyrT3Bf5N+CBwm56rgAvuHogojic6Y9mMwGCnVgyCXN0sS+ipN5ngXmvxLYhKaH0WiOxioFmX6H7nSRWV4kicFiGJPnIO7bbXuBzWNYssQkObBQJUEvvf86D52Fh5CDgLVM6EnLrNcwyprqRhg1qqBoe0o/0u8C5qJ+bQdMmCa4kzWfZoGoF7hp2oeKbOOeiZ1Lluy31AWk9L2L1WpTqoUpQn3OIvaiFkpF+V/oj1XGLUDo04KiFjcc1s14gz2Kh4ECDD3dZKKgF5gDv+HLl3R7mBQgHVI7gfZ9KSIsfc79a4/OVdzGJvIfRwctgNtRNlP2ZTvE1UsK7Mclzk+i7pk2TP7eMmFf5N9elgxVDrcHsEVJ4Ef0+0RbbzpGNiwLgkn+tb1zxAy3mCs0D59cEbE+8Ncukp3aQFjGiwO6Ee5k1IrlZp8GQHLCnqTHkAkO9heK6yAmTMHmoaXy6Dq2WODhkpTBSyvhYW+Ht4QxeOwLCrpE1iLkQ8wNNkYUT9yVUmBCOPV46xekyp6TO6IiD6oIr0UWKuXsXfUwsnDTsbnt4z30wieMMSVMrGhreCvzC5MsaF/DJs+R2UH4nEipIxdd65tUii+3okIETMD0xuPsqGaHOw/JX5+wYxEIYM6QW/evEh831Bk/6Q4XviNu5KQibmX4eugU/svQkSTXCt/n2P2EoJJIKRhkDZyVP6+AjWsLLQEI+po1D18c0q821w3fwi4b3BYGw/LLxOtrYEAOdyTyppMgiY2mfSEoiFnVe4TFWAqbDUbe74WHL5dMaPaRpWb8S0vhfzKUTnFLYYrdGybiqYrq6yiFmldx8KaeTBe3TAkdp1OQiS7h2pEf8CdICrLs8K032AIMxx1e+mJiS82IwXjhO0qPG6x8HhBlsmM7thXP0FaxDsEk3xhGprdGOm99SnK3HN9RFiSpPsfb9orX1iCyzLJGreFXhxld6wOQw7ZauQGJoI+oEt0XC1lpMO7ZrkT1moDM+KK+Bp7LZkCB9eN6eseZCDNE/hNeecT1kZIFIHwLDSaClKH052BjNDWqlXegR/jZppts3COW2wzmqZCdda0REVMfmkYYZBl7Csrcq3XcnOeI6b57vRd32NcIy/shkVn/7jVQAs56SDyZNbRC6x2AbnS5WxnVNpCnW8bupNXnNR5wYn21HzNPV+/E1zlk3FcV2BO3CRkPCwhOJfofK/iyzU+6ejJF22Rz7m8dmp7DA6z6y2Qd9kI3bNTjk3DliTekNarzRfqCooGhTGARMddwjB9Jbcic5ehIksEwEBh8T9AlfZCf6QIBgvwFrmVsGd1/YsI97q90u7cUA6X4LELXHqBK/JlWuTkggTVkcP5Qu+Xvm38v3HhRvH3oRnIN/JTzgo92+1Qmuo1c2wnusMZ9FZN/OncB9K9AggmViLo4I1arxuTlC6ZU9PkwD/u1+DggarsHFqGS/AF2M5fhYAF9p3iU+5rqkzQHYtoE+yHj7L9Nu8arEXXAX5HU0094AUtgDNA6doNmr4KkGIHMIB4f1WGzrAk7nmv4bW328rmPxQlxG68Qf7YGb+zcPbCECkjGkK0HqbRxVtqBuQ0LG0oGweHrXT7n+mUZRvKIJWarkzqEoiVV3xLY+fiUJYZNqrBx27KHq6o43Jl7Cv1PeLp0zQTEdz2j+1ZLgRSke1gYyT9CX7DR8CmLxGxd4cOSNKHdHXModeCDgM3vLL8lmWDwGz8//uKq0w7xvhUbcd5Dzz/GNSAFc2pjbsfxLbX7nMbDIJkbl89DtLkmCe4EgOi5Qxje8S94C3VGQWNCk9b1kMx6EGZFdyQ8MEWv5WKspqdfmnmpVkadpve/k9LU/WM3nY6fz/J/FkK14g7s8BzPcCvZejGv6DHMPIlXVEtJfwEQGnFIhaq6Q3uk97bjwXDT7yRaJLJWt5+ARv62WnG0OA0SzGzWH9N7JsFpN2BsB6j8pILXYFf8k6dj1JqB9HSjfbDiS3VZs2EOEMFgDYOP+tNpAxdwtvNChdFsQtj9d4ht5NFEBMnAdAvBVxWju8uN/PPz19YSfPcNzdR5TlCP52GJ7TCXfinUEicf99GJJrSkwSLezd1+owzkPhdWx7/nJj9yvLQICnkNwwMAhlAISjZt8LsEcithjfLBa2+a3MZGOBC2/pCIoKLJdox8yxp73JhakXe2yAZXb0lqnu2LfsqQMitzIDrhYjdnrQ19YSXWhcyw9uqp4TGre+wK84nYWIKQ43gKgNH/TVZ90NDcTvpVsV7qyVSvuJXf52nMj0D0GgmtyG6WfQ4LBRCnmSYMqexbZX9AZ40VOCD2hpA5q9fucz/pnTwIbcZNHxQQRWb8Pn1nL9IUDO7eTwsyky7jloM7XTxfNXkvTV3iTeARXh3o2EQo6jjzsRYp1uXQJpcBTxydS/ZeW5GQ4KL14LF9npwbBoyPKUsstK3VJZ19qUoMFUNEz/oUBL+UNshYDCVRBFaB4nfvheL+VEyEeVf7sCAcSWzHl2I1LMRARJQ5xJBNIc20YsmE2K3ndVLh2WJ+wlDd8JWjZHGnVLm9v+aQhiNM8Hz234HrXrEMlOyLigigz/JJDxyo/0FXF+t+6NBlBkR35NizNt3qRtWmh4+nHb112Mq78FQ1FbKAzcWdL7a+sUFJHZjPhhkXYfcEEnOatviY887g0bJrdbslsEa+/V+vnk9ZjBV1mGAnFW4LVxAwhdI26uxmIjVmHwZEsq9RYWF7e2/MekQoLaNCPL0YM3UPn7gGfwIAr9ltiWWOFhuCSHFzD3Ul5YE8mNhj8K2dLPda7aa+NbCFdt2lswELzK+cgfJs8Gk4c68OPLWYFxfCL14TOvLJsFOZ3oE3W7XldSS7cV8OE/ats0JYkxT6SJOcYySM1o99WXJJpKcb3+8NAf+nmmV2W+oxTfL2cgiC+hg9EAGQi9DwagtROzFJD12ATzQm3WRLzgVYuTuLTGwl+VVoaRX1+E5QfPTa4EViKzkg88TYua4M5ifRX3oKAcrpGgwrM6ZMBwFxW6sTQ2ZNqEg5mQO1hrSLkp+d5pxdWNAvzi/eel/V2rBO+EI3OusMKmvL3YDidTFkD0+JXqwNTQSA+p5HIRI7wwIJitvuxgiOAA3FRa+S42NUe+Iw7/uG11OMLz0X3/FlBNqSGmgDLmchmV9GfEaeeHp9s8yR4GVx4FAYaRcGKO8k2sP/y/AFUi5LyUXkSQ40hG+PYqjRHYBGD0apTeqmRjHbH7Yp+Z4FOzqEj7pSlGqPVKX1OK3iE+2fFsDBOsth10ySNWI5RrJ9gmY+tNoyXPE8KcJd8NHTx6BkBMvzW2PhncZS5J9kBxAJo6RJLhYoqbg9jwEI5VmEwu9MEsjdXslQ4FLdSycs3e18aRDXOFb292YshDRcHlQJY30QyvH1FKuAnYcJycHG3NTFWKiGORWMWCdtWfBx0ls4hUpyCQso/OXbicxMyzuivgHEaCZxkmTDxwqhlLDLxoFpb740X9ud1TZun7d6fjQkQSDvPh7pUefcFRQgX2/e9htlKtXZmVx46c9j8uurYXIzRfKD6M4dFZd7gvMJnuyPmUNRDongegvHnhVXgGyM1BO5ALQb7Z1nCC5f1wMiRof4uWCIYaQ4rFavShr7J6/nhNhK+Q7z5rHd1Pbh9b62b0Ihb15xLBos9lqjqiNsQlGQyT1S3eqPernTmjLyvry6jtbzjdc3WtUqu1hVKNChwkRW+WKxqa3eVobdxkQd65DfUfvZFudhjCfJ7CL7vGPibM2zTcuEYREY1+SkPxPAM/bkKoqHDxqRkrc8gTpAc/MiOCjYcsj/vnI55IHvmfXIpahxTf2gNFqKHfBEnQov3u1hUEfwqB0J8KhHr2mPUHu4Z2E3zzpoX1nNuuzUrF4UpPgOhqwk7WmETzQta7y4W5oF/AVHm/TfrIZnk2ZN9hQmm/gtbG3PK6w9ZtD3zlVpZseLNIyHcXaJ6XN8Jl56DuJAFr3pq2a9vxJl9FJB7+RczCI857F6EGkN13wM65NLNKVgSYYXJtAg+Nn9C+hkGmSriUDzxCs43AQejX9z5Fd1CZfWOVXEjgRMZ/pVVs3zHzizg/SLUIE37iVRABoRrhbnn+vBahrgLWwv7J9RmhFxudJA9ClZQw1ZBdtd1Y+Is7FO7JW23DOpSfiq8TZWfvlR1Lyo9h04w/HgqluWEQU194kRMEWILQ0TQeLUme0eBuY7b8EBk5k+P6aXEMGMz5a9EfYhISzD8pyjvFAMJWVkxrNsChXMM4f3K/kGlEyAf2ySQaNNLnbWXKYZYJdgW6dJn/IvAhi9jXm0SVOx3u23NOB3G19fjFaWWNo5Q8EJWsvMnf8t8MIEVxjwl/HLU/boPhs5rKaQvh0B4iAwZ9OsYHUq63SVYXGNuYwuNULidtXkV4PnH1bxy0XKy2oIolb/HNe458e2EBqukKb9NhhDQOuDy1SjCxi4UWU/ii1XW54crHGKccLAniZbntSxh9Te+XdEgLI05jE4MOIptm7/aL0Gu4otD32EA1ISUEDIEA8yN90fYFJ6DnZhfDQQyAsbBsW+Lir1zlkm4WT5nkhHrTgpacoh5walSHProbvOgiaXvfn/G0X6kwJGKEZ07xkZW2BMnAqia6whGFir1zq42Zerc8Rzwcievqfm1GW5rzSlyoj8lHvUQDMIh+Evxe34gCuUpzYdjhOo6SY+fDWChjk7nfZsXhEDJqXjWMxWUJ2REErifNiDJUdVfIw2qFgfE3hdrXN12zess/k1c+Fd9DSgKlz1arrvLM9zGVhl3TxM3adD9Q7f1HfDJO4rwZRfSpwru3axk1JwHBvfgfswitTHSEclP7leWCcVDKeMm9/JUdVybIVdiOQEMWpiY10cIUA2qamWRD8CbHK+tlQ0mYchlS9gY3KKR88KS2Cx9iPc/qRmZOheNV1swkXdfwO4fxKxxNmhapNPMwQcHLPxjG31c/r1qys+nKUh+/SbgHyKsp96trjGZZiavbIzuWFKAEvcZs1eOc4MsY4QUCTlxUU5rd1BtFntEBtZK/AFIBNjV1EcykXwf8IgpPaOkgST89wRDupbAQeZoU6h5qZmHfyirBneuFvWwwGQkN0pYz81b3krYcNDUA9hhBoO2kqwgiVagfmoTSpzN+MWeWG00+zDvY5/VPk3CM6z/N3zKZGeplqp7ZHYgDpYSD9XFY+LiNjQlZqt9VKp6ezynnFlzjf4xutW7d9wEc1cBETzQpGCQ4sx6rm26XDgNr8igBPAKgnj/eyy4EwcALiZ36eMjugI1CY6am+IVfzprB9YolArw2pBp7SqcveB5tQ/LQLTBg1sfpcu2qfZvEGf+8Tj+MW2MubAqwsiwtjQqPef8oqhzqbrf7v2QuCCi/tpPeImq0jY31kYHtp29CDIlQlXY2qMZJziREIobCmhe5F9Ysxtk6SFnQBZOne3Tn1RKgkbSO9IcT6Uv4ngnxlcI1EOaLq3W+mxsZJbPE4bRwhtZvvQviNxk+XRHA/D+L9OKXN9ZCbKMzHdllhBijHDC7dNlPWMb3d+0qCu+9I2rqeNA1knZlIiORdbrAuESlO3pA+C0AjfFKH4X3/Yv3pUNOzPX3mut+UtUbv/bkH0MGY1Dbj6TVy/9JULG7036gHMh8L1UEEGHo9hHxt5t6q7pCR+lZbkOzZnYqqmSWhWODpsb4pPiJRhxZnF8YUtymp49h3+yeltpTALwdRdDp/zRO/ns+aqlBq+h+g//x5pS0DSq42mUFjfoXDBtw/eYqIDCz94OpJQBX1ikvLl5serEO3/Jm+++P5faK9an1XiS8iJAHY7q+5qWO5i8fxYKlYZg2VSC9kKq0P5qUCyZz/Z00Sb/7vBDSmzz7felWHGu2gqlEkYgh8uHaYXN6AcWS+vDO94TNJb1/lZ0cSxuxM903xCN2iRWqu5jaN8Fsz/G0N+VFfioiPnyPi/hKq4tDxht1TZJk/mQ9D9LtFxhAXJoq5ByNRXz/kd//qzbFT8Vt6vziFBRWZAow9wDGi5MxOSN+VV+HCHnlFuEvmbpC63eQ8SdCUoAv8v3zA4oySxyDSws/tE8jqiPJM+MFwbF4807IM/z1Jh7WOc3gR25ns6RPIrMhQF9ogVbXTpEvZgE7rh4Akin6wv+HnAkCFkbfpdV6/9KlHNe27FOcBlhtaTAi0Yz2KYKoTnzveg3yk3U7gDkTm3EqfR3k5w2WQkspWK4hCelzZfdKkt4XMm3R/n3xVNBwt+Z+Tf52Mg43Cj+vVPNBgSr7STuyfkuhDbGVrQ/210UclkWsHnUORn0GMzdYIRYed+4GzMBwv0BiNCOp+ag9gj/BtIGUl9RbqmqzWtVGsiK1idl/W8aTaqP9wBHcQFz7CwG3pYzGFfzgxtSLQIBZWGwl2ZmwaUDMGFy+avz9dPXhIabySHNgdbNbe4fni+aOGIzCGNbH+A2jlfVeGkk2cd4JuouiBw+jt/ee+bcp/xRL5IO+LUvIXWTihdkUbN5lmCymxxLbSDr01zcUiJoNfiBF3/dJ/bbrPvBKcTGVfV5EIaPIrOc1IaZeQEkg7uqmJ6gpGrxvOe59j4WbX1KaUUe9i/hL90yCgmoD2RW/JJwHUoFBhC1+AIn5ghNfrMfLE4acPyZZrkn/WAmoSqU2kjPS6Jo1N8aHecHReVIxSd6ELPp1x4jPLqXn+zFzrcCchc8UGLFuyEdeydMrdHp5ueMd5O726M4iiyr5M+3iiMDMfRx+NbRkpW4fjHjTWXdwpbNNEDnIp2de3ty7iGBSnSwHWK9LWZ9mrPVy3M0PlGj11eMLgAIH9PF4gmbqWMtnP+zAcZJD7ePb8eipYHfUfqXJv4cSIYlJHPDTGqy5ccrDaV/xvMp4UxgRwJEx/ah10Oz6GqNkBMEYmP1hzLLzWNPGCdy5KaEZVVVgxqdyNoVl0pCuX2PczPTMnkALLPJOWLUPlhz3Qiv9JOiyxdwadnoPXPtiVU74RRLKvWBrsBQ0DkPFfJxsneut6HzasJ4CEJoWvpN1q5AwRMylIpq82sQGFWIWAs47pv3K1kClqQzPQ3FqTq2gV1ncTWmmJEl3ovkJ/3EEHQRhpd+6AQFabSLVOiG0DlSiCwnJ+YLiwV198V5GoXzVMi8SMo5rjmwUYG6JFl+GO5qaT4325kiShPp+qwiPoDZIyXQnKk7o3/iM5bvJzNubF1bb/m3aWWX0KdhQeFiybOqrPUpbPtkmxkoefUGAR6vRj/YNZY0ompuNXQG1y8HaTFqutcWQYNjYgGIfKS/M6JTU6wFJ/LYHA1XzETWYwEhgqr1w8Zi6THpUXyjZXO++Dzpg5gaeaarfgEG3FWp6CUX0xl43mQDvG5ZO66x06X8EthCjPsam3rSkoJWSdQeYky/nn2zGPatlE2ZZ7/t10oTZ4Me05zVlfJxhuDw27E/22E8r3Pmalg+sMDGBktpS6aAL/aEFnxw5wmSBQT8u3nME02NiBXPNXJOaz2jGWtvOJ5YxMlZIoswqEDg5trmTJp9Ht0u9Pu6hyDLa7t7cDeoXMS6IJZK7a+oS14xuV7UACQKUi9PkKXQgvsL5WByfZI0uhc5v+GwAmWQ92orBFa7gB4j5fRT7haM6CVuV66b04s85bAxnmR9GzXZVaE99v2eYFdop0Orelljzu26Tbc0cUFQYZXijpIqRP28Knub7s/ZTP7CjGBxWj/zSnjuZQWIV8HWsgFsKqGoJ2OHx9RkCz6XClB6apRu6WxZtHYpsF/V5uR8L8AY0pGBhYKD3hsVba87z2UAt7UcAOp3YtpY/CAzAwcz8Vhfjun2gijmbdb1Wm03FQzmR/zDuZunEoD0Z6UUQUDNpRGufJ3HkruoYEAzuDjj2ZS1DVYMpDGcyGoZpWTxPZka0ctMtD0DgWX8sC2//pvArVicNC/P68cc6qpzWr2vJYTSs+g7kUu5Fd4JQJz5MbsOxclt0JIqTOf0nCru9mBWA5fPmjj1hEzaAT7206JTY1vO19ClwE8xIOE47BTaqJ8lsIKRsPREyqLY9N6+tp/9w+mNy7j37D3IuYi8ALR4E2P65Lci/xaGWueQvLuFH0zdZe0W6DtM/NVlVsPEWYRm3XjoNN4Ntxsjjo6Xa1BELjlYxgOpEcSvI0g37bMDfbi0yZJZwDScJUbkoqP051rHVMNtP65wp5bTQmdqbWTwQTKO1jM+NLtvcgfs3ELw18qc/7fHZvp9NHRF3DnZo+f9iSR3T6XaSGD9yTcNvDHXpZIw+POwvErFUM2dktKPvUIg2gTYp0feqknBFYDur/RZwDU9c3akYnvUSvi4N8chqM0YHAmH8MC5zmrs7O57TVWr38W3K50XXFhZi08VYzcEFGmAN1lghzwqeoRGTzLCw+460nCQ69fYGM0IgE74F1SvN6OGbA84k/atP8ANivYpbuI2j2Oh/MitRjoDyjY+jYdnrBr+3NdlIO2sMmHsExhicq2xvZC52VIF2hoOYhI8kVTWiLtFPCBiJGx52WDnYezIj6E3/AQTapJQKQ+fvqy4M83OS2PDyq2G3n+qpCjNhlF34DymSrH7S2tX79JoAKUChkV5kjllbSG0W+rKWVXmgcHf1YIv+VInAKcapOo8kHc6fTmybscG+gUhxbtidmjzA4eYjPl9AgcsbTQ+0vQizzRj+EOSP2ssJjrlQLkPse0qYrlk+QCp5zpLdfh2T2rBw3agGQeMGX4IEMx1o1wqBLu1juuNG9j+DjWH6PMNSBJH+Mr8tOezQjn3mb5JxtuAO4F/6ev4+b4dqLrSGBDGT4m9WNzzc92J1xoXUqbTsZUQeXR5fbJmriN/g2triI476N+QAiT+u+AyhZsyHxIJvaFSOmSLCAvihgVDel11KA28GJFvxyjbvFbsXEspq6J2M4JOVXbjQd0HkC5BEE3qK86AM7g295Gmy0LE0O/NzVDFQvtgzs1YfSKJ3gBIt+h8KLTV/PGcIII+WtnDoytPSeIpBUdxwczGSgNfTRMYtxyhcJd3UqHy5wCm5T66mJPtR/1YevHDzPtMksHc3TIDuJL1BDf6DjGjVYq2iE39pr3tAmZoQFPVr2agNRQvFxg53XpsFntLjccLCmXLYHAALrVn9DWwy5a3gXERGvMfHzfXKBxu0bFFPjnAm0LmFyFD4Ed+uayDUmKgiVplJPxrc+qWiMAvYahrhjLkFlbuXb3rwxvI1bzAKrYTBESPy/b2JgWSk2bXhgQVLBIElY3k6PqajjNPq+hYL/aPFIKLCguTNHkEgoSRzBRnye46WC/ZmeKjZkUFQCNNME3mlMSA+JAVK39gsKSH411Z82l/cyzr6vt591NHnzI8Jz621wPNHa0tfFgYqe6YBqRUtfu2uRC+1jfKzyMxQWAgXNNasnOcE6Gsv+SwyS4O71HF6LPRq+6q7whCj1ixGolV+Jf0wsjIQEd6cstrDK65eHaZ71SLwFIjcWhi1eYdyO/dffBAnCuq8AXhL8Xruil5GX+S8/vCXByOSGx94g3Cq4l/nuKoR0vC6NhzBSsJqXGYUz8gLf9Ei5yUCsfzdxIyCTOfzYaksVolLojizNhQBdY9KkttIEzu2YD9dLwkPNEj/QKBP+MOus8MlKtpABkINIKyoBdjtnrHXry8GsqfsuEfPk0PcfFvNLqQIlZB3YZP0JbIIm2Hbsmd+tlUe/qjTljQ2lq5qMBbLKUXvJLS0zvAGCYRy7AP4q9cE2ZCQnU4XaWOKuu1cJcySaPlc8JdTqXxvyexn65+4txSSQ0nA7iG48nUh5mwpr87lr0U1DfrQAfkxmVNWUYEndMFc7tYrfOb7IBs14FigZRZsqmeOohuChGATyR2tUFC6FmbiuBAjBYHijtnN4hM1SjBc3CeTb0gjbfAui7Tij6cuhPp3bohOgcFd4oUzRWIozaEM9rm4O8Wm0qHluGH/5ZbtXpyasGIPibVip0EsdI7WzMrEAbGQ5SMcnPuz1Yr44+NoALK1vpxnYUkjzSnAAkay3Zbx36dSABVC4839IvFclchIY3d7uSTo/D6JHkZn89eVn8aNmshR58yMBR1Dld4Y6Y5C8Hev+AZK51lCGydNMjcIEegm9eUG7GmllZfXx7pL3nymcwHojM3tG5pN0bWvCR5XtkHjU8BWWFuPGKg1z/955JLUE9YE3EoEBCz+TVqeQ4LxXLCeQ5oXHa1ZakxwbcNPuWZTaRBIrPNbsQeRLZm+fXpqk6cy0uTjADuuznf748TSBkWkDUP1eGAOotDf4KDOu9yq99slPqOz0CYP89UP0VBTrFGAal6shp0SboDt3QldIkk7tRmnKRbnaCPi5mI/gy/XkcmdWYeOIFjtZiBbOYU372Wb1tp5o0eAfaXekgUazat1dItIcJxoMtfPEpCB387bBeRiNbr3B8aPXbSnw+qKVoQYrZUY7pq9qN4lKgUXbaWBFcWI/Qu+1Y8OGUTcD/jlXup4r6Wg2mBBPdBdBOdrwt8LiTjq4ojRWq2HJ9UnI2IYR62zJAg6hAMw6NVrzWOwEkb+Vaai6ul+zvMlHk7ONUPOJIMjBEX1PQ6b8XymlV0C+5JSLt0LZTHexxWjDhrNkyJg632tE02i0sVxr0bIzFj04SZc8no/RRa++Z3Qc5FocmU4aH3nGF/X2c4UphUHnYXhIrqyqX/Pf4T8cLxrvKnF05WfzCmOPxOlZXPwZjdP9ALIFmdJdoa75wvTCBLMKlmT/dIIiwDG5fW31OyLL6n4WvTgRpzFMZZDBxPgrZGGrblH1dLbiJ8V2LxrC4nAkrVDfykXRIFskggNnNwNbOIonPO7UgY1l3A05O7SNWSo6bBEHW+nyRFa8iIdd+mqMm+VNBatf2WVY/kiAjt7HoRcz9C6xySvbChpJEofKqXxhjbPadFH+Ooo7c+2dK+p2giN5VhotdjVmYvlRp5ruTwSuZOpGMgtyOVpgcJYa7vwhQEqs4v0NGUQclclmw8flM1WWGQmln1EtorwW7NWCwQ2/jE5t1DntgvXm3jC6jboiY9DeTydGrF8gp+QlRCjl9SDjztAloYZZxkGzv56YNtuplYBJxOynEDs8+HAalep59vcVMN49gqhLkf03GPK5E7xxGtXq9xzNJCEuu82p1wfMJna4luIOh6Uqfb+baioZa6GaHXFOAOt1ZMlyZRcqCrVmcMCI/RHKn5cg8PFJzWNRpFORKpCONi7VQA+V7aPbp60+LnC1kysSNqbCD84zYKmdlnzdeJFJj1Zz0O0l786Q56IMJY8CO8bat0Uv+Ge1Ib/tdUcGUFpsbpjBNqA/3rJL/TDQTmfbHaoSbISb6wjbW00GZbi+dfk4cE14wv3MZ0ppBE2ZoGNZUPy87dNqoxLy5p6kKtVNJbSegmrkbDypA3TqSARstO7dw8b5bf1dIwkhV0TcwRgl5NFuJ5LkpQ0p/wXj/jgOyE/XWIAlJqaLLKt3cHw50/Cot/ZqeJpU6thcTXGhedEL+P4egukvG0ELmqBpFlbLvuP54GHnOhwnIVwiywEg0ABwMBkW14e5Ia9HbvcLzchB1QHwemh5q/u5YXQi/GpBuMv0/cOywkowkQwLNYxLJO65I/9Aey6DDGzECtRNc6OCiciD7JT/ZncMKWgdPGhbv7GpRO+enVJuViDRKrVT46TdXBoDtpuv2zkJ6xlrEQ/R6V/AEOXWqSrT9I/9IdY6Kn+1e8VH5OEtkVbNZib7w3uvbODF3/qP2Xya5CVYe8vVLN9GIwv3nqC4X2GHMXJySINgJLKyw/c4oUxlhPcjpjTREQXOdKHUT+5WVIlN9NVAVA3Yxz53Ugoont4PVajPQlGYz8flKKspnlTB0E7MvNuT/zAc763TB6KuBrT31X8dZLGWhRZwJpBS1eDeURhGf7zVaf1NJiJcJqEsmyosCckjeaYoeKITYq7G2VqbasA9BrIuSPVt5RP3TL57DcIXPj39wj1G9wiCfL7tRj/4ldyB6KAsoITi3fYq/2k++F2eU427nwN1kbwBXcTFleVXRFe0WFpXTMcEeEmqp9rOwh/vOhgR+Y69tK3RsW2IrdHwq7wBiw4XjLTVUWdmaV0oQUuuhC4uSaRy5fm3wgUvpgO3j4Bd6KXRz6qEoMFHB4ictMMQOpiZ901fVr+QmGe0NrrtPBPer1r/dTjwo4OWgItC9GUQAXjJWPI9BGEAy0qSlx2dFygevDnqVSTidQC1YU+Rc1uZXUHaNlYfLFEhnPX4kL72tekERr5z0x+sT/s+GkLl7Dm6c9aALbN1/D6E4//LZDlz/s9VYW9lOkzWQ3NNmYuf2j+leDIH40AX51dfkmdPVBGSy/fsV+gATZNS/1QTczlqHBALFhUVEf5jYXGG1+6qJxMtuYX2JPFr3Y2Dgz2Jo0gDtiH2LkHUFpnavqJYZpUhcwqeo+zKRrmL6S2yriRptw0XZ0qFAud52wQMOr1KD8ZCmH0rCa64tTuOvxnmKTRmflo7vNvQc0tnx209uR3D3xjfR4tgFE69XivVpnjGxwK/ggvAeSeCZ5nzx8X5hHaa39jePHcObwekghdy7IMQcNReWHsizjhgqQr8GKgxolsq4eY7g8yDbgjH/aiylOPszTm77fVYpnoNzbWbIH5pZL7OzccMDzhGC9mgbmdNPNXfqGGT7JVhStQnI65gl/LtICu7BBbM3XVddSSfjAAgDjssjMFLIU3uN9Jgg5gOpPMBProOzTJSGXFfjOq3LImWmN6wj8qXVIgrkXbbLCFgY+E0T+xRF5zcMWtnEKQWw3RCq8ztKqP+GwJau7ORjrQR7EwFTquqoatDCTym3w/QvdNi1lTM9b0BrHT5/dYxhsV38+nL9duOfUDIB5YIcLV5GgxIUH/i//V79IglU2/MMjEEmKyp586DJr0OrgfEJKv9QYCsWNpVYWY8R66w61ixKdW3m40LlwRwQxNW90qgW3bePoJ78Km1YGlPZTUQ2nGheyI1h9Zj9lufyFj6L8qD6Ntv4g7/DKiU2j8rTLM7/eUeBlzLKQexF2G7ckV8PCpNyO8qVqOWNltaHTuEY+m+iaJ5qBb57VqE+JUKlKXSWp6i7OYUakUPMDb3eF/KOxFRoDS8Em24RyIgLvy8BEn5IqD/+kt2F6CGPRxIaEg6TvTATCvQ4gr/xidDNL/Dr8kp6BGmPRdUdAOANi4icBUFPGFFGOd0F/iDWbvOxcFHjYxcJirQG4IRmAWO609TL6A019DxpvbWBFpTfUKha+3yihgSxOGfua1P1JhBgvLMuFW6byr2vnpQoTlk1YKIueqeWlknCsp01uqZz+d4agkpXaLT/TkhKCQ50FxLgdDVeTuFAav76P4kOgZY4BCvh6jc4V7M/Ps34PBU0MuPkydiuD4oJrOmgyY/5d/PVd3Ykgt4b4W6u7MLdA966ZdxlhanH8Wrxza7SD76XAytYLbUqIOe2IX5cC93/Dx5j/FTIwNROQISEP+Ylog272lFnp/8W6A1sbXrkMEmubs1IEtrkAWU6uvXPrzN1GSlnNC/VLP6uzZpzuEdFi4FHRZUXxBryaFspRlYH+1rMM/0BIs++sgArTkaKj6Z9gRCZM7tgLlyaYtLmMmF7QW9neWJ0sBeeg02hSl/oSIappvHBldNtW9l43wvriwE6kdT8eqprGSQKUene6XvJiy1HtTT93oQwNUoTeEbIdv67wWrYQrzSU3y1PxyDFagEKCFnjif2NoZMimaSmgjeFlvHT0+9qVFVtEAHP1KNgQjV6C15jiHidhvfGbRLNAkpkFGiNItIsdhqBcvMk92rBK58KL3Z4jI+KcfSRbr6G2+WER/UVlwcpfcB0XXOvXW0QXlAbQ72aG4xk3jHl1XMiXFM5V/FDlG6H5IDJ/FD23FIrcviFtKwyG99DZ3cA4XxHUgqame7vWS4/EzMPwHIy2bh+jp5O4ckM8XvjlQyPILV0sao3W0+uJPX8DhmWkMx6kLeB/fB5Zd62z7J0xQ3aaqExHMqJ6Ry79VGDbp5CgEytsVj1Y3asieSKSdxQDLR8gbonN3eHWF+15/9URgbPCV+qsYubNmTWtEzsoZ62PyC8fWODNpgvJic9OTstlmY9f2XFcInz3ekrYGIpRR6t21cUlrTuEJHhiX+cQ11rEO64dkb55Pdx2rFLF7BRINNaRBJ3yi7J+n+n6hDXG3IcOce5xXEq+4xGZSQAq9dHl79ABwGlNp7MzQUzA4zOtlWl+l321EyGvVmA12lMJi+XInwkeYGb8alAbLic3ZM7+wakqyjwDCE6F2xT54awRKDCcg9nJYb1uABI154aq6bKrdS9QZ7dsfRlqiCkX1V2B/di26ENpxjxxCYZcaNXpkLE8lV0MRpWLvRm7JO/rmu+XHFoRk0yiEF6e0qeiMR4sth4Tgn0qxmY4LPcWIY2O2EvfwMmW2rKqXz0PvL3pLqemW3kMCaxskz5rdFHLuVtBvO9sESMTfrMTqjx1gKHT7Q0+xQ8yA1/zZuuJiLnGJhtKzEwyEsyLDtkpNWa4GJ5YaTXOA9h/McJYGf7TcwSBTa+7ml04+yrK8jvybhyGnpBJDd8RTzEsQkHBtPhVMZTqrqUooj4hB2K5geyteyWV0inwBjOfggzZDJj9GNyS94E04nULqptcb4I05UaePeGLmuw2eRYzoW6njrazbi5hO0RLmvwMXu1iOMBMcuQe1MEVFAjVAWoq/dvD8+BpHp5kMBYh/w0Lj/qDZKtTxFixnOaZxGk+AuoWQmuGgHF1XqPq+yA+XM9cKIXkhG730dei2cTvPCdhwmznkb8eyXwx6sYG74JnmKHDjerkZ9T1nTo5LrI23x0fReLC7FCYsNTyPB+2LuWykKDpiwOy91ydm0iBoVxRbMZgIIgOYrOkxMqq85E4SJCVUop0OWh+1iTnQ7CKsC3US3tbzhHkN/nVhJOeCC3Toc79ThZ9M4ekCFRAfhAdY+cxGHov+36T4XB+A55NcbkaVlldH6PbRR+vYkL1sv7Fx4Y8JYHnuY616IXHAI3q1xjL77W4WB8CdanB8wSZXInCT8r0yHjhUXt3LgRJmAjguzLoReUI2UPeKntYkiAex+Md9oYvh/sZddtvMNr7YDUFIBL4VaeMYcqt+5MS6WN7jhB0BFiQojHqA9i405gOdeSekatc/7Dsho4Bbb3sjcK2LGu7RKloVIcr6H5pORZvhSfzwuJhf/ingOCbLkCqb+6YPxzd2NwB8m6FIWGu98KjS42qKG/lgA1q2+UoalOaFtho2C8pm0bJkDdd9x4ItYDmQZ0+cBIZUiQkX3liIhkMvai1KKo8wtBwt0tFYA/xWqm+qcCJRWDd4IBIVc/NccE0XC+5/6SV9OGA0GtThl7NSoy2HceDvFdKoQe4fgytigGOFy57RzKcNMnrexcdWV7VLwzdp/34sRCM0SVPhJEMlhx7hCoSRTcaW/JwoCehhZ4ClMmKAstWLS87+VmqPko66yUlWsLQzdKxKVDzRsRk+ejZfYNeBemWPbHWQ9KoPeVs70Qi+/cnj6ro4qAg5ZhEAVQ2kjfDMbOeEpvJn3/DAQ4ltNacy2PHi+FN8EnoWBqCwnAkGvTbJFLFmrvLl8CJVG82UKXhSyay3vmH0vcYfcSYGHHvRnrpuJoptVVGIedzm+MwCm/zta3DQ1FllqurcpVsdm7bZ6HWgyuqjkqy5zk+nrRkrOidR3bv90M3z9KwoK9wup8OXqi8gelxn4vWiCCxyBqeoVW4BoXZ+RZRm74GM22bls6FS58ywPrUmrI8ggT2mLO2UGNA9O/br1JJOU5S94/MC77A1ZT8qQw1w/V7klDjz/mur/CrHas8bJNZVh2UMYQdAv/EkdNtn74Fo6VCgkmWgU+hh1wMKAtSGkL5ldHvvxXYgkmJhj+gsropGNsvomoNsBveMD8xmbKBQDkVD2RiAWvGM9d2QlnmuxgseeEmPBt46cLNJRxn8EkLut9kG/Snnt0DOmKAT5OHVsze/x+bDVYp2IIcQBemtb8eyY0C1Q1sQuNw5CTPyy0T/YKGcdu2sJ7Z8+qxoJAJfLoDMS7EX3GYGGXFAX1xiyDUbL1a9Gt0DoEn4vxPMei6uNtTQqctzOFBChp+4Daf6DMuroWhbYerdL/miJIQF7fACn7zqtwL3O/AYLIQ1huuSrvPjyf4452uiH98UBYZeTWMPPQhJjd+JpjOOqQT/nUHddJ6itiXNlAWsFpMueSHJ/Dsdpg/LjW8915hbxpabsG1PmPk3GJOo89SQx+ELtqM+mz8xFSSN1RLSO9J1ZQsIHD9Y/REUWqEIY38+QDz+/AR1ZZ7wjBa/vhdo8jJNONd26fzhCzfktNxs2PwJTrPeF8L0Vro9RJqa9RLCmiXCuuzSV/VIK0t4Q66q5EdikBJSwPhaB8zeNwYxPyZEUjDVoAgK2kmxatvHH6nL3mgzpwQwKe9HdKejAF9R5myao32I/Z5kTcA3zYtCobqTWwVNnjiwY0awp1dxqZy2fLY0WPZsT3EEiI4ws6Pv0owHmCUr8cl49XKJMP/H1SZUtMee+rfhnJGCucueEe5WJBZxs8cLdk6Ut/n3uU+itys0+Bl4vfl/ZsOK4xAm2vXSC5SqfGaFgjZh8SHngwTwIj7rC21Esx2R0zEpA48Nmg3TCxIZwn5Y0rVcDW6aMTH3O1wFw5SxFwUWWlw47TF+jCDRqrRQ3bpEhqwnWjU75mNWi5NHlnrIGGQWgKsigguPx/bb8mhZM/jvAao9hQsb2eBx+kJKF+G7QGo/KYV6ToUhlLY8BxUoYnG685hiUTWxx3WTur7KvK8XSqZYlIRVeg2UN/FJ74hjQ/n193ZIOXTYZZRAtzy3cgyZdvxnQSsTmHy9OJgcRscOQLd3ol/NmmDrG+OB9K7yC3NLwRZGd7/QpfWHxafBcH/YGHDQsbpeO9NEX+8WpaCG5HvtrGtw1HcP9x4/um+gIhYZ6PowrXzsQAfafSqtdsKGIAv0cT/AwURTygxPzaiFptaOxGLc1eyrCC2eNodcRo2LmhNcAN6k5rqBfVjhnn4VkDhFitY0RjUiVyZL0CNvbzhJYIZYrTfBztyx6snxQ9gYi/qZzLgyVTgOugfZNCMGtQVmJ/Vh5GLNXDkTKeQBM5Ww+jM1JNCYEqpDS9SVD1Fu+zccBys2ZsSdDiy6+9s8Sv9oA9gMlfiCcvv9tBnIsvw5qBVhr5vbk8kJyFj6wbx7ElYUY6k9zah23cLl1beCq/TS5rN4E/ZQnC8TN1kvONFpl9eVI2BiuPWUtXqLO7VzetF/va4d/D7GNvPZCrLz4yOVWb3GHS+JSdcoapZQqdxFmj+tHwOmx9DP7fvp9CSw4Nc6GjKxPW++upov7SJwmkbD6dSSpcI7w1vWY7NtNBZpsE/fand+WZHRvEUQfZqW4cBm2sZbDiEdcQCLz7ZfL9j7tGN5bqjvpodE+TmszkMpfV0BKtHg1HfkLbGfWjaiTxxTdhtLaxK2Hgz2Vx4+vWbgvZNN99ew3Rn0XwIzvldJPqz4RnwgnCwReeA6Wq1NJSzlc658rYEtC1FTFXvZA9jEfd2rrytGUcziG1YDxftdaQxfUBXMla7xhYPxmnw0G0URWpRjyeI3HWv/o9mX9nw2hRd+FiJsrWUBxzqoNCiS01XOOA3cPm1TZAgaX+f+u3Irl08eTySe1Dppew8icSWsbi8VWbicUOG2K7Q/LYJodx2pw2j2kIt874ByAVJui2QPHe5f/P9aFNdkaIM96lCm4s5lfV4E1T1jMzhYziS6L0cV2PQo/WZqM12mvDp6VGyfD9Lhf7EkAwC3Z8OITQF2bHrtXV3ptz8eIWS9tF7n/ItQfOfJeNf14TOlmHvtM6DiWghiu7n6bsoG9LMJj54uGwHBMMUeGnndmAR3dr16HMVxFO+Iibg7WF9IFVnlRUv9nEpbF+O8I9EW0YsW8n5qZTpPXVobHH47nOnAbFV3ABYOvgCnGnksKqmuCv/at41dEEPKhg5YgWC7jW4dEcWYSVcbU0CSc9uSipYgcNeEhIrNkdVynzuxZh+JTV8GgC40l4PUiWe80sMr2OVSVvk3NB4j9z2Ps/F9BGYE/tviuWASyhcwJJuuBQ0d4rHKniPgEFmA4G5Kb0DCMLb5nzsTKNFqarQ1HA5BISJRgIs2ONiketXIAkIdGT5JpXLymHIsV+1q/z+6gQOEchPt6FRlbFPScgDU96qYOOuzsQtcljLE7M3vSuIem30iEY4jlkzD/tgTV0CG4rOWd5ZR5J1QDIAemCE4wEw31l6bFVkHVn+Duq5kHwforIuZ/gfmCwSjqmCwabunf0GdKDbVnf4/gwOKx4LeoDImFQOA6z0FWfsiwHDKpVZnYBsrnU9CJOzfZ2droqGHMKJJKFkvoOJxoIEAJMqWSqtlgRDZdg5LEpsD2VT+M7UFhdzQI4t4884V/9MhdMGR4DyYmIyW9zCobHJAc8UID5KgaHHDStg2l3PeWGT+0paZSs6lGsec5I1ygYTwWzcKS8jZF0gOZzT5A8u2wS+4Kl6QIv3uoiJNlP8qeC91Xvmf0ClkVn5osDtJ4SThNSKs+D+D+5epfs/qHUau5bKIzIGQPNx6aSFZtTgrj4DelvmDPvncojzntxX66wm775EOmfoLsU60kBMzxpqREeyrIUh7DpG26RXtwLzH4pA4vEQ8UqY6SLt5eJtJ88rd27QWXwo2lNqXqmHozXJyAuncWVKtKZQGJw1QBD9DXN2vZBhRI7led8MyhYwp47SuvAyMlx++AO3ZwQKJRfaCj7+XLMw2P7unI90b8/z8rGu3CDmCpi91rkG0DcMko07xE7St6TLh/Qm2PewPuy4ueyk2DgPTdvUw3DB6FUccy3zcM9KsRpKQDAUZSkKNCoIvrufUvyocN6KuwXZQpBhw7OMMrRvcdtN0tPCbB+7/fwwAwGdrXIMoE7Q3kpmXKcQtbDjwXkXABzBX+4rhgYm653VSfIf90MeV3vfyG4FXs2SpoFcg8iSJ3b0yGQM9HnxY+llmPvKNAel7ZIAIwcQ0ik3SMubnzua52aJFnnLrtQe5JrWMgtUANfThTYZP02qMhAjhMiz/ZSAv5XFkoALLm0doZaE03pbwHnIKuGNTg+C1r6aCSxn+iVV7szknrcTo6oMP4kuEZudcFJ4MGw9+TdZUa5vPv23rQPRZwylN+q71YQ+iSWilFdmOWJOjxa7naI6wRziG+WTwTJowzcgEy6vtc7O129ugdlZGTHYZXfXFjEhwgsegNZ6WarSV/rbxZXUT8Tcv7S+ezRNtMugHJrA8IlX3vXRFfxjY7x59K05e1DXQVrpj9C3qoGhGdk0SbrByCbNiXV0+azeqEUXkDMhVBrn/1CJf6qpKbyJGUgb3SQw5ZVCrFOx0637QGfQkrPzE8qKKq+yPoJY+yuqKG9MXYYBxzMIfrSsjW43dA8htB87peMgwuJB/OqNh+F+vSE/SDeUfCS3dn1weWCgZeF4/bq8Adr7jOSbu0d+8FH7q4Hy2PWZkdBTXDyZdFhcfrDTEFQ1RcAQDz28jOUbn8jU0xnG3WiBwgzMYe56gFazi3y0lL6FWM2K0kKUDSzar118JPItNiWrBd7Lz6Bxil5rojTuqQnyvZQCOf5z/dDv6Q8JRylA1J7L0MjvyZHODoc+R7hgPBc3Rns/ejN8QtGVu/LZfVq2T0vmN0YgyBLx954MZ0O9GzaM7ffUHmoMvDyQJrA+nqWbB1IQ6lzb/GhR5ry+rv0YLP1K2aelMjf/2ZsK2Drsjk5WRWjNutLPpwgfNMmnZ6QiwUcZHh24N7cz0nWPDAnT/z5iHBTfh0EJBAim8tvMVSm5Om0TyxGGestj8eR3uw/9a64IKyC/mWHRPIIkrBIFs0N9rJk9PqyqDtbm4xHFfgZmduy6eVPY+RT7Nxcjt5IADPAeidyUAhU2WadkEySY5L4fgs2OtcFd/0ODmJ783cSaG2Fn+azeJBMoiBMmLNJJE22BtvCeTRudF+47gJI0SlpGUFCp66iM/etpX4dY3S+ku7PGNgUr+m3RBazPzKj+2u/EuBw9/XH/NcU7WIkW3Se2EUDAEQSLM06h1qqDqzKOJ3JSRXumIL5J6a0SgEcHk2fVPRUouMyFre7yYCpt2OpDDtcUUf9sfJShNjfgu0VTMGqSqqojm1TN36JaHrwAZ0nJd8helPF7nkiJ6bRZ79Tnq96q7p2dumaw/4S8z286Bvf75Hq3anP1lA6uHGYcHONgjjH5KSdStm1isHEqsLvvZuxpCZgySDAjuSL7Qd3uzCbhaVLd9qqOZY3o1AP93lUeQE0ZqtxzU/IY7/kxzas9E7cH+/r4Gwvo+/N14bGI6hXdP/BNSTc8X8wW9Plr/2OcT2tUvM8O6x3gTx7wugmDOWyKaiDmyiM5M31LzGcZxz924Wk0IbFSpXMMAvtZsEnJdjRcOR1+7gCT+2FmSun8cjMOogG/yV/ynwCKeCEk5EUvuPo79qjwycYQKdCwBGGtqYf9KtgCTyIcX8twDCWonukhbghVR9CKac5AzVvXOh0WO4Ju50ywli34oBMTXhWeAqFAWXJjXURVDqbYVfk3GZa2a7UQ0P8huBEz0EjkppzwYLrWij7xipmF8jDCXAmB77RUr1xKE1nE7Oap8E3HZyTWbfilhg3HEim5kLlCWcm+zm1sXGxn3gDcp6SoImU1DI+7rGM1WkDepV0wGA/3c4V8gFQXTGhxhU/F7790HupXjHA/fU02gpMV76hu0hVrrh9AOD+buAAe8v9Ao3w4j9hnLJFeDUi13mzBCaBWMTehTIK+hdhh5W3nJVg7qdf8giP4XTAyiGA6HLTPOtomZYwPDtmSG1OQ07yMjX3N103qeh3A4rSt4H9IEJrbHr/Po4c0Q39ZkGeGePetPaEHQPBw/thvJ2cEFDDrtcIaa8N6vx8msCWQnPFi//UlC751dVwej/xAjAyxL6HBgFQgDFY0lr8BETEViVTbpXZx9wxjJ8JCoYbL0W+X9YkFOC4lJs2FHEavfhzkRrrp9Q3diTz8+uZvoOp8/tx75plfsYrGsTNuRG66CORri/BF31sWDCzaMv4hPbHHqQ0bWW1B8EBPc1QFHwAiq5e5UWFIO5R+Z8RsYsphSODknwpXQEyviQrUWhyEqiJ7AM4n5xrjCSZFAVTWUFlG0wV8zKsiytAwQs7kIHzvldcWTwQlYiqlJvtIjtPXmlN7CP7/Qx3VC9k90bMXalkXFDHWrKatYbUsap1RDi4217HWiQ4zvkTRMVliw2zuEcVcbMBTjKM69LN9JhtUK5szRKAPlYHHN82TStAfARw296p+gu0zLQxy1L1itVnPub7wX8e9dyB+xlqjLKNMCn++BN4IeOY+HaGG8Ry0hbFfdMzxP3c+U6zjhLQszqXzSAfWbwZgjpbSwP2HLP1Bmc7va/YpFCTzwLsOtBLkoAQqp/KLrbVr00PwHZWHDzCy7AadowJjq+yak51l4CjXMeL3Z7t6qsIQ9/79djmaJrDpv60Cs31D/Pd8NZMPY/cQ8wdYDeJ9ku2nBo6i1ayDZvCuBdKf3PjoezLFePZBBYk6d8vLbh+STW4p+Zn+swUEZgR+sT0TtUquJAYLeaYaMact8O9zPzmISKhAca+TfY9UzU7vZOc5veohS/uFSRci85qf7XsFPPOAgnZiR14aHRSPlEa9Dy3ff03PMSk/NC1z53r4/TeW5Oc8sm3uKAx/ENfWWla59kAvKBVh9iRosWbWXwLwd5dduRszkk/1DNwXnc08gvYC9750DsEzdps7qFbdnqVkc46kcMChRDCqkyB8YQe9vKh99gGfqcPrTxnBlh32/U4JnsiZYIfmxiLzVobr5NmLOEsqqqV2Y8guqynbS0QymkFHslMzvCcEjCUL1BmNpSo6Ga6vb70Up0Nm9qHmhkl9/2P3znf4BtfxWdu8z7hGlatMLas1HKrPlfkjBNgKRQpEc25BEH1MH5o0WoVJa8KbxJ4moivbVxT/N8f2olj0CPKMHiWaMAxY875cm1bHP+stvkNTPCgRPdSTHYpTgC/qRxMMB/enl0V0FzTHUYkZvaFgudEPUwNgsXXFsGXYa/rIby/JEu678kR/wG2AdvD/8kKLrogP/TLh4CPE0JOGEP0/67s+HARbfeDwSToL4EOk1ptFX6Etv3x5m/zb4ZwM4aZQ5XYf6AtV6NGhhZ9ZNs/NK6miHyjzbUXpZ6a1ZpkBe1vWmzNNy+p1E1aeWCB3TFOscbML2wPOBbbSc6zNEMSk5MH2eqPSR5IgP3PZHsN4+JP/Bx3iPU2MPHhbZcT+qNUSDBWwUl38qtW2vr7zUUb1KYqr7ImAVmAdPeVOg0kIUTvC2cYe2xo0yoSm/UK5C0asjqCISg81lm6SFabSpY6iyozLIO0DZvt2Ik4cxnF612DORTd3wZeiWZRGqDHmQ6ZrZ0uLMHcM9ZRUuY/F99eeJPGPo9Du3hS1jpKjfbZQ0ymRB8Dtlvw0W1+xwedZq7ZtkagzU3981rNURRAVVAGOFyeJv5Dm3TFbJaUTAnRl6DdFx+xpm4SlFSGfaVdHT/MuhAD9adv70Ovts46tzkuJQ+31aPJs46ghVLguKuuPrlZ/rGWzh82+ikmUGv2u5AEMgi1lYWeMmSH1g1HPlMg+zRLYEIIo6krMqMIphd2Du1ttjnLd14Wu4FNajJ2aBRTk/0Q3tmGKXSE7tpvq0S/NwNzCzrOOIsd/mwsl9EMnE6Oeb+hTzW2T5J6CXZKEajif0hb7wsHHWOqMggzIJcZFTRI7elL/bA7DqxbUByxmfdI1pHrXkrJLG7zpu4iNOWHCcNCLfZAj2CnBOUHEPU6+5ZEPXGCHqqaUSL/TgVdezdErIvvi7kHJHAkRmke9mQr1rzvnRUnDAh6r76cgjtSnbgKez35ry+umkcWLeMes+KTKCnLDTppQtH2Psw7NztcqMHQ0t2fdTDso3RZ4gNUZwoavxhw3z55VY2meuZa2IuTtycS9tBuSS5dTHWAgzC9yg5K0K5wKvtzFAdh9wAdUhoem/zpbc79najxlS3A+RvsTd6TkIy10/hqbPGzEFx/drT1QZY22Khgd+F1STdx0dnIrenJKEecbaVMckjzIWmNxorOhAkHttC5bOptxnSnB6ljR35LjVewyG60UiCu484j7VgrLs77pLOV5eLShVuavgd7AC8QA5li50UcYP5OY0GhJl+UHJWgMFybQ6M3iIlXALyc4r2gvkK3YamJZ6TM5+dRLV2jbYfd3juGr2mwRjbnd3mYrqdOwhur3YcqAbgBZYArmhYf28s4iWQ/OpNTkksebTLiLjBnNZaTJ6qTjqEM9OIhUPcRyVyN5jtRmfcjEvtuHAOHPE/PECptEKQaHv4Rhx7pYO/tD7ReNrHjBR9buyMQq/Mlazx0JEEm+4wRefOFPxn0/aezltp6BUCtoHknI6Cej9YBg4eGKJDS0LtSu5AfOclOFKmT8Na0fh5jSxj21wleFAigz3paX2SXazv+vlDVeaqOm7904A0W/hzUDbN16DlQtWm/9NX8RC+ByyOVAci/B9iVQ8eZ0xEGQ68xMzFgwjDqxt62dXxclI52Y0Dnay8+hvuBQbZqEmCLzbrzzfT2cU2uIleOdQYkll46cf5BesCUCDRx7tPQ8ozYqO2qALxOaerMfw2/V4djmUgfl5hkYGd/SJgDk4xPVyMz5SMds1oRzJWsFVFpLro+FQBvRW9tzRMcm5CsAdp/q6/UN12Eg0Fj98gItsYZpO/UHZZzGDCuIssamcS5754tHfwoLtb9aC+vO3NMdiwRSCusqrCNbSAQ1j9Biany0giJQlDrf99n9Qks+EKZL2966Hh1lclhwo5pcEr0cb0FnYSi/9Ya1IyCG17i7L/l7v/cN3RhSxoFkC6XXZqC67Djv9OcJhP3hlY9Wszs3C5DkR4xz+fH+kEq1asia5KA6MotQ7rKZhcRyTW52XkemIuCg7qqcTexZgs340czDW1csJ33Ja2oXxX44QHB12ArILORgu8Plr2QkRyObH6cpSG8KxzAElrptGvmNeTAvvu9BYW1C6sUcxJUfOQ8fx+eMGGY2Ya31Shj6pFTM6AV4R7fZEjReJUI39tq22vBAyYEE/ESRigY7I91Z+/zDwXU5+ALX2yb+/w8QKAyPi910TBDWdzHz59TuxMAlR4R3Er8QOJUgt9miPdrOvOKLTLWawth8dm/h+t/CbYBMPjDkdtxiEBexAdF0eVXQc51x12yIVrFMXhZdixvHSoE9A4KEkOGsSVErwB3PF5kQHUfs/Kfvf3UKYjGDvKZOFS/b7heCHHS7BWRst80ZHz4zcZqV8C+Z1P0tHxIYJsB0FGgzJJdaOtv2RsziUsBl5ZepynzEPuUbSKxYm9Y2e4agcaV4JRju9XdQ86qUkfJpONj1odHnNtcycMAlDt+h773ETRQCvkjPdoK8EZ2bZQrZMQTqPCti0O3ML8ExlxOF0QkkwK21bakMqa/ijVxhjGQLkd042QM5+sP2BfhZHAdgh/QqnQ4jEtwlYFoZmgqvu46G1pcds4tGTeI6QirdFQYWsWn2fTQDMNUmszLDwwjezqAnQquqAPxSIQFh97cEws74XoMOxXfrMIX6k6qHAXcyIY7F8Naz6tuxlVsQ07X7Rm91fKWtyW4DPE7QeAMD0TtN632PDpU1Q+G1bM9oFlHDsiT17RmSJQk+h9AA8TIuk8FMqs8iqOkg6gtMs3jlBRTEhHjZRBHMb7JpThluHe6SN6U8Ozck8+bXXStGERikOxH+JcXFaMDQgiSs+IoraGfEOETxcYYE36gppXWO/55HRkc/qCN+6kZ3LSzicSE21UXCDq8g2g0doBJzi+8bhj+aRQmsUUEqvhyKnR3llEkCsH4JzmMUn7VCSY7bJei0TATKXLBCvNf4qyFoURreJZmeGa5lelEsvhzPafjmYn2xntJGI+VBz3WpWRy+dqVEVUhs5YM8jTkVFkKnXN8G/x4JNdP54t0N60ra+OI18vm+68tFM7zzXy514W0UOazKWk3RaIRDUrbLUB+4gZUZVtdfz7DJaCxTX14BWZMYQChSTvDPPmilJQhNLH2lER8dUImNZy7GWDryDwTIqX2A8UntATeW91yklND/Y2V8DcedvGO9W2NKwu/gqZiNFfsqCnfgJ+nuRDnfufCj1OpioZX6M5QE+gZ+gMug3fXPgjalBVvl+z7uCVqysPwYit8VESfKUfeYVV+kLzsywpn1lBY0HQbTpF9sT2zvNsYWFk+iNY6ApakxdbNFUmOo5r/WWjPWCb6jeTDxxqXAQrdYa5LaVoO4uH7+KrIcYQGBT96wOQNwUg2ohDP/esptRid2XWXJr9YeUcUjtN5xCIWyb5mTVHJpmtTaRZLW65zxC0bkkYGL6ABiumL+K/tytT+Y8son9krt2QRT2N0seUbClWKDf9XWTDUI3MOlKcw3/QI/KR5e+KuHImI+7z3iuEn3emSwZK9VbEsE3UoxkHcaRhTM89KpORe/ddVPTQtQzx00cFiHsCqOT5SWdG3lgvCEVzClwRmfQuLZtwD3ZHXgbmcbsaxL+9cS/6IagDFJfgpQqrLkqx0c9KBTABaizlps3sYvocdwWsMV39YTbVEAqYzen7hPL9+CTgiseGyWq4q5lKfhKTF9SHXYDOSVGjbCqgwUZcnirb6KTxyVpA3xrrNE3oCis/XzIryoMMDOz2W5YlO5hA8flqkqhiVhNGBzIEocliClazCNkj20euEW0uKrVmIf01zYZDglHPtjJlyCzYHqDU8wKf+kW7YNyVvMD8yB3cY0r7yzEsIR9iIwF5tXrAoFILVDINKTQM250cHlObzMNcvSIQX1Alpmh5XokodNJO482qO4Oa7eZzkG6jZmKfX83XE/5RRicuJu20jpMQllK6iP8h5HAsq0AJ7NUjLmJq6VtxbLj36rtkpXdps/nC+rUJYH0TaiwaaqQFNFs5bCyNqgb87b/iU/okDnVqKeGVRq3eOGaxL0ON6QjKLHxiTMrzQkhikFesQR331SYanNTC+RAx2nCox0eHl4JrRRzEDQL+aeLQbgl+nDeBC07LsFGXiHA7E+8WSA7S0u1+29gJ61Dnhf9t8D1mMsgRK5uNdMjpIovUX2hz4pxCdd6yLKQ7J5qWJiTiSVzRNnJpeTlPymN6xIVodyG0ESZoE4Oger5xmZn0j0Dj0z8Ih6oUsl9eJECj4oInEg/HjWzXA4U0BdPS+78dkhALMFoNXpE5wrwaCZWPyj87Z6kl6eP6t4tS5Ux040pBLhlp/W1YWQ666aqSdn6jq8scjgKBGj33ZaZ/kd5+0CyEGturEgNfpmdljjmZ7+koCSB2ENcMS2oPisg0m70GaJ2lBfHl3XiOwMXT3XBUVCsK3Ow9voiL4ToBxUXP2ykhkh69kMWVeTJrisfc5U9PZcad5CTyv6PaCNS0eyavp9NSOycZ9/1pnrcQ7uDJOQQW/I2G1qIt/dYsgp5o4xDqix7CMtMcV9r16RqD3tOVBIFMrwCn9Eue76Hm/V5SqQdk5BGmKZlbajgIoffXezSFt/mCpkojc6VDz7g4YIfxaru0Dd4dNr3SfVLM2ls/TgihAFzW8H7/Krx+no/pSwO0X7vhiFUFp1re/NCOfZ5R6uSJ2IfVkr/Tq9jdIZn+fVJAvNvzhlj9iP4FEh0A3Anrn4+cusW00/nddup3ZDdVio/1Kp7cPSPb+NolLPIZiQfbOPNokEbP8h1aP6SuA1i99Ep5/VkJ1tdMLkgx6HS+qO8C6jUopLO+S+Hh2ENpw8E/guAOuqFU0fNbb7iCxpitSen/EbqPVFVUJMe6wq3IqWsk+/qMVofxg6fuil65iaEGIU/OSXUpmehZ7Lw7T8hQDxyssTC7NMEfl7fIZjtMjtcM+8VdEFkhIHn783/K3ICu5geomQNrgG4K+ZocjFOxkpqAhg0DMPjafHwDuKQOT92rFpJ7cTaPChiH2JU7oYWR6lF9Pdk+jUNboGZb1j0NMI4XAoJbidJuvpFLxEdbS7t7K1jso1tqsTOY6tLHZPNkJ1dXgeBliP/+ff/Wv30RlJ6ih9uBx7DjwHdanLhMJcQ2CDl6i5cHawKRWonfiM0VQ4xlF/lL+/TS+NkyFDhwdj0ATHpsHdWjdMHQfFMt7SjXUVTezyj8SFRUaJeE968A5WoUPeZKFCctrWEYwGgVY56g+2w0ee/z3MqAZQELxwXU9zkqXLcJxYJdLJBHyZMEKCa6SWMfaIMti/F+wuHwocEUfpwzZAtanmYU7Yugc6Fq2fmU8tFGt3UPVM2+a+H7mQKMLVuUCDX7AhYbIH3xZRui0yrdgDWAB/Y0SjkOz78dcJBMZvM29oXahKmEJilG7aCZAXDzEE4CDGDR89IhJyI8fcyTRNXq86ROiq+yH8k/WnScyTnADzZQblZAUO7Dd8p6v++qcXvrMvp+of2ySaBH6Jt3bvrG6LnAPBGEkxtEDpoao3vhzLR2Y/DY72mVvyg5saqqFgcQUXN6yFDxvlU1NTImeS9zVeGfBmoJMdZXmzpyLcHrK7PxGUcNzzRHYXKNCCFSOFJK4MhJjG+PqNeDWbLY03lTXWhl/sfJZjqtkierU8GHRCstPm4Xt5woFiDM/aTdCzxpjVNA10Rfl12byM0Tk4A02YFinrpG05VAbVS5M+p/q6qR2ZQkec1XW1hlr6M3RAHaVx+LYWBs3BxLxNuTC4qMVgje57WOszHd34bdHzVyxPtttlZRg9/r4MYOChwJF/lq3QhdtlVk3qlCfvcriPko9JINg6bL5KAOoIN6+RljEugM7Cb9GlxTSKtnIT0asFQ2vvqSdHOGDp7+woHga65MQ4odifMlPC7zODzRNLA9yHkKdVCIENA+ezqtVQZ9x5KPs0Ork/z7AQfUnTm3MtQc5zeNKbNpyfCCNmfUjzFCknwFpoT5Zui18WbwKvJ4vgKR95k9sN8+ywdezkNEuXGBeUbV7+cZE1oWg2kren2IAw+5llcnoPWsrQVbnaC4C2r3r9sb4UXnI4cZJGiR6lVzO7POo81ozB6C9N6kTgwRh4HIO3Zu+0hnUKPQIKhVQcrfp5HZQ8P1cYwNrjy0wffEcJderpo4nigNWEqNPGjf1Og4lgsScfOfB+sopIhCFAgTqblRVPwn0cN7tCSnUpDLZ2Dx1+Qi0Ye7zz9K0YKTY0MVPLA+WVKsU3rr3SPUvj/KVue0lzfdIwDNae33HGOevV1nN/AzypEJTdVNEnfWboN91FpLe/cu9824zNdBez1NMiyxNrERSbfsck4bFhAbKTJ9L9HhJ75JEcodgUHmylLptUbxNGc4TQbAbUMg8vWinO9bmVwtGJjadIoYTrV4tmLmEdrDPIkh5cLzcE6qrXH9RCxBhj7ijYGjeNJ8zOfTTb7gFPgc6eyhN+3BsPYUaXZ6O/e64Xcw49eZZ1ZY0FfSTD3f+sPJF5Yu/vgnxKxZEQCuvVkd3ypGw49axIsn0zihaE7yvXVkYhuU4F3HoMNpj68MJMrHB2jz8NKgz+Ser9khB7fHun8aZ6vXtmBWgdJDbPp6w/TbwHCo9Puio15AbkUPsOZKgNr1x0o5v8C0iSqFrqT+hRTXVGUvRnVYqpAsZurPgYjAOt2c/r+99s9Y3xDiFbuGLX8bGHBY/IuNFnLXRidT6HcfY3g9QmtjT6LgoC3mnvrvLOqBOgz/dPgKhqJTXsuIKG9I/Fc9v/NyToFNAL/cjLYH7pD42WBzzWXoZotN1Jo/FZIN+LA8NVrfzByJXWNdNtAH29AjoR2BC0U2F41A3aQbvfuwa0knE7KEvosn7iqwjeU/RDBhzOduLEkMaCdEpWVRLKQopXj2awfx0udPYbuIXgfE2KNmsTom337g/pSASvewLa5+iIH98TKQus9DbTCgQUOs3VwSp221dey6qGJacNrYuKmP3S6icLe9MDzsRMdc93WqdrXnetirNO1E8BbfZQ4uwyyXKJqlhwm0eBZjBBTMXXKaWz0/wuN+jP+0bjKrwUjTBoSJHajS0Bcp49QvKpQR78TpBnco00OILoOs2zSxr3SUYA7AGG0613tdcYCLrQT+xoWnBufBH+SOjZzUMhaXQzqv97xKwMtSgd4cWGfK+reGt+vLfT8vyP0KIYBTi1a4/LdNRunQJcb4jz4F74REFYEEd1UOkuc85N3LE5RAxss6JjBJ1YQ02gF6DcZCDucSNty5NW561SwZKbZHGooyeVuhGfZiBaoeI6bEIq1hOWYnThMZFmBkX/lHXw9QaHv3be31snKhkswXgm/g7tRINx58EGMP4VzbTkf22B4DhlI62qfBMNYDir0Vb7LYAqm49g9la2TUV7KFSJe3bhN+nZ004ie5dD2k7b5yGvXlKI0FzGVifjlxrGpz6+3eOeZT85B3JD13WFeXXvioK/JZpYVmJrj4PlgGhixzhMEGEDkJbSN4rcXdIz3I2bqVCODWOjvW3wDEYddpfMbWWV9/Pc0gAgRaqor1WN4IXih9QYI12/tU5TGufzZ93sz5kJ80Y1QKLeQB+2gV1gqDWe+7DfSBfqAWCGmrIfzSi2LKlcSIOoYvmKZd10EwXw9Ubp4Zad+L5GrDKpy5hvJsa0Rs/cBrAxdR8O+cnFIFdnwrP+5ahIAoHhf+1U90YR5O4q8BSGtFuq0O+Co5iTZh1Cg8Uo25agpFnNm7qCv4tbk1VnVmiL5bPFBhYzSRchWNrItGp6nUJNfdhryuWR8cYEd56UWKjEcq5uH7RkkaPsSR6UeNBWycGNHAzCS90XFAi6xjiLDIbO4rwsNeQfvZrIL3BvEGdgrcjTFUI3m5bT1WHNXJFrqm9dvyQi6b/iNvu2gvN7FcQeIEwpgyby3bP6ju1DWBKauxIxrNPC8jP7Gor5awhkE0SqvHGYL3dDw+0zSe3LGeCryGBhB2QQpA5HkCvnmQOHjUXK9Y2mgxOPdl9m1TYsCP0bhYVrNON7NLZuakfAnqRiQ6VMZCFDJc3yomxu8JPhRTLawBgFmX0LkmZgoCmQ7mlnJtZ7xdRypjoX+CBl4gd+RgkSN1wm1ZIsbqO5In3ou2zURKZgsPilKx90qTJsuxHyEYru1twbLb9m/FIOT3ibgkvjoxO2JVFZeBBy0v95NemxRFnNMQ/f3P85sgvZcAwqwyVc1n1Os3t7oYVKSGElHHxhl7F/LPIigimXcFCKagYvg45ZIsSZGZLm6U6d/srgb82ZVMrXEQ1Ghpym0Dr+unYdpZ5h4RU6WmvUvVa94iiP2bwOT+Wv0CRNZzwhwymAqvQlhyFVlf4QGD36i5zhohlvqJ108tWwA+2O1kLpIrgV8FMtMWh3RhFbnVcJAzySVYRT7GCvkNFiOLNDrxZnuv9NsNJWTESENf552w6vk9D/uJSFyGkvipYfUW01iE2ugq5UTtjaLnU56vyzj5TJzqY1ZZR/Y6qqnnI+ogqgbkr3mTCVc6t4h62toImabQCKFNhlM4OAOwSaKrUTllxgGcc9MSyIcF/41wwdBrCLPDIkE0KWacT/ccUUnCmzkwuTQVAsvwAjIdJr7O/MhVgkt0ANyursvIBmS+MVcrQMliko6vBWHWGj+FfEbKHLIdkOC2TAFuPGgTuYTK/56U3aV0H+puMfNs7+yr9Zb9LtTIi3N8/sZdEK8jouAiiY9MNDXjtzbi9Swf747nZXgLd5LvxSqmPbR4NN7Jxs+d202LAaJ4fhpQOc8OOPWAx9ENXHA0FQp4ANAgIZAIxHDrOm6FaE3He3kn0OvE84wf9Fj7cVHEML0ONauuG8mxGG5BNPGVS+wPuXym1LYLi2CgCmrpyUcMpR+Eg2RD6Tyt2d17gqYl0CiJS7epl2Rr335FckEL0yYkuv7lgOi8aRJhNh/tdXDhugOOQf0/WLkMQg6sij6lwdbujh3ipK0FOq98sN2DQqlkthcj83B8sCieaxfynLE99eHLeU4YThSkU0yKbGoxO1Cs+MAwMquhQcOckxnzJxT3e86u6Sdi1TQyfG/9EKbu+dgbTxkIbFOIrtsoPRsHnD6MGxliWO1KhnPQc0W8fxxcXmejPwJQEstLG2wnRptmGKHhoUSOjgPUMtJxfFl76oM1rDf1C/v4VLdW6a9t9hkwogEBr1nu/g0uviQwvqJoCvo42IqmL4cK3Ya32lLlQ1qAT6OtZMBt/F5BBSoVLyZKF2ciGR1CPlV50cd/jLkcDRTpHQT32MKPjiTcmkfOTEcjQ8yf3p39kpkC6kCkd+Ud4EXsb26eM1iQ58nktGhvsE9PXXQz9Ke5/mdYlAo6AyhVoTf2YZcBmKbKJYF3hc+yU9o6JGmFdgmbPMcXbhiLiTKtZ2uk8qDPRKRUD9C3QLL4hbrdXN+btaUKJi4BgB8tH00FJNl+ExMfXE9+JDDop0cDINtUfH5g0rFtp2R7jwhJQX92KtIyWgiZhw/CKBChnGfBBkKcTXi2qOskmJHZN0Mz+MuPpf1gqwpXLJiBTU9szOojCFweKVuKqMW7o0uvoEqmG0xVLntU2PZwmKpgbPks+1oig3WiKgM+wlCLE6YtlFNlc94LYrH6j7k+g3m2W/u6ui3/Xp5SgNMRvJxvJ1hkr23t2JrH2WeIVd/n0wyk5yir4OfXpto+KV8scd7ZYlVFg7ykQcuMunny0t0U5sWLvQ5Hzuc+jVKuTABXejCG4QTB7BrgQe/wuZ4lKKJbGLZ6aKUZFQ5JKAA7olTWhqdOoZw4+R3SXRuNxThTYVcaxh/OfTtYBOkROee2Ph+060p8ktLZ/Yd9oyIENK0Do/KbMUejCTikOXckXY+56sawoJ+3FX38fd6Uz/t7lZ1So5PARssHH04unC8D8rWRCcpETbEKm1tXPW7wbLzzOotkOqVWJnvuUqecBu6AGNVnW2l7W3UZ7Mtf7G84HIrgZ8ZXx00qnk1mMeukozUF64n10gBxOnK8BzOnfwB91r+53xNJXqGg2C1/UEfgbNwxBblqZxNoJD7NAKRM+FsyEd3uDlhrP0X2MX4pBmTpS8BqSCGwkSsBC1uXW6gVb8pWDq9SuHJOBQJZTKnzI4g+3JFp1faqcxLaOGCZ1b2+0DRRbS80u6rOe4upX4ke8L58B5IkxKFu4I4q2GAoU9Y4tRP5eqTCGaZuQd04tnvxw607C9kOI+s44v4DcRyiVbTaXyOOS24eJPh7lxG7oN+wTw5LV3ocxi7nk7ptgM0L4XLwN+EI+NaIG1/5eYg7zL/kiWnKRKqchkTVLduLLPolcDiAB5cyiENTMkXT6YYbvd7AtycjOaeNy1Ir7ya9t6z/8y+Fk4bxGxA9L4IWhmcZ2sMngs4E4ccS5+DLns35Mt+GYJKRnApKrcoEpbaze1f/G8JN7WpVnLXmP+hwIwWKLoLX5BkHKvsFh9lg9JuzzZCdzUO93G8rLM5yWGcQ0s7UgWNGgwBJ7jnnKUPCTuwmiii595v7QS8bvF0j1YhvaaUtQiy527RP5LKd5XEBS0uYP5M86fqyCIdofNE61hEadpPE+NRlymROciqqIOD8DN0qddDxgWU+JckpatQEImru/bdW8q/XPCwPCbmOvyY5We/YdTatj53gM+NathBISY4Qga3mga2jCMpPGHkOzM/XESYGvjZ+i8RgrIJRr3rTgaHgEqCQnnCgju3Q32Hso62Py3DHQTOoMbiD9MZOK16dHsvoubKcGRV+axOExZcGOjimVhUd8Ace6G+0Je1jWPwTuooLlEkDl3UcxR/3/BO80mVXCu1AIf4l7AygG8759E26eyRvnW8BJ48PCc1RhvYwSGp7gYaykFq1Ruhz+EPa+xwTShjht6IYJ+IvKed8ZOBZHBACryspOFA+QyN1jUXGvLeJhDh0YIqlHHK6SctwMBvBwOTlvCb62S6Hjv61nDzedV2fUV9NNTNwDkzfSu9ikVG0X29AFC55l2ursd8sw2aEqJLZhOot1pDh+tZh9yfSYkIIEythIFZIUhZDEuVCsPDUledGDrk7l9IiHiPaZM7JgQaTIqtbp1q0+m/L/cQ4x8DanGwamKmoxVMe33Qd8Y4dVcM044zxYBzFJqwS0xdwPRvlnGwdtzg8BD2l+TF7JdFFnk9YbSbqeXsHvaxTN3HMiMcGaSfVBugiCMuzWA4SDmDLPTsXYD4EOlb1jCvFnAxVwsOYiW6qaziusTAcdzKp2kbPqXP634Bvbwpx6AlPydj4qV4LMMALxs1+5DUgh41NYLIGO+2tStwVZ2Km/cwpmCnQlOfNwx6t6xd49E9K3fP+qDbJdyPQsXaWCP86R7B7553UDZqQbW2aM0hS2lcoErv4iYpPfFJb/vMj6oLKG32GEvoH5+SufuyiLlZZL0Vg0mpYItVn4PLg6Rs+UMOk3qBzVU7lve8w+oBXzNvB2neOvy1rRAbKYJJV4nXt/qH1V3mzFzuN+lJ7wyt9YmFaXKiaxeN/qf4epUpbZ5ygDWCJuvY/To7ADRvswwWT6FBBjqp6exe1Z9yoLin9m1ARAHfUEjm9r0E8vCi/+iWzYc84eu7SIDVPjOTNBuAIc8EE0OXatHEYl5VOnTEqfxtfT/iwMG9QyfeRiZdj0I9FlEng8m+wNyQm9SRnmzUfBNWMeV2qUjz2ZmMr6cNsCKkKM/pa+L9ZLJ2U20Qo+FvZJ4HBaAKYxjb3rZzjadK5jcv/+ClXvoG5nuXlxuywGFUiMK1da78lV6RmZZ2ibMqmJsHgxzNh/mYDiDTLHYHkniXeGA2bq57oG+upk721Wxe9UgpPPddaNTNrU587Q9t3qV1TL2RDLMMLTQrgDNG5FBlQnmlQTui2OVK6xq1IoD0RcvpNLce2latuefz+WHc0rGsjR7uAri1aqc29QYtTXUnqvS0I+AKf3YXkxY21gsRjwgDidkMnbgWJz2DnraJS4x5Rxr2gMaf9EqtgeyfzcnAtElvlcdJBkST+EI1pvr6RmE1njNdv4qIP7ed5w6dqJyNub0mawl1vvwfFROQ0LoK3ZGNpa1ULmJrKgfIcaQebDlCBkDq7mnTM/1VkyUgamhbHV9vKQArJ1hrpI0xKJFI01nBmWYIx92c6pdJojV0OBu3y+2Zm8XV4j+6mTf3+9SkcD5vcVyWDup/rFaZeX6QuY2GiV6Mxm9cOAkNVMGRWKwqj2laSfaa0/B+fled16mxByXZ0MqcWn9n2M6mP0jeFQvjbfEjvAM7GCJy7AtEWyll6mEVD6oA1TrMqgKSfquDa5gC60BI9YDEsff9MHjn6oYJNvhNejOF+0aGlGfgAk0w4HTinFaoEcHRAjc4QW4mcvjYE40LsQi2ZhYnZPxKWVQb6SipHa8ZWBvAcmMzGxoUMi9h3rykWn7SExnnsupkEMhgEta/kUjqdcDOR6e8C+GLRZJHHtTWmDeazsBNo/AVfkCJ7rqwrrfkHKgXPQXcwejUiKZoCBnoVWjLZAbnW+6NNFoL/tRDcTWoT78K1+zu3gxmtjLEQi40TUEt08ZMBm6DQtVqiflUdRWAq9UKQivt2tzQK91g8YdW0q18JI0c2wEctb4aVsFe4SbmocUdsbs2xlpP14XnPNPsnx025vNkUjHgi7zbtHyt9ABx9RgLY7Y+YwP5qiWBUX5/ANPJ+9T65aVoJLWYbF+Zj4C7eMBIBg51KQfkM1bN+Z0R/73sxOHvRsK0Njjjdf/v4XAriIp35KoBqGqIodd5seDf1jsDWOI4fz+8fjpXYoGxgDTyhiG0T0R2Y/9TfDjLSV58X0NoSs8f4e6Y0pdIV7vB1DRKdqld2mFlOk5ZQ2ByckN+zuC+UFYxY+OmEDfcCqJDneASIiXH5UcR5aj9ItCaJau2py4AKMhLDHVWhuH5EGYK7ECxl2tcw4twY468ELxmq9ZW1BNI4b8pR+Xc1qOGusHWwZtqw/HE7H1kS2gCqpp0uPBwlreDCjKPBMp1JBmfhLydgvAK+3BZqTLQo7zFMJ9h2ZeUFs/84kChH5xxRtp13wzjkrjRQbD6PaDVO7HyoJFPJIStGLJUEPW/KmBiQVn7lWVw0WIa6QpLk3Xtv5X4xiM8taoQZpZlMXlZtUEvb5Y7ZpdvoTY5r60yPHNegqT0nEwZBa1w0/rLpgrCmP7RlXcnsG95FXU88wR10zlCc7us6laRxNQTfTxDUOvQVI0OniodxowjQKUgKjn3gRISgZV1c8UlC/GOkM3ubFPQQWf3DngvuPKbk0BoPrE1snyB7T5vHnw/+mHGNw8WZJud3BlNtUrr94s5APOJKXTVXaLkApfodmOcoFmMVJyq3Rlqme8u1KdiqVQlKL58Tkd9QIkPgXBmJ0va62d3ePUDNxBUM214cBj+bYT3ixR6bu+pRHLntsum4PYVn7gBgzl86CDj9AOHgwROiCAY5xq2RNXJvSCScy8wNudK3qxxGo843PaZSjTk1k9m56RhtK1XT5vzOuan270fl+jUXi2LfPC5DqxPosDhaG3SRZHgXSo95+PM3cK4Bd+ry+euEowDKVwLRhFJEjJYLskHgMdtnHwtjb1hsB4a3XdAL7CRZtFcdiR0KpnzkvKiLIeO65dq0bc2xApdTm9Vvg0OlKmwDbbh4X/yaurDw6hXXyayUinjYJ1rxs+Qo8RMJsRHhSjYMPB9c3JRV/wqt9SXbiR9Ro1zOD0b/3yiY+zDA3qUwyThLoBxJLVNfxFOZyB+/85hNihPav7BVYYkcb+PNXnK1VyU+N8o8DIn0oQDQIclbjbt4WHdRwr0VHTZKzfgsAfmK6kSTrnbO0EUysxDO7i+lt0qVa4lkVF/cbOVki3l2adPMbdg2Rq7k38dCImc/i2RnRTEdvgl4++AsNfecZizu3KRWqek7KPuXILmK7z8TzX6G8k9s8OqatcFzsVPSDtIOyo1x6PnJNo+3M6VuoeF5X7ATKGiZMc9SQpsmmvRhUeC7C5ArKxQxIraMH5diDEygEtSK1Hac9sJMkfMunpnkr3dvB9IObk1FfQfYxdFpyLAd+fTyo/aoUNHCbS4lubD12sa6vqHTBCRItmX3X/4QKS/1x5PTd/3ggfVlLsLTy5Ol7ZAhWAEKf1tyLeGtFF73IcqlW4+OFp/9i9j7/bS2E9vVPyoQC8JkWRJkPRWUHXj44KB/kuPQPuB5pZzpq4xkfjlc1bLccxnEiXm6DnAOEyjvGFqIOxG6PxlHIa6JxpWiHO1TxSXqBA6c2hBbOzspX/yJrqgM8rb+0b+OZRetKoQlL9rDile/j31MBYtCxFfUFL9vSW4EXHp2eocDO5VqkpMqHfETkTgADyMBVI40l5ws/ckMCW+88MWY8PHoyXKd+ANQB7HmKbeJO4TqAI/R+mv7lguY9zJKpoaJ12miVKMUDTSuFntFx6ZAl7/xWN6+5Kc180uQLVAb6kSVfs0TMBpLYGpUGrm3cCGJSEIXvfRCpff/bRkVUJyXHCNQiAc4mj99f4aq6/LVlzmwIGTN8zKZG/z3IIyKUBiowTIIehXs+v5ZH1gUYMFfgL5UFBZesu9wBDYZ/eVY5Cnc9C/fGzEHgpglrI8No0F7YoGhFAMO9JUSYlw1bLJ+tTB067EYPOgTMaOH8CCnD6DD+4L4BxK+iVmI2jSFoUNFb0LNcVIym309EPtOq5MJXF7tQCUImZevwAOqQSw6CABq8WMYuFanpH7qSS9MyHf/nDmKcCtGaHemB6b8vwJhZzAn/N0c3bFyOe6W673+l7O5SC63QPBtpxmSPYRSVB7JcG9AH82J/WVzQareziJCHd/8J1Ek2C6pA6JnBVvWyEa4agqRff4k2qNRrf2umsPpQlacu6gQQD6Q5mxYc36shacqVFrYKE+L07F3jljQd0FJbrDDbgFzIaf93ucaqzs2Be0JJUMpgYSY82EalyWMT+WtG0Z69ddO5eeuuULzSEVJ7AdPOTsztWc1rJ+zWm1ePz6V42x4YRNc26c1TxtJNtrm9EXLoj6975d3cu7tQlndui9VOXstVLVmyFlOtPPbKECqaQkffjbwOpr1LBzKhZ+hrz4nZ0WwI316BKgeBVinndIr1S5pnL5VQ4j9msGr2N7/pzsVhHE6h8MYmmFUtJ1dmuv/orqfyBAhDJzIL9sosMHf+N1x90PNDx+f1Gdr3c57dqwdkXtZ4Sm4Ibayz+S/TJY6P7O2g2CFM5rO0q7KtFcD9DPRdcUENzSNQzirLNbOU6OXQwezVOQE1tTOqs8EdXGWAGU5F0WMvmsjjNu7z6Z5JE8HPtVN0Bgh92G3POfHKwwD/rQub8xN1AdKp+QFaIUktGtNI6cJwVjBM7elPjQlmZM5HO7KwVD/qcibdGNDu/N2xJtqDwM672KPkhUP+i6e7g9Ytbue+gQigduUsKBD0P1lm2NDWcbxYCI/CHwmAN3qMIXJvyIZDVVnPNgT52gWOp6roAhh5W3ma9cqNOQUg5lpQxssuw1dcCKNn23Y0xNl5diNpmmSdqkyu9EKzC2+CmddDyKRz6uqZS5KOVk6XtWgHc8zjNoLm1EYcnOROcURwrBdYnISuUPuBVglq+dc+laQOPT/gC6rSC1RNnUkwHEqazC+4WjYQLuHAE0VOe+c4EnM3U+Q/q4msIU3xfZErQi7c7DpiTNqztxvdgnWIiT0rzi0vv+7wMpkkh0JWOJWQMps85ycqzt+WIr7R/4U2anJ3zbvqPVtGjs0IT2YAAO6ISX2CHzT0i8DG4syxi9/5XPRdh918Qb+FRwR4mUZ6+jJNsAKFBOgGJ0dHZUvtCVXhZFmICC/F1bN6eA/8sL99KyS8BjZGIS3/M58aHoYApTeMIFaHoZ3kbN1arnJ/gnlQc5bmPV/UT/Te5QF1h2Ov5HCDj6bePccc+HmYzEGQjryk2di9kJXP4Ee+M+GVQQC8mLzUEbgNV+5ynuO63V2+3/EZx7BPATO0XLrR4VdHUfuvtlLYAuAvmobCK8tsaonhmaC1ygsrhxMxe+BAWDzHLlm+QPbT0Pe3NnMBiYLOu3g/s1cvWYlwH/kvU9NkZ10/as3+tf63ptBbyCaqDV6tCkU09HCpXeaLrSnsLSen/AeUX2Mj94jn32YbAKWKdw3utfczALb3mFMwn1j80o/zrHIKkuxSCBOpKC5hfiDzNOb6CdCTwbDdOi1h7JNtJuMFdibWOR+raV+E6sii7DG27005JfVZVVFG/L1HlZp773cNouPsuwQFd7ey1PtdA6jWRti7YcQBIIxzy0MWrGLuV1fzw22HQoVnuph+jQfALOdUnrIZSCdkX3imFW49GfDo2azv/ao1Alz+GwuA0T4K1rnIjZ4UyxUKkh7GmBYfB01RFEVd9G/if+zvCMwOYBo+Hhr9ysuA1E4TwueTHUi9uZ/0XFdcpmH62GfHDNpOUR+iUDqYO2gKGe0C3Mf0uC73RUU0euL09M0apaWOrUtXvpPYBMUgvL8LEa36CoWiAIDjxljwj8xUTVadubLfvZ4T3NZw3a60VkiLPY2iQdkU9PLcJz4geIhb4uAAm5I7G6X+Rp5qECOJkrD+ULVR8/LfRYSXxYDB8QaWn8bF4K/HpOpgJJopaz6/bNRFafzgyk5ECE7FVzPXePCc7dhPKYv+6U6PMZ5x+EEKMCxRfd5UP1Xnn8HwGDBDhkAWhErPPjHWQphgO1X2N2fTofltqTYAtKfUMkX8pL/o+1nyfydMrpB5vhxLEVXSDCb1a5l5XXZps39Q9wnag5So61N2+NyrFDRjStDQrpwfaGOQNxev9KEJCzJ7MDqEQgSAWtIqaWms1fU9EENw/0GvIeZesIDuihiUV8X7lox6mDze/OoM2hVuyxs81P1YOUNC9zKM4iZ7E2wSsGzarI+IfscQl4agUhho6Fk6uyuOlDrExZnmo5sZ+pBXZZ/5fqulUpO1blr+UMuT7qTKpFbFKtzvtR2lpIKt/4SAjba4Ebmmqkko68gvyDQm/1racpxMfzuojaFE4zR1G4njQGS+53W1/iQFJ2LmJ5Y9JLM5syetnpbXX9TGfHv/AtnYeymSvn1ZrCiTSs0Yi9rhdhCCi7jwjgkcl9x6vIAL7ZXz8XK0a9SKG6+hwrpJEtGJMpjr6hsQIx8WuegOz7yxQMDtTUvnILCmqCwaDQu4hB6BnjaMoM3favVVDxw26FFa4l3XDAp+ZSZ08qGWHx6gCky2YJwb+goIR6kT3y/9k/pj6N2C0y2xq9yGs/1ALsKtDzM+ShCwCQryWiX0IhNlz9mA+mtKgdKNWbsDmlxPFD+S7P4gBhJuRL5lw49WFQ2jcQgqaN8r0j8ahHBmbjh5HbS3DDgsL2+uuHrnC4elquZlxPEccViuWvYvcqQgiNLpmcE/1pqi5nvCpACEsBle8L2xGkxL0r4v07tOPBI1dcrYbRGoHYY8EqqOQYmf8BZwkr4aJIH0jlVu4fGFGxbm8i8annFE/YrFbEPiqmJRxDaCNq+d7to5OQnkG7IW/4/oI1LrKmPnezpqBjMFOZOzgelCu6FTcufGPUnSuz6kzs+D70RBBa4IZY9t0NJYXihD1pK0QFqWXR+EEN6eNeTYSGYQGXOzelHm3pTFNX3ASmVOYyGyACR20kR9IFx3iie4f9dwblc9uwYA4zWqCbftRWP5XVhne0zDhwD5KW8JX9o5gADEky6n4PsI431A8XylNHT2kdol0NNjhIekO9OBkkyooifTYJdKrIBpGf7MLuQELM5d8hA2yYmek2dWzPXNpI6bthT21bxp8Snrb/SuzYcHSQ433gQMuFHw8uNpYlEFdQYj6/alhG0oCwEKLbMbCNZp7tut6krTSQeOd0sdF83trq/cEHsycqFlWOArsOCG8leLVcEzigQEYTA6XkjoeptEI+3pJFlojajKqX4EhJSJFgxuN674QOBZNjdeJ5qEOobfyDu2rE/p2pCCgqlkBjgrEKt2ZF58PgH02ggym6J4C/wZTB7uUECaZqB7ZlSIdwGlYu7k4vmByY5bmNNWeGSb7yusdzuiHZbsP9U9uYawyTNxUlEDTgvnfKmdN3UIJ1sXFDB7n1WNz8+s0ZJtPnpNwtmxQUT/A3BfXi9/nDbZ5YwRlOI3QbP5R9cO4TXoRejvXuc2iKowMkwst2BNi6KFVtbdBYofbWKZQXbBHIoXIyJSVuDMtr3R1OpA44KDJpixpxL8wkWZIcNiDN2JMSe917EjAE4HGRAtpidHY8XHWgpXg7WR24fj8zZ4u3Zp+Adh7rkSbGp6ixdco9hdZgSBCGZMNM2V0XznHNHwmiJG2/UXCudaFcWSgdNBGa9tEXtN0J/eqwnHd1ZmcJXLWpjoIMTz8gGlrAveXV7rAllrO1qdOStAZlpIz4vwpGSNkW+IEdzOIN9bjqSxjIu0ZrVCGmVUnczLucjgAEAgToJ2O/PU9ViHtrvFW8jLUjSLQDLBj6FiN6iSckBc3yXqFz0w2+o2AZzI9RoUORZFQxLJRSUt84VZUCuHpiuMtSF5d7RqzSvXUEVJl0MfyC0hvA4EnLYSRPZTnntTfNDCJ1PyfFCiJP6PZfyIAE0fJ9gfaVD3NeXb3C+VPV/E/9PURmu5cRWxp/dcb+rUyBI7QW/srSJw7QQ2tTi7im/J15Hdk7iTwiWLbgX5tVLJm94Is7o1/l8d9YOSa7Xjgchuz8cwq8+l5lKujK0igCg3CwKVkTcl9Fd71yLOJjZZENOUo1EHtVuhmOUxpJkZDp/wF0qiBxJbztRQCOoLj82fvohWxyD9GHG3N+LCGGK3AM9aGfoM3ErM/XFLEBQuNlncb9zIRn8WTwpKwuct9v9fpsndBHzDzQPNxTMWpLl37pQ3Ejyd+DHiAjgyHYNWxZk0taG1Sw+0FNPa2d//aeTS5ImTrpvVS1nnNwDvSBjaUlwrcBlB1jFFMvDNOzP64rWwQheUx9OO5iBp03COAVoq8+hdZ7JU/d2wrEuxhPUyeiuiUdrkf/llckwxqdZyg9doldRdmdgN74RZ3XXFnx74lvu4tY0nao8w6cYwxKAlVfLEX0OZ1S0K5Nl5NGTJVENh4D5XN5hggL/LjJCeNKyB52hvUDCoR0F92UeVpfSl9COZ+VGJJDkDuj6VEAlOYVYVAUlImQzo8uGUtNROOXGIBCOLCa+FfZSF4MR22fgNIqvrSFj3N3CxdwhG6Q/KZcQTHwvMXKtn/1oYpSwn1RXjxHS4y9kaocLEwUO/C11K+/QnBK/OCRkd9j+WFcFNqfBAiBu+y6YrgDUIqFCSnDc6l91qHNiWEZdto+9KUgwgkQHN4MhvQBRcMr0xvwUQmN02K36OAVB4rPJema4gcF3DlWN1Vwdk/em0ZqmnvPKF4zcfgVOliAkh3QvREZ/TJzDLEJxOentSh+pQm2lMqgp1Zxmtva7ldv8HcaQfQUKjZebUp2ZjQIy1opY/nFPTagGQJxUECM93YNz3Ilm1ERQlA1iJy3HSGpvmtYsp31120fe8CcqU6T9LXoQtIyQlv95n3Df7i/um/GpbYC/wWjJvY5GSrraAuqTj/N36NU/1M3aVEDG3b1Ha3hCqKSHUlOOMSvU52PxlKhHzAjmsP/fD0vNF9jlXXb1biTZ6Tx1RIGf6BHKu/t5bG9nfDrlOCrCU7AYNUiQMSva24unV9EDGSgWTvJn8rAU0Zdz21zlvIU3w4xebjpGGcecnWxrvf5+P081NEwrknSNyUm4QTNqsz9APKa32p+l+xyoa8E4uueCXVyX4nZaoONyJJu7DOMy/tmpABUdi52gMa9ds5lIle7hZE31SP6bjXMZNzwIMIKPcT7BSdg7AytawgWsKljicFyy7W1yAyoZZJpETtvsxzYzMAdMwWAir6vogC6mGbNASSxYVM/B/9KiQBl/Li9fGrFrum/pkbkMOfVZnfdIJiTNVE7KC1vEnrklBIjcpqZdIbgsXRMfVVC5wCWYm6loS5ncUcWyxbamWfaIIzu4/jmZ5NoSFmX/brtok97WMJ7bqUogupZ/dxmwbrybTsUwfXHqocvkLGnzlGUY+N/9Amp3q3rnDCySpdxTNGsGfAHCmbsjrtnZt5K7tFHo0CS3Y7Elck1eELXLmB7IXagcgbbLhmS/zYQzv7RvAvhpxXx+ZiuX7dBKPVYmtiUo/USpyn5bwdxMWaTK5gjVAjySoLa2Ih6j0f3+vcbiws6xE7LDxBPNsLYnQ57kAMQ7ZNfnmI69AhafvWKip4ZmDpiErqVwNdbecp6lZusZUmDaRtDZ1n4k9ZBNDuGHJNulMrlIl2YFy+S1/PO4bpWcW1RrbuYKyKu9VepYgApiD2spmwdItIT67MiGOs4jjhx0jWkZnXshskU2SH528adcJFbtc9BzIdrKanrH4l86RWgdyTTQVOGI5ZIt7apjrVqjg5grqRhbxmh6XfcvYEyJb2d2SVnHyeOElosYdNrqyHNipFbFPi7O4MfrvHsMC5KDBzGRH4uIMJQxif808enZmjXubiDYfHvuhmEFRWXTkz0QiuNmJM9TrPEaJVKXPbJrS4AwOBvOA3AKJoP2paeME5lXnLqbN7wuKK3phUJFSxfkSWx7NTQJcDQI9LeoujS2kQYuMfbB18SeBcAHBc+CDBi0CWRzzi9KWjp9uK5VhErQeuRkk3qi/eJyQP4xLhYZRGzsp0X3aJ1zT26Od4ILxbzgoi7DvQjGsomYOjcb5jOe5OLUG3eeSf7T8df43m13MOIfKbAWcCt56pXXqCPnEl/g1YLDnjqoZmgjBNWxjfUguXexG+jKvuI4nYRqoyY4Zx8qZ37HLBvnVP5WZbKRqGo3By+0LS+dVImxJzcBn9AVANTXApYQ0JzzunxG29vz7NRxm2XTsHLzgJUtRHXjTs2RdtXMx3HUOXl2HYFaAr8QH8hLzlziF7um1/PoyWa4x0NTPY1GMC2xJFuQHbuUphueOrXGAgAbMZ1kwiV0C9KF3gY3vdc5ejrDkNmJG5PiRnAO1OLPJYyzrz2arZsMs7MhDyaQJvUA4CpTFy4wpPT2QgpLJjL1V121bjoA6Jbw29Ikjeqm25Z3eDJuD00oJvGC2fVQ+5xXRg6IiML0rt1h3ZFisL6JgCp4BSSBc2Dl9+4K84xRQEV/y6fhSlwIqcdFULz7HHequupPxJl9IKrB8+MvRjCuyc6XTULg0VBGykbKl9LVanFs5scC/zTxJrGHvuk2DeTRzxmwAmAGUm3jr7kLHQxzKqZLobdTCVIQkOnjMdGJ6aZEJ7V6IEDvCr05EYNUmFlezwrLRejYBBWwoHV1dev9Forhi6MdhpInsQ3Ol363JVFr7d5+xvhIzQRPVR/1eP5XpZ2mMviJXsCNu8MFolOqJom+BMVra4FHsNHLmDZhkTEgMZhhk6V2PHVYOJ2zQOEDGfjirYwgP+jfnkl4bivA8IB0dE8CJr04146CmRdVVHslzigAwBlIDnFqgeMFRBax8laU/TpSGBheZlJxiFl35RAr2Zr6Sf3GZIQEtkYCDslBEsqC/bldODawigc1WTlsQ89kkz/H3THHuEjUaBgk9XaeK9fsse9F2xHuYq7W2Zm10SojyQwklctBR2NdneAjeCBro00YJ1n88sZrsDySuKAoFFQmrp5VSJWIl1IcWZl8Dad8NVC15afyViQXUaK259oVUHR0gO8WjlY/HgMmrIu/mn8i6NEOfARXPw9XmTKFE5iX2Stlw7c3NdOfvVWRP34SiRdVbrcbd5PfJiK3HAK540dfDv9Yh/7N1D9EAOp039n4WH+f6DHyUHZ4skvvFTFpVQAxj06/1XdWjtfhFUPODHBnYe9WBd+xBorUkkG1JKtJFvknwkRTWkiA+LjD5JurUR94bmrBbj1SYzI0+58k9J+3w7zBruZ9zy8ETpcJ4tmoT0gLMVbgVbM1lmiesCQITfbIk+zb2BTZ0LbYnkwve4U5mUQVr2pf18LodSukX6Lub3U48Q+uSFSdNp1HWouaudJG4om12Md5BSLhjroQ7IJ5d55mj0T6o2DWUiLNtSF9rbja0qH8SuBbDT3gpdFqnOiv2hFJBlVgrS/DbCYzAcFrB12/NGxn8oElLQrCf/NY1BScKmZs5Z8HSkd/uftpjvE/B3qTsChrfluHfo7iz7LoabU2eaKau5vq64dY763PTW2vJUvdbGtICdH+Jzgl+EAi+4KwSJGXEXnzOZlzAESPnvOduMyMpwoh96mxGspLC35JDXoSN++EUVJwFg/gqHcILQkn86K1AYRNTu1mQlyUYivV6EQsrsEmhqM/vx+5EUsEFbCFQ0VkIopspoqQs44yxskGfD2TVR6NQsp4HyMGwr+DyGbxVPK92Wyk1GeB5U9suN/bkFXS+dbw0FzUHNTUyrreBXDeAR7v9evtYvRzcQGrpRYq++6h17/lvwODjNH8mQyiVrVK/kMQcXbtGzhbYBw0v2vJ4jSURhER10m2JJQF2c6Dfo+kdEvgYiHWjf5j6uxTcOF2wQ2wMEaCbFcYiIW03jK+VALl0HwkBW0gyfxueWIi2uUJEeiESvKkYSaSkLS+nH2lsWiulsOzPOA9rYPGNXBdHWNpM7F4HwPBKiMyC6pYpOMEdj4V7nq0fp5M/zsTRepf5FYLit5g088ljdLOCvSEsRanQypogc/qcVY2kCBwneDGpAxTlgvWbtKvPk1VbehbUlPqCGX5ABZI5iCe/uY54H9ekzE4KQbf0/FaGYrZT3kaBpzaOQRMDwpcqT12HfTELgai9xPbEy/mewLLaXQ0FMpm7c0OfAKgFwOULQnkAzwiiPejR4ZxrTmvqvXjJd9mqN3vgni4wKIy0wuFhNDbaKF3TN/ARwGrjxoKsHShU9ooAe36YSuQuE734tgEPfe/ipQ40ixXg+WLx8xTx1xk3EyEVGDocFUtOrLdpTz3y5lx7Oo+j81aK0GgNPZSSsfwbSTsN20PubFOZAiTR1rVdCMxQTLqTzhsf7jBS3HvptBmOrgVaki507HsZAkiPDIJ9l9drkMFutJciwdTd02jKteE6/dgVX4HpAvHWXOE4TsvoUdOENELaAh1SyWgtDP65Nb1/hf7enWqtus+3DIcOBfrLTuYKFdfb/huhbFaQb5cU2Y394iwPzvTq0939YW8835DrGu1fTa2+6RptBwvrv6+FU4L3fMAeW2sNCwLts2sAihAD7baJt8Pj46iOykhDekW2SlIivKItWa14Hy+no6cDXUh99ieJvO2CD5TU7LpodxYhq+uSmiEvoIm/FfiQj7N2iKUBbiT1m9hwZXhQLxdw2i4Kg1tyRouWJKns3F6+haaQIVRf4+IkNnsm9IyO9Mr7JvbgRYK6CPNNpHSOl0txsMsMPsut+CUOwbrakLw/0GaOlbDUBkVMiPQ+K72fuR5ESjUAOQ64pDIqs8BtVrU9SE6Yza59vyBX3374QSBytta7FoYnU1ynHXWYPw91M6CDd/RsXIrooT2Ag4dzsIYDaniUThQWlPZu1lpoue1AfGdKaowfzg4cI2eLk7n1V4UYurMMmaJOVPFRKEXyLyUEVVNonCR3jcuNMUoEqq1rIDPgsKtjFKE+cBfIJjYYb4iUvafuCeaB8P/SoFU8f75TrM1ttlhxUYLoZZBstPQUgm+1msOBOFZzgmoc6UJBbP3Hbo8J39ysIJacGBf3uMmw8lZp2h8n6X860f2RN8I1vdBaWimdgyaeteE00a9dh24n+qqEbJjpMUSUPCpE3JVLvLgW4Faj3nfVRCQQd5dXIlR1Ok2UcTNdyqjP3OxK6Jo7yPfCv9MRuabE+d4xFzmdX/QTzMOCHDG65ru+pKIvZsyevVq3sDgeBfmJ6Z6GbcqvTY7Tb40Qlky42Lbqf7H7sm2BpQEaKo04TYI14h+6o/SAhxV6R16ykI8fvPWwRzhVswAILvijueBEjurRqk/EsZNfB8f5EyGe9zL0itFCcRr+TG8rRV22t8B7c83HaFkJ4T6PQezTf05Z7jUlwdi1NbczlHJ9piCup4nY3R52HkBiUwSeYvdXj1cTagjRdQBzFXJOaVPbUrucR2kk40fTQPTLp7z+VuGlphHB9w920611+ZdYcG9ofYJfqxYvBE6yPj5AxkkEjFZfFpbFa1eYT6wWgvVCcvL9oJeATI8eGPjZx/DN9mYaLsjMncpkKgYYvxuaqNI4KGvR9fTYSEGYaGzrMrbDdEA1f6bYKXcisY3WziqeWh7fH+ubjsa5hXZ5mpZ7n3CbCeLJPyJyoloWL3GxR9IPWMJ1y6N7BJlvKJghVjBc+gB3RgPkGUNJ+GqUUGbI/TC50i1hGPO2q3rbzNIu8jscdJ9ED8Wm+nsuwac0Mj6v9Jej5K2NrA9qJOUeeuAfzM/AFwrF1sk5P8Uv4KQlF+HW2cDrAwHq8mSwRWqgl1yGc3R0aGs6jpUuR3PnXqWQJ6IvZnq9oJMUuyalhjJAr47GU/CZH0HF1uqCk+D1MNon3hL0tyNhk7OsJv/fhSK4YWDPlNmQ+Ofd2yQMmJu2HK3sJJXGhSrqyEz9N6wktCXFIFQNURJHjSlXaabY/oZSREpEJkEaOTWBzpnoFN5UBy5iPC7Gax7KftAT1iQk7All6aTE3HLuw8+bNq6MVI6EZUeZDkNGkp7Ml7KvgTKmjKh2le4TCEZBcTtu4zXo5nhISXYXfGVJX2pDsbjZLyd3uwBoWLSrEVktPz0IY5Hq4l6rA9FZWuxvfPk5KaSJsO8Rj1ZARyjElMJcFKLgqwMWRVUUXJc6rSgonzjDfirKyfOpuTITmN4FZ5dE/wZWFTLQ0Rg1Owe8UnjLzXZb6mbfmtL4FvKDkBBB8PymPSGKP1AiJwxNapCxNBSqu/N+Q565DZbiRcm1c3gwau6RC29sePoWsPAq2ysxFDhY6GgluxQsKeOiSewC8v8ptptXnztgAAaXkaqLsUCk/+zQ/GURfKZYF5gOckHMxXIXy6mMXodiFgG9nSePz5Cpi2o5uPFZGFBae3GyBbMXjYGrEX4dK8Mc3pKMurTpo/41goE18HRPfTw2LqlA45JUWHxMw6DszEj5x9Os2lfdVh0qZS8Nnhy2OHXGp++XqKsD9zbNMyQ1eRGCwcv3qL957BqnVpVvufENDOz5x7pGuSRdEs1+5sr3CNKdJVWp8C6yv5e7WNnv5oicK5yIbufUBIiOnASRDMGFIh3TdjbcT4AG+ADlA7Skl77t9531tkq5V11pah4gAwZu6Tp5GcDfGrz9XF0865FOZ9nvyH6I5TLTgoILXvRc5kQXctKclARivhurPc/DDk2rB4QUz/RzQTXm6vq2MOJPFShCSI6UqhW0vjshPnp05bgjagPRB5cgXYfh3T3WFpAfpYOi33cgJ2syWb5heVbvz8RRtCQM0b99Z/aeOA8P1pY1p3OUfLGn0g22q2s8S8PIzlmtsmoZAjPnE/8kM7MsaHAffuIk0Pqt0+i5GQ559pyDrhZqTq+/lCPkhbNwLX14v8A53Fzg3V0qMlx03koh14M+o5orqfd6e+pndKKSKaayz0lyTE6F1g8lsGiPjduk9vkRl7UWxqLRLdad6/9tTWSC3JC8sbkZCtBaO3I7VWtkiqE3+RlOHRsYyAxp091C8yQS2xa+5Q9ad+Jg+gWF90bPKiuQs4tGsxMidQ6r0ak8N+iSW2vmCGYYgzphWdz3ByKuGRTFGhLeRN5xPRXGt3uTfL7c0XQqYBNLnNYAWiWAZO5RA3ni0gCAPCAiw7Yt0nq+PXi9EG7xNe5Y7OG0Bh0f/gyOsuDXwYtJl9BIjUohNJZ1mRGIbgtUDldBPFLCpnu4Ig19uXoIb6lUxABJKWkf3EUnn+8htAoUiUxf5/QN2Ta6+gJs7JGiuAxhzBDcbxVRcey6UUFdoiqTeEhBKMUelD+2RggAZ8IRWiRU2y1Oc2qvX7wZX8aRt8EDnB72sTBTrczgVSmiH3hdMBupATgURDoVKwgFgA1YIBctAk3OhpqHuQLUUczyfcHaVFASqR5Wx8gryr7heb1Vxk8qPodG2TparA/yNgKK8BoExh4wF1+sW+h4OHXm2qxlEChgYFweMHMSk2eKcD1OU1qvpkSkV1/PFx0bTPeUkaQ0AjfRbg8dOeHjoTiQxOUxv/z5iLp9arcIUkurwSapGsYGuGviJAQVlY9itWN3YMdt4WYPd9ASE7SVPFXnMpMtnWlx/nEYKq0S3GkgVNZ0PxrJOTIbYCziKAXyO1DUZHjCG8sOrLMsbxvNOAzUG4cdCiCNg2wyBGsMMyLA3zJG4GUs7uBRux8R2pqMTLPcTrs5O0v5Stw8Ol5+dsvIC8IvotK5zPlr/hviXdd7csI9aundJWYpemFvLom5DQMRTDqKQj80LFaGL+MhD0tNylRR0/0+1yUAZjCju6NrlrY5GouueiTQQDWsUXkq625VvIliZvoHcPk1+t9wp2v59ks6znhNlR8u3R10KpO3SZXQjzvLSmgQEpC1hiQ5cU+LmOaEyPSlWW6n1Fmm4fM82iQ1AKaqbeJRW7MaZd/FCyqGw2PVDkOZg0pKlM7bkRSrQgMH4MZsQ2grNdRCTu2cJY3bUkRQLcjgb0zdIHlx+i53RciyU+WMvQbre6W/unwWCskFf0YYwkaautoisUf3JDnR4abA7DwKETA8frKmi9w1zuWm7uYB7w8OaabxkMXvSew60cDtAVfou3+dneuLHfxN8KTEzlpc3tonwrd+hbxn/hXegbl2NqmDUj2tzSxr4qVg9tpm7d5kF8Z6I3HFCRM5nSnq8FewyHfINXY8lP6jI4iQUQ7KHxx4FTWegsXTT0X0sNdM+CeuW6gX46vTzVU6pHY5YUiJyzJXAuATkhdXJp7SX4yhKht+nRHiJTtqmc8dUmZLaUimyHQaRJjo9uP5lFbwYrcCuM4GZXkXaGYx/jZAI5drUaAx3pCXmb+BI8fW5ZYa+MLT6Bfs96qymTI1E3EDrTRoXndmUnCKnmFPNQI+iZsCjVFfeJEk8GGDKhvEeGvIvtS6/BNCeUL9CR1Dxmbrh+Z8vqyPHu/vFJu/Ze7J4Wew3UgjDZPd8F5HQTOfC+eTEAP7GFGikSNwLie+/iej6++Se8Q74TQy1Lna842xFJbcjF7olb6/9gBoQPRPUCy1nATC6g6Z3YbothTSPJ7ue7VUjFbpaVrPdJxBsq2UYQebj2DRWoqQ6hz68Rokn4KeL9lKD8buQPgDBpWecEIecwgJbe5uVHdKAEnyxTXxbK2xNbv7TgQ6Bl6VWu8RxcaQ9pULXutAtzmu7mXTJR1d6ZL2+huQ1MGe/d5ne5vrSnqCh2rdk9jpyyFVTSaUBjtrq2tcsv22DYVbqmqZW1EDXpMwp7k+eztSR7knCS3gniZt2feIzOwIBCz/GgJnGAcCGgNDiGwsvKedYJ4m7A7fnfUr3iX0ohO9meANZYbpQym8R2H2C2/jr7AdDGYlkmsnnFRDYF/Z7RvRDM0X3hrGDT28Xxt7efxnrdBzb6F0ZDLLo9nr+DIXbekWhV9c1qyG6IwDzg+GmHBalPYqWQuYdJJtgv1PDs7xJdhaYt2us49e5P/DTVH8NO1MlIAKIIq8ypW/QR95wOJSR6lRfWzLVml8Dgw+HTcMD4PmYlF2M6JGB54u0zIgtkgdwn2JRcdQ5hhcLc2AT99FMqbN0e5fEZeY70TDrHgUuz7RY9gwV3cUU3y68ik3CNUzUOM8D2mTp3ZdUaCX5xA3bc+quFFONG/pHQIuU/bQlKV5E7XAA/OAiwk71Y2D2hKNdWvxvtzUUGjU+MdUjgSEa9PKYuQT4GMTesoGd2diK/WbMfDDGnq7/DCx/Pc7CP8rmE8D/xGaX6ZUFCkj5vXUmH+RfBtfLrFDtLoYL0zvC1NeSYgquK3C84Wn/hz+7Ea+u2leBdSZK5RAd1h32q13GeVx3MFaHQEfKd8ZAgf3b0hYQzi7bjJ130ZIyOEvege7YyZ0efYXOGCW0HZB01DfN+5LXrBtAk7jmRV8Pv9gdOTO7ZzP5w+CJCwMORroB6tqNiCqTO71jVVoiqwVrcnkYWAbKySe9HtdyDScB/ZNksXEMNy6Zp2HhvusQ7xqpPt/iZgdz0BgwLJmc/8g4/9yQtjoPkcNF9KhW4bXDhK//5d/YZ5B5QUbPZ5Q9k3WLzrinvmowaGZKJePs+BLSFozeTRAW+kuUYBrheAqiqO4X83gjyjIzHwm/5JHJys1rl1hQV27ujwyvmtr6n4tAzG/6XzTTkFMVa/D1DOuVMcsfYWfX45cfzxE5fUBJkDZox0ahIUU/iVCskQ8uN1fwRyUaLCGacJoq10h3mq7h9Odbz7o4TUrwDteHwMf86Q6DQOXydKAK57qbziQWsn2dtD4r1BQGBniFkYnvRoZepiiWY9OIRsXA+qhwOsLGyodxMuUvmXs0lxPAwNjF7CGjzo6ATRvqG73wHoOAvD5KiYfTnrfo3dTL/jTmoBB5PQqrCZ3eKpIYMs2Aee5XpFLq0qtGFy5DidWIyVTeQbMkzInz91DYatv0x5SW+djwi3NkSgDDIpmQlkhSR/MQLZXbaglW8tBjjpxFK74lZn2k+nnnru7zCivMG3TN1eeivAKdABZtcRZUxZtD31kSfA9DmEJrL4M3VPIqDbajF9gYUkPXjiwMgGIa08XWoclVlfngZFZB3+RmLFUDCttz12OQ4NxUng79r4MDWTLg1hbAfAqTcQV1Y9T337zk+El+GCG9mMXuGubKOOkUKtefYfBIKd0lP2nv6fczD+Xgh8lZjlSTms5WQBwSfSUTSQtIKGYt1SOqJa/1d4QktScA0XtrKQEdssK/c5W0K3UG6mZ1jVj0la8XjWXMqgVLP/0q9MDIdc6MRJJ7tZ1HDwt/omR7rU16m8TNDrSSEwgMm+45/QlBnjyJ8J5DctDdCSvGce8yu+QgUzW9Ep6cuMNhTCoTT16j0Ht35IJ1CvePdlXiq0YNix7F1Ol37iDT4kbnP6oOhArwmbbvLzKHghFgSg0+um5maGDUHHD7gVj/uRm/ALkDMIpXDv4Tok6G4LwVvXtEl+MHDAWHmVXHLix6eFlwPD8M1QLSvF90w3t+fhUM731HBXWZIYyumG/GSuj+pCGC7e2wa3wkJchMWy/xhSnQ7eGpxdpIowBOTEmhze+gt1plGu+B6V8Iz5ep14txlYE9DZ1PkVYDbU3xp3jdLqkN3nbnXPXsEH1i5tPJNpyvved6EWEr9Q9Es4yUDB6W6mhoIewz57Ha9y439XYtOAOyfvMKe2i588nvxqnlDnxcEzA6hq0MWGXAttH/ws7dAKnl4K1NDv4VcTQYQsYcfT3AqDSxIBMVu0TxSJmx8++IuMoe7NseCXN+72JqGXKa06H00CdMkRzhfY3OGEHMESX+MJb4DHDV2XmxkRrjHlw5XyscQEcre7HS3T22eiBO03io5KvTjB49R/Po/0aV91BXi+4IsLRw98Qd1vZLTb7Dm7CZpiPndHdPulIyBoiDQRKYoVaa8f7SF9xPB2y0F0fM7SaNG4HfX1ucBp6wl/21d0g2vwyvyevJ/gc6o6RfzJEnELbMZJCkI6pO2+l27B5Eo8lUdxgLO9fNlXxatTWaNEQ0QXdE9Sc1MoEDK9aV/XJaKw5aJbGEL5DEKJyvDst/Rto6dclOIUF7m6x6RW7j1Zn7+AfQ877r8u6rQM1e4/GyChICOyLf7MRU8VZUa99AqCyAH3cAV7IkHPc//HEiE2xNwQd+c6n9hHxkoUSVH8iIVCyPke7de3ASZVtxITg2mORB6XUDAsuMqOALHWbgbYUATq5yswVThNNeHtKDJMmgDvpo6KDFru0wOLQKR7gcuAsUS9tIb+s0zSZDCjOjtkcdbQtP9F8hKPNDWf4mBp9JtnKF9Ra3RAs6pvO9atdHi2NoKlWbWhIPmbQdsxBE/AAC08qq7cVA3fZqgVobBn3qyCJDjyV9jZzneufekuwS8a4lZ/6/vJRTwRbXv6C5d/Du9KentnEbJ+uBJuw30oKgAyKUjhkTgtiH82sbcxHtqCr5umBP7DFrZQuLxumFlIwyfPCZ24hpcE37KiTGD5DqNPMmWMv7iyZNd6FJesW1X5N0Hd7gdFQiv2tw1iH41UfhRRZ/MfrvW+wOmMm+1V9L4YRAFqrDEqKBRz3dAeV23NnshG2XI/S0joz5b4xJsTgJVWdZ0gKDFq8e+0HDk2Hesu6t81nt3weN20f7Afey8mSCCxmorQCaD8b8QpSGzMpWJz5PAHOxldmSkWbjJOXsKn6klZojfJYgClI9+gspjpUNb/U6OO8WP1DMAxp6mqVZI9LVuxmu/9WQdfAuduFVh86ly6jOJmf1O+Bbl2bj6Ys1Oy6BYnYLItIxhnpk3O9RUDV+HbXB6Ju605yAgZYGrVd1544GFEmyrAZxNygkKI2JfPXpNUzrh6S+Sq5rJcd7Hv8bHswcRScwLc3vhd6dqhue1v+Ta0O49k0l7y3fVAl4qiRL7WFM5hY7wQFTVt7l44HQ3dX6tEmXZpxSaYbbrjkI9X/9Vs7QFn/lrVOdoRVK5d5c2hfnrZTdGC97PpUrWLdwHPw8smv2K9pM/8q7YxAnos22MoXklHre7q3c8s26pAk0iTerpGRiGfgBsqQaGd06EMW8xA0/ylS4PxPuFBcw9tKj0clFOWkJ6j2dEQMIw8p4DKh5wV8IQ65qVxX00+r/UsuuUFvpyrCZAzASGjSUSpy3LO4XkVO+L7aKZvMCHYieQH9ht1C5LKx78AZqrICnFUw4FjofvRDzjU/TUiOOmmlEvBkncPmIneQ9MuuL9R6OnA8KYHKGuW0RHrGKzDw9dPaJ8ubEFyl7D06J6Li/l6WdZ1P1nrjhQPvxdxV0XeXsDC8yqAofQXbJYwYhwhCZQMNaK7+znBrH/qSSdRuyVqbWvvS96Guy38EZS7bnXYFbTF+tfUI5YrGzsLiwcxW34uNk0j16hcy8Y6hZMzX+cH1UN3ksvCig+XTDtKd3nYe7BQyh0lB7Fj/RVaFr9wzh5pG7hUaJoX4sa53yp+0va4QJ1aASOBm1k0+lVFRXIWC76y1UZlAvqgKEN7lpDxdGWQ4lpWhOrH3PeqD9kfpFYG0JVKC2pcJlHlht/Jts/KLsRWmHGF3OtcXmaomR0+/mSCyP553WAIQnOR4QqgCfe1bdzcK7uO9t8OJ0BkipgzAMM+Xm48gnQsOpAV0Q9xBLanjT8rGi1FXvaNKNJqNkSpa2xCDhPCNKiNN6hfhwE7E2iVOgpEkJXWv2Q1po1s23s4PR45iJ2HqTxXsnH2339Qt+Ngteke2rOQZCtTjAr4HjvHXf8DQzDNCnjskgD7vIB8C1roMHAQ/4mHhuuVAt/Emy3HtJvL0K0JALTbNvrvPMquuAtMlqPugz1EHxZMzrn7PDF1MDsiMCsq3OEwDwDw2tlpG+9jwMuKqkMqEYaQOnZy/yB7FwKl5VnbKyuN5sCZGPQpzz3WWWWHcR8fne6HhblD2sTNmRfh2Zf7PjnC6q/YleldeKD32KO3DxTb/cZCf8gtmBiemOSXUBxmF5TiEbC/wwLR6bzNFcg5KlwLA6rqmJOi6znP16MbMLt8/hvcOhhgJoyIV6lqZu/Ck53b8M6l6Sv4a4ivflZAFIxR//mONak9xOTuTHGVNkYFXVnyE/0jwTxrKCTb7kSqBR1jpCbrkggablvuG4tOfbO6zCHAwbrAGhFBSOw6uK01dOnx191Bpz8/SwHwMWHewCdAjkQGhONH1LNYyxwoAk0ACgpHSbNOIaPEqZ8LHcDFTxB8fvam6zz/Ce5FHDgg/7yfNalGSKYh9notbXvf6BmwcxGO6KS9l+LS4tK7NBTahmB+ybiJB/gxt4T6daSzbn/Js2vlNBUc/KeSJ6YRwWpoAtohW4A+eOhOaFR/6+6uNU/3jw+Pk3sjWeG4ZksZI0P5XplKBRaA1Sw96hPx8glj26OsMlp9JwX0dJUDwhBGEEfVfRZAEHn1uLLHA/SCglDafZWw8wioGjw23JKXDJYveCgI5f28HPBfsuyl+uLMAkEj2tg3JPYpTYPWxUvGzDogxitFSr1sPwQISCqqrsFjgyZVZrMmRxhV8yFNK1DJ4gplVJ3OfZDYQUD99SOsdhBnAe/n5our1qB6I4bLUxJGLLsU5DlOVmVPGaMxtjeK2FljlH/K1TMIlBY7nTHTBuFbCTqdBCX9mg6aP6ej7qcAHJQ1QO+V8RVxSsA79Nt3up5NX6FkFyox9kHJ0MMiL1GQ8Tl3kue50slSa4jlE60jfExA/CjCDwSuq4XHTjVbqkX0jqkYIYQhqkdPIYeG30pT474EhlmmvhFw9xJyu3/UozQRBU+G876PFVnvFvuqu4GCgaUGO8Zr/xzUt9HXR1zaALb7peeg+PPxNS3xudSNldb7DN/+iuxXfXDApsATk3KDD3HX9dl4oax1gGQ2tuIw9NQ02A8JcOgJNTxH0lD2nGKESJZA5gyLlL4zeisvr8SEufR1wdhuAka8fWeo1tzjq0DfblTlOCopVFlqp1ZxyWyqH9RZxa/3/nN2UEX4XboG/m+oBP5uubWZ8m3VTlEnvzdgbCnkIv5QbdY/U7WmZLmf2eWml3XPU9N57QbnkI/DEj1Odh48jyEPqDSigpqtAzHAUhMZYd03zXdeUZwU2Js/JrvpdQ0ffxkJ2sizoGgqF2DklI7MVqZE2t5oFrDEm5RRoRSbM2w/kUDfLqRLqKsNHN7Kl2FOkm8SHoSO1GL/Jiuh4HgXGj39EFpLcwnKaOlL+S3AdgUQGVo2FG5iV3fyHUd2pjXcmCNvJ5wJ9zkULRQzv55jBbhb0YnIdMPsQyW0R/zQP9TU3Vl5sLBLzg1EI3fb8g0CDsZLG35TtOmRdU4KPoILjICadyUTeOE7E1ufqluMfG6x2Jre1QJP4aK4tc4d3PfZmK2Grr6tCG4CjhcvMRXOsYtgeAJhrvyYdydZqTEOgCG6xTz/bFLfsUf50Jmf5+zB3RI8rsWFkdcM0Geldv3Qm+vwGI7ON3NgSBy83ckJrOEpfJnBha0aYBTc2L6gl3oOKqUTeP/GTYLn0mJFJ9/8o+r+WXaOWxcwHKP99I0Zoh/5yzM9W4qSSuNHdN6l1G8J5OYwLiUQ+aENvVnYlo3GUD4rmg0IrlfzW8XHCLMkHrHLdN33V7LCIVNlLOcndud/vuPLT4GWgZLiQLpSEJHLl8oSwtPMKHSJXvdm9Qe2B15K2IpgE+nvKWiqAzODhq2lRW/hDvnwHC5XZD0U4gdpKbndPQZ2ccVhkhO6Tz+2jH9++8zSDUgUatC+kTiB5zIEAapD/ApEK3S0OG4LgAMDv34gpxuwF4G9aJXm5wXrmHzrVYqu5d4ZoEMxD/exFzZRrH3fggyJXnBo6VPH2AS4bpECvZB21u0CS5ZL8Gu2GXgPwl2DDKLeVy6eFZD1dzBdfG44G3aUj/9W2KGfgz+l/9kfTKHa4PruJ9C1dq5eHfTprCTiHgoLtIzc8VxRVEe90gypRWdPuakmdcZNbKP4ZMMaMXId3obPD/wYWqASgjAXOkYC7zgdfycniAApU++IS/4GbNoI6BMi82/xl9STJMY7x3tdWShCWMYfZbgHMfZKr5dhAZPQlp29S5ll8DSZf0aksvugUrieETotVv9/oMSD6wPvElxdmu+xCAxKQAvq9h+0h6O3LHFY5PvJ2zKQK0a+BdN5+6+HWOKXSUcWto4FoA8xrQKOHMlt/O4NfdxjMAHhc4K2SRl9WsCwt6D7q0DJPtSDgzRhqkNJjH2tfZwuYiVLW9TMQqaENe3kHruUUnJ9l1ZhBNr0Mt7Po1XCoow+2RngA8Q21sYFe9a0GiqGt8/z9RYJBBHUR6XryS/OzCqpFC7q3dcFwY8yBDxdBVQQbAvriLG/O1S6/0rfE37uwWoOkI1Hkvzn9TDthT5/9SbazfZ9riqPixSgstRpHMfukilYRVnbXsI/om4IIxpWImMB21Fp6PKfpc+zWUsPvcTMLzMRX3LJk2jg1skB7BhdYJtnhnTtjVb+7V2z9BUgK/AIy5IQbYm+r+GE3l3JnG9D66CkDRW5ezpk6+Up6NZ7ox1kRUgSEjpH1Ql1ldIc6qG1rDeScFA0P7+utVgr5c0zWGd7xuArY68rLjCY+jgDdpeg3wwx7AjVvBUpp9wbp2ZmAH0Ha54b0wqdz2gmq7ST3U2Sjfdxs2DhxMQTNr1ogYbh14zEc5ecC1yQj1n6nsmWh8g4kXcAgYA89lvu3HP9bKSFxjc0RYZej2EDFlkfQUuhFSJaE0Z3bdA+5i87ZsJ8vvXNJ/GTw7nds+SpD8F3hsL1bx6e0cFHC5kpL2kXrQ4S8EygbNi6L3x+DuompGuApaZvvppX9gxw1ug6z3+Hq33Ikqt0dFwJqJtQGGByTy9UAfJ1lATyzlZosoVXHKct4jtx+m/sBBjdeKpmKdmNloafvoHal4e03ssvCRmU2MdZMl+w0wsDmt3NI4F+q7mZdNV67QgIZXSARN/XoXDE0pn3MNFFxX5XRQl4dLJtQb24HaOJMkwMcSZsHkEDfgJo14B+jx7+yM4OMT5b+vZVHTtTU9ADVkuk3t26Lm0mvSD/UmlxiV65aPPvjg51ulrWvL66WP+sFRl0/ez760XffnP8Xer/6Q5VXw9xYuArLNbEZABAf+cf6WuvPXA1FNn+IqeWPKtdx8ccuX74kP5lB9hg5BnLshdw5T8X0+vtgHChgv6AJhieOLYZewXoQ5b26mqY5Mmd7PkP/5zd0DN4X+VwQwBy/vbivxmKPmIneoylrVT3gD5o1wcxpHNQfIL2h0bWx63M6D2Tn0gihcbKhr3/DlkOY9tva8llPTRvD3uWHP+cSOy99z12b8TdpPdZQrQesjvDoUek6ccTzaVxG0oZ/CtYq9/Fwf4QhVEe8oU/cRLWXOqM2E0pFnNuoOpZuSeAVf5lRx/k1AvXyD1OuN8ccLIDVhrZxYcQcXPv/FkFBoubpYMpzpfRSlutyJ85UCGrrPwm4xFHyEYdWn75nNK+UDxxI0oTxoMAt1WaIG7ewuocsF3To4ZhQddgycq9uKdWEM9hgDW2zuDsiYo53wDy/q/X5RnhmLJaLtYViAgxySlpcQzHqbjpzlMFShehoFUn+KS4230MG5z/hVsMgAkUNnY2s6ToXpJGfrQUwP1+LtrFTnNzC4YUi+mp22XkDT6BFRzgsk0Tc7YDKlP02wN1iVaikyL6OuUm4jXvt784xHr5bjKPWWJRBCdPftg+6Wza3owEkkKe++MfuSh6Jk4XOMcPOCJV/+4I1JQeZT3BpPvlXjKxAcUUxYdLtgHnejlH1RPjE22oN8hfQb8aJaiQgi42CzOD6Np7bQgSSd5HfNMR0nYNnf8gwlbMfjbOB7dTrRjpG84wKNaoCt+6ndufkTCg/zDRabeQuznVOUyB+B27au4fpjIQIa+5OdEa4XZBU/p5eeCWLerF8s40yGaPs0fAEfkKGcFyxhDyipEMTIr4NC/lZXXEsb4f9gjwPX5z4+tmaamEZALn3mC/EaGCK57qsQCe5NwQzdxaB2hxLnSDI4IKV0sytSEfZWUX0U2/5ZfucLRY92IKWgTEjSa++Qa5dbqr7R0Hc4LzXrPEOMos7+JE0WE7a9JLHlZ6fnpGOIUgCDVp7GRXL9f6Rls4KmTbuN7ztvDfl433Ojck+AxxplTvFXgOV0dG3f7XlYNCEEeR6uXH8C/KCAOkx0/11+8IwiADXp+MIVpYoyXz5ppDTuEnm4zOyQNZl2JAHqu1oFD4k3MWcIWqd85UkWdRbM09ACnpIk5Ax2WfK4X0pS3CVGOBh+iPZANjqK6bVYhlOKrdIO8Von6DSw+JT4WEqoNfDfVrj94Nwy0G+mq41GNavwSA9gMie+q0MqwFekUMpt79f6gJQtl8FEq9bm1H52D+eIJ0BznRF1eW5njOFSFBIO5IDpHbTVQRIw1UtofiFOPdCTXebczo4ShDI3CBiCNolFg4RNwQjMzdgurVwzEu1HsGnRauSXh1a0/hq5P/fqcZ+ZyxZZo1/gGtEJ1LOFvapsVpxCYAPNnd9Stb5sEy8SSyGuDtu5XQuYoPR0HWDITNPaSp4L5CnSd6jiXwu9Q0UqykAcnVJNmlQaM6/5mcTKcwGDfvsgD9YPgqBNK6Pt7/ipeZvafxmLIbUKYdyMW+1bA8T1kbpIIHl09mYQ/g7PMGIPupPve5+La4S0UkhaD1sWTzwmWcIjAu6q2wqjoxchZ+cDhg3HZ3l9kwgvWGXFr/1GJxIj5IH5PYrB2K7tqgJ1Rbw3M8MP01JxkDT5YTBmOhwvcwd4hyzEdz0zi4JOQ8DXtR6DMdTkP5zpPnHU+xvLqoS7gU5gvPyxfLZKvf0Rh2BS6XhsATQ/Mbn91cGYa4I4Lb6Z9BSyRmfNS5U+EZIC7V5NLWQdEhGyA+NybmqKpNFxq+vOejQegwRDFqCL2RgmkSzcyCfgnfuj9WG1NXCQz4/6yy9V/FJ4bfncyas2WEKA47Ah8b/AJgm74ScFJW/SB4rc7mZ65EzZ2Bpd9raQL5vsT3CFgy+xHcdyupl15MsWEt83Z0ErPBcA+sltTrX9K0X5RVwtA6uuuzWNmtBkfNspwvXixf41R3dx3Aedlol1CDHzodgEM32Z/kg7y+qZsIaZxkKM2N2GENb5+dhhqvL6VXCe9+O8UKYHDkVV9DdqaYr04szxABoKGZE49xdze1WPn9Cn52aSlcbyF0cOA9OJvdI0El+8qWglfRkLAbP48qytXzJqWRyY87DVCk2KhUD1fzRRQMtGYGjEGWtJF7jp34zZ6Xv+R1xL3tX6cOXxFNVHT20nUlb/mTahPeJ85/3Ijde9P4pg4zbaohqm7EJNBDVoumgGwpIcm1h7rCUWTIoIq0+CuNaz/z577FEDf3W27ciAW725hHW3Lr4Yq80YTAH0Ldk6J2YeCHugxg+AWbsr9wnh0X7GkDebAwEkonUCD4y9vcbwoUtuhMdJyyMYD0i+9ZchqHjeRMkQZb01sdP012icpjcHdi95vtVnm/Ve60OrGGz2YE+e1V0hsteXnngc+bjvu00uN10t4TrrgIqP67Jm/NoSPijzgA/5YuDAVCEAimKdq9/Y/s2Odf01PBERpFTc6WW0plfRn+1HCVDI39O9D5nSbS1EWbgBV4JCU0CAgnpaCbedBed26Ku3Ktm+zP0CqRE2wTptaxB5R2M/v1cX+GZMmxg23hIBLpz7G5dRU/lnct22qnIuWTe1nGxo+1slEb/JvuSxcOBt2UBuTAXNJ3K33CkED9nOwEWlq6mvD7hOxC3MG5CSzYDks0CVZuh9ej6FEZTVC7v3DGBiuFw+4J7thkFAsJSKBh3mmLTQ9CJ73X4hhbsLe2fil7oK+ifJ9VCKssuusUhPblGx9Bo/7fx92GLBhrL0+Pin2Eg5AxVUl7+WBOMy0AOXANEMz8Qm5oF+UPM4jron0F1A/CcenGpQwiI8bmnZseWHE+gc6i0m+8MZLkD0PF1lYwlfhl1cda1i8OH6cOOKadxZJuypvWs3BDbZMem0wEzaibhGBFNeON9qNTSImVHEV/9/S4rJZtNjvgeQI/+dc5W9fOo7pHG7CSoI7uMO9mWJ7ymqzqO0M6ospsW85OlDi7xV2AWDTBOc1N+KgN9pWOjJY4VD3I0BT627B43r+gjsdqxHoPOn1vfQsmMvyaupdNOpttUAP3Hd1VWl1SIzKIOs+EEwHoDcyf8Tp4fUSfeFlxf3wC04qQ8ZejAG299l9O0nkSB+S7rvfTO5hH5/mtJUJgKCU9v7n1KOEwrw5GKRlxIzSGffxeoO1a5F/Xkb7s3qHBFHCdk9fwSSf+qitfHoSiEFMGHrPCj654xGxDLsL9O/3am+LCs2hkhVwvqY8SwTI6y6fBHfUWkMvsqGgw3kzllKeGFAGq5QhIGShGfqBy3X36cBUUk48BdkOd1NN4yEjkrfDL2di4JyUeL1Km3cLmSiz7C8FRkwDeNhGZgjIkOyiwoTHq2d+0wEqZ4/LMjc7b3v2DNcGLXiEC3nsi9dKNBW5L2KdNRtJHSCH2xWQWiR3AsNDGz+/eYjx7wI3eu6ys66nPILkXG2OmTj/VaYkTDri/jzd2ifed3HeCs6cUWDaD0SENBO1kF04M8mNl+KRD7fMDMbRMLkktqfHjv/OwemU5opb4OgIvbDRXmzjFTJEB5JONVS7NlLptCk1McaT8sTWyfYL4LzufMJiNkh1gXirQ7xL1Fcxoh7BKNAXWFMhfFK8v17cl6YhbWdKMU1cHd9goZRQK1LLMO7aSBp5ObB+t0xyuAttilO65PTFSalXlHeZOCvCkcXg+Gz3o1VlZXkiTdbfLUFdv2baW5yQmzjNLXvDeCMkFJK/rkVJ0nKpWCPzY7vbTs9fi9zxRHG4Yjst8qhmX5cxnCV9RwdV9Fw1v+rMFl9wbo1vHPO8a+zZ74ctxXpN7VilKwwFqfJ2UiUVgo8cJ+LVl18HO6+GflCAUQmwDmklAem8Aa+EIKYU98dEWN1Ql0CA8Pg5RipKt9GURZspifX+0zAOfkHsz7yZYXjnOz4vbu77BpMAS7zQyHGjXVncGge0s7TRdbQ5GJeRIfudntPzCHHvJ+3E9ebm0dvN7LoHeV0DnnW/1nJl6bjBRMIdES9ge6VLv01kQQAZ5xve0NojQWLbUnFfyetAvi0MnFoYf+SzhFmkSLO0ITnDp022Qw3KE2Mw+n3tpAHPjlmKYIVppbJb5yOC6yNi1pnCsWoa94U6eHoNUT3zul4t3gvceotaDTa4Unu511sooZvyTMVgs72qLGc/6da/+g1r6bm1orquHDiBgzAUEtfc1Xfs8KN0jeBbURVnJQnWd0Q6DNUt+YiNBnBs7AXiJu7YwVP8WR4DoEuf2vZN2pBNfRNgBP1ZaIuuJ2Q/g5E5TIRisXVekgr9T481pzL1IbRPbF3WJDPtGYxWmhQCZTFRFPGz2pG5MoJL4tIowc9gvlOffpfR16hL0hpBQjrtMxqRyNL+48pp9OLlrK/1aYzTMHiaaDX1DCDrDYYDYXYfUmWzD45RxlCWx9Fx7UjA8f9fI+GQzFhIe9EtGU6l5TOBcScIepNeIXUWa2i2dS3+haj/beSBUkalYWCcavoc3C+/NAP2j6DgBxUoikVgU/KVc4QFySnLBJX0tALpKqZiQjKEqIFWjwcbDC4xo89DPZ1O8qP7Ql2AT+gMdhr2x32GO7HHp6APwlWv7c9xaYutSTsv0/eIh3iG1lztypWJtqfD4mTKrMF1w3tNjHt7pJ4SZqJxMb9I3U+AZLm0/sEhTbtWmbVxb3lb0Dng2ZJhJWLmp2fFL7l/ZW8/h41h9Bn8y7Hhj1vbcFFTdWl/DG4UXWK7HBrOxV796955kz4g80YeSn/Vbc865vX7nYGFXlcSBW5DM1znfDhK8W6u6o2cyQdae67w1/6F1Hq/KuDUc9eLcnF64OFzCrh4gm5N93l8wlYATSVlbmgzL4VeETcfGSAzM8W3LeVdMR1OoaNMEvxi5Xa2WWB2OUiWtnMkBwPlm23xicuc3twR0ZZzAcpI9AsvB8hrXMsOJxHzFfIYMqzvBmXGWt/K7Bcq3vKAorPuCiuQKNj/49tT8BkUpBVU/1YVKBul8YbIgzaOfpk5cd9IIu22pgjIhjGrfjJ2EsODBuyc+OfvrdPKDr6jJXffhYzggjM1VbORkxXqvDx9zCC0g00rb/uWxqV7ev66vnxb5Gu39KnftO6y95vm1/DNV3NzzRvkToTrGKtrpZzBPPF1O0v9WL3flkwfw6IsnoVyXCNOBEKmaFni5QZSHkLAWhwE5IzIZFII/1mKMcEXTky9lJcbaAwoAxosraI4OOF8Zx0LrE34NXJo93Urs1jMHwqu+BvJdDC88z6yC0IxrNRfTjt1EmxeRrKd0Avco+ImcaE2CsF7RBMaWAAIoiW+fmaTCzIWj5GxcidJA3YvMoQBjaBqFY2o2JDnXRiAI7VXBiQIvhpT4wBSy2Rxh0mcEMNK9xLrpWrofuCvCmyNcZFGipsykt4S6DoWFgXfWjbNMHjb0/nsJ+pYL3t/44+i2KlzHlenfBdqWRkoIYjP7ASWVyfjDIN/FI8yMAVb8UlOsFoAz5fk6qibVE4VBGr4xZHBYieG/m83Wan/z0sysmoJubKawfIMsVcPpOwSALqSPEe6fRQF6S6boQSrRC+8+dNyHSfDqcAJL0VT1xeya6JTI/QChg+5DXvkRJ8QkjJTpK1XnAErvaHiuWcsV1SUus/+h5E/BX7YZJ1+AltxKBE9sNSoaI0+HfCayEZC8Ws+A31phJUPFo9oz5NSvFbNxo9umCcO2By75rsiMqXSKdv/d77TZOa+kEU4onPKLJqmaEeMH35lotpwW24d+N5KNZZOQorjWIJazcDkCH5WOXYfVcDC5Fj6ltuGUV5Jb3scBTSVIrPVbi2BjpuiUAiUIdw/qbWRckvfAhJlT6d64PdlDiOUf6Q/KGNVRFqp2Js+7hYqsCWug5TZkz7oVn6cyI58D7E8nQsLW1JAGtVft0AUZbWQ49pTR0Xxfj23vEO9ygIgC2qD1o5J5duJ56U1ypCc+xLvoNC9yzIRDGEtuBfG9NrBmyyMgnBSiTmxJBhfSYcvJ08lm6TX60v3jHY8BNFTaLAERv3/DmsSdXr63NNrgHOVJp17d/Tb2zrSX1Y99MLmBZMr0WU+tjOtHximKD+Co/PXeK57e5tf4eayeHuk/sN1hvj7JEUfYaq6IXXsDVFxdK/SiFt41PVD1MdF/+H6x40toUJbiyY6yw10cdIxJUreAqv8627/XA/JyVaCwaM9tjzL/LqB3UljHdjCVLUC1PJ5RdAFxEG2uAe8EaEbPqdNdr2FJJzZ3+Qz6hRlhUWbsWGq74zbRRmZhpi57eFrWOLkjRbiRXbiFBRKty4B6TwpGUuibmR8Tc3hBMqCj+qNhO3uRTSI/yXxw7hon9HjY3/B40d38JQxdSqYZkT9v2ff403yZahd1GdH/XRxzHEeZA29dOp033CDICIJ8Bh6e/kw9OoaC707Ke25kX3zkfiVe5/LjnyXH1QDVOD0DnB3d80VLWQDn8YD8A1xo3654D2nQ4OyNYRIyMdo3V3xka31tvJyHn8DzwkVt2/DraUOAwAqTD2kjKRO3Wx/l61j8HEOqNTZw5V2XIr9IXeKQZRBRRGonsiBWx6xg1YvpWEreH04ZwstJp0F5ZHMMnb5p8jX1faFDgaOWdpKBT9Ciok03WLORKlUnLItueziPig8I2LF7OLog5kgIb4VHLhH/vBQ7tPGHQkCwgiTyq1MxKkV55cxrICFH3PbgI8SGiSMpLEpcBJjTsEWJGcTJJ/GxFvxoG1qiwJRgxIazqBZVL9sOu2ob+RlUF0fEiS5nhcKnBcUh+BoNwevAnmsH3LFOAfNDY6+3Aem+7FDKQqabh1CYLDR7GaQIzD5VBWYJE7s50B4DIdMHl/t9ah1x+nYHJPt81D8At9gFtZgNZwUmQFphV1y3h3KH4YkrpCFXH4MxoU23qAwUzXTflKEkKiUN5o5t96vgmHel4pkb9khV61BnajbPz5278/r3t+qH31ky4mgvircNf9mvkYk4HcyD0fKxG9lEJu6yotgD+eLObGDLNEm7TNZrZXE4JaaBy76yLxW3CPEOkz1+vQIvXgr7DFHbeC3yl6v1maJpSjEm3aQOgEDQevxbS6Q26xkukGlrZ7lqmvXvhRmSwzxo7wtChNiCWNyPvGm+sGA0j5Mty9ilV64qTT5Ncz6T6N+Z/1EJONOegLNI1URwebvJPA43WoVw+N/2pJJuCgdDg2b3JiSNG9Qwyoeb453X5K1WWnwBZM5I//WuODfLTi+LLVlFdBBUoM9raw1nDqYW5unzqkltdX8KZZuUksohpKbVd00b2CbHXaqk4z9VRGEJEm+f1XgKRd45RSobV0jvYWZo+cA9dSFv+MXNstea7QgvQYFAZK4YDYZL+AGtgiEy5Oy0oLsVzRFk9WUl18gfMqobEvVPB7xumuuqgQ/lPyZIGIUXDsX8g9ckVfFYsPdOkWlGYk7ZxWVOEuDheIsDJyd9LeDhUWbzUZwPfj0hc3vkM8Y2KbNEZFCSCBL+kZpTqvUqhdvp+uanSMhnA18FKKuQvOohZXrLfQl3ItGL8BJ36SO9XNzKcYFVTt9OsuIuQXW/yMLed4auBnuRHpgmYRPd2hndLZylwzrBq7sCHLRMz9GH3ZZgSeLlvYEisy+uUecahlK8drTHVHT+xyVBJ9+AtdFZ8Xl4fZFIRZiM4uTxdVmT2ctqFGG/FeHUg/X/0/1VUTYBsURBlmLcIJnA4FDuDAYgWWkSKHtq/eLxS4oAxv9T1tsi9lh4vOYj+glo8YuVx8rp2ctpkaK24t6vOVcKe6042LZLWmg2AidavxBiGJ51qtof3+y5UfuMAVJQKhYRoPV7VWGvq7UnwXYXqVN6cO2n0R1uAMR7VQQF1dBG1eoD+Y0BOJwc5ELCFRDE6dYSOVlg/50qsIJ0qmHE2WRov/NHGI0Gr+rLecmzaAkHGZNe8SKcNrhaxtNdHoSlPUqwcPsi48vUJKx97CPrjtG/lbegUSFekM/qC3FfDVHmEL4qHO8Hi4ue2KTz3uo+tSSAFfWPWN98PfdISrcDP4AO7i4piAzjDYBKh8srjiHoSRNS0LvT67dZard05WQLikSZ1RCjEaTPh9KLrOBxfgP41pmycB2iHb7w9DBHac5vCLePK6JnZjEPBGP5ywwhK3ktuJ3e22DDuPAU/yPmAHNG9Czza6bP5Hzmgur6NfjGeyMN333LhiQEidSw7N8dmxRCY7rAQvfKXyKmWEmo2+c0SR4QvXhPYy/I8noQ4r/d62oGySJhBSRLo1TdKdAWY+/qmzR1aIT07OzYmFCB3cPxAkE3H5trsIRzvZC72fxbcWrrgDhRe/L+QKuItPs6qEiRGAcxeyOGUidrtBe06uEEqdM3WP+i9X+rGtpBiQoLX64nIVING8BwCsJVK/8eSGID9QisF97bNqpr5TZ86IsCdGB+cgFqS7nyQj+Fo1ht5BIuxXn/8j+DW7Ap59UGKHKY3TFcGBs0lJ2livTDdFKxFisMdIrFLvRXcu5gPY/Z92qtJuktn0uPljtdHDB+AskbZ4ST054AK24BXyofcX463UD7NhdSp5j+JlIEE/crRJvIn3pUsnr8sNphJ/Yb6zub9NJRF6jrrju5mBpRtxb8ohI3aW8rCWIR0t3rgvuzYXU/ZRyAnR/E88ZwQ/6XxcVN23wJhgowkobnMKe7f+TwjTj8CTFo5Rc1C2o92WF2xcdd3DWRQpxRzxWNz6IdM9NIfgONxg/rhqQc3v/XDe5eYlUhsDI47ctAISO2nm36Bl3cRr8qmgESuaKse5uF00r146mZudia+olCdduZj9VP/IACe7H8aKf1ZKsip6tMjjxxsDJ1SgY0WVqsB/xcTH2NRY5luzfx+X4Vl3j9wB2IinSISm2c8XCN8+jH9RsYcK3Y5pD82d7N/y19fxRqswJDcXD/qu4Oe5ufVjxcwwYLw/CkDQjNW/yCiS0Dvumcno3RO3DvzFyf+LhxgqcLF9PZgdIiR7yFFJGbXHqSpBhc7toJoGlALVKFyhN1jUW/SOKt3lheK9UhX6llq3hNBDU+9kVm4IYd98myCBWiLJpuD8sPGPgXbAd7MZvcKCXt2g3CQfYVWSw88X9c4P45SrebS1ANUNiY8xUhA+kx8mkMUBkpfcV7Mn2LzPcFjLBxamPe7OdSx2wSHD9BjNqjuWTkS4yXKvkpxeEA+Yn6s6gxN3qSWBH0jPQIT+kM2zHSKXVNLTzZviFdwm6Zx2+9woZSS/LDV37VuzKsOeWuxzfuSYAvqd0a085cWgi2C2odAhs7uFVqCU/ekDMD0X9hoVT+ikZ0LEW1Jeada6YTRnlbR0G18k0anYGorBKNeIj197VM+wBe+qTfhZUtnx/Dq0X/wy3g5qpqwiash/5mzuyZaRPgcabHVSB1Y19asxo7YzzCA+ZG856dCYcS0UzptW9DxaoPfFzfb5tXDQDlal7CmiV43JMsjyUkHw+6OdmeuT8fOUdf4RZK4lxEEKjAsN8Z5/IPXVlJk0JjKrs0NKD/FLI9vr1guK9H3SGJxbizD/s76R3ujFWvKxyW51MJ8a7sbuVNsOdinNzRZfA1Du4ebgmgv0f1urPLe+alY8jxOSf8lw/qZZ1Wuab+q6sTYNS5OTLPA4ESTaqMeIZZg4DbjvBBtSB089RYssKPUcf2KyHfauM4EeAu6dynq1h2hLxdC+N07l2pwOES4+rf/v9mBOv2ibF3seqXr+2vInG8Vmb8Woj80N6++zfEOA/BKaLWK+rrmHsV/IqdIv9/CBi6RK7lqvV73WiznqVIjVQXW0b3egiNdkNc0R3HL77urhydm2SokboY8mYRncdp8v/k9E4lMgmWtF+PBX6Nl6/B636BYkXDe98fyo4drGkOkq1y3ELWfjbPJY3hzaakt0VWu/C631VSwjaoyiEb68lvba1zcaBruPA4okFmMPZ5oo3oKmqphu80w5RqrWcDlcUZrwmcp5k6sec7A/NAixkrQZovjWmncvRciBjgDHDI/Qn5gg5zgXNLmc8k4a1CKajumFKYoXPNbQD/mImgXgqDU1sobH43hPMudlvuepHntXI2PqLZKrdrC+afrSxlCMprSNdpuU9Mf2ejY+MmrnXmQNErJWsklMhuya8vH8JEoo+eH166cbOTR72qCGEgNU5elkUjY/Igpp21hkvziDcWdJCl/9I1fAfpJnR4PGlKVA5cLnEnfUjlilmW8jW44+DMTUqyD4hFjf5a5Ixi+yyOQQytPydq45aIQvVqsrwljn04RqazR+duHnMNdvsespq4ieg1qcOt2Dp06EuwGBFMqZsGmsIfHJAMZwdb0LKtarjXuqGVQX1m19jMWus+rDeEGB0b7LPakqp7hchhpPNEiHQ+gz1MnYCgAi0DaTaBmlyFPw+OJhsn4faa8DuEXt+bcwt4ZdE3sCM3gNE99ipXUk0VwWpGlKISDZf7k7//BXrBq868bwIqgyPMbtyYuuANCXAM34qHQY3++ec0h2YM6wJhtoGU4xdoJe0GShiqWwhWn+73QwhyKJLdJwWG6cyflBElN8meAHmC3xbTwxzn+twdpBhYt/7YQFY9gMwv6TYt/FaOFwzRbjnIacb7a5vH3tqrO6B73aKZGWANBke3K470jYmheAzz5bHJH/JKizbVfXClKOOIEe+Piid8NkJwlkyOEyu3gIDdX2qu8VlWOufKvAKEjyElZs56jdxMrpw261ZWUOWwB0vquFwgPUN7RkrRXJdkLI939hjua3QpFNX/O7cP2nf/idISJM96GWQVb3tRB6utFhrcbNnStSY9hRgZm0kUyyMDsFx70zIASzHIK0HbyP0NQO/cVFakr5KRbw/BhvN532+A/9cjViVHWetMjaT+ceMiQb3Ih04+SXJmrSGtY5B5I3qIJeyrQMeoeKA2+sQC3V7wGR/S9zea81a0ICIvaQhEt0iWaBB8g9O9skRenI/n3gh1DlwAknC+Te50Pf5DfVn9+6Oxs/93MMzZY9ux4j3aWIfoHJ4bxdQu576NF1Cbp9Hi1AUIUS8Xb/UuBFW2ynkOP98sC+T7E++Cg/DGxJKJNZQ7uihdUUfGf4uiCG2E7HW6+IJdTfJMzPDFYFFRTwgrcdizXal/Ovd5fztaRBilT8CNTx9C2PVT97B+VnL6AnKzwL8aA/3Sq39kSdyp4qa8UNjTeowXjSk7HkUYWX7TwTcEskM63iAhPKgTEHXQzlzVyqzUtVj+hJewypuKh1IU1Vathak9F11mnUTwKBE+oC7xNskl0gDA6YBaPpC5ynRvSt6+bWlAX3mZzk05raYdGlumP0CidwlRPyc8XmuZxGwD9eWAJNXeQ7I3N/GgjhZnU3IglUyDZIFXrSvmghTrF2q6U/TbNwN7yTvxenyL4MvvE98UHtDqRrkanTV5ZoFml8xmqx5tQ5c9EFNLeAHKCWOOzs2jxRlI7Q4uZPjk0MZybKrTwpUL74l7w2KjCDGf3fsFmxfmGIkUSRJB05shKMjTYeuvnGk2PyHP3edQ2IuCHAMZ/aqgBPkVQd13uC2hqyW3Kr0huvnJ4Fa3BNMcvUczFz74Yu7lG3YDFrhjzO3DIBlL/vkXOrh5cDvcehbbkAQmPIoceHPN3mFizFfIXbrawdMY+jIrcVItIjaRglOImQ+ifgZMvCTVRuPiYj8ENb7eDqmK3zFiqsh/6ZvWopldzUvn3id8xt7Vx2LcpPugBJEvjOCfezkrfETX5u+6DfdO2HOifw7rHGF1TF1bxGIaIYL2dXynxrPU2T0d7gp6wCNvdORmWrgVAKcoW2/IrY0cz4wLTdf0sOGusCjTmZwT1Tk2k9po6fPET1qn1Cgo2Ya6Z7MtZTTRIbqH7OyoMMfYA7TJtE2V8bJY8YfoKFcytExyK54vhBnujZdl8zsIrfRVZVNIw1s4wqMw555mwsOTCa2BBdHm4JeH7JJQ3MqrkSSX/hqzWi/RmiL92mTxi91/TJGb/vN1E0FhVlwm/psIsuww6MBJbxBwcd4B7u6HGVlzKgiXuj8WwqTC9QV6w4cTjjR28NgKZ5Blfdmgct2cJSWNduCxwloCVncdILhhEpNoGb4TcSk9qEE/hHOrcIFZF9Bv7fLLwLY/OQklgvjyT885hXZjyoRDI+4OlpO1259HsV4V6zM3Wipf9iqAIZT1MlQhNo/zgstnKHTFHWIQToIRz3ya+1UkV8uUIv2DrVuwc/lMCM1J/uQd5nsScvgYbVFxjsTjlFIzGomUPGAtu1XbA77AqMBPIEmgobl9RoqD8vwtoIdHz1Dr1ke4WMa7SCx1peMiqbsc3yrqNqD5sfPDMQMxGWGvjDsUDDOhmiwKJ+FCy2d59kZnnfo9BEP+bvLJMEFvH5buDR2dfdmkXQSVJvxPgjsJD8HhWo4ZuiUFKI4isOgvYwl2Zf7pcIjy21NOr/fxU1nHSEWPcxBG/sZXKAbUVDnDo4Ry2HIF3E7ecubhaz2/sX19VaU018UMZ/HYPtoKVOYcF7pTLZKcPu7a1TbZXWLgi8GhdeXWHJV94HEDa0ohb051kJRYVgX6BPRW5DN6Kx+10XbQKMCRWLgyGVohUshMwmFfLT/IEXd+HKzZocNLSG2jOALiCM7/5siMxgn86POYiijLjCXOUMmciFV/zgTUJTq+UwzcBydIY/oz/4fZMBFe8K4s3f2GCJ46LLb4WpfuxNJaCDj8nS8bk6yqYGKTy/LaIzeuzVW0l3J36LEaYkAUmeA0ydK0xvvOiYDVt3mrk3geGFHvFlQH/T/G0Ew62QUCDhLBtEDezdvCsT8IlBSvN7xYSJicf4vL7FbanD2UioPKlx/oKDSZcbZohGFzT9EDvIlrx7zjBZirLuIvgvwRVAFcBD5zYkuWsnh5yfubNMLEiD6GuivUrJnMUjDEFJNMpNyaXu9k95WluhD1qcV/LN1UC1CAHSghCI6FPKCP6IYvTOXFzB6lbGISaMHDCZf9c4NNVbkhzsrDaj8KBZM0EzT/yGZe60gLB1oUj+fTPapZ8SmPBB6BkC7yOS0GhZq4MGtzNUArCRronfbwFF/e9BsUTqzIdTL6uoUtRZpU72jkfFoDMNVbe0nAIsMmzqN7Ug5k8YF2XSkghrNIFNC9H7ynyCQQWqTlm96p7EhGZNp9t3j+H63NafDMI218qENcg14wJmDfcq2Va3Efp9P+pj3gLqcnoQ37JK4mcJf41n0HEh6o6Ds0BAU159zDB0ixVnskUK/EikGU9fZsi4unr2JzJPxhonxLlQvLOEZVdOZ4Xjw+OtJSTnA4xxqcuv+wZaQanCzNXKh/dVPLVvLAkeaxgjFlfAAF+4SImxuudm06mB3UfgC8YeL7TfZC5yy8GczPqubdRIAOZnKvGOWRwJZ9uYwlSs+EklF1NQrFUD0TSn9u/W6ilvbMrT2mpRjOI/rjtNQ/IpiUOaET09fIKwFokB26UnXQxUdgzZgBwemQbZKgxd7g6uQJgOYTFsygPM/Wz/dGsAyr+ifEYtwArxPHL65wzeBFMBQoZ3XYW5aL+rNFTea3Bug0PlIvQokG4DiCB5QuvPkTZ3UB5ii/2CManSXdWeMhDfuNVwaqWu6Z8fSK81sqtarfHFqq/3/L0JxQeAqC37zN89nXFneDnzFH3e58KUcPk5mU6J1tAUv8ZVdxkZEsy6t3nD10nzgPblhGgVEftQtJqwcfve+E9XgXMXNoIuu6Z3rykPNYDfAP2BIQGMOq+MnZG6kkTOUuNDbhiyyDg87bQ3j9dM64tQjlis+hX6VgppZMOCRvOqiUN/bD+mWz3r7ehOcv6/FFRXW0h9n1lqMRtmK4ruRmqz6FxACGoguNKiVuQJTaE+RqlWczMCBgurarm9sWGIJQLABDSHfoYXd9+1uP8hSylFXXDDeTMGElsEufJmWNMWA5ZKy4NLt/AqoD2sj9y6mrJ+29gsNftO9YVIY5toB0J8lTGVNK81+kHTRmpJ5aJwt8y7nAz3NT3UMbcdEbJ8OHoBDp/LozH9RNNT8yaenqg0jRIYn0J87PRgVfO0O5R4j1gvUl/2Yi1k1TBV++tfwaMwh1tCiTJwsSxieRrYLmzqPBJBI6vZva5T9YjTNO7/lC9UDwa+S8kD9l8/Nx2xPwvswO+yfqursa5ZzeYRLF8LkeJdnMWaP/MhFQp0cM+/jrhsmtaOtkbCXv6Kxs7qnZmI5MLDaGif1DIl7HQEfxj9T/2xRJTnz6ARYSq3lJsy86GyMCbx+E1bQIamSC/zeuY0+ptwmUww1wlNPBd8s1BHB+mr9bkts51GoXp9kT/iJv6+u1DiSCwgzVT84svYXyMuOiHxKV5ExYhX2FFdL4d8gGZudirSZ3KYiPSjCmC+3cuHnJp5wM9REs64bcPFsjFUzrbJb2Q52zLlLCZa0gsbsOCkunS+G7yxGZhJuoP9Ke0FWhqC5Ac8FWFC5VTN7IZKnPo8Bh8gdQuWaQGD71bX25CV8bLDMvslpQQmPdT8BBWZkEvXTRZvxWA2hBQBRQi40CeI1azJ4Uyq+yCUNOI48pLLferYqR+gRCRpzaC0X8O3N8tqp9b935E0SNeizM4BZTXzIilNxf8Cb6eLDJgOfcQ/+oW7PUA+f1TW479IajVT0OqGNC8V4HXOm8r/8oJ7aEbHOWorIHf4Utv5SB+GA/zJFm0iy8irjtYQTa9Xtu1kVaYsCrjtVhhLxTLFqtTaFDYoIhjI9493cy2jiAFhGqmuuiZjkSJ7czUZ9GJOveojJXqM6Yqlld/Vz8diRnaX1/un32MD4gGaIOunF8/MHQGw1riU11EWJA0X/YRZL754+rNz5FNiRaMJgQge1pxna0lbUBkhAweaclA4dgoxsGoOMOf6cRQ0yCXJb94f6E3cDuIEdLvvn/zjqnJPileIYthcr9pykOi4sMFn+iu7HngAoPodS3lcB6uDNltDiraoJTC01rD+IQeQJOqcz0WAVxdgMxv/JSXL92ZSWuq4+SjR1zkdNREPHu2dS2tlLNgbC0+Dbz9GKay6xbtNn8mKnSjQXn8OygJjoS0nlvAlxGwKYYg+2Dw0i5G5gq8A8MiXYvb174sJOl/P8WnRRDQ6csws4UT2kJ2RL1xvoKgIzBeqC8lJbtzrw90Rc3nMDXlPLQVpjZ1gYHMO5F1EqeODGHFdPOXIueGqJGgl9NqFsgEb099VJNJ9eeZVIrXT8mMQrmgbez+Mqm7zpWi+PI4ZCJi/9LcB9x5Wa0M3zknYQiG42Wj6hRJxDn8FLtFQ2kEHaVUHQ+FtKn5FDiB56EWITx2zny+QJJ07uaQWdmBPnkjNff8QarX9unNVRN29oaUVYdrSsdcQeT7BqQKDUtvhwdvGbY74In5T+Jfw1icDUvrLItEmdm3GXcsgm7N3Su8dsLECqd8gE7253KVzNURgXQUQUNn3cnKM+9tRxD/HAwBq27U+PSl7NIqWrUdJ+2besDJZB3b/C3BjmbyWE+dDT5oGHoQpX3EmUY4ggL8TwikP4flzmGDlkUvQr8CBZgLX9e6OwKEunuaWuIT3+FXPO0QsZTTjYwP+EEUmGb+xj3iVIGJ2ATLqVRKL7aB6bRa6zY9t/zDDSsYx0pOP6msiziUgqdiSRXHPvSs+9Qk/ku9ufUfFkfHA4RiOvkPwwLStyF71x6NRcaJMmAtFESFs+9AhpjfY3AD2Mg+sKsmAyFCwXCiqKxdvsimubFPrcAAiUXH5CtKdQOIFKX39K/p6xMoXaYijgef9o39xhetD2JA0spMABGQitYt4TPmXS/IgTuTU8y3UUkUKTRQMGvj0u0FhACjZ6d7lX+NEmASmJuj8hpGvlB1sRaVpKBuTbgz+6ImeFxmpm62KPfK8uWQU4uC0Ij4fn+QhIz2cf1OXPTBrusmLLLOR+inacofC0I9BGkot4JH9PBIuZtKy0n3LAt+3G9TmcFOvP5K7QSCDLFbUkJ8deltDhIxenUk/7irixMXTeirlY6VrqXexWBAz0JbHtWb7Oi7rb85uDnMlwNjAdE2TzvgQ4oHlVrL4U8Vtsr43CqDEdxWTnqIa2+UgHkmbdQrAWfZdD6552uFzoq2V88vSSkcCrSc6lfpLtT+zGIYVTnYmrWUVYYCzcCqA+L03FDmN6d1WYCL0Naex0SzPIeDvbwjCYrH3ajlH6C4A1A2K7aAZ7XAKt81ojoYgtn4paTDdX8FA4cIblX3oiWKTOY7wFdehb2EP+MqplVc5x/xQ4z8Ncl4ECTcJQOxbmO+FFO3dUTDXwXFBFwXLcBuU+aQELUiLXVi2DdxOayADxbi3RBAzIiMXtVDLgi5RmUP1X7XM67YvCw12p+TuMSR5GDz2WigQIj8LK3z+szDmqqCukedKS65K+pdVJlDolxx/Qq9vH5CKGr14+5k9e1UDfqAaGtYZMgKSonoR07LkjrP1zRk+U8kRHnB3kr1hW3VvK4LNZL36SUWWyl/PClD09rSrGDY1Wp+jqmfBBbBd18flINX0aoJQJEJfOwRrnJ54fHBtfXZLuDGP+JZn6YdvfZi2zAa/cInJJlnvOI2jKyXcC7X7imJbZkwBtPUbR7eqDiVQjNp+W7JKZfhx7b3AVpOGjB3cedd47qvHE5BmoU3ErHdD0hM0PybNtIKyj/dg+9UJd+PBXmHxtIXGuX9vheUsUJJCJme9n+W6DzMGUdve/KSh68mTzV8KQFbCiDBY8glcwzCKLlenfc2d8IaTQ8KuLCYGyTak0Reozsi7J1RdsfQXdFDMMdZRB7qyZ5O0h0jZw0qjG53KrEFMTn2n39vTN3TCz2RAjTHClm+wln6HurJjPaR/v0mhA0frjZTpulKioBRVSvNwt1ZOi60BcHyBzLTCyHK46cRRwE1mcMSV3+hQbis0VUia7FFG4wxKiXi+Ish2R1zKss7NpkNR1sTmFgadpLMs3Y3whUxn2kEZ1/YjN+t03UbwyFExcLilVG4vzl20OFg6MeeSiH4c9Mxq8dwTnlgzx4unQMVI40Fr7qNZTek01UActl7fIEpGgyMYzpEMs7atlURRX5IDi/MNoW371C+oiKYsq+gcBegbHAsUce/2GIY9oacNOBIJMlvAbkrjrB9c6xA7+vfWfW16OuTxiA7pBlO7Swx8BuLuVRjvJARjKqJGAfVsC4uzHauGTzpqNSjyloT/jMM29lHi1xZG5QeQ2+HrW5oirJ+JEZqt8EBZU9hu0keF63dcZrF+HcgG0jTS5lRJYnsUJDYUzIeRJGhPu/krR+njXlIoEgn1D7B4Qs4t19Wad1MWUY8kwYp9ZZhtnxnYytYqzrLYNBUHyErePGF1dQ53NTJiOMhmc0oub7UIRozayp1MgKZikaXu//lsmey8fi8mhOrwTEHM+LBwRCWAKJ08qfRIyR3o7o4Y88L3F9l5JgRRlcz6X+DPCRCM5MfhhzLcEol2SITidDE144RQWDkc+Cz7dS0QLSjKzCz146kMws4LvIdLDyVJ4iSIRVWWdTCYLOSKmA16Wg4THpwMQpeLM3Vp8EGyQuIRujf40HYyG1sG5t8iMZiBb5kiXnD4ud5GqMs3WFCk4RHSn/mOoECi5zl8ikdr2GRZ7ZQAqFQqKATPtBfMwJ7IencDBEQyaiFbctbtAjfqSFKGoJjCalLy5lHZBGWJqNNUhSZdHx6RurzU/Cf4DVUzxLpEH9JRDa2xjuiZiKLOZtYVuKCsmDzSLU6JJuoBSIjco5SNyqvzjipVBzjFbp7qbjkNr03BxG2I13gJRMUS02Y3DBrhAoEbGaBbRfBfJ7GGLQ8/NF4b7vBuUDGNXY+CoDRNmt9/u7lrIqlWyG/H4m8G78IBQmdHIgDySY+z6bjaGltoCQ33AN4E+islRbSeaw7pkYSzMCijCn96G+DOhZDxgn9kUfjWaYcf6ASs3KWlyrfqeODKije2KFJPVwwFTN2vkFDU7mI84ziXC6Ipun0hVbIddJDOsJBaND/cGo2ap8PO55q0S5Vb+BC0jVrqUKxKkjlxg++t6eXHQycDA7gfMjjZOpq2VKsPiBdOk1JBgYtE3Az3uaC6AjuBrn7T01npbSRmLLb4CSNj5+b3K8DSiuJ7ad6F9UlHqhIZOicMuruaO1zKsSD6+SfMn2nb4VcZ6o+5OlQQv2xZWx4Sdc6F/TXOfFRTp1SlvUhT5tLaTCjgUGOcoMBukL+P8Wb77A3w3lNMEw4I3bCRr7DLWGwEdy5VuTQSSyNoaFHoybQS4iuFzq4JKzITV9XyC6ubPn5G8HSJLhfRT2objmxDDmNpphXbKX2mgXwLWM4pgdiAg/T6NUqzC8mKnTddqkWW0m3qnndpsuAvEMR04HvG3h7PU7+s+3Xl49pI7hCMkbNP8odPnd7e+0aErJkjJO09kkLpH13MjmN5o5KGvy/qjhVkluroKc+BcTnk8ztT3qMpxY4OM54CG39kFcLjJKRLlCG6DkhwGQp2u/GUDq7maJZO51MfE7+xBhOVms2RtEf0Tf9Q1YfgXMQCveOJMSOfHht4yQLK1qejQ6sCENr8EQHB6gKuF0z1bjJxyzGYIA2BYg8EM4u1H4YLh68JVniJz7umaDujbMI714vFH6Fq24fbXvr7i87TouJ/MVgrr6l/6iXInCoLI6Q9HPNcyczSJi3Ff03Iets1cMb+sXBBmabqRj2Z35V/LxslfOL5mO973PMLs6wKNpwCaGBBYuPBuMb3CfoHlKcuG42J6UR+/dSpxqX3zZYw3F7YF+KdiVw5qWzmvVJ0grLWZqv1GbsotLOo37WTCmKrd17PlpH8gLdSTARkJvrpvHD6hIw+XUsNhyDPgm5UPe0I0S8SHjApV0zAxyouNWHLaHUXh7a5PqwNtOMDS9tpQFTJQR8ydhHrLgCP5gHgxaF0VW/fjOx2+bjSLcPEOznIvFkcq9ljOIjn5suZypeC/i11Apj9QPUat0bHrlbj0WbwM8FizhNzUVm4ajG6aZtNnvWN0qsz7mqMdApyfSMAHBY5SqhqrpYde/A8lRX6X4gOxCXWfhC7EwVWwkkblcp6/SZslxxnonN4+SLX8zof2yDYOOlRNLPLJuk4nkhSteePM8JtTbvylxTXKvgKtpK858l+IHyzQrrBfkg3sBAhWOAsUS+4vRbI4vjvLVggsHuCS7cRxkf79r3mEi3fkhUERZyOZrAtHvNRPrOyZhEQkjnBfpT0OBoQUaRwymloA8oDcuFPd+N7ucxxeBp9JatEbiOVgsl4bLFZfeXU1tWur8hj+cqMJAh8yHJJxLMLAuQTTybNN0nXy9VhQN9NAASB8Gynx+URFrNnL6AF4tSgD8XnGglvxuV8bCTDOLMi6lgQor3D7w++vmwvVifINVCQ+YKlFnhnaFu7DNR+RQEjOutWNrsKYr+g14yYNUyvxDDkzrbgh0fazBkEcIxRTXbRcSXKsaggUKeTJtFxYHq6et+t055X5Z3TdrR+Y7UMm+VQhkD/YZwTZhx7peo35lUBoC+9UYhlbCiHBTOUb980YLKSs7xk7jfXJF5eonI+CgXfcNISlEBrptryx41uu0jb/FgwpCikQWAZUujJBPXbsc78S+wmGsvd6UB2uZlxrQd4XjHqeIxg4X+CBJhQCXvgoG8k2+ghUdyLAw9ezbISIsBSF+CfT/Y/a1G7vFz832KL66YAXSdfd2qCJeBqxApuogPjeakkJGsV2TY6VOeiWcQV+yDDFY4JefYRqubJrFZs6L0+H+7EtzdSW2bDVIyfs5Hw9KBz/vxrQYWKtUKD2hZv9/knvSktuGMb5iym8Kj5Q/Sk/Wyy44SS+tfKOuCi0I6vjkDH6/A8/bior9Y4bBleGdQTS+0AFCNPXXSzvE6yFiCAxmhAuLJ7S43j9U9eTgFLRAKNwG85MovUzmSw+ep4ngA38dhNYiOUtAx/3ZMx4LphqkpB3jX1ZoeSUo9EDyeckdg6eg+KR70Qh8RRdJ2aE8akSn1VXjUgQKMXj80EojKmE3yiB4+JL2P0/jk+BKHoQUzupaJLr+TTIQSvHIPw2+sHJ7mtq8AxvCn2MnDVZlSuwq9qazX6Y3jlomEeRCfiCnZks1AMSigZo9df0Bz5kLEYwLyqYOWPsBOn+ejjncE6b13LOLy56+QoAU3x3y7ton1AcPiahqmC+KnLi737wuu2t5SAWS8178PW2OSPRfM0bluXcRJazQYsnoK8NKTe/3USbg0AnaBlVc9Tq/Duy/DNjHATEIDVgTksKv4nlgx26NG08ZCokiqhSjfr1wpP3ZoPTTV+cMBmK3Z/L4WyAinvbNGcoQnzA5F+GWhkC6InpBTixSOyhFl/J4kABN4Idwck0+FmNhoSPM2W+X/jSQ0ZzoJh4gjgkB26RUyQu2PD9elG4QhK78Ow3nrTv0SWzryq9NsNwrQZzbpLrXqIPngpOtDlubWN42BZQEXs5k0Wc+80VjsxkwOTlTZxVndnvEtKvIAXWH4shWtMhDV0K42Th6v8XpZ+8uZNu9+vAqDl2wv6ReaykqBA/Wgv99tJ2CdtVKzoOFq16nBUd6g5ctgUmb+HFyhhCW7s3/K5/7D3w7412De/Juwd3wCb1yP29X5UlMhLR8946aMTW+dDEtwHN24GTHEzzv/unsqWyqOa6fMuaIlAH++5cgN2SwS77FUQI3biTDJvdHZd+xzsQhtMr6+SuJ2T9VBSCsaclQaDL+d0DPYphPPUjIMj8sBpMjXVEnWPrAtQgAZp8zcW2QxttqauxUprpQsacfCG996PlbYBVguUsW5hMx6KHOmG/qD6cIFXvTBw+/+7yeHWxTFY+eDoIJCnxjargN4LqYtD8BA3JEjWFbXuSCGuCnVV8jlOgVJu2n00xRx9KPIeHtDG/BB3p7us8TkqbYdBqzKbMos3Eec3Q3xlo3UBzCArS6PAB423tOfJbQJKRb48f9/df+91/cMOrss0gjubLVCD9o2omzaK5HMNtiCjVI6lnzHL6qs3RyyxCopArQFhCGT40pWbfrN6Hq5chzKu6FvDszhqES1ti7s+FArS/r2l3op+if309nY5jv03RTAakCYDaZawMQHBUPsWB6wc6g5HHKg1rCMSUWLtWAO9lMsW+VlrHAVklTt8LkhDEv6/267sOuK1DVDKVCqnZ7kcrFXY0Ok2s7356vEdT7Zl85ps0Hsq58odujW6S3GQrVKxUxYRFkrPTf57QSr142jtyfg/6MsKtqBs4L4i/9kn1JqqFwXXEvkRTe0jrCbYiAVJf/r5t65kjGp3mvzmpu/UExVjkMaFO6bMvKHdIdhSHjKzBPpOoVe/L/lTFN9HWvlrRcbVBy83wN0fAXdhHt9lwRkGkci8H8sKI5jqDfT58PFuKYnya3Yy2PaQ3rIRFrw6FKaHc1rIsCqBfCeStfq9Q1ODyhENDOo4L+/9DI17hkx0mc+sWxz3UJD8yKeqyAHaTdtsq/K6uMZEp27h3uInrWD/Iv9T0wxNtnpzeCXXiNXdnEFTYgNJCZFshahrO+Oc1mfilPalHG5L5tFwdUooxKWmy2P3+m0NvogbNz5uus99kQbJiD4bRUAq9gCMJNLGbexdjQaJVo5tMoz75xMJHpgTGytSHzjRRUAfda9pcZn1m4WnqGb/9a6kbtn6OOIAdgn2p7jMlwjqzeOVzZqzO5zbVCypFl7OKzlELC5oSChgnTVeXbFU/C+EtvdIZ/FA3nqtpWtmcft2OBsLHtyYiJRDL6yJYkknlL4qaIvDpIWVbSVLRv1jbqORfHYLJi82xQxY2Pt142AhXfYWc+VwZP2KOVTEz7H/ZYgvY6rPd6L2FKA8HpMh9dhOKZ9OGBey6JN6G6abU2THhn8ob4IQ7RsfxVGLq0NrNt1RmOxczNQZoRdM/YeM/9YTvck3dr4CG3y48SdUHjqRriSNyoWhasvGBhdYGyQe1cNFM8+zeSoxHSMsnCScj5B63kyZ9NcZF7ycs8wMXYwkcd60njv8iF2tFAdEmwHKR3mLTpiMmKa23MzwASM4jYo1XCLrEXM73sDXdViUCvGjsL6BL2bgje2Pd8vwF3nKn6CAkAfq2dgaSfx4bip6KUqk79N7ggJEMWT2rAT6A6rP6MQJD1SDs3GSfJh9lKyEix7899LYOup7V2Ix+mDzN91X03dQbVFeL56sx6egNYbZHVMHGB/zWpqXmsFL8bF9/bDXZtB2sLZzKrs5XH/wazJ6xkIrqybBMxzuEP9wx0RZE6wFzPrGUvO3FVCSkfHuy6Auoy7PUYQxWLcgT6ZnmypXFj9CwjfZVfn0ZD5W5vpfPp0DqoHUJahM/zG2YjkAn6XPF3Uoi8qrTHSxmfEQMSw4RbIX5CasRGZEYUXsoFYLWlFNHTjHfCQqtJq66MA6EEEdL/c11FuX7UyXgttNnltqsBD0VgbRmlaGaJRTCV0UFY42FLDxuVqcEBhrDbJDbnu3NGIZNxnONJvC/p85+nbHB3BQ7SwsO0hArezgFhe10clMHezcovfxoKnKMwI1n6S98b90gQMD2tzRw4dhZsD1gZK9jv+fdS/aTDzWcSHkowkT3oWNNpF/VHuVx+tbu8o0/SSJOU417/7sRYx6wnMYyA3xrywdrAQ0S8bY275AbkCxPr0qVAJRMPeWxxr1+V9GSOnpQqxtkvS5RNAl10ynSSPXaln8En/hVCmGks8yHs7NW0h9OIcr2rYzrrp8j7AsurGobwDupyXu2sH3C0Nzw8CREPl5LeYvvZIKmsIrYZ+uptZPb4XB1DyB0gb2d2KRg6wAh0hfAhSWcoFfx9+tCEHWYEqDaH1IbeR7bVYLZLoq0fR5abEwt8q1KgALw2SgOGkpXcz/ex2wOauJXjIm9zkGmKyhZqP8FHBy+LnLM+as2f79u/401AMoDnu4esmZTK0mfqjF7T4AZkaD2FbiiK6FR5ti2xGDys+1UcrmvD7314vBRliOug3EOf85fZOo0JoUwcRIy3rJ6g4cH6mZbWJEC8n3ualdPU54OtxjOUkynUmz1fn9V9bKDq9GWroSCg1o2LfRTeymSbC/ghhfX8v4Vo2oGsDYtxE27QGeNbsx29MpUIEOy7fDw1d7BUUq6HZAzRC+Zjn0JFwqn75gL0JiwSUWJ9m74APjxp6m+/VweCpjkJrSS85oJJZallMi+QNVndUeTrRBFEmbYZlqJggB2pWgO/3tZs7R/7ko8kP2hg+5LoewsJsejHIbzQoQbQLNfUCuxFBA4w4Pn4pPv13/GU/jj6m+2+fsOdMMfBIyEi6BWnwOUyeCyeG3kdi6+KUUYfQnQ6m38QvD7KJgtZdFwB1a894Q48Y2MOaYMXAMD9SRUio+RAUsGhT7AMWofHAaV7gPBtlm79DF5ymtWwCHoNRkKT0vFw2hnRSx1GuBvbeRV2e8Na2VpntsTYpcGXzNpVbgVrwI6G58sCnIFr5AkYFHnCGW10iJL1PpmXYklw4I0vvI7G/pfPPszpyIKR3w232iUHGZ1ETW8wGHEUCky4RKMwz4t+dMo8LGFNQlIbKH6+bA4Gqh/p8wroex8eJqMJw065cUi2nY74zyQIFE0vNttZbh1uZ2Fu2o8MrwVXCk+3kTo5Ux1DtfXibt3Lsmy9/n1G8ZAH5hmkdwY8/8wZFHkuUIuCGDmaQ3l93+cwGa6oTVBwIbiPh8CM6iC8PDe1ZLz3EqJWgS7mEs2BG7vX/gUZPYd8i+M6K6Mql/vm3eybu6z8LeN35i0ApnH6fspNvRL64MS5iQ5rkcpHiexUtaXzXlUgjMv6B0N7XIGIrsIa/m2nwDehdMSPwTOLwtaVTkuSheZp4svE2Usfr8VxSNXD1TPmhNAk+5vyxVxZ0qZLAOz+XiZL3RPJIie9+34SIrucSezlmW13FLKPXQ6gwS7JK5anfzkXtv6jLdpDFqB313SlVO660teBSThARzbqmED7K2TTHhLTdd6nuXQubatPEKA3R1DYHd3ALilPb2ZuiihNQl0PI6fiIjDi6uvQ6LTCZ4OICseh+4xMrDmMGwKPIBhN5a31arpN5YT8yPIWQk5TjD69994K/RiFdddwBdXicJL+AsD3SaAlTaXbg5M/KmUh1xQ0g9gfiSmCa7n5WIbOPAREJaR2JHfnVfq26dPnc6S0THmjHtFfE2lTVeGLkbWLdSVDONxm6y2CgvcXFG2k//HtSqg6/QPcS1tb7uOzmrr62AUEVxMo7jxiouiCRYS0yettMtoEs1KLm2wNCKpk2wGsFjgvgm2mKrE8BcZjg2MhpM1md6VHQG7w9yaVe9gDlMyAJIRzGRiRJo9XO197YPsXZ6iM5zDwCkzNjRuaCiuTaaBddHkc970VyZya4Lgas1RdFifXN7Dy9tLoIYshSFi4Iibd+MDnKzBqKEIZ96wH3pxvlB55J8rua+qOufxVRb4oHQ8nh6wVn8p05oJFutEMoHOD+i5GhLkz4SPghqTLsYUotsXP0ZHECllQopUgYdnOeJ+VWaGa9RBkPii/qTF7xBK1FTTswGLUD7Kx1eZGewHdvO51kJ8jElj1Fbvgg9TXxfAunigiA/8ZyfilzYsN3RDyVa+3let+IzMtbrtioNWQw2bWLo0FBuOf1RuSHR/aGTF9qjsLR/P8tm++xHZgYwjV1d7XjqkfUfZLCKyoeazE2d2aexw21r/cK/YjF3KBTbs7khXl3xJjivrcQVrfj9KMxXxTcHx7CrfhEOROtj6EpvaMHC18YpF4NonswGUZbi0W8+/8Pr3rQA5qjNQ7WvYcqQkBp7uEqskOKZypFG63syeEg7nUznclsLLBZlz/oC72LU5JLqMX7EJ4atVkDETUhXKtbNY4FPNzRK+oQVskCSyPIYqtUDS7J5gcbOUTJbYMzvcFRayHoZmhqMJim24Xb92kzsDuzQQbE7pVF6hHauML2DppYOABBTUF/zfYWE1IQBLR7LKK/ZSXR3ep5tBiMoxHvC4lxZ0ciCwfyDZciMUrID1Wlih0YbmrKk0agGpG1sqnsYw3J5/+z9nfL1rK2maq9ZxL7teYqzZtoov3fLr8x9GrXhNd6UtoOfGhZHeGkMkUlSojCLmUbaDFE2KN7svRo06TkkGMiaVVuH45gvnvzVMsG6nFI1GEoERTGBIPfeAALiVLmAZPPmsbYxAC77iD2W+a8o/YYNIkd1bVsmj2Y8kdrbHdwR+ghB6qk9op72CwT6+C9IN3P1aAdcHWkBI0fGlyMLzgp3TNLFlZaZcuqhTTeXNbaGXuqBiMROiSf0od9YIblgBeNB5mQZozGE/MpLaePbyTE+9F75m6ILDDQ+V2/qSBUUWOeeICi6+GuABIRt+AERIZyc7gweQjG89BoC72mRhWh8s7VzD2wW5S/mc/n63O2TQ31QnAzgIXzXba1jnJldJkR/UfLt/057+tG+nv6Pa3lhxmrN/fiiA+SBcSnIv0qg3NVhkXe26u5afrgW7f3LLZtlRh/pS4bGpIM/A+IhG0bCdYWQRe6bOZskgE6AvNqWdZJQxgao2XPdbUkh2f74XUT2+PiuzpnpOLpJwTqi4HOQq/wrBTCVTpl7I3C9zq1avDQwIyaBfcMRNC10eAbH7JCTT4ffbssjxwCc+HPYWQL2xDTDg0J4TdjLQdKeQfalhjf2yxJlKE41B9Bl/CcS/MMQj4Rbl0WtzjOiaoZLHbnrupODy1RmIKObA8+bd3/UqIDjeChK4fRp2ZTYcto8lRKeAzTAsFuuZWeKE2sxiPqZUJ2VHshuDjlOUN8yLnghx4u0eMR6PnlUNYVcDso5az6yqVU8octUAqgZVCnK2JrhtbWlQKH5oA5ml29VOPcr2uso1NeRT5veB2vl77t+mkhJfJt249s2Zwr/cPedYeH5auGQcOunesH+G3I9SbvVZ3ZJ7ffGEvfGfl7AHhwTWHUAUWJQBE55uPU/yh2LvEu1FhamUzsFlnyktwYz/rSj4DecIRc6CNR0eIkR8wzApIcTqVbSNI/xAEKTCKaEKXWBcZOL1g8fnb0NIEhS8BNniqY7TaZW6WJH/0ltBXoVFCqxjIZeNqL8B2gCFqVbZIhyB9vE0407vfhPVZ+oQB/u730e6mCWwR8NkOMZ4f9gwbQ0eULvTnL8D8jkY9L5nWg0Q6McwvYnjA1C3I98/IlOU7iqIdFu+Dk8VUiyhSLD05BryOeB7qFM2uKaEcwIyTRMW0czOG4wjOCZlcub29O6WQtsTZ4+KKzKbS4bkZgm6J83r+axMr7wsXwBg+3TDdh/DXZj454Un57OjOy1v7VVXHkZOkrMdnEgycVROW2zRtHDHDeB9Ys3vvdEJKLfpb5/mhXgHW3IUsRegDz1O/k6bcBeLdwMH5kPb3ApY2IheHeHReu2UE5l4z5H6ggZ3VopyfEpmW6dUNR3UDH9M38eqIOGN9gMyKw968PFstdp0m0urtyXxwP0Pm8BjsjQF/XMvSurgKX4A33RoyH6w4WIRm2CRhZtl7BQ7i6dnqqxn9si5ZFQ6kA6ioPuQzjsbdu+HSacraWh8Furh28nQIBl9dAZZSEgogNpy5vKFywzrF/tVI2+OXTqaoqp4Gwr49oTIkp+jDuouM/sttoH+EnWFYgQCLyKSj0o9SLMZpzZqgv89L1z251w+R4JtG8sA/ZPDELjdylCPRau/g5jmD9rw/P8IsFy4LyrC3l9gbWM9cVTGJAo6BEVLWv0mnx7bpo7p6b7gRQ8qPfKy6z6nku84THuwlMZaGMkQ0gAlwYPGZ4jgDQipX3we1qBu0RXjO4H2eJ5NwpwHlNgf+mpi2tLua+xcuglsGrCYq9pFFK6Pc3PcB94/VwbpmoA6+5tPEOoIwYJzzc+riKupgZfa00nQYE4BR9Zez6A739gtfz4Oo1KLWM20F7RWoob+RgqgWi1Mj0Add7322YZYBYLoVaDeowH4OJ7+X/du7q/F8yRoU989iQQ1ydTfnkGvFsWy8Xj0fZj/upveawUQOm6/Aa2If8Iqy6gYvbyEip+AeRSwz9kvKCSOo5KAR2l6KixX+cbtWLXgAO1R37BkccdETuCHTw7uB+Djb7e1s6svj0tZA2gOV1FR/ZuRb0xGy+8cid5tMbwFx2h2YB1AISY01LOCt8KaS/S6oNEVFDcyJtRQ1SoQYbKgvn9UuAoDsmN1LbDd8psY3S/0nlm7iUDe3iIEqa7IE41OBAw+9jLm8cKdPgT/v0JpEqpKoRuICsoQmTOULfpgJ5bFL48Hjpjy/IuH4KTFi4Krp4M1wlEdT9jLZKs2v2RBWtKFMNMusrzuccRRZBzXUlAVgiF89+LW74qVpYEd4RN7YTew8Iw7QgU6tI0CQlG45QeFwaebA1FJDDHmTpSxS37weMBvJA/P69+rwEGxlYMjlJ5PLRJsi6DOZIwvzVVXgK/1i7tGa6QKYz9PX8HO6Pt+n7ucrtJfizR32YO+gSeI+5mzq5ezvpoyS2vEHBUpGpsLh0eqf/MpTuOHR9jwq2XFshk3zLVIHkjwBMNxhYGTqkyX4JsdRRzXRXeBXRz62BpRcpp3tNTTqE7l0/Ic0Y7mQXaNvNrLC0+sY54JGFPVYPDrDrdN7Jxwp4t4yrFXYMKTTRyZ47RBUUKxNq1sWPbB1Tg9ZorAfowMQ4h0SqCKyj8UiCLrcR1VORtIl6ZfDAF3c0+zI/W3zkyD9QfvvcFd35G21pkaXRAXSCBcWax1+Uo/H0Itx9cixiFBcIOXzD1YjGOJumvYWCKAH7SBYsU/FDIsddpyBeVE9I35YOCU3m2nEjSjAvyBQX7I+QJpXZiKfzPA2m3R9X0niomGEf0Z/GSBK+vSJdhut8ZFi8jmczSXNa3Q9cR23L68tvsp+TDudEM/Gu/snXDICoQbGO1h0MhMGfr704zHteMtt1F3rB999koCnnqf0S7DqUaxAiDZxxXiUnkLDv5QW/5JmGd+BA6mKJ10m1HmPAy2zOHzgda0wiv1QHPOoTu+N2xZ6uxFPD0SdFprkM6fLRuLQRHRgFnF/4pEj0ln2JYYp86AItWc7QqzNrLzBBYgvZ6ezz63U7LzAkW5N0KK22MOV/xMrEv9cZn4iAdfyWlyb5Ohl78JAx1aPUW8uUQzVbSffbS2DrO35tDpnzXsdib6LJ4lLNuk/JBDnoaP385aXcaLcI/n3YyOgRED6D61D5kzLb1yYvv+ivA9Iurt3sGwQwOA/EZ0bumMZhXI11pyjlDOOc+GQ2FK1ic3ZH+G37CUcc1DlxpbSWwtbZvZbEDITHrvFMkbbmXcsYTrOEhLjOjjl1JT+zUUYwOj1EsxTRbvTlDl807qJ7hd4NssqBld7VJeTHAUU2FfMYTfPFZSHbjdvPDoLdjlR/VCcjXfn0jIGhd0vlvOvaYNY3BJWI2KS/UlkUn1WISgg9Rk5OC2c7xJd8UILY8rNvfNTZvQvMl4dHfXGBSgOh+sL0IiCcRGYyZHzijpBOV2NiOcQSwmdgMBw/FfnXPdMBhOkBkaW4ILCqpO5uMZ6gFv8t377Luiqd2xA20IGU6ncnSNJngY1u5KSwo3JvwNcZi/uawHEN9+uNw7fsX6NLuXYZdR6R10dMgtldNUBknhiqXJUDGTFBm35GZaIh2COKuvXKIu/eUrYuBG5YouMRw8N2N7S+MWMTQZCqXVM+K3WxZ1NlUZL4rGJ+VqIEqX3Db5Ojaj6i9cRaufMZitoycoo9kb2ibpN8E/rPWVw4AO6DqtTiXDTh5iIAGwx1LbOA81UTSaLwzuOFD9ly9knXkoS6FohGQzFXLCO5HwDtXSyXSql4G92Dbjk0wWANA49eL+lT4NiyCErgO/1WMvk0fOowa1m8RsjEwxEcpixndEckXvg08OQg7760cEM8hQafOgeWhQAiGYpfIV7RcpWtXo0ZZV2CKQBpSUKebWCpOynC9T7pE+XDcsaQ8RCzwGsHi/HiYT5wh9skrE+orIYQQPqxrxDgRzzGXi2IhuSbqDV5sUzg4QydwP756hdKsm53F7KdD6a8wqkq4Zv0mC8gw7DFMsW8fy0jh7ltaqdJRaU4+E4iT+ehdKlGYMzFwOC3d3DO775ZdjskvdwHHPlc0X0CCt7yA7zRQsaQyXUaQbLHwTuGtaI6qm4zntT9VziZtOfaubwxF6QRNT6tqQbwssgykolf76wwjcWkZK7MSPu5xMD36TulQXseOjUr9I6+tjltexC2GDsLNorYJspgDyl1kIJNTazAcD/HEnFIzXkDuXfhQXC6NoKM4NfPt8l19ie0M9QihhrO/YUEwN5hRkZsGc6VNSXkNQx3EkLyYDCYPpd4/3ezwlfhbYP9gXB3u438KA8EC5sF1ZHxjAmsbb/0LX6KrzWftfkRSIi3IZwYmQJco5x3U1DtFUmQOnissb6HVgBD16coABxQ16p18SGNmJaPIDR6D95tOAnA/7jSiWadfID4E9A63a6sFr2lVCcN7dUKZLbT80MiHifAL5LZhaYhWxDRB1BSvV7Cgh8TVPszfRgb/oPjskL+BLD/ScjFx8S9EfiVsyk4cWNp6R2kVf9k2E7eOQ6om69HRSeE0+4TvabsVwGCA7LwLnCCaYiKrwIvuSGpw42veSss1pcO9gVyIjiru145FOhZeprCIKzPOijLDVt6qd9G4wWF3N6xUmzsVoh9eRXP5ypQrsfgV7dSgzP8GvbCV8uluP6TJ9+gXPYl4ihkWEA8Yn4yPehQNq360H2BImEmqs36nWOf9Rmu9UfDrG3BExRM7viG9p2PE/1H8rC2SwOWGEeO0TBLXlF8H0A+KKSo/qYMpipJ2ImgWM2cLd8yc80+bvg7U8DYQGomCUIyLgiUKiMGlrUbhMWsboFt5TBUu+Uj2bLXdwUIcE3S4+J1uUzTM1qG54rNGhyA3ypvZjaukSqcxVHRNxQY/DAAwdp6L+H7muZTSQ2MkGfLBwjEwA3HarmbVbqwtcKenhvwOITJENDZMW+Po6U7tof+DLXG+XxdcAQ8vj5B3VwxTVwEZvt6QDK2/2X4vspfJruZ7/q90FGNrcajSucFHKzk6NxYafeeKmH0SzBic/uCEGo3sKkDds6B5tZF8W+2XSTF+sekVdZvLmApfiocqx7ZxJOmUq9UWyQoZsSxlGLjE0V7vGB9/mqyEjYuSIceMjweD+B0R712cxNZjJK1SQo+zgcYsBAc6dAcNiCsZTejvTKDeWyk5BfCLSz43aaSN9fdnKD++MziFCtmzYyWSuBW/6RdHxAyDgzYUloQOZlHFHjwaYsUKR6K/7JB1WVkyVdu57womkC59Y+23CMgTk3pbwGc9mlQt6ggmn8sslkLw/XpVYDsL6MfwguyPf9qZ0DWrPohAymxwbTmew+7FQrIEiAQGJClHT7X6Hg/BR9zvBuHgFdPfW/9f55TuEUtTDHOPHVJs86DHc8fx/9GbHwNvVJ+MPEjfwYrAkgzCInnWjR0lsDNlzgqsrUm5Q7tEh09Vs1yUsshQppDWroZSio2dtCkhXmFXxjZBFskNWt4IC8pJL599EeBF7WL9/uVf14suoKzg/HUpX9n/2OmJCpIqZTM0zZLl5M4ls80vZCmvhe0WG50aqrTeU8AfgrnYtCVx/TFXKprA4pV+gYkJBYO4GpLjA/OnbrjlJqoEMNlbAFcyvkLMhs8CD0OhEzBzpJKieTSRwg9JKwkvcE725+8K9K0gmvP6wGKK9RA7xLtT9GtgB/BayPci1mZ45p2Z5R3SHOYBXxYDbELOY7R443vXrLIRk/o7DoaP2+IXUfUY5rcg41wOETO0gP03W0eFMp0CPpM0YQluOhHIvqmTdSgB/vabHhnO4RlKkvZiD/koE1r5OYn72gd6JD3Et3eZH2VA5P+yhSQoT7MqnRtSUJ8jgHM7KODRylBgKNRSUlWmTdjU/AuZbXNaVt60PlpBP5jwKynQ1mOPNKF6V6YuaMsQ4V/E/pFWY96D0jqi3ye7l6ry6El1X3mizEEys2JCkqCE/h2xARn/UDJViauyyOCLLFBNS9Yz/g4yAF37e8zeh36KOjNIWnymxKavLJXGReJqAxUBCglywwKYaD9dRcYPY7aD0/UWAKKsY46EYBcszEiTJq5UJZXmz+yAnbysiQmJjyP2//MMw1BHMEbT3gAZ9IYsxQ4Nb4AQJ88I/prwRjBJr+V8fnmTIzy42yuZ+sxWIFMSVHappVEQ4+eIRUiOWDavFddRD5P867iLzoAf3Y2LbRrywIZzV0OgyD/S9uZoIIszEhZyv3tGgKbGhbtXvoRIKlhhoo0KfPlsjTEgcD8yoM+VUBVKKHWYQyyOmYcQQ3wiZI4eoBR6khdBk/uzQdvvLDIC85uJzXD++bKkKOzPApllIhTOKwBYqBwB6i1xV81W13eFLdL0KlSPbeX05f2OfZByXkZD9Nj4w99kJ0d+fh0VpdtSrmwkqEYLDXeA5xBhW1zdYjUrYKOAp8biVh8EaFBBzoZ3vf8aXwbYET64kEfQGwxEI71QWERsIN90yfuVDzTGe0yIEw06lzr+vpxszzq0bTBS1YDM9PAHNF86WHixQwwpljXuUj0j9D0qYu/gEbuJ8iKgHPWXOSs4h4zk+bd9N/wArDBE1dVn/PJ8da/airOcPYO0RjqeAG8SlnDIQpM7LJfZCeNZuFcmjy/skt+vAIAoZt0osYu90p9JycSWMNRN7EMKy8n/yTLpQVWxF39ceDJ/1g3c8EZddPF/zMTAEMYjWnbzSQxshOwEU+MBn0ryCSg4Hgj5e6HQZCZ5C3WveZF6PsnaGriXdnP309sz1TbqCmRu+po3Rj8N9K2RKDS5jCM4SznEcAipOLuhx85kpGqwVKMioxrHdtL1NEm6v7B9UeTdif3+U31wwUKqleLAKbWNEWIhcEQMBXnFOctji24ptr12AmX796Elx7HqOLW0qrcUHvI6CxGpTkh14a7VyHhc+BDiQgGSBOa7NRV2WzFhSNmkRulVXk5KeCiIcDeGTZ3geaB7olDidjC87ahORG4QK1T9KH8rrOONOWXFnJPIxK85Q8Is7ThtInNkAvxMj3EZFyRHty8IzMyueLM0VT6wLJPmqobAaRHuFeQkJu+Y/ChVmYzWOOf31c4tPhD8uwnhhrmrQThBgBfCi+QmQTKf/AgeJwD02V/S+H7WikikzppFqP9s6uRc4msjjqRKTc6rWFuQhK5PHZ8vVhfL2SS9C8/3qRr5w9OIkRpb7+GREfpalNOgoIWR4ii5BWQZvQvvIcvZ+/LvvQ/Mo3SmW8UNub92o2SXKSPPNd9HGcSwHCxK9PHU/BhdMCI7bwi3X2+z1qnY9u2lGzsAlTvODSrt16aoPUypt1vVbgy+mhnkqiRT2pM8rTzHdgr+74RlJNZXCIC3X2G2HX+6xYl1Yc1xzdLT6fWWppNS1fGiPQDzNMZlZsERIKqtYjFpNhcCTZ9Kwwpj1Q5Eiek0+wc7S3hy+h2Hk5QbsFLFghjd9ub9e5kpzGee4U89/CKLDF88XxGj/mVU9dQlcnRFEFhinxU8zXUxEknOS6bw7OtlMsBNoIXEX/OM6QMND9AseSzvzAoJEMhL9c5v4SbDTrM6DnnOIuxcwpe542AajebPlLNnEh7oNM0cOoPmlQK8q9uYR//aT21fuYYPlmU/uo0uo8LgAJRYOdeFwsYbGmf3+ASnxyJERRl1nRRA51GyU66AbX/3qsNIUBZOxfemyq3F9Zlkg+418tfqXxVWvNBxC7mwihV7ao3dtsSQx81PbGZ+4lZ3RFf/miVQ6ZyvewlKLddEncsaE3e9v9jnazLlpXBKX4MzxCImbrfcnSnUxVhloP4+0vImxQPN83eX935vaX2FadvJXEPrVITbUpxt0d9lNviXQIH1723gqGPkioAYBfUfgrH8lIvXa+RZPA8/w8hAx1H1biTZ/innQUqDqKWydTTm+ErzyXU5RDv0/eGWGiD9wih6cCWmjifLasvrBxdbMrlefZe+vFuWbaZvZjT0Rd5ALgRXfHAYf34oKfjEST+fKTIWbwreGldxOjqdpqUBIDkKDbPO6rauUTqBttsCxHwkNoy9+6B9qS+zujiy56aEI8GRb+IDi4TnykDGR9g8rsk5+X5rXLxdqaFoT4B2Y5uYc9OP/JgAxjdrP9xenDt1hmCEDOmhQFKlZLamdAdHEqPVKhHBstIU1EE47xqa/HO8AJ6wEngLYUhUtJb3jgaMp4nuBUkGG6Ifh9IlgzaR6Eu7gJxeH8NvienPUeQ17kwUBGBY/UoxsSMwJitf3KsTeoVV3wHCSjQ55rnTLEmwusjN0JJM1tlFc0ZRBXG3PZcub2+XIASKtuQ9gFDJc5Qd/MFSXtSCEPpU0mWUZiTCUZXmnLjvU0wEqbgbtCKGm+BNvz4yNyZyg5T32fBq/+ENwatFZbQY+jA0m0TSMkFlp6Uf3ypFwPeSBd5nf6IDHWYkn8XghrnxsnJa/mc54Idid2AS7nwOBNONc/DyZN2rCAriNXJhPyncJjNLErxRcRXs9mO7H+e7p+Ams5rGhjnh12WZHW0U/TXpxDlT+/UG1KsR2+QoJeA3d0u8FozjzQimxQ/710GHT+7V94HB+kUcYRT5gPKb2Gu65igCzknJ+0guGBNI8weWG4QQ9rGnSnT9YDNMmSH4NQZLqy8zWxKs/7eV9GAS90LgOI0hTJ8Qk2DgznYGV+EiE0QPzkFNFuj3odil000AVbvGCr/ECZTM3qcY0qCyTns/890XOcDy1lVcFnFqro3LkQCh/Zg/ug/ndQxhRChlkj+Rjpb+LvX2jtPhgP7eFQaX18gBrDkDZ/fEF4ogcxzW5C8ZwicY2Xuf4F1ut+w9G9v8jNgRuli6iAYaaRJmO6Pk4f/QfR0dYF+618rxfLtJprnK96PiVZfKyUqB8Ax0X+jrnu28qyZx4M7vBP9M/8E7C3UBNUgXsQbuI6BJ7sd73oemhwdda8sOQypBYxJ0d70eexpM4RVrl0ZXpiykQP5SxKyJrz6qAX2XmlwWc92PK61ox6qhnrZe9e/D0AuRaTyywElHqOpF6hBR6rlutUWbanE+ZPupz7qSNn0kOtdnC8kqyhjs0cjahN2HpiQmTEmF5Y6VDayVJoVZOEXTnNhJ9/K9EBvEuYRghKs3oNVWmpZADQ+KSVte/pcAvloOpzigZ9ihmDwVLRPcISmvywFYmFgu+kS+3YcaKgGKuhnVwDsqHSHinqxiKKtDjn8fLMJ0ntJPT3Ify84gyzfbHFdNUgWjTC7J8dzPcgrZ/ItG+vmym5vN0oP36y+qSQnT7G0peTtr4YZ4xBJ1QzBgI1yxccNSaY2GUmeHAiYIN5pHCmuIzRlmH4h1wkaZ79Y8zMoNZSX4jrjvy0BIAkoh8nMdLXNhCiT62K6ETinsFLxWH7OsjOAih3Rn5LEN1687B2If6cNzeADJnb4vE6VvYTeAshzC0p1YPFu30eTRUGU6prkuAEb7mvLcFig7cSHs8bxbI1ia0Sd0hhiFcb75nlVVeQFnYh8IYIeVc32I2OoDtthMkjrPMO9kXnEIRuoegKrsdBluZPUtHsNZcilY2/3WgYA3zg0Yb8LHeen4o9428W9QEJ1uC4glyb3ku78zQPzrmosgSIt5E5RRZPfhA4PhWAjraJBPsON3IqG0Uu8KoD44dU06fH+hy3rBrJDZlJsGHqSt458bhqSB//+rxM2p+Gn9soNovJVN6/vAJp21v5Sg/bimZIVzBuq92PFG/CsfVdJdV8Tc4vXlLfJATOiv6dipf7mQz8tAIT4/PAqQu5w49kOI2lcKEx744I3keQMjCky5NvuySN9LuTz2ZpHIHbXrLNJ3f7xpkKz995yQDfwMC9M7gWle8jUatvJFnRr8lYMKk1Xufc4yU+xRdcBfuvKxR6P9W08rtbu06SGtLQI8/ETTclEQwEvO8F8beuaIYA0rZET3MzsmCjNRHmG0iE94Pc2X4d4iTzAkdRc8eZxaGMJDfwYqRsSMRri++HHAqmhHmIeygoG7n/MHVo+QVyjR+PGjf/H/LczG05PpySKnXmWmzLv3IKc+wsOD5Q2swPlamnrSaRKl5JjFHjafo77di5Cbd3to+WddsufIhG2z2hRphg5n1u2I+49Z7dIa0kBOqYF1Yf0BmvwMGjV8MOTo2YiGFhNbue8QyARJOSZfSBRlZeH4n/W94cPSaUEiGttn0FwTDapQsRwikjlz1TS2fxnTj/vB0A7oGRw2cos9xSWgu/CA3V88ZB7F7PN/gW0v9QCzipmTWJvJ534ick0c20SZCLFAxZTgzoXtMFZt6Oz6Ta2APQWm1qyJuxZBXWvMGhj1hqNIUZyivYKbQLBd0FYQpHA/gVtE2BpojTyeG+WiCOt04IlF3uI4ubPrbG7ZAHL3i3EMkVtcAOLeMIDofXULpiRvv+Ks5QASbhLi4sl7qnkQUlN6ZLHjwEay1LRV3em/5xE7Lns2fMimpWG7ZBEP39jMVB98bTCGaRb2dNdboeEY1xm/P25kQfvYm83Q60aMsyitMXCrMdiJkWq7Qf/41NoV1B2lzbEurj1ZGJsmPPWFt0L26lBHe0Vg9i2DNUShqRSFyLMsWmWrcfEblnh2NmZ4OQ47if/iwk3fr2wupx8k+VR1vOIItPKEUafnozwzju+HywpWQiujIL28HUKP7FRgaiFaZH9CMxlnuhweqVMe1/zkjQBSfg2PUzH2iyG3Z2a0oBq/7qdckV48SM0z76Gg/aYhrmZndqYuIJ1ayQMOwGM9v24zykm1+A09HVg9HxImgD+a9TFTYQk2ndUrUBPvCPMAG9NBMqJnRvqRI8h4/By35Ro2Vlk8glz7KJzJopXtxO6xRam0y4h0s8BEhxDYdYDHe3SbNKbAUrJP7WHPXthHnU18qHAI2KKsL//0uOxV7ei6QmSYn6xwdhd7GjAhM1JM1L2qn278oxU6a8PxC64YQOrL50K0i9WPZYthYhE/Ygl9H6O9tN7WlrXwhI17LnJMxVeoiXt2HacTo1A19211OKWZCsGhxjGqmU31tF7UxFmnOswPJfCBKW3TfxIKao8OGd4H/4n6tLrVwXsGX9/FkApRRF1hrpOjXs/VcJ2oCgTU4Jtyr1jCoOXitWYhTLkp2JQmXL/Zz0yCqFbI146kcxY4ZuLSlyd6hJ6qPeiVKt7oHy9RVimp7jHalb5NcjjKak4NDPtnXTfA90U6TkZi4A8PoNO/7X3GGdPmoJ8h3j2F0nUzqeBXlF58Z3xW3ZzpOolp50DYw1hsbKGjBY13gK5yYUOWtwV1vReY5KTBq3p0BCTBWZMJvxj0xfiv9fLKIMJ1mu0/UfeJt+QhmG+giUfAE2f8S6XeWg5+4eT7TPc8AHbWKeLl/nFZlswvfRUuQlnFJO1HBfoYkm3L0JqvHVhCZvJ9C/lzwkrOXf6AMUmfH6OYdAxQL5HeiNA7Yfk0eLohHepxZREiXuLe56+Ze12Ln/RmunBL4dyMx5Y586F7kucV2az3QsJ4FE6K6oU0b3epORhfzO2fcxYUtxm9PVLC2B48hwxEBzcCOuPsjPo+yKTTTvLvZ4kWJFffAm94KaQq1SN4q0YGrOMXIe8l/6TBwfY3QIp6Bf9R8SYyHimk4dOMtfIUQdeo4kl0YAsIykfUklfkBa8eKrrucmBZmbU1T9fX/oWUiHu6j1e/dFWls7tWaS/SfyVgVmWf1slKIRRnsj566Ukz95IUxHxzQtEBNwwTaSfCetwo4nKMgUE6M+hAEH5Rsu+d+MJKJVy087twne0H2XCUYw1r3nCaJN0QnavmjD/VsMsazccY0uv60BmhlvWqKzaBQdtbg5WYnEeB3tB8aw81TjXgCdZMn1wd5j5XhkRoLSix0LoFQQu8tpGGTvTwyfZFyk1Vq5RrgJEaZ3fZu9y9D5eHsgHNRsoG9UqwQN75TqmwUCbsm041/yBvZ9o2QvU8is4Od0ukAHQsluNJf1zmSqeeN+Io+HSinp2X3ggaBz8PRJbLlFXMYtMiDKr/O56YLyHE5iFrgZjvTx4RWMYo7WIHVzKMJXNuXnZl4Pa+mqqu0yN3nwG15VZMIy56qX+DRISEo1+45Y6F1CDPXUJJmv661dcP2J86uj3r+iAjq6vXKUxNgqf93btAbZSsF/Dltt1B+B3K6K2l/njoUjOvao7pqbhFJpU78WpCcEHxXICGt3QDb8bF28lkO/9QNo5l9FXQGp7kM92geek3aiobr5smsbyfb6OsDN2RAe+MPU48YmBkq4CmS6Vd1WalGBRnIdvgJ8duAbLA+3/k+iutXFOCWmMDtRn/yCCoc8IY5lDImAqgqFGUSyHG6LsOAObg4FOclH5a25jjw2QY1Le1HfU43SMgSV/wvH9x7pCmVvIFQilIFq13Fr72C1FXCA0ZaPpl+d5+UXeN3VkTFRQ4IZ6QCmuxJ50ForlnUAUIv0K2SfSxcJsQAOeYVVkisLJ5vsWoWYnMs4isRnNz/WVVna/HXu1X82phzjoKtF3qRM9oiiCqPOCj37W/PdnpCGT1yiYxzmwsR3U9ll4I+1181jtFwCDDbyPaT07B3XOHqSXoKTWsRIw65FwNh/8jghMyAn5zoGF6TP27N7Qa+cLVZ0C7Jqp8Vg8WfmRSa4Ap2kkAta43WGdkDDOZnenlUHF4PdL6Vh0ek2Inil2TBtD5JrfgCZD1SBQ3DO3okgFdbnBlRZG4e3O9N6jD23KjxlSvX09Bq0uxnX1T2nMpsqxl6jLoz5P6P7EvYReoEpEr8fhePp3k37HKtmTxo/jRxm+tioekwzsku4p4gq5UZAdIMLOUdfK0Z/cPWlI1pxI0ZEp6lFiCffKfTl5HVnuDIIQk495i1mJTnhsXkDt/PNvSp4aZuGoqX0NhI23DY5vAd9LZdsEOZ4fQYng0gPEIJKu8/mm6caZVHe36XAPSyzmAI4fPklV9QFIP5/qZN1G4maK8uFnocnXXNiz14lnd0+ZIsl7OjUofeBz0uWjMc/5KrQUs1w9E94qlfhEgd2nDAVAHfdc2EGmDXpPTnZI2YPaTkR21QrWLU4eHka00Y26R32lTIoOoqXHRtOYwfIuFPv3b9Pfvbs3TI1vV2Abw7yxUeyeNrCnVS2Hiv2C6tc6TDWReiAJzziTRph/YOG+SG244qGmwee0nVqO9CWheVS6OQJOwpTUmsPI3SWI7T3ebL0KvPWv4xFsueBjbkCsvoGznffkVLwKzZREIq9b/L1MiCQBftqkH4Q49t1DACZ6QytTeC5x+Mi48DsvvHrwH1TlDHTPtCRiCzQdQPCrBptIFlWwLjWHBcuAqwlVkwFGg4fRmhuc3BXnwGP1MfWepHfhBNn2GI8EDFAAtyRRMxf9SJiEdV8FetztkyjrqMykfsGPi3DlXlUnV+5rODlNWBVQbIOoKTKHIMpwG7eoYEuKyEbRSKnhxeuNBnBN/zI9Ur7sGXwV9HuNunTYYS/4f9yP1jzsLrCYqfOcsdcj3vzhBIRIAcq8/iTcknPioJMfH/MuK5AvCfjZVopNxkEUHlZyKT6S3M2tZwSHmhyl1Clq5bBKT8GmzG2/0i+KRUwiOBh6MCInLUGFuOrP3ukeGKY7wcWrgpuU03LpXcz21bHchPhmNFjTE+56PSgBZ141Y9NibzpJXXseBPwMTGd+EotbhQqfu9nZcGsslk5fdL+dMqCc3ho0X4BOIr7pgb4SDZqFki43aeQfAuC9U4nxr9LZsHdmmT/KjCnH9U2L3naOkeTuAdSEuULiQbytwlJ8RjHz28L9WDhE9DK1nPT9MaF+oZ9103t3vkoGcBea8Ee1xE3G2Fa/pPEec2menfVEglv01VAQc/u+vsAd+3tq+WDO75qQoPJbeKU4FNQamoCiPoke4tjKZOSg0hPoaUFhx376+eyr3hnDZm19jPULor7moJ96E/XZhjaOts+mgOYPK2tIO+/GqNWBW5E79oZzErCPzLuHLz93tfAhFCPaKHIO8njtYt50ymvr46x9PsGX/5OCTGQFdLmrsCpBWZ+I/u6yJBb4aO4CtRSB8tkKDp53ygB5u9DmPcJ42eMuMf0qgSH7jefg+cqldhiBvP2YSeIClUZrTstMCZqjxVO03fK/rIPv6DwhO18jdBUaK3yFRsQbO4JAe+iqt6h3GEetwX3yjoF+C97iixEg7I4hRzyIXEDac8Yz6heanYf+xqL+LvKEc9zvUeO+illzKbv8TP0qP6PHq0L0cejxiHlby36URC3LDBpCOVKAGGjIqZiyBUCRucRSkZbx2G+Dap4Yap+SQpx0EzQbqwcWb4y/CsXv1nUkbOJjD0aAcuajs/IwSElIawVDOxHX9b9jrl9Bn63fGyqTl0S9rwMLBRcDMn/I0TtfoGnfRWEQXied328Jw9LPmnEp2ZXC3cU27G38Iaw9vjoxatDYiD//eagtaIrjeDnWCXLB902YlV+vm0Mq6u8/jVkcIM8+l07f1/ZBrOkcwbCv3rVh5ETwXxiRnzNFb3yHyaMVJ4/mjnW46jL1IcSy1f1Mb/RoMd+BfzmURF/DjfYTpGoFqqQ6uPdfGdZ9DH0UI7ktMblIeWdO7h6MK8QwLJ0nADG92KDYARXLW6593whAeCk974sfEEeAFMk8Qap20LlYqS+AQgLdjgDI4FbFN43GOzjOvqQcHKgVzEUKqQFtoB8qWjzn+k/D4oYpho5tGcIZjK35elcSP/TbskIOqz4wncnKTb0EIwTfc6wEe1PlPW9ELKmcrYpLleTekA7dTWLgy6VEi//Foq517aRXHDHmbth8Xj3Srd7LqhWpTTFnNRd9KciPdtBncFlOhcmbJ6SHF/V/LaQLrLKtLD2P/P7vcPtQcvxONqKHXGYEWkRpBZkIWtakCBIQrMDvu1ZbUMbQaGjd4mTxEbBtF8mzHQdewZcPwpsNKMhtSLpozp+Gu6PEFWdSEd3s1niGkd+8tttdiZ12fpRkyT0jBCk4aKEAUYJ1e0MuHSMNwD5VMCz8bpqFW/FI/jQWhIov/Ti1eGX/PYgV4KvusODR+LCoQJzisELK9Ic/CHh/AUnVjufCfBBtlltK4uE8NbYWOCzXzAYJVAO4hTOv+80rEEMk3Cf1qvn3SW1TdWPnj52bBfIYvIEMheBI1kSUVSXyZLJ9SoM3BXiZhqOSTUb3HnAysVAjshrsRYySesjlWh5m5kjNbCP0amS0Bq8BDh50YFqH0jw5IYt+sBY07TbTkKJu5pwN3V5QJKZwEWf+iXlAyGcy9slCMH/Mvi+bQKhaXELPOqPeIOBbGDCawMLv/Z223M3orQn8M7oQw8hZ8M5UpM6UQiUAOrxFvnByWs935VENf/DgnxQlXgxEbJDZX9T0RxZQ1+cHH0reUKbRpU7F0WdiFIn6KQcEeTHLgXGwoMTQ5JDD2YxPURel+TACCT5X8n4yybllToST5skzJ9JKedeCtlaFcDLVxW6/dRIbMGNXNZQ4CMKDtelkw8eGYclc9winQUOCfF3uUCdCjB2BnD19YHy1B6uF6HnTbypByF75UjRgCoSazJhYOSoCfZEIVhY/0hx+e5RpTB9ZJ+lwDPPXMngkiriWWJgBHs7ib56ZZs6Bo07Em0GAZP5G/NbcrqMK+fiafLX83oRAZF32FF4rxhUofwCH/wRUInWnlfAouIf9KM0DSnURu1tDlfQHpKyLuP+VIKCI9orlTeSdAISFO6E6n4SojNSxKoidLfq93xkR0PjHWqtzIDHxwl76jdmytP1Y91aiQAEjkZadfS1Hw0O4cMJngglAP+GcM7WaAPwkK5q4TEQTQNcU7/tSD2IEsF9x/HTsnSrLzQ8N0yUi6tpGt3epchRgkELsEvjT3Houyd9hcIwxDNA3DzqhX8HBzi08GY76eral7kY+19+1ZbYNdKvggPupL/+9olXzq6Mz2lQx1MvuvYO7XAv862JqPfi7QBknA7wso9BrWFl9o4kX5PfnxJPp1M3oxijnVPCkghkQ4WLU5HRXKq5IFExHS/OK/E02QWbqDCUdFPlR0Hp3CZfiiE3e11YkgMvT84c3rPrXUctu8OYzB+vel9H1JZjui7BzbBeTO4/Ob1T6np9kmLiSAK09IDE07xnBEfN0i3f/Ty0WZNcn+AZWIDiJLy+5rtML0LVj4Axsj6s0DXvuYuGPG/xpzXhSHo+0rMyEgwYIAPPIS3wc3ZihI+PAYmPoykJD/xtJnTpdLhDmhIjmKJpjBdy2S0Io9r5bJph8dxT4U7XHTwpuOOaqr7aW/FYvux5bDVJHk2TF25jIHy7TPcUAuI3yTc3N4RXUrtwhEwuABTCWJYw3mDAcEiiO4NBRggi4zhuJm6cMJIYL/D57N+/cVJu+gk1gi8oIbJQVHOI/zZx+qnrrGOrURNnPePXif7splfidOPh9I5WDBzyPT3R4V/eXAteOlyuWaY+hAxXfh8ZmCWL7cs6B38Nv6c4xS6PO7ovBwY7A28sISdExBoy0Sut+HwfFK2Y+2h1JpQuP4kxESlua1o/qOIED4622TXt/b2qGKSYUOjtjze1cDwi/Bdv3qZb6rniOMtccyoSUkj1N0C6HMSIutbzmpp8QtIK3c+fETq4MkYWawk9O5R66iPEjH4fXmhVx/gAvGQ7ublscBWqb9MntdTzH6KhibIMDVu8TUw3qA+9jYHPdbRWe1svxn7kO1EjRwKGv+QLsHfsGpiM59X1TyJwRBLXdw2wnUp22PaAgJ2SXFs8fm/QRsk3pXSas3di9s/5rhSQtolMChkvYKcH+s8/U428FnepTELys4j6z6DPifntd5+YUdRGif+Ro8ncT7qVKq06z2e0Fu3FE0qAeonLJUFyFNNVfMDuklPQCBFptbNsK9w+BGcnjSi1RUXoONNSoluDnXPDUl2a6m/WctFrVmT/JcCAYXLRXDI5AQKqtt7frcZIBmA9qEnlRt5FUbJAOE1OC4HLTHC7+ZAdhWE6fZ10lkHgc8tq7/VGaUaUyXhry5e8U5eTojS5Dtf2v4+7DFLM29ycb4XcxXN+SfLL4uuUbTqXxyPaYK6MAw5Zinx2B3nb66UaYPNqOFsMP72YluxMnvpE26xxuKZcEzmYSwvwdZrYffZ+8BStWVkuc8c3K9uWrio8/b2zjGvXUpO0Jl2VHfSKqoUcbxV3PFrtKn7giw41XTlP6TgTMv5WqLhDShoffihR0slTYlFBugnpXVDzUQYqg4RqeeCSzYNRYQoytDLFIZWIEtTsqpMOG2Ro2YvWe6L7JAvm1lR4gMyUT0gS36mDCa0EaOjZm6ROLg+cIvLfmIpl3ATyaDPPRBX6PbD9AqtGkEUctEc7dnnWrYSe5rY698mFyRHir19DZCJHAEVyeVUnzbjrjzp2AEeECOM646Xb9Z9bNbRaEJGnBGyOLtYtGgeyV1rIi5vn62liHGndLby/eJG2gR4vF7+C0N/TssTweMo+yBtqERcI2zTLQ6CIraqpDHQH8iBvbYEZbQ8EyhpuoPPK8gQbgkHLh8iUhHr1rflBCgm17/ve6BS026yvfSbp2zd0vCz6HNV5Gn+EnJ0l2FqFmNGfE/D9rri2mFhtCtzXdlxLy2/CPPu0TrrFRyZczrxRxU7Nak320WniRxY3hYnHMo0QFUqL6BW2NREwVvi7qWugifQdUaz49oYRLoJqY0V6Swgo3rbq3g0huTrWnGPRctfyqN2/CQ0p/U75D9b1XMVy6JmuVqd49tPXuL53Mbso9D8L2RzhsuEahKpEjOE0HQAvl3wqRsMQi4z0H1yH7MsC0gjo6WKmMS8tzWBzfoyzQse2Z/xz6CRDsR2E+DFeJvBp13+siFSmH44hM0ES6OYEw6lFsYATBaVMIo3mZzg+/jAufhp9+65MKyCFHTlpK/plgU4Z5Ni3VFbtHODI0pIdjSh2cv0hjOfBXUiIK0Dil8SyjEGTw/38kRljeStwaVSqHiySFrekiq5CDSafIlWMHuJgz30scG5jNBNMKhuFJAh5iqX9MSOa6CeuFFUzSf690pOl8O40sSwdipnRiiRAM7+gfUZbbec20T2AJQnFACBld9tsd0AHXBihDLnPXkU11k8PALQF3Ivkk7gJrQW6G+YTpr5PFmfQUAlFeyEd8hhiln/2smSYmNhgVjrlgQL5hh2r0QyKxoIZKLRDDBSG9uOehL0zyn9SWmxdKHWr2WmZYhJxG5j9VS4FeSNETfW4p6dKVyyuL7BX9HEKGjQFg2ZVWC2khSC6KyXFyBYKiLiqD7IhVlJxFnghO9Nyowh5ZGawevcaFGNFSvzU7GQ2/2i3aAFz6PH2R6x0Ss4syAFpZ/UqRh81wK30uDzNVXAgzbv2ZAgfchJ8ndGMcFg7RywaV0lfEbfTZZy3i/TGWFXcD1wNdWkBL+J0j4QCH5T5w8KY//U9UnAzvR+y76LImDHZw8SaqPxfJxW7WipV92+VcgAT7yTeyHL8LMzJ5R370q0x6zDvnb+guib9MCH26NXikqVZ9mOSg9CIjPnKAyEdjvpcMsvLLQ3gIRk4jS/gdDjKSlPjeNSJc/09Qr38bGjXthNdHBWj9tcN6Z/ctJM2+yFdrEOOCZeMW0sqIjb38xgIp1ytvSGTlNLp8XACCzSvmgG+vk1ZI80dQreOiMFzLIa2o7OzGaBomrad106GHMD7DxuKANIkwry/I8THfLV5zSyCrXnatUh7rBfgDfnf4iNxnGsc/Wnho+Xs6vIosRQsqWsLQZxsocXKtf0A3mR8RFhET0oaKXr1g5XWFtjkPDzNl2v83H9AIzMffdVQjeI2jtAO2rwFqmDuqy+Chas4w6WsKWWT3S/p1t7Oik8pnCBPUv9+2xm1krNicf0qsnlLAOBOAc3Yt3TtQEwmBlXf/OPWMDmDDZ+1MGud2+AW6EwvaJnL/KM7LaX30cSNsI+DbfCnIyVbyKau88U1Kzq7MNFnzSBaUSLDgfyL4gcZlMHgLjCfWXcshiKdbQ5BTI+3upMCiGh5BljdLTRbINsV9fBp+LrN7/D+5ZXQldCpNFqg+axRURDDh7EvOMydjahh0g7SBhjU4DnM8Ma2IJKCKcYjHfjbnzsBf9bAq5OL1iZlnK5qYySOhYlX5sOf9WMRkhp6uDCBA8gJ50NpoB8XwQU/NKRM1CqCg7tgdkKhNlNUa4hhzsMSMts0rkpJIXEvIKopMPHpDT/moecyLE0MJOsR3o196NcI37//YQxjuAk3cYVn61LrUUN77mVkrCUtTxCrvA+jpXuz0kL9ERuozYAPoEr2dbvPpJzmbJA0xhGq3OIPzivkyOYmjHxSylYQabcAKJT/6GyKerG/W4XqXELynz3X56dy3wvdwn0fQkKJERJitI8pArW5/f0hKRd0cpM37jtGKuyIi7twZNK8hL/vFXO7f37NXaZ50HRUFkq6zyM8RwDfcyzFuLfe3XDT7PLhmkMs/6CnriHySktVJi2OZrVs6dZS+YSqxskbOcl4cQfKhOHt5JFtZHOAqZFgm0E56kdJjZhD4iA5NgPxtDi2BKZaYOews3YrYUrFnbZ2Vj9e1ySHUweLj9Kfp+3XGP8cbbJVW5WndO16Bq7Sgvbao8i/w3yZSppqQizITRobpjVk9mj/qaUYBnNXcvk/EzEsJ/xWy1yRLFmpRMfoYuM5dJ2ug1ypwYNzMlsGq73vtOahmgzf03oOxioTGV2ROGy8n4c8uq/fSlsxJKG22mls0mw2ibl+Jw04vAiVYx49tPtihXkykIbI1gfYk3sHwENaYyQ/h5VhJK0MGiyWFE7vQm0Pf1qOO2rOdViPurmUvEURy/Su5WoBUClEAVLzQst/uidwmpvV3vJKLCJ2blfw69eY+wAIXtZsjfr7ztsoHA3KmPHa4ekLSNHg/OWVr5MR7EAnNqHlC77N+yFpkRwjTlkLITY4E5qochZFsnvOeuZxD3UuNVLmrlkMOrY9jxMJfIwslyETvMBJ3N4Yqia3uD5Cipgda4n0R6uz8q70xO0nq87amsIabh0/r1s6Amw/n8yHfflghA/wqs1frCTI0nhuF3at/50Wu4hDzEd4RCg95n5UdSuN7M0rOh9zb4R8eXPzBLVqBEhaFcjHAVIzDKVVNasCQFgZx6IkP8jEt7ZySf4vGoz8usKEqZfPKQFUzcl7GtOW0m5wSHArUSAPcg9K0GQtZA8XGk90/jc7fJvpqUHw4xv80tulZDx8HNyncGMGp1B6/VU7wTsNccB9pZajqId4xrQZKEXLrlu71LZRjrEIs8tw1y+mejkJEXBHzHlQLo3n5FxANeNoZC2SWecXrAasI3hJL9xKbv1VFTZF7CmpI95PZmyJINZHREidUdP8VOPfiICNk0DWFzBgBADrzSauHTWmDDsoOFM5u00J+rEnmybpDcNE+Tga+sXgmdPf6athyfT8HS/EfsbTTCt/E33Gz8qSVbK8RWPyBPvIZHWwNklKtDQMbOuF1RkHZ7sQ/Kb/57aWwDIixiWa7RUaSsYmAnPh3mJ6BCcAVA/hRR3S5SX5t3h4Qr7VqvdUwrH0rTK2iLTalvlqvy76B4aI/K4ZszUukQdFIciGCT+tEMrKug3gECgcR8sjKyil+gIUdopM/ea3F6Kwh5NOWByRQFteC4LeP8MjNOA/rwx1c7uipywYfs9zrojCEum6Znhfs21MeUijplV55PcMsUu9RgB/QRbRD6N7vyhPP9zFidrtyjt+Y8dk3i6uLH4IzhhiXtdR2F7CbActy9/2QkbrK427M5lCMTBfOSFGkAtLLYzzac3+468kh+tftwiIQdQoJw+l6o+UHJwRR3eaE4Lu9CHXc+5I3wFRHTNu7LKQ72ceFNVGyzeYwjGBvcp/ZnR8GGjvoi7bHHKg7/O5uRM4+/+SHbWk11u6Av1FKFkPqP/KVyRo8mWybH7VNBEamT73I2Q3ixeC6rQRS6Krqnss5+GWI/gs99bgZhWb8og4blU00gx0HgxT9DbYti6NJp5kmGu/HY27zoxB76zehWNdh+y9tnVOLABJSVP0l+C9BbJevQScXTK4LNdKm8bW3KiQVTNTExvfsVitwAup8YaT3TRTkgMH0M+HXAphxQ0mE55OoYotjZR5QLrMNZXqDpwG2QzPAObbGHWiVPdJq0r5no6SjtGs2/DobqlIN3eLFmsiLqb55lnAbgHjimgKi7LNU/qTwDxoeBim3KPmQq49KWmg8MNK8JpnHo92uTt1NglaPV+Aeglz7MnuVAF9whaHRu4Pg+Zwy6ur71AtFzA4ZJxcSTXQUK5WFOoequzgEXKrSlz4IMEjhwZRbw4IC57oW9KuLxkkwSzW2Mi1/fQsasc43KMwvgdj0uG8suChMhIHGH/zICW3Z6NvV6ICyGxQ7cOSUUXAj5Ac/0V0vLWjeVj7FGl9M2XzTsWVhiRGkI90BR5rtdxOrkuPcySEXehEkjs2kmTnxWjq9iOXT7cXiVZ8aZewE1c6OHtB81R0rH6XBBoydaKDcrM47ZDx5sUoRMFtkzegwHe8dmnSuRVWp6A/0RkreRqqkZUdoe0fV/DpnvQ44vNeLxqY3ABNeWpShDEm04ZrRz4bz7mtpWqoqoqhWTfeW2Wutx4xuaE7N/obYEikUjQ+1KOi8OjNeUxfbrmN71H4b9GtK7nM8OyOdvy3ggk9pJcNrzs2LJfQhswxtit/Gx67veEYFhfuiu/MBUQ54puiv7UyJtE2a8auPqSknR2fiQnnGEEaTkLTzLpZQXJssb4KQKylps5/zk9sibsr2zWft7/c8KCrSg8CNTuYXip4MtjWF0B8jq+CLovAd37mLmeHEJeCoAiUJys6H9Vg3QRJ0hD2Viit+58clK4p2VfScHHIhMAh6fMQnXVAYuMwg39Ap7bIZbCbMuQ7181fZkQB9CBbkGxeD++rMPusdioqWAjjIVTBYqzLf10maAcpP3tYlNoP5kui9qgG8Vf6HNJh2PGgSXATYbpYUPcKksMlBj6XXEbEH5i0YwJUdkbmlNgNYWpBpjUXb6oubwBdXayniy7XlusxHH3Vjhz/afFoxlhSuZvJP8RGLxLxJTQsgtPR58nblE0afemU1P+k7BRng8txCpbmta+ko5Ypc4FyognT1ZiBGfQEGU1EkX1IDUPulLqclqJBj113ff6oxLWsxXeXVHCDsPSKTu2tpysB4iP4JG+8GnMEcptJqQ8PvZ+oIy3sCf61j1F5n1Lmmg2ugtuTCAXtksEW3j0svk4DQSzrGa+WiburDtRujA1TQ4F6ZojAi9ydVamcbadu8OPTxRGmnt6gI9/2/zA2q0n+3hktd5Q+EiNTExtNZYNpYyloRMqvJQe5LcvBq/gNBrV00lhOHlvc3Lh8S/6ZFOEi90vlt7F3o0aC5Q5MnfBBwKAmKvnzdQ6ogtII+MD2SY8s/FtcOOBU5Ud38uBS1Bsj3CbH4E9kFRYU6iNaVkKixeO73J3CdLjVCqd5Clor4l/dtzfh8Px+JDtNOYP8m/W6VydTLDlsaOecJ3ZuSWzuzsrw9DEC13COMZ0+QsMuS0draNRBNFfFAl8fAvHNhzd/sle9XCdqG3N5SHvSOV9LnQ2o9um3vlQx7rim/5HAB4s85c9rxkKKSw94jzwic4yAJ92NY46waryfAnYHTvnpcsqhnPfiYy38ekERIIM20yICej3yqLbePEXNr6Yh5RNm55dZNtXjjJKuJC+E0IJvBHsPASnu6o/33wE/GW0Ddw+f/ncCIYxfrFoxx7obWRv5L5taCD29krPGJTMXzbJc9STdKUf8cvIuKxO/TITDS9o75UzlCU8LrpVjnYRDV1CKv2owz+WdvfHxGpU8reSy5G10hMhRAoYkRDAaalJgoEsKqmE6p4Mn4DggeR5n97+p+1jRlG0SE7JeRWDjOw/48/Ynzi4gyJBfTHJ+icjZIROGv24Ts9VWHwLaYfwjReonD3v7yk/aIVmSXCOVkQlWD1Q3lRmMW4XQLSTs6qIeyJRQuXKGyJAR71UCxAB0IRLW345VGq/GVKXo/mu5m+I0HhIgnKBh4L/7pqRkeV5R+XlBU5/tE9mley4G+kkpOf1/WpVGIKOdFPpRmBwANCscVgYfgdiIu7o6pe7/dLXPY9VxfPs/rTwIgltA6cg6xyXxYakHa+bg4wNBG1etlH450M+O7Jpfhtd99OyADpNBoqPvFHwWmv4h+gscEBPOooi5mZW84oHXvAPyPfkCq/iINldKgiKrFfaTK/PbVc73BlrquLmcdHBiiuNswISzG9Zm5BaDYe/hwlbll08XM7dXbnt0Ydl5Ihp6vytuRz/FUBEZQOmBdHKwreuhIilOTnM+ffluxbSM0qApYygLPVFxnNYkO1rN+W8QSeL+D+rAJjNzz60CMiil143zM+JsY6/5rThLBU4UTR2Ut4Mq6+AHup+UgXOpyXvPnkuP2IrOHRgx1oPWSpnJ6JMoItONDfdcFwkMfRk5ScR4GQKfKnhaOMQ+KLdEe/w05BKOsWyqxodMvcNBzPqB2XoiasqKRXvECbOkA1WbThaa6qTuweE0oaLR5EkP6TgcdC9vJjcXjWiWNJ8W1avOZc9L4uAgwsaaTEzIWBdIMc/sAeu0uqfrj4UOljpWPe/GD9+aNRmS1pLmsBIXSnjnE4ZoZWJcITxj6h40J8vwnFst0RnMzcse1algfC9cUJAYssok595PtA+WKYDYtBd1M9XMHl1xb6mAYvNgehJS0dO6vJB+hEpzO7v163A1mqwnvoaUZL+DJb1VpK7kx0T6dQNMmordYQLPWBsMMg4jMU9B7K26G5XhGKaiWucXK1xj8vub8wvUnpDUj/u94ExTYvPc96AXK3LfkIx6Eg3r8mXJPfAvmk5BEkBptSD9qdfILLVCh4D9RUFBmfBqaS0XNLvkFZp2DdW1QicjkzVT5FvdkTb73bvy1rhNYX0fLaHp15M9JQBlY13L4wH6HeJ271tWWPpcPoBm1VGK9mdfCtJRbR+N08VrUjYl4Sa7hVG4RTGOeCbiGjtUSRktygFGGhMw8sbglnGc9N99vs51VSuYB1ouubS1om51fnohMXrCSIkJXjShBXc+Gz84UtP7Fef8WZ00rl1V43L7JGZ89wrPwvy4WypBdvSvnQ5jqzTeFxjzpeAIgbdoouz0PjeMxcG1Bhri2nGb50C01u5D1XZfmxA9Wgdsq3xcD7oRFGQKeZfk9jElCDGIPOX21WuG5m+qT8b6wOcmzrGsETSbeesriSkuUBpVB09THi35NVBM6Z+lzQHRfQXPwHgaVcMYzbmFBIZDSO3QsnIVJEuSJ6SRE42hCyXuD3gS92Z5PHIDzoN2ehgKxF3SAoZE6ZoZiXMvpVUx2ZjYj7WcR07S1IUZuw2YfomH8axHw/asphT9tCgUQ3UnrFqqMnvw/3bkd2RtsBSsDz/G+VqboHmkDvzWZTlgHXmsfL2fODRvPtqzRoI4+aaKaObT16C8YVDYVDNHJVTvs+AoWruN95heE6xGQvrLmOWKR46AMbUDTz0jDUuYulMAjiWgmgCOIzCLhdPjt6mtzN77MeyOmPLzmQa0kOVsQGcp/lP9HNOfFEWFRJtwWIplagjqZ3LsSpml8IfXaq9j7PnVGQrMo5SvPeX3vuagdU7pTRhEiiz3rQ9rKT86Q3s62qh2Tk2ZseKainXv1fE9w5ml+lrltAlGp4rUMbCmK7Gnd884p1EmPmupRFx7fo0nWcdNqKX4kYOKZb1eMPwcBXwWusQ4DBdG7RCf42o6UC6ndcg8oIp6bJlCKmbxQrOn8/xCUveyI93RIqLutouD/A5hGUvmhtiCBR2aGZHoJgMzlPq49/PHI9wF98SHc64aPqp5/shDet3SLVXUe5tVHyLhnFUzOVCGHk5TEQ7V9ErL9YLSCQGCTG9p9dNJiCQ7kLuNGQWefrUdGufmUmwhbSlM3twUa8G9G1epBj+XABF0XpzLefdw3TMWOpLNA7zfeyB2AC0e/uWVR2RxtOQQINM04ttCQ0aj1LwG7kVu0u+Xofi+OLo/1Qo4bgTrSQfJ7NDMRDKvheQbj+khsS1bZeznWyF5qNTsXWd6oseGIGrU6oYe4hxOCyYBzH+1E0MYe/Gf9ph0iw0JxWnP/UbTjLaJzrzZy6qLp0I3j8KLW+HH2aCQIn9mwvwqe+PMSd+7hIbuIaZDQIG/cIv3uulyF+QDvjSAyWxa296LULmJ3jzFJ+M34jRMVlYhHc9OUwJxynZzkKfXRqIjr7pKcICn1hfT0mdBzbjtNKadS+RR9hm2vIewVrV4zIGpksGinH5yHYOTq2qeL+CROSPc+MrX6BTugg7Hjj1VK6uxSQqvNa1eohngBBliybnAMySseMpra4uV2m8k1o9tOr+Q4vCIALS8S5+gzK7yU1aLmOP05QdEJaN+vB62fKp6nSGvBj+w5a4dhbftRde63/jbVnrOM7rH5BI4MsAk2BBtCkbDU56hCHNOWxi1Wo2z8Cu/YKsQ6PxyrahH0fFSjoXjLEO12FEnz786J8fmYLKkUzvWIZKp1dPvzxstAp4xWv4ge1cK5/UGVkXUldmoczS9rjxLB1r2BQCrusC8QUoalh33rHJgmSU9rYz8Ke/MVGetyoDtgKrdkt+ZwG7eza4zihi6dR0FhzreKcyvR8au+I78PzQQl9CttnMa+m921mwb85sF1UFK86eaWkjJNDFI5WmnNbvZG+nJd6f/WamjIGwBgTt3bgumRdKxiPj4RQwyh8i8xU47i/j9DABkjGj+lmVhOVJ4FaQls9Tk0VppR95qe2oZCVC2DAIs9lTIeHsaM4HQxvpwniVpxxNS6IKg5zIVseN2lwsoV9DZikTW1pyMVGbsfQ/zqanbzos/6ueFj6wF9JKsQw3NS8rBCTBbZrenMV/min8hvQpJVYrkr9P10JC/4cysFcmk1LD17kw33s4F17t84hyHAvPH/fTHd9xNSFvi7E2j3OuV/TPeywgnmVj1zAhg/aTuO1lVPid+jjbAbqz6n4f5MD+lGziRZAKxa4YcDef3Bp9EZ0ZOdyhFOfSiMRt6+VdiAjnxuoI+voPhbGIJeCvSf6ucyFuURHyvdT4qov6Ui1hjLmHVwqEby/rEjvYDcrrYbMpor6uYYsG0aR76kImEtZ0idxx6Ii0DgPlumW2op3B+P0G7H8VyBPzezijy4d/E9Hszh/D4XbUT45UXacG/CtaBKUGEFujo02iRMsDnDvj1XRlL9/C1+5Ijcpi07RISmEI3/B6G6+n0B9SgLn5RuYbyYoOyhmXU60TjWqncW9ZQ/DXtpPu2V90+AkWbsqxyvbKA6pnLOpymarAwO01h3lHiEzjJWD/1SXKheVKO91AD2s/WmN9TcxK9LUURTpX0QDpTRlEql++N2cAb4BY8oEMhQFuqe+PwWDLVOLg5XhCvrO5r9Budu3NLV7KD7YnQeYoqT30gFDMVOzdJSwXxTK8UIaW55mDoJ7VraJuiRaf4XfV7G814kQHdz4ELwT9YgAH4i7bMb+4P926nri6Ms1wL8UGUfU7Ig0HypmEi9+nIe7jg0RDuCOw9ob79UfEhAi3UcnrlrOeq7yUtSCDKvCdNxO6vTBtIa+C1FAt6Pk9b+yg/3I0osyq0BRO0L36xVvoe412NbVvy4EcMlD9bYshdNVH93ekW/4Y8Nbwn9yM3nDWLO7j700HgqiA1DPRObsfjf7OWkfk78hjacszlrB6GKFb/hhPBuHQLwa1gWSJObSz7B0gh0+ltV7XzK4lEM6+mOsGh+Km9o07juCJ173vQcpUTBgtNMTMo9Wl9iVUPN6Sk0UKGTkOxe5slMFMl0TcZiv5Rzbh08q1l6y8YpiIjpjJ5oz3ak4TzQERw1G1jOAx2h1gtFlRdbey2Dd6ZPypDP7z9auYif2TFS8TSUnZhKGn/BZDL5MLoM6GyrrgU2e0Y6Eh3x1FSaMIfT8W3j3khosuOThQYtmUgn4rDs24N/k7napMvzQaN5dydH8BmEXaPLSe+TnC1nwEwLwcEEgva9hIEF5H+FvZUb4jxRHy6ZQIOvtSofKCbCF/yAZz7rVmwwxEg71oLsd+2sehGgOx3DbysbhlbqqMMCQngTtEKEy4CeCvliToohLjVFzi/766EZ7G6UMgDewEQfir7qHiBfRtpvaJw1BhHeOdzut01WQcrE11GS1B0dyD4Ffp1P2RPjhmk16Mkm/j5pm+XKib9Mb3RmcQj8dXRFjK7Mb9VW58CIDl7wC/A0mNfDZ9iMAj2Xy7vt7fI0zaDM7sGg3Mum3rQg9Ar9HRLR6fy5rnJ48NZhn1FGWkQeksLa9plla76goArJkJYZrSxUV+GXr5M/XbPmhkX/xbJDd6dxS+hKdEezfg7YjCOw8pAdmAMsOLzj31KMmRJnftScO1o0EmCP1MYTm1BfvbU3qkCsP/ljnksMukzuxp7t9Oq8G7jXyDhkyNKS/PifS1ZPWxU4cgCUDLZVkr4oGXzSNNnEFkTKIi8N3kvsb/KwMmfznfpht1kL2SBgPmk0GEmac/ggIilDBXeevOWF3lWS+WaKvnLCB/ykz6KIXetOfWqr9I+7JhifP/72bn9XdjIWmBc5Ba9qyDE7lyNT+Sxfni55yoXAZby45MZRJNcCnjDkHfIZ5tJK7izH+OYCPBjnNr8R1q4iqfOgbx3OaIGbFw1YWGRcR0NxACNN2L8sI3AENn0q75HJN/WBvRpODQCfE2w1QtUkjDLt1IpW4k50eHtGYAyLHgEk3bjEIMmIgJbDXz6r2p07F0SFD0yvdP0EKG41vPPIvUjeiLZwcxxKIHMIZBOYdcRmWyhi7Zo0TuGsQY59HpPnCgExDgIvJj4XxVNXObr+h2rRE47XnwXanUtbSxtVNZl4GPCyNExFMt/YW0hmJkGL6bdZVU3bzEq95khMfY56g0WdG+W334zw9GGkPB4BVgBkr9woPFqtrN9uT/B2ZXEcFN6sn/+/TIvpd+Arm8NBghyQDmm+6IWhInlNrFvV2DvgS5wWIBfqEp88c1OP23CXcnhQD/Y6aRQo82UPrpymhCu5aDAVOBbR+/zJUlhFSozMLPVP5W8K062F7pVjRv/qa7nVbL8a6iisTR+iMPuDqoivjPUj3zQ9vVO65xnxv9v+BCVEK7cp6DB1PC8rdis6dxxoQRFKuyEx8Qf44LXNfmnuBYtpOOA+ZNlGD21e8Kde3Bx20HY9FxjYRD8e+aFuRoTGdpPw42p5EW6MZ/Wo0HM/iPA37321zFVGs/t1CL8+/zcM4wzCxDDvUz0069fWC+MHk+oIFZ4eo3HcTM2A4YPQPHcPD9dAI9WxKJf1SVqhbo/e1Jl4u0ec+yyIH0RC2HO19eflr1QiZ79hvGElcXGrobYJ11ffKN+tQGkwtWn9qll4TZyYQRFaxzFnz0T2jKZ81Vn2UkC5A1m62ft5pUfKG/VSgRdozAoy0ToDtKZwLmdjoTGVBb4k9Jha2fXv+YRANl9yAZVrmR9VCDCDqoJVxTLH9vMI2uK/qgneSfvS/u0v6L8wNe8/Nw2cDmOUzPzoX8QjtYqy5AaB4dOHT1YfZE4Cw4mjBCsl9kuEHjv9xUChX7mGSHjY1hNGjLdRELrs3R6io2MaEJRFy4SdSxyfo/GQXUtzQqmDv3SoOmny8XWoi8gISWINPTEjn+Xclj7luqKuZIL62gay94Ij81ALdsewITxQ1/2i0yB8OfaN86HLTQ1WjSmX8NHX6EmCC8unEdIbri7WveMlm4OhYIMI49YdwvET8yO3uvM+URH+Zd2cdo/XP4cV9A+NfOTrsKBJQPy3N9OqEb7FxMq5Ma4rZt5el5qloh9HWh7HTquRlPs8QMfr7tnRlGP4BN4tVF0GHuNqcFnakIdyieQJntz3s9AXJNCSCe2tM/Q24Nx+j/LXUaoT6OxtyMF8PNvzzf7Gpe7HiUDP0npyLY0nGgLfhTW4XQSe8OI76r/sp+DPbZN4Isp6VJlqr84ojLw2b84ljvFLNVDvUALAVLQq2N/8dQoldxfkOjxRkjvOqig6kN/5aOOM2sxNznjQholo6Ks/cPhPEJcrJiKQx88XAdhqy5TD084Mx+Ku0ZWH2QCKRcI22VxANzat01bgnCQfsT7c8PVZOBDE373EKhp6CwJ3RZVSHoeJJnxT6/3XuNVmbKLmyXBYRNhyinKvpW5muFGa5zL0vr72h9YrYE43ZKtJBOg3Nle0m3eXVsZnduAhw5/pL3HwAwIPNCYta0BUzsuTFeowz4oJ+50kOxJ4cRQewVmXjC9Kowm1VfR7pNBPQN4xRxizbD/PgKe1g3nWq7iak+T6L4JfPSmgU7fJQxMukSXt5wOznYHUQXnd4zVb0krRuno0gtfreD14FYiEwyXy1SmZq//4RFzxgE11+v+bVosEskADGFOl8PsKVigEgJ/t3QN4iQDqdQbn3pdlnMy5MAepcRxOTpQ/pCvLpT1FI2mjOh+ssW2sKDtAo/n9DzTmfdf9GPoYAu1hx1bpWk91PJUMLCJN3uwNYDtK8lgI03Oq9haSPX5QVPH+/WzWUMGDXao+dBoaDcqd9AlPfxKC9JQdbwrXTeKWyKWZzH8o90hOl0LGmGEG6NjXiLmYLqvjHWErLxrkeyVS/wX5ilQJbPHUYJFk/YrzNwIqkjFH25z98RzEALJUauMrSBoF6WSn8+BPD98KxtqRhDkR+hBwpI/iguGMAaMn0A51TBhkpgy8P+oOi9wf8TictXewMn5M6/57lFXk9yFeGEPZ/Uc65W9tRIqIe1bpOTWp7P9/p7f54XpN3SH47aaYZRIqOmoXEvcl00X4GNaCadrk42HE8oUKJJQ1yITle/LHOY9qhg9cdzhjiksgkXljiUjPxWV4iFmh+qZnikxlsxqwFuLVTlSQ57jQjvDz2vx4FDg6cHSa69SILSkyxha9zJzWSUvpt1E33cg9XlivHvZRUJlC/2UFwRqrodAbvlRDB8CvruguQH68M/35DDlbAF6U2FVg6ttu+OeNb5JySYcxJsEpFEbqTjykwjBKF6t6vTC75Q/3RLPfw48dUbgLtLqJURgtJwoKrpfkEjOY5akzsE+HSb9halN/QGyVzHUeA5/F7mp9Xs7kk3l1W5qmTmWXI9zeoL+TwwAK4ixqicjIJ6BLyIimFK/J8GLjf+z8fSTsK7ZMUxCLZyo0epc0juWkJBzxZW1gFYtkevzAiyVPtkzV1hAqxIp8ynLPBJnRh4nbtqV02dJiqxLoPql9ckBdxc+AoQV0Sa9p0OTcSoYT0V2CznXTO/Bp+NbkxpeGG4oyuhuPjC1WbyU2Q5173GKfTLaSKMUBZnkZeGxqTvXLM/y97LoKS9SRbVOVn4S7NIiKSauOdfGt9HTICKW4Q0PvBf54ytKsHtz5zH7Y2eSWXFrtEsTJt3n5Q1RB22fEv0LiGK058eW+hq4nlpWKsD7e5gsV+2NbGKoJY8U4eKKxyI3Ldkxh23HrNLd57gJ9LWjBKNn+15WA3lbvc/rN1RzoG/x3bWCZNWQdn51T6WOqsn/32aH1eEfIOSAfkOQsFzULhJC4gcLExU2HBXt1//OT00xW1GWSDO/wHCFfyoB911h02OUPVt43DuOiBBp2by3B3s0lApk8DAUhiyDT3HqW6J//Dih6bS2t+s/ASdzg+aHGLSJ+v0+oaF1mToGhPqg/92/PPpCxGjuRS99lC7wGBFxhbDIHKTAWpxEpLQ/dIyARBmCAHlhI/YZC/6WYKU2PGnXbZc/IJVccPl/V/RLTaqnlW/vmQ8vBnlA9OLRZsRfQSBNwuf0qgQtiFjyZYzYPqTontIZP/rO/Q6kTzQNSThoKQjc8FJmq9IkNa3zPjTfMvBujncRW21hOFokpRXu9uoOqgsAhSwF8vzNLVZ1MT2mGCAVjThtFp8Z8wb9j2sSHU5SeKxyv5xgGVzNLmrcE3bmMYmajT8hjU53WemNtv1uDEwAksfY0ecmBlehv2IYP1PR0Wo5qf9I/K09TFRlfEPFqRm5kAXtxmobbvR95E8bzU+xbsbPNYXZkU8NZXfR2zf4De48+pmsl0YDnm82z6PWIL0v2ww0lmGjx6HAEuwnOrTE88KvSnubePGOfuTDRwq/rCsyVB86kSaZ8DCBDE8jQz1jQtBFL96BhVTbA17+y607MU4EawS2xfyEiRSxfo8BZ6BO/FSiRUjn/Hw2u1hcb5vpr1/i0zS5xtdVar2L6p19tCGnw5DkL4g2QrzBJhfI+SISp5uN32gB5J25KP0hs11/DzoTvglg2nW8TXxwGN2VA+6wy4qXlm5yxSoXW0LDHLMvJMeEmuBVFxLSZLbjwJw9nGHRBAV6NMpJNP8Su27jGgbJVW2fLfCtgg0X6zkegwAEZFcv+xBj8+oxTxw9yzSOIpxMlfx2L6KaPS6v09RL5rtUCviY7UAo+/twSaln9xd067GMs7QG+cXbqK4UpjmDZrlgGSOwtsoVkQvJoSIX17i8G/AMQgSO4+b6eBei6fskZrrMrN6AEoxf40Bm5Rt3exF4w9hsM7CceunoXpNhV9W3YxTFAaUbNkwTmapuSwU1IFYSBfdIW9hnbu5Gx+Gp71UPrQGfRJstZNnVM3pqzqvd+Ryt6FEJlYtTe0JPB4eJtHn/TaSGlxBw6ofltszWKdFQfdWN2hnI3wG+ux6sH8K92W+TPgfsVghawohSu/SAxzI7ZmzCC7CWYSxuEBQP2dLHlWt2VAInU+a2W6kO2MxFr6yznvRYhGJT2JFhyT7+yOlCIhBCfADmJkPlmY0F9Ob4X6vS802UE3kfRi+Qjj436XBp4VCqHzXE9h68GwCNaavn3CMVW7/XVRjYlRm9zAc0GCLd+XoA3tbng4TZOkBvKxFLyCxGxkrKHRUPoIE2O5M2Pi13Oa33tXL9fUATEKIuX6CCkQ/2fMFsxdC63vGizWIKuUxB8+4KbQxOKWiJqkEPf3YzDewGee8/w2gIiKHxtTCD0fS9Ye9JhWcXEVI0fqAZOV5LsiKc6LIrYa5F/92ciHAjrAykSEyHLXA/DuGfTWd1oewod+7H0x8JRBD+UuUed640r4fb5WAncWUydDrG9WU3kIegk1duOUKtki05l1HQGTCwhQmd5nk6ENMpbdWYoc0/CFo7Bpv+QPPk3dTPvW8IAXcqSKv+XRqJx5DiKCldUB5DUS6GnJ0h+uu4uRvNf5IYlNJNrZoYwfvLx/s+ZKjVWX37EM+OmcmKU3Gbf755s8uz1kHf9IJjlK+RwwBWJzpGSteiSUfl7QHVl91wspTLpdwrYXw+YauYotarqKwc02SRoLgiG4TKoRRKL92d7GgtSpZyR8AQM13cLAH+iVlpnG4zGeGUjE8HKMO5RgKNBAJHsZRoVy82nCFUDzae0X6QcLDdeAaNHE4KdpEgQLIMeQW8X17+R++wSC8PHW4LgXLBIyYJS6594AAIgoA7ZMuEBNLzIZ88rSq55m79xhDyXzah9E92H2OoPs3j7Yr6WALXEjZ7rlObSUYkhbaVfUu/MuRrRn0wdxmy/uKYEINjrmCOmOOGnxEtJqwkVeZA0RbYbAJ/tjPDqt54twyvXe2o92Hqb1RY22D4qoPa+3bTctsZY9FNEguyUso6GGcyJ1hK/3LKdBDf8wLzEkxDDFI6pOD4yp9Rfpsh8LVD0MAsJ3uX3OhzieDkdL4wLCjH+/nc5oxDAujH0bVn0GAGhEH7lP2ZEcV6VEXpShfWgHjyIzrB82elNz9BRX0Xz84Wa6KOkUcYTzzE2MP/Q/V83WFLuWs2hy2LCLzSs3W0vJjb/7cXJFVx7pzmTh9MRbbRQ0AuWoJLX0oTtAUHtArQC6RNqvzyDJNODkeKTinvxc+wVdwNP3jZkCt6xj/vIjr6v/lU4uvvNcDbrC+omxKyLZwwbBYofwJpO33OEzAFpC6ZzpwDWnPIPCzGCVQaYQ/TepLCqt7TxAbw8AWYJd4vFvKLMPlpbXnUxPMOJvrby3uJT0lAk0bPwT+7IcE6uyHFFl7pEFucjOxF51EZGw16mDd73RKN95uue5JKm4pG7i4h/tT4medljvBpiI0DEHJpIzKW6oh83OElSq4Z1Z+0i4FmYMWtE6hq4GgiHUTQajV0EkRsHidwKAYR3LIFNCfM6LIs5SLhGDpXg1VCX7kJDonIG5CxEc7UiD8jEv8Stq9J0sXEEZLJi7+tWBiJ3wvEgQR3lLKQGPranzJbKbd/WH3Wjl73fGpSskG6z5klPZ8eQvHhWPrpCH4wFxKIniBZ5Mj6d1q9qp5ozLCHBah+7FKGLcULVLxRqXcyrfImtH8b8B+8g9wpRuA6Vdd+vcAnXKQnVjnl4Pvyao3E7dgeNuuCYRYrTAmar0xaoZMU3IUfeVKxDf/Drym4lwxEbX2uytcDdr3KuDYA68vhQgqDeAwaQzA0BVkUhMasSvuQ7sHGTwY8nyyebn/CkDQ8sMjyLWF2n7+jqABIKWAo14OcZX3AN2zLUh5RwdlNFC2/GX9INzWjzg2J4ZZ/wzO6w5c/qYXFbgdr6pF47/LzUN3DtC3crV2SIiPq4qY7kl/JZVHUPnbVEOrlteYNjzdHOxwQsW3B3m49X9sz3nkD99x0DDD9S15l/qg4b0olcCOHCGLIV5R1WN22Sub71NNdENmpkoGhlnbixZbl6+BRHOElTPrBConjFCHufoBN1XS8waRMHrg1vndh78bThftEZ/Bv1fw7QI2vjaACq/1YT/Ubv5vLUu0hDtYXxL2FkNmBM7+0ME/nR9VnOavlW+ZgqhLThhGchTrV34CMmDJqlkzQYS5mfxVYOuOFoTMywP8ExXAl+nbvPVUd062clIIInP2EZq2ojHuiTVxY+yrf7IMaF4YoJEN6mabr9XAqrEUE7XcZ52qpnyuWGIpc+9E69ik81EMaZKcwqWkbdXfxs9Vzwv3DCP8lFd580WV3ETzf0pErDwYhgBWodvlDvOeSmAnB+CPk1/fR48l9jFd1Wk6m3d+9Kjmo0gsUgR8Z/7JkFkREGft2oKuZcpvaP6CDZR9q2cWreQdTMR6BQFk8inKeXxB2APsprjv5rfL6BthH6hUxtNuYOdmI6NYo47lkOQXjMwbdOmXrasVHZJbW2J1QXqrwF6RwQhIY2sFnhSMXmzedJahdKxhD9CctCHq2hZ7h+RGrhT11yePkl7Dgv6k+NlzDfeWA7fipS++7UIa9j34YbYVvOcJc6Kc6f3efXh5FJiW+nZrGMJ0Kw4sIMCX3gLbopa1RMYGdQM8TbHEkQNYEgNKBniNFM3LxgcWARORdcqIQszGMLDJnkA2VGpeuGmukmaBEeQ8Q9LSzcEtsEmGKanH2124/M9t5B8ON8ZQoG6CwJkbT0FnwJad06+VF4/CYJZHVUZQc+gzv2nfLNw0wDhJVnVhGgN2zyZUMWYudVDj+f6RfxkwsdVsVldODabRH2nJD+VSyg5iAI5tZDT3p6rektyf9HBUk9O8JOIcjXCCw4zcL8bfS4cVjv9jpRf5tcWPvi7rX2aLOYrb6AEt+GQn9LPZdCops1eXXbbcWTmmuORFqLdRZKA6x99VyDUBEifC7AJPO5jqnZ21Pe3rWPM9RoulfAxGva8PFRv4gTq1/MlZU+WZiUZeg5ESsMkIvnI6z8pj55Mr2zob0XIefPQxHdawIl4f3qt1GGSnOh06vqVMxX9h8k/q/o9csvYr1kE6Wiz6J+qKcPmHpW5vZqpPeVWkXklKYqi2DnPSoVztQWyBr4Lcu3cg5adcy0ZyGoG4OB18IuXDgVUS6FtB8B7NYoAzKm92MGzeRPoVlvGWIAOwVSNdw8lCGK1U2q7eAH25hAtZoWKq/JyiKmld/jM3XUoYDsW3IbGNR4XDS//bJQB54k0VNIjNSu94D9RFI5YVHBCqt60FOkpicCvJEFyS+UHSQ3yOQPSdPhwI9sw3VuGFhllhmOq2EXyH/DyzQUdSoT0cEnTMCX08pVg1HGK2ZLq3lkHfB1kSDjQfKmC1BYpSbGGJIA+YWMAEe+rtajhWlRkq+GxeiAM+Gz1KKBSp9y4+FniWaGpOlgQROGSxiNsp5r0zZsL/TEwgfihIYBySvp/27HW4pdpcyiwyr4R1MyzIHadNfzF2xtb2e9mZYPyUPfEROS0RF1DpFspDYMaEYWN55yIDnxyjYaokMp9/G9u1YGkeKx/24VicQbBmMhTgnPfYP6fRD+jz+OBCw9xjerUIKNo0BUaGeqr1tsc3nDImnlUqQCm30kBL78vuwCarFSyU3g/Uo9+jHMSmJ8bk2AQ2/K/A21RTE70Bp+fYJkAwvBZMpqE7w/Ih41aFhuiAJ9tzqXLvu5RuJmeizwEy77qIWcgFR3ZN2zwmkE5hE0mxHptv+FytYpopmC7m5FZuv1Vip1rKy1miyblSgLj2pV2zo1Eftrorq6Ct3g0gio1VKPBQ5yggrrMquCfi751R75mbMtNflzu2xy2xF052iTotEJZtojFh+zqaoLah5ANsVPYYa2szZjk1A2l1/RT1VGL8w6yiugQsk5KNyNzUMVEiM3cC+wqtD7sqGJ4v5S1kZ6WZYJHl+CVVPGARe6HPebYCT1lJ7EB+JjS8Vap6dmTRZNImrvoQHBfVfj93Y7rcVg6atFQ4XFtryzCOpp/IRs/gumDnaCx4X53pKuJz/1EYTrw9sIS5BNkRTAageZxhvN2q09/h58zRtBeS8hhiy8h2YGUSToWvNAgA3j3/QTOfzkRkYtQtb/clJ8VQ+AvT2cYpcg+NUsqKlOIOfwe1lp7zyLnk6F8IrivgnqlgDPxLwpfyS9M/r1pCHiKKf+EdQdX7+/ra8B2uag4TasRAnOPOwYYXwjrgmc1HersN4EawfGD1/Vj11cCLt7ERqpS84bl6yYZkgeg9u24mqqxl/iME4hWEwWO+cBZEp4kZRQa/3iKpBq4Ovno/WQ7MZotm1mlRi7hqB9LN3A1iHkTqAmwM2VzdQsn4tz5fnGg7FTkWM6itKS55xPPdH2XtqS4V3Jr/CXjsNIITe7EhislTJrBxyQMc4Gx2qsBstGb0oUMxTW5MKyhbF768VssMksJ6qiiWDN02QB33bI8/QxY+lKtHXIacjrI+s3vcSuwh6d7DqedC29kB6WGoJ7asiAnLINJ2sDzsHWuZfV6qOQhsXT+oj4hsNOEgqWkDgCVk3sLPSIWcWe4q1OpvNvcQPHjI0HbuoLBouv/t1iXKXyBN7leEw+eilNuwblpa5hv4CCJyTXg2b6rODvZ5kJ0J7tjIj2QKgS8ftKb7ACYIvib+G9jDCeiYy2EnGRyNAzTWLRrdTE/iyU5eNRkUIzkPg92YkaGAKJK1nxlUDZYH2ukc2mOEWPM9foodkeJuz+NNePy5Z3VtN/TLTtNQXsTHyfXvuW7vZS/icebQByacSFzPP2o9rwod1bIZaRZMlOU+1UcXHQMJjVzdYQAYIJdiI4OjsHtoBWoaVpwaPILRRNgUruVE1d7M19FP+TrwR15LhaheH+F+yuSHR+90nqUE0+YC15cxP86gzxPpwKaPCD/9/Iy/cd0ISv4l+jVCP+CgaJoazCEpipg46c0RxAhz6d8Ybj5oWj1t8UxA7qh7FdTaSbYwii/IzLfMZPwgwM0fdPs6aDMjr8ph905Fb7235BnogK1QCxY2UA9lV0hBYOmJH/gZX8okPNpu5GIEpbv2d0zPh3JoArY7MPD3BlD24ky7IF/PvAJmPAT5S84apvB6k02TkuFYuhT4cIHucRkqZYgDiWaI2Ao7mLIg2zTAkudn3J6gEpXP3V/qym9MiskQQfPgTiEELx5q2TaRaG1kTIKZ7IZMzC8fhYkY5BJeKFDqcDRH2Ob+hpO1Fa3HAhxADD3EJJUlMn8AGoXlTD8BPzbAGrgY3+3I9dWOeTroGt8T/T9qrmndj2y0KxI5tnaimRbmP0PkihvcOs9U1vDkYhhYV4+51Mz7xWEiua5xocGwsUTNBeV8b+USo/VUPv+kmOc6V179qHN4WJi1GidI6TNaugU+3tASGehdJPqv2iYub1VAjRkZOfMHj3XJ4fKNhASz5jOYwPt2+0Wt+4uAPt5PXrZTpoBqJrZceRQ0OUavQ1WakeIObWfudBIjVGM94dknKWfXTzavbF+6zbKwvecDlRI9X02f/UhdSfemaJHYGQOSs/wqoVz9n7+dQK+tED78panNRWfy5eK9rYimUQe7wYpfhiqjjvqBzAZ+fzn8dokV4Z9KHPHPvnyXg24KVu5YIIWbLsUV15s7PU25avi5poV3yCXO31Sc4jsJLxUYdVAnlS5gBGUXKxRwgZSLmX6UpkFuRScLk9Kk5YhCKYXJ82EUHBJjFzkm3L4L3kF+prCJjzI8KgT634vWUxPbty7nirGosBKXILy1GzvGkk1Cf0bNo3hAENL3M9zn4HBHpppIiy0ofoeKoKiOYH82AghVJ56c7ErB6MKlppyHNgJ8LL2w+QioLTtfjaXYckBCbQhd3nn5IfnZpV4ghbJuefUA+IbszKb09dIncGKycJHb8JHRJBsvQ9fggh6F8IbFnmUe8ZAUNtoN/jm/QbyiM/LYP1/Sef5gyJexV4geAN4GjuHeH4fRCutt5q+/sLKv1pjdPivIuLadSUD2ZM/0A2bDySE1L9nZiV80c3JLHohiw/bg3s8d/YXuXp3WYlM2cEWJ+HYoCB0YZdy1rr89TL26Z1I2LvcEX0Dl+5TlG9iuIOQhMfeztWivjnRXWgiszoDF4gbLMpnL5UAhUP9h4yazr91ILa9kHjOTWdz8A7grJCltcQCJVKhmJ1dDkieuni6L9BmsP+bE/ZLFemuG5aOYaKxWe/PQI3latTdVEgyGwJfLXAqbIhAEIF1PG/p43W5Qmh6DoHSYvRWzJTGTEDxp6/D4Yh/MKuyZGQk6yriGKxxGsq0/xdNylhDqNwepjGwexly1M+K39sk+n8EsE5aFGwteY3/5dFpg+LwQcwnZqvzuZ3BbMTwWLQaNFzxe7JxuLmzgdcefO3hbhI0Nj7TfnLCJyRhH8a7Vf21UOs/hANH2XdaHGLe9ISeHg8sNMsj+DJ+pVPUgDK9n9FiBLjRGAfWiTX+YOyqAU9sJ1/YRUWHigu/JgWtePd6dUwPw5NjKP72mQGFN8sBWV2j88mNNjtMoWrZp2yLcdnO85U8Ja4yyUGchYDb0qFt/i2sJoB567cAFvGLNBR3oiLKNFy0fPcr+A1aJT/XqgtUhoP4VwQgt79+dd7BZ17xnVJ8bYO/t4ZCrIG7HKjhzhqabaiuds65lmb7O9Cso1k9bG1PH71uczSTLAI92T8F9zSwA6Hk0aEsgrFBLHuCKtHBRsu9SsydrA99Rh5Bbe9cyWj66AZQD4dDPNY4/9hFncrqFgz+rJdtjAyTN2cnWr33JG2V1UmqQTech+uVgJNIunRgIUe26+vsbjiyghkFDfDTReCZnMoPR6iOES8Mm96TVxetSzc1hYCnVMihOW55sKXdnfq/7kza67BawTLg7WPaVj6Nkkx3x0G02i+tavubzit/u+60jTLUpH/K7qLJ1Yna6PZWCCqY6HBrlx7+TEeIVWEGT0UXgnwL0WjI5tZeZIhK3upqserqSVXUo8I/1JpBIA8ywaEB0YLheFP4BfXVZm1n10lWaFUWslmlICiTQ5HXALVwD+5nQPYaDV88WomBrUlvIFVP2sDJjHLcxozv+lIddOxrH1IjmTsqtGxQQwoFbkm+f/EEkn4gun94sGU1yTeACRpAnkODOtIlJi+SXAeOXBDmdP7QVosL8g/9N3yW54gqEQwfnCTqJjhn7JphDW9onG8F4a4Oq9I+FA/V2tNiVypceoTuaTmN0/ZQiZvLUSX65DYMzaLh1ykTnWRwRSjqXX4VRqiXhR/zkqJdh3oHZj+YmlsJ8AO+/tO5+CpMGwZnRjoN0HKZjXtyu+t3sBQgwaP+bxK7qRW0KbcHkNCIGjvzfXBcjjD2DETQXVhpya9ntnv4Vcm9+wviuMvzDyQmp4YSe4citRz2URJb+cfsh+Dz6KVFk01S+EXiEUZJU1eXLuakXrQYnM2Z+N+hW+28231adyZPHM1G/IIDHmN/9u24z4BBV168ITlPvRuTuMfp7JSPcNlgV3y/P6L4l+nQQj9raAsoaTTTZKrsm1H+DryBKfX6MNE1jmzdyPR1/d9Ladf41cnhIihdmiBo9tSxR3jhjjVF1p2hrOJVEypLuAi1Bf1uXasJ0ia0uazKRGzYDs8dcHIKgev9UP8X684cGlT6JWjCxcJBIc+bxrjwzHX0vEmmyhiP+S5+IOjM5zWAxECmBBH2GyUJtAg8N9gQqR76rWSmevH0d69y9x1rav4VkRtFhBwpSQ9LkZit6wx0gNte6XprBZjiGvQ0eV7qdvVB53lDtp4L/Q7p9ix83EieA1lpCGoU+2YhG94XrpRm5NpTbPnyCO4TUlIngBaayBfPIV1pzUGB7BnEJzTmBwakoZcIc429NyC+6QWjfeCrkKUw79QvfzMuSyaksFBBK78ZvpHs5BSHiI8Adzf/4smpao6Bbudm+yLjrW7X/ROvK9P19xr+sBy6DrIdyMCSgiRQDRQMwYkrcc6oYGAvdE27a9OGFXmbo1nySJUAfMArWpVps/GJYznEiOR5/BuYIWNtHUHu8VuaeOidYSafkSr0MpAAkMRBuyWvpGI2kzZAp8nX0G/+VQfcJD7+8AKwdb/ozEqdd2+/ZPz9oLG70lBZQ0ayHpMckBMrl3xxo96OlqEoI0+4iH4dnrr+rch6apZ6Dff8j1EfsoU465EeZ2kocVpVjuuLjFWQUBvb2YT+3Ou53QEONu/EymXTzgrVE4SO47Uh9eTD3A+q802Io/YDShBQsbdyMC7xHBMQK1wccRgZ2miUsiXmDhhlbMPyv362fSL3KNf5SXae5tYq6238SSq/ASfc5dTctTeT1uyXwOw1bCKT2BcjTbAclzNXop51eOAmAZESmLlmKu88u4xkv48hHbDtP/h6kCWdgRgPKvv63FhLrWUwdGoxIHzb+AXSI4sE3Jp4ovPn9atwkl8R5Ki2274T9YMLBByoTIZv5ZT5xLEyytHtUu13Mha3da6B1RhERtoPgJuhykLqB1IncGyc53tDzlmb3AdEypYKp76ECVy3jl9nv8Y7etx6hhdBoY/eZNeSeMvHAcWVaBAq2W+5izx67P/TW2IszSv9uOnEWeTWJ6IzRLoFMb3ewkZFHG9qJ66dZNncYijnSIcXJPX4uU7W+6wkShXNHCbWqWYMBlEbjSxaabhM4dWNbV+6slPumFZXsM0iH0fHedxhmIY08DVowkGfYrdWr1bZ7tRYx4AFNENrX2unGCTNzL2btBqnbUfulfGhm5H/DDCrPqUO5HcMvskmps8IhSmD83Mg7VaD2thc3UmyMqGSwYAvXOVsCFwgddAxUeOG3Ge/6O4InaICWQGNRrmz1zfPzXhARtgXy/xL1MVYLlYc8U+/V8gS0e2F0uyK5YZWjZdC45oFZYxEeS/qwIOb0hi8Sx4s4dzJ0uZhb3btiDpSxlwx3REgPNpDzjNIinCw9RKZqbf34avUXCTuWtRijv8LYy16nJrsPUokz+PvUNkUCVDPId8acXapOYMTl8cCZaDgcdDqg4acXRXc/247hDJs1YpYg3M1BN/06WluvdDbBo+L7sIpGOIgApG3VRV2170DHkp8wpamKc8yYCgeYfXB79kg0bRC22MZ9e2YCKwnM/BIMCDdZRTsu0MKeOXT1UkFHDPITo32yIf0+ANq1pfe3YK329z/6If5H6+hvVvDg09bEIupfLlOjX5YIQfvpvQKXLOUaoRZ+PiLcXJFrkFUqO09Zpt1hfpuLYw6qcwkDWJex/LMfpZvgVNP/fop+dScc8906MHXpyj6nDuytqcOgVt9sdEuXzeDObgMyf/0YBFi9bhbtyIBvw0WlMPoEtCx5yCd35nm1ZBifg8qGB9cvlWFJNLK0rZZ3iO9p4pqbeSMLnHeUVBh3eThrCVPH5wj94vt9LHsJaAmWsyetRFxkJdEqb4TWjErF/ggpIyIlESusngwsworn8T8tz4vB9eZXefbnMPUugD0DMJBlz73OeXSE1c6ZHgb9hofeh+y+U5XXr4h7WF1+iNpsffr5UU33o9cz0yxGBOTqdTWxCroctGiYAy8gkcfzNG5G0gEBhdg12e9rmYA0VJ3VzDfVRsWRcutzRL/t10xekiB8R4gTNwEC4EbmLZoXy7yY6U5yPZgcp6x2Mv4ueMoWMmM4SGdB3j+K/jKvTy0O5mNHPrWFZw/m6rcRBFGV5w3HHOgrHR/BRFFUYRfazsMsBFS8pqEVJLdUqXUCRIeX5A3RTzufXuE2gynMphll+B75JL3rd+Xj6wWp3DoG57WT+SanQttiB1a9bb9YoiUdYKFEjoyYndVpm0P5Eby2hh1DKYXPPRfYAROMvVaNYU2sa20yfmkn3esWmsz4hntQIPV1XCUEgkC4xjGZiqJOyjmR7tNDPyW5lLoyB446/SpiC7I6VUNEg4otIftkqcOpyE3Ys+F2FH31RQSlW4VGg13Smgj3ywbghOY4r8eBVcZtZEuZ8rkGVveNJ6FETOUV5bgI7B4A85dwp1j0aFd0xfql/uY0m/cieVdWEXBHRXgsLZXX3rEa13pUfe1xkpOOijJiv7w+bpuwVxwiRyibIO1nmOFQfuUnMvNnkHViuXt/LxE5B3vwLmRY2633pN36ffvK1xdOTPBQfhXsqQE8eAp8xklpzO7b1i0CZrGhF2/DZcsBPADdZswtX5qkEVCeatlZvHwGzZ68RZY985n15Saky2uLqILExHrdPPbX/W2/U5H7bLB1CV1HgyPvoZE9LdvR1dTHS2aoJdbgwIC2sfLSb/EUPtR63uVSa5AxDnds9vT3Crool+NJCXcR3cVXNeiPciW93OLV/407vxBRzRIOyf630Gcv8MzBDllW2GIq56TMk0REwaP63iuTz/dWxmCCwaRbI81yIjmU7GsEdMfQXSM5tPwmDCL2HK2h2+cWDKxMtfdb4Y/T0jwG9Co96YvpjHZEsWuqM2lMGqzWRXmpAqHJ3ytYrsOt6sUXzbFVL3vFGIeGDjBT+tGYRkS+WnXyNrhGA25E1VqOrQaCJgoJJC2RSk0wIh4N/j0snC6KUaI5vVoIOOi+GSVkmXxcwnGnONyZI70UGMKAbSjolO9MnSAnK8a7NXLRkYIzgUQU8MJTT7L5f34cxEjWtk9JEY8u/Uzpi6CI2idVSbvYYmpBiSV+zxjwQCSt9D0qFt8cILmk0O28ZY/P8IRVjQKLhMtbrGEY5BMzpIb4JvSTzCaKVIq0azVH1BwxRoKH0kVUkvrpGqG/Se3jnyiMbrcIK3lSNCi9p0ry8a8ZbjWOu0eb3FY/49kYPwkYSq7VGkCLyn6pUoCZjI7paoAOYSNejcxDtoWd5E9CGucz2hHDnvfX90Q/kp9kPOPOFc7soUeXj6ArXY+upTzBAuu7fmhHSOtyKbMWlCrPRpPS+UaL9NdeliyMe0eyxH+KcuScYWzom0qeB3aesh8IzWUtLF2az4eQ0p4UKMRSs8xGZu0puJyjtLoLYW7wZudtcUFQlXqnMH8suqS2E9sA1j+4sBJYmiuzhErsepmrtsk2f3iKfKkQqX/38idiILWuS1d9JzRc/RTioRMKXwSOvZ4peKP+DD5SmsHxfQWjorjcV9nlU0k/FbPc+iihkqDBVOR7U7mC69mm0j0cIrDBijIkmo6heO2jHLq4sF6T8dJX/1lB270RLh77mpI6LzbTmeI8xoNDjliEbhbYjSfXOPMgnVZDrbbc31QA+Lj2xGRLbzdhLlEuwjVKRm3Pubv+zUk4/PEHxP9UPGNWvbS8nBzyNWMXHBHvbjUr8q7vzNkVTUaiFJGidFgWWPk7TWWciDzJWWVPmpWpsLBdVepFxoAQ7xIB+2S9F+E7QJZ3HWnMG9hzF7xdeZ+Djo13dcUXAF4WqOw2jC55pXz7GobIA1+JKvYRgHhj9Yrm+ZYnqbKKZPmZUiTaljArh+Qe5zl3CG0FQ79udEQ4VeIoZZRnNeGat2UXjiYm4y3JPZ9BX7pFRl0+siw4FHezoOYltS7yl68M9q/uZ1FS9pQFI49KiaAIzHPrWYa2313SK5xkEnGv8mZ0GI7qoG7R5BiTLpBN4wGSznNyCDkhC6hs/RuIq420nO9flmYF8d+RkrJztA13OMoyF/ZQ31nvVWwR7v9i+QVDq+RK8ivFKNKrsmGUxV0hHvdHW3AIiePjNx6DHQF+4r610ERigCytLhNWV1rSD6mcBXlDUeaLjs44SH33zRdp0GGVGGjfuKx3wyxnTAz07DcISBgAyd2WksptQoDnUU0h2eh75ePm7AYwRUfIaBPcHuswohRSL754UpT8Vm+p2vfcDYA1AGIpaNy+PnN0gNiGHdW/xEu8Z8KFNB5p2exbxB55FfXZ58efUZqg3RewVyNsf/Baf81iCcSWP1ieFRo60ldmK8YpelMismy45UQNxZnncgpmN2uslxZDoG/fbauPIC1CQH0kBvJTfW3hYO638ftPLQZGwhtOkFPNDfv7RNakVtX+XhNPMCwQdpDWRJzpYyTaGiega2k1lXoAh10oSJOLzjmlc0khjImXsY7KaCHZDrdJUNRpLi+L2V2joYVz9GCTRoJxmUPnnJE4DLgbLRrZ/sNRDNuRVRWVvsqPYTO+CwpE3CjfGoqEVFnNSsVMVW1B2MaJaMDdCVowwJbJsBgDGKW3TG/ZdRrat3pSnQjTxvOw/GvGU82UPV2e4iA9hoom0L0lKsxuzrTmkS/SQu8t4UtHhoCoBNR0BApWL4WQmntbJ9SdKus4DZT8hqavvZetaxsFswpzORobF5qL7abDeFpWF71MAK/BEyeVym7VR8LppXMUt4fkaYb5DrH9kyqAahDFvGUiLr785VG3j9SLwsDSOsnqpXRX36JFps5e+IonO0nlXpKtf8mZz8Ye8io6anp2Rm/0Pq7ENTJQ31iBmVcGPqKEMt4QO7L0/G4tGb9zFQM7KTrIUqyy7+Gh1yxiszWqElJXbpVoh9+2Mkr7HAFZCW4RnywwsLCeymmDDmQfp2m/jR1ZuMehOI9UR2Os3jpcoriJfxrqro1kpWijUI0YKowlrjaQKOqCpqe4SFi18+/FNen4VX0uED4a1W8MLCzcpIRsgW9/CfBR06tltNd3dESTPQlFRqaUxqWhGuBogI6DZgCz5OompnEyjxBDaLpi6ACIAm+89teAV+UWude5Y+OdQLlZIrYJXnpBw1/GfsVxrAsHA6iERh9B5lWqcNM5EhJ/XAQvyVsYMptsc+cjEVChSgpZgFdOpuuhGRycGiXuFZ26O4vxEAkYl9rFbYuKvXgRr9cYr3cTmHjg5YOJip9JuW4Mo+o9xqY5YB2XD+6MyqwqxvrrOuFD32sH9sELogCML8y0PkYDOXs5uDH9MfqZJOOZDpllvhFrm0SurSOZYntKJ7RV1MjW/LzQgmQnoPx7rkICQc3PNg0g/YVtlIJZwAEJUlG0qikzYX4zau18Gh19kgWHcewXWjLoh7ls8AXUGN0bHwQc2mxirFBMyXsGAM1yBZv+EQnP+c7/0AWSFxxKYfCxs12ty34Uo4H1NIK7mo5xocsNo3L8fANHz06l0GLHgId9rSe75WecUSzwp8PY7NID3Ufy/qE0l99XFRWymwTFHQl52Tb8TXGtQoOujXGj27aaERKNG1od96Eo55EPxecxDwUF4/ukfW0K93F1+8l8ZW5h977t2Nn8LPEVTWO0KUoOO7vIiCs8ecs7xQPFzZbGQ2Uea0k8TxNMAeFuKdMBG8MfoRdtwaueKzD/VeHNJM3VO8mRUyjBPOrSKqKCf86L6WwG2UcAujwqotQlwuxE4G9E0obVOICg3vr5avG9A2t6IhwiFiW9uX9jvvsaLA9QLZS9FxxTC8tDMQer+oWfr6YK2RGLaqQBH9Jst7sj/MXVzG8PQMTtAl3grUH7i/ScGlA05TTS7bJYrdwTEe16dbFTubxQnGS0EelaExFWWYgltjLfFlKqba/0dzoX8Hrx/x2/wfZwgcVroKTlIFMTkvafKIiZsXzwmngpA5VzdsTYvyCTk++6p3BlenOmC2oMx8Lz8gN1zmg2rVjV/D4eta8zUOxHNNX+8rR6ZPiPNkWvhWaVTIwCmqwmiTWvlN7HlZdBDJxQGqMzKZrGlqE1H0O9+AEzfJwaPehcQs3OMs7vh2btTlNN98doqfM9XlVc0efyX11TpUtabh6aRz5q7WGwUf3xRpOsAW6bXCEF/HCk0eDYT2TmkNJQ4m4DSjIVvI2fdvxd5/kq0C05XGQdQGlC+GPGEP9CMqo7URfRgUfmgclrSrMJeEe87dfgX5m08J0NEU1Yb2P33PHIAVCzN9mPXT6mO7lqvGwMv2e0Nm+My4yIXwVhVXgr7FFs8emuhh77EckKeoFNKc4xQPoOahg44NQlbgh9avdOWVuC9zDM55KYNTJ7a3X9VOEY3M1+oGOyOa2RZQST/VdxIgZGvvxN370rvBNx0096FE4G7bW+aZ7GZ4LcYsCXhhg67MHx07I2u0zIc8zgG6uY5f735bBJxPW7pbHexxGzXneLnhmcCBq9s414E1K6l3Tpwv+XwKnTmPTSjxN40qF3NRMsPfv4VwxOpTWwc6VCkp5JTUMQ6ZqucPFy2ZzUTdwtcA8n4CVUk0gz4wAqTECQnR/qhQ1XVOkOFUuIWSJXUUnoOJbi6iEkz1unufJVZamCUlTFSt4IhONvTWpuM0kafLwq3rmf+AO46EIcI2w7pMmcfrE4uExMUDWa+2mjbFFLi0MFhThDhOrPm9SK8GRa4kGmIaweKxH+7tqhQiNh6wTI3V5Zz5PQiU5+jsFX1sPVMEA+LjE70ME6FcBDdUEplbSjok7u6ZYrs6sHNXpDxyXn/WGkEnxUkOCtIzoQIufEtcBazrAJC3cxCvEu6RnvMhuMnlx+t/ZuPnMYPgVUHmnwTpnsAakev0mVd+A6uKe+AcN1TGSjTVFYUPZAzwdaZBDesviaPWdx+kcgxEjrXj8Vn3y1V1hREoPEqzKtH0HdM1Ok03OaiCtZun4otvf9UJdOLKfhcv4TOu3qSW4fJ9df2yE6gvfYgB2OJVJSinqiFagwA9iHUxI0S0uBZaQAgGBAxhtg8KXyk75NyhZ0R4rpjcesNwnoKKH3IOHmRvKkSav14YWeYN+oukOTxas3rdoLtdvuZ7wCyJZP8/SfFyW3DVJzQyruBVYISP+oqjl2M7GNSqhvttActLaRRQ06/LWKPmz2dUewN/LHaiV7vmnRoid5GioG6YlA7glDQvnkod+DRrE8zxFYMI6CIwjP3BJaA0fCnL7ZRXV1hz8BWAILx2j3HdxdW175DeFERGYIoKLUzBUdvrEYy4qs2RkFydZkhSlxvuC8vHR8SWRtlOMG6ysy7vMIIJIU64YT8pVPzKJkH6e54IUpg4rJaMMkzJ3OyxbxSAIJ8PDQSVOigHxgSfjDrFj6i+3DkOE63sekvRICR15xqznfV1lMBkncKWz0opz2oKkoXYpeSrvhia074ibZwQeWuSaTMnDT2XpdYIGfQtv5F2TvVKPXqo86/Bw3ZC28kAVDWOhB4VH5APYVEmCmjzFQO9th2EC1OuWm4NehrbbFUUy8qep1DzTeRyYI5wRF9RolV7a0BQyfWxtGsRmqzFtRu7CdZiwVOi8yVlL3JR5N53X2GAZ69ERkz84GkS/BszmSdj5iK2q7Nbzpu2NIiY1BbLkQI1ARwG4gU5CO0O/8Lo1efHqs+ZKgk2ih4Lp2aJQCqxfX7vQ6saSN1lF6T2lBj5Wex2AAJO90HdACsCc9TrA7ByXKW3iDbSQStp+Fk94K4I9Ld9ewhLk3TIUekY4xR5UALH1r3oPi9giTQdqrbv6isguABsurD0NzKBd+VqKZqLDHD8ZYed/bL1y3ZZ+dibrJg03ExrjrQ0iHxmqKK2MKnoIIT056pNYPBiwcy2g+EjCeQnFDOf04hLE+Dnyv6RSarKyfOwgJlv9NjFdr1yC0ssoWa0tq2nBmZnKJFrHiHmiXKZLhqSqp91D87rkd0jbpwRbz0BXzuYmGrxS1OOV3NTZ1R1H5SyVsY/taWQZ9HpglrwdqXrcGmYSDJ8Wm/3rKRAt2c+LCB3WJKKMFav5oL5fcNE/escgOKdpkpGjK+yQsAXhXUNBZEMqNKgW5oRs1pEMrtGBaO+XvJKCZLg1PEg8Oddm0R0ABDMrIArjmSitsBo66RzCsB1w7nQ7JAg+doN56+E41eSDH9f22PgIWHTg8l5TaYWiP1th0EPZUBwzJZsy086kWCCJniO6/tgHYwvdOj7aND2QsD39PaR1x8EvWkKYb53uTXXbGOhOTC7UqiKV8QpPLnr4wiPOfkhuCvsF8nuQq+lu9RHHjvvbMlLQDvaaZWvChduwicYzbLkgs53oGTlJX1XmAftn9PmufqUCEtNMSjalxb7iNJLFxlOMCSGV5hLV6cnl4a0jqu8Ng6ZrpuW2ZJRMqphwm23yWarSQhD+fUsC+4TIODgXgcZNF2Y3oMj0HDOawLWnNOEIG8pFMvOlDAm0nDs/E+39HT4n2XCqJSOM5JTywdFLNu4dJHLOUOE24fiZKUv8JtwfXrGxFZGpwOsp+9RzPVUxh02JkU+0gxdIY63cMJEwCOnst9BRgOeaiXDpKp5g7zabrQuyDwe8Idea2SerNHlKVYSfYWYkeTa5XzhIEqtv0GBQIK0vyRyq7otFwgO0/jfDkdNjghkUn2g0Y7270+4exZ9f8Ba9OSPYJ+AWm53OfNKRidVFZkeVRHTpceoV2FRSNWogr8y7U8jo1+LMebwnflC6XEaBd0rA0jmUMT6nPUUoqKATeDd7Mu0ze4cIocO4Nxctxv+MtLBkaQOp2ws+wHA7peHRcmZGE1PnRS8cElGicPLNRzXfwVP9XWgPb3X+OoQUJqJiLqODXX5cUejoAgVnCAavLZvvePbRj5GFHv7F0K95zRPBQfxbTwZ4pnsS3DH3tHDnAD5VQE9cLYVd0ydrVWYJOBSP1yVP9iGTAYlevxMhWT1KXhaYoJJYAyatzJbZGOs2Wyfcbt9EIQOysxkBttq3VrxGQUblb32FtJSSox0StLv2uaxXnchspu49FAhUaVcEYRrAwe/nNyIHxer8Yi+JLcTC/ulQdto/ebZfw7p+51GXQOmE9rLmBVJsuL7Bh0aN0s8QB4AEATzHetHOCCyIC5YfqdSey7KfdcyDpiPuH6Q2cnbSm+pLiIyLYPjzHG3HSPrjOoFFA/8EgG2gfKBMniVm+QEmJO1fgcW6ZX38UuPacVeUN0/AC1T4C5eUEodXLSX/Ld2cKjRMN/jPmTtpzjarZh7NNq3/2S0BcxLZFg713PqoKL1fv59woRPQ9WJo/PftxR+xSwwrg4qyiBzhD/xKvPrO4ejiiNGZLcmt9Y+UZvr3ogVwEJQ/yg0t5sUjFdZuCJGSGTFAZ9wLupcFtsnWwIm4pGpntqnEVEFMsyyrGKQZ+BF3dnbLQBL9xXVmmIWClVzfWvrYUmsxWM/diT1AiCP9hasfQA0ulu71ToMytbJLjdeCEpoZ6WVGmBgRFfYe7L9qKiNkONoC/tFbB2e9+K03w81Nch5WG1+BsSapM1Myc3DXU+d5F7zOdZIsLQqjUc4pKcnVrlvyIw48Yenct9ioL6ztJHEdexYSwlkb2uvglo2Mdaku1RmoXhO7xnfdSnkCbcEOmQwzUC1abkZoBiDSLSToVPISN/HNIR1WEGjfotUKDTZ1MOaM8mIn2CqV/E8ingDJEBO9XV1D6W6wDAE/cv5e986CBjJ+gWVXh297R9WGQwz7NhHoU3J8S9fcdMsYefDgsAopQGX1hTfm4rlxkhUi3uT/C5pylu3EbURGyyp2VGzP3b7JJIL+j7D2CIA+n6rb4bw+cz2VaNHX149aIo9SCEfOffuUZkQRjdo59ziWvNaHOl5qUbYwwxir76R5gAfuL/E1pqJZiOU59sgt6YBOpsPfq6fgvn3owRVfzzf1nyfkUhxI4ms1u9VUT3cRB/NKU0pZ5EB5BTzzgaTZuQgHm/vHSZIoCt6zjeaVOGbicZHZ8DPCpdlg7y2Jek/evjhapd4dDpZGhxHfjnb7HHVAxBTGHHbDiIx2tPYGl7KkjmXDopKpoavd393trD8fUTyiKcQ5Wjv4jC9x10XvZBdCTlJKuPPzkqWHl/U/eCD3DddlhajStxpXZ/ldGgFeuU8keQ3T0Anb3oQTK3MzzyDWjHLCFUNiKXKxpthgOZlwSEbZm/s2x+DwA+7ml2Pkm9SbpUFqO4UTJRUJqAT/UPBWoTBy03QHu7h+Lq5iMfkYDc0GnQXiKg27TfHtFo+Bu981KFutQsD5o3LIYEJgi6rQQtRADfLB405diQ4yEPtRB87cbTI94XI+4K/HeaMimmP20dSPun8b49/fm5M2TTElu7gU4zmCjg2Tq70Tl0mzw6KTEwdu+5KlwErg/CMrzGHEyWCYLspE60ZwtFuBFzJXuluuDHPkl9lOF4apRmSdSYucC9BNHlZLBkbscTF+M2Rg5/SzLN6oQrYOp8MInuqWLrGxCkF1ef6ykDKchPs1HZXBF8Y2GnOhhIXx+hptv0u3lnUhD/GmOkV2ENC/8uyRnXlwAhUuAuEz9NRurgT5h18PDg7dNXDaWb86s/yo8D7CwYWTUmziOyC3oAyK6Zfe52/i8iVuKF7Ry6RXkxUkfkC1jVeOxldbUWdhqY8Bc+odHoQY0bZl5s3vWVLCP5uYBpp/VclOxWQmr+VnsLNFbkP05Zty8bCU/hoI1kzV5YYeNNnuhbzMOblJJ96i2nGtE37//+avC0LFubv3BKvjHRwN+/vtYEtM1MNt2haDkO3iAraAZE6HxWBwX3e/IOHwlRlLLre9unh4nIdoS505mQ2SomCmBc3L1bxoE3Uc+lt4vIqh/oXDwzdU1kYqsikQC6s1vh6YFKMN40RDVz8UkSwSSqBqIJtoQz9mPM+7Ynv5FU2EIciGnb5RmdAm4nH6FcCKrMTv4yvSJ3xFS+1RJLHYdqMufZTa0HG0E2g77PM03acz1DYcAxW4xAQL643WqRrnRpZR0SbhJa0pk5jl74H70ItQiXQI3c/wWNXBzhJLOs5KcdQDZ7BHXoa3Bltag+a01MV5Scwem1sHhvboeC655NrfePjt8aBzaVYIwBM+KDCG+xKldTmQ/x+/gYnwfbH/NndrfQnynnh1gEXcSywC89ydJq3j2BeMFyTlSL2kaAK2pMW3ARHItriCgcI7A6kNs8Fn2eZUGm5dd1tlr+rKmu0MAxNjIyGlUXHAopuXn3NqAKhAKY5vHAtpA2S3AWd0juqOZUttwwDagoWMhzwZclWgGEaZN06q/CeYvxAscxDqOLC+btqHdRYOqvl0I2whi6mXN8C7IhUm9ytKM0vmJ1EueDHg88Q0zVSSatOIyJ+iKzsFJ5TWsY3uqrZ+shQXONdPNS9JpH30Qk2fRzjpAiTVg3D2c0FK5m7PEBMLAmO1XrfUJshsxb5bhE/JrIgkjErTP+w9i4J8YcvlHwFrEwNH2ZhsMDSJPABBlXHHNQe6ZLaXbkhzgvPrHjD2a6k5yrbUn2KeQgDbFOnp6mEL91Q0l9hXxhecE9t3iT/TljKgX12BUQosWnIvsGBHleA49K+vCqGi7Y+yftYW8N65GIOL5Pc9Zgx+RqpbPaFPEThlRQBDYA+32emetKNZv1Z6GG7Qa8k98SvZYTyqLS4OKC2ycXiLpjZ3FB4HF0J59LYishRI7MXavUF3ydG06jkxtHtZDh0K6LmKsFhABrZ5K43cpVyhP4RKcCMsv0AkccjgSA/tjqUbGUI3UO/lrxCmagfcWZr7Pdcjh7+aZ2GhbY4WEFA4kuP6ECJsmL0hNMWcI/ZkMsq0BXpYDxEVMr5LXDFiEylZ4nSixkkDMNMboWfrtTHMEKsdChiige7J8dUd6+t2gs+bA1/EQ6pk7WGzg/3DXKlKg4ZlHog3S/e9jfwz1Cix9f6tHHBwK3qDj7znC+tTk/cMbk9HcPYQmGHSDhM5N7MNLlTv0LfhBCodLfgMp1kTFzXabp3Qhl2sOKjSWPs7aw2DPkF2LMgPgy0rzcC+baXSURoLIdbd78hcZFUYsNm0fhN+GNutpuYhnyW5KxxGVpGJapUjnRPN2TOSSRuvpH0bWyBLNLGBWaWxePywUNIo3eDwJREWmMvePAV6GC/8tWAZcqDA5igqsIbo8n4vJLk4+XtFeRGsGJRxSw5M+8UzCwKQ34jyiVggMV0+MyaQV+KAW9PvyqL8QkV8q+IAbgDXOLU8Q7o3j5pAz01fzVPsPfphOgSOZ6gHFCRC2zF55syq12ML812Ev84n/7JnMbOLUk7bcd5m6qONUwXyqwP+tEIN2L1YrXIrQuTeKVqdEsAUKwcdwkTC39iFwXBRVCMmfMtx5FxKSqMFfYtuLhOw8wFF6tJqNvxnTqVNWD0jHytlwbCkw3y4AfrGsZaH2PGN7gp4sJKboRmhs4MNZq1ZyH1l7dAddfT9BTwbA3suCVqTOk8cWqj8Cy8pXJvXFj/Guh6rkyBufeDrDdybECEoKG2e9v6cKF6cx7STh2x0WTV2vCcEniCoqaLXHjXxRfOP6eQFvUM95Rm25RDr3qyzdElf5SleXJbqpwG2F5DwAHolWcnO/F7tqmAL89Dvr2QKvtnSRJAQsbz7oTKSpkI+vbuY47b/oFMlbDZJiQVdJBsg96fl7PF5EXlwZVtF/Kl/jIvM9u9i+yaFylPLqhkHXUio3hosaCEqceEy6eDmfj9HgdWrRnQkIaPbNE9iyrjYco42SLXFb3/4rwuJ16S+ttaQv8LEn2UGfuVXJqagxHcDbI0jGyu3zYXL2XHEycTwR/++MgooCZeY7XxxIoEjDB7DQA/s3FTOH4EeAa/+pOPNyEvGB7zqwFdZGWBVM6ik1+eHxckdaBWdCoXYwSJOgd5JJQKFvQJ0hr2rGlhlM66L8CBYh1Sgt+6wfhj5FL3vne0rVV0hOpNXnpL7c8maN2HJ5ImoQzKyM4A8Prn+H2+w9QCaa+faFP86kwG38kLhZYst9hoIvF57KP/eIJ9VTJYpjA4r7u1NztNaqwHvIprgFlanovRlZSdbNZgo1CwnWZekv+1gJNgEjeFeVd+jKUdwlXx3aAAFyF/fSPf5b2yq9v3oZ4TDVwVsx1IGTdd4LVQu28zbyawkZpEHyL8iqbHY1dJQ4tBwBJJW/WUyBWVZqoMEnc5zM73UQy6laeP7IGOmpxB/dW1GKN9pzvGB6KOHtu+qdOw2exOv6cJ3BOt7OOCEfVwQpQR0p724VKbgZvz9/fl3hYtL+Olh5kXZGz2L8gGLLACojI6CjWIKeOLFWmI0RtJIo1wFEfcupdIMo++383BqpI4+1vpq+jmONOC8ObhxwH4YWrABi1UaaQxlBpuUznBHG5XcEvAdMOzPZNhDurDKychxD9wio0mjDlDCB2zwPiJ3xDgVNNWgQ2kqZQBC2JubuPzNqz/ko2wmifMgz+936+drgxwQTlbW15FswsUJtSnbGcLmJ4HtMziAx92EOtJu/Jpa9xWl6qFooQlBipCAGx5UfodVO0/8FZ+9VTL2m7yke1eNyJDZjW9X90Qfqe8nffLUC/2mjxSg9y7ptu6PyPZGrf396JOBxTFZfJgqFTk0IDZ/2g15r70vPPRPER5oDOvXxmqbh9iokbfOPWEvqfoGC17glpCmbJJfmrQt615RkvS547lD7zq0S60rMrMxh9Iag0Y7qHn0Xg+2rJHCGdZwOFdyFhGStZpTxNkSso5z7D7IXCxHqKKduV8zAFQ2dngcjIm4Rhhy5o2Ww+f92MeZfL6y25TAFr5rKo8piOtRdhGhKT/thiOiMW8PxIS5bnbhtilNwlMB/mrKe2AgMlQ+NzEabxIcBvq2qg6lBR4UTgGiveRGfTprnv5aUOoQ8Jyi92umH6UPqhE3ATlEcZahznOz2/nsEJkXZ+o7eJyt8aa0jqyZgGL7e10O9kyrNQwALECiejb8uVDXFu0E/YPImVmLwvjFDbRCoa05E7YB3SzzgL+BPXLZ3avAaCRpnF6oZ5JCNSJ+amCklUylLv7eNus5+YQ08oMiCF38KqNSOzPPz6u0TIV1XUznMwtLuVOJy1aRnUalrBNUu7kC/yBm0oXeV++Fk0OXBX8MDcxLNnddYQDzMsq+L3SH2g6FgbFEQJQtGzDuh2VOnRq9eklW169hgcmHR3F4OvjvzJLn5IgCmeyTVDRq+cjRANvZseOU7ynleTyMJzMl4OysEhf4e254Uop629dTU5qh5JFfD/8ySfWITMQlSN9loksg5MwiGZ8f+zqick+RknlJyIRAE3yFWnMuhm4zXx5CSGMyWifbKJSEHT73h4TmVpRlnucESFHb/qtTBef2L4OoFJ7WhQQIIUEwEBxbMRLntt1HqLRSs1wTjrzAvuTjCa/gsEhUmTxwIsf2c3KBnyC/PtBlUlVuIad/WTth8XGIVoe0F7KkFIUOS3S0wb2lEil9v2gufySPaW6FdUo3C0MZmkjsJWQNuyv62fBZhuqtpOTrPtN2Txaey1c13YNBA/bFX21kPjeZ1lLP8dWAlxUpN1XZ3lNoLcOGyso/tiL1sTkE6yf/xEQNPmOgoM1Xyl7HmOaVwYJQANlfh4cxqKhubaVrGGJSMxlu/+8+5UHifmAuvYqawBsdwoatUK0ih32fllprRUbLsiL6bPVQgj6ZcQenajS+qyUXyexGy7ggMKb2JJSy9mn7ZREeIiDq+N1y12Sei1jTBc8bQsopU7+rVG9ZKuw79OAu7F3M410P4ECmifOFDN63vi87RGq2/JyoaYmgglhapCB7HvI6RmFSsja5IhsIHqC0bpj4uzt974NRNYg5wTyAHFMmroiD8PiDTiut0B0xg8j/qCKspHgAvAPlAA3Un69ZG/mrspcRSyvzr5hxbPcAp/mBfbjPlckOhhhlFqaGuX4bJ0RvYT2mhR6WmGIKnBkuEdiV5tzBcRCRHoSoFO+6MT6N2O4ipvR+5OrPqp7IlTKwToeLpJjLIFiFTBrHCaOASa7HJ8z/O+SQ7WjZYfp4TyiKGrN79FnqqY3ztlxNjVVieIUd9MvXJWED4FkrEPJesJTCj/wdmPD0+7mbAbXW9mfI7aXK9/2d75ytIgORslxk0WMrg9rrcBWndJNoOmHFiqmmRH8waUIxz7999yWMgZLqjiDXPsX+ZQu+jWFdUBs2zcDDHopbs744FxYpiooxwRl4+6T+yhB2im/ZlIQVtXT7BDMT0H4IWvfzJGcwN2gxC3gQ8gCgNPsczMz19IM1Fellv4DdDD7DxjgB1zEeXfmRTKTZuvOAQrOy7beUybckgr6cY0cJauKfhCtQ/U1YWWs3mOWb/K5q0gl6PE68NBKIYijD2RSqOF2kWiQbit2V0dKBW8IODe3nFjjf1fEAjGLmyuONHJR2QbhjYaj+vbznELdpm1SzfotJKFVs4NSlfQqvXIHXgwI52ZyBu6Ofbw29wbEZeiduGMrXMRkndl8k8lOt/VF78fENuf21h5pLwYprUd315dSNwlAokMY6bJqHL5g+S3VIMqWftDFen5W8grk0ZdLg4ospsFi7eflCBD9LzVCLbydhfDt0U5wLhPsm3rpvUtUBmfMshgS1ubUucQzT0Zt32okwiekC2382pQ4aP/vbRRxuPFssKI6s27PCE9J+43wch93Uneya43U3q/3dCw4EE81if7uHwzQ6exTcGjj/nK6s2UKjGnMrFiguyaR6p77IFsrUw3x9QE9IZCPrl2qdkiOj0+Wsz5xTJ68lsU7llCeaHOKemgvT15XsFX37eK5nvHMaB8q314YnNrBbWPax9m5aP96suGHI6sZQKd0N3c+TI1wqs55kzO3JUx8LcshXReiLwuTmJacvx0a3f2yHu1uyLqvsvl/BecqqgxbNFWe0BQ/WOwR+uXRRW3kgGpk3CxYWx+tqQ+RMV+PNy30S65YSVqUQ2lmKTY6ij234ruwgDflNe5U0HbGu+ZnGofiMpfVQJuK7+29iX2yvZ+f//QFXLEKKGAPwe+XgOt/o4VpvSQcYRzSzQS2ar6T+K6vXSCBK3lE1brekA+9dAT2iYWgOgCMUB4BdrX8fNSI702fZY8+KSArujcgKqbHjsggeeGIbXbyPNKqoFgsCJmhYo+0Bhw0loOOUi+usaXqn+WneYhcO/bmwXwC85RImZB6AufUp75TzRXR8q2oHE7hAA+4HftCtt5mQb2f/k+kPHKBTyFMma3sEp34mAOkzj+bxCXVuzvrF+4ukyAwW8PRPqJPFKfmEyP6tX4dmg7Hy8pP3I454mh9pJK9T5qCPLcAoxZqjvNnkiF2oq/76hYUDvCaaJ/zAsMq5yNJSa3bq2jP5ynlHs0ZJtb83zWMlbK71Pr7peSg5X/x56ve2E5HmL8palBCgXMap6NYdynuGunvw2EvU1dgrPQyeHK5u01dRmrG/u+rJT35/CzVomRYq/hpKicInIEEDuxGlr39MrLZVfq6nLBgo2zB0d/fImwKSgWaTYM7blxI/v3PXRNj9t7DGdT8TAAEAG30Vtm3+CFIhKHyeC7ppPGkC98JMzmHe0kz2pgXdoY94ALgDWcNOZmKq57b6cscjeKVD0b8R6AQkcHRqseNZSrHtQCyqJPcP9WiT5gy9JbTvoWBguC2Ro6E8RUaSiPcrYIEKg0zLx3WktntQwwQ0zWNjdj1afBd04Of6raaCnAJ8hLZQjDD6w3i6QwaOsjEsk/uP14bOOcwRJpxS7HwK1bH3BNYlpBDPeNWFVOSQ3fIBE3hgaWtqG1QF/Z/cAjHqq56IgaYguAeBBo11Bcr90xoub906+/HsfNOf5S40w7YwTuxWZEN9N63KEklb8Aau75H0Q2Zu2fV/HC1gO0CvuijxTW7cUDL38vi5YI4wJITOrDkino5u7LeLdU4tX9c/Xca7udz1B773ZKEdb6O2ZXSSyIN6z5/U9QwxCIaVX8QqSAzjhTFVl/wanh/CNXUOX/YTfS70H/fXjPbNf5El75BobhKgoKa7HTV9QHUegIUSKeVFYoP8ZaxSFsBW6b6PcGcYSdXPxeW5NCdA1Gf1eZXtC/3lq0y8QLoYoxITJBMhJc6nP785xn06CXpJyem74Slfly6kVKKP5iifC77B61BOs5YGim1Cq791cK4doIOWO70WH+B+uQ+By58j728WpAZDyfkbAFfhLKP2e08+83mBPgq2Zf8s1J+dMqroZXWJx+sZ53aV84ZKa7hasksR7+TbaQVunS4Af7W8To/N9CV3JPIOqM/ptSRtCbkfck5lCNYOR1QRvPk7WEedicXCqduNIR/tMe5gi725qVVFLM7L8aOjobIOHXHGKyRrE4pnW7DoAeMm/iyhnx42nJB32G2r2P1uYM4lLjzTnH/WHpWRcduAlhK6rx3MaPH6UqZ/egA/gy34fruNVox7q5H5qtC2vaIrbGL+As6yizpwyzwDWLOtvxrAQceRVayLSMsjaUysPCnrHUCO/wJARCORUSfv0DMOhNxd1CqXBNsVJppKhYSAKs6YQUmBYphBJyufERCeFE84LZ6YJPm0j3A2Rf/7NqWtvyQ5RhwyOJotdN724t6+lPJeG/PdEalNBWLTdALKVVlKw+HFArQlogeh7UBVPC2ztEB76KP0sbdsW627+M/so2cvTd+NDvdb/6n7H555RTATbTCXUMtUE+VzrD2qtuCzhyVEAx3/0ZdlbiKoaslATSPrZuGBzwnXmV0WJuvb9oDHgIx/iZhOyfDmnCz9wANVaOtRNi4SGSzAIrsfSJ6ue726HdKtsij1E0FQmVoE0Q/piZmGLVqh9rLfw4jcfqAjdf9Ybq+qYYiRsZJtIoE1jM8FDYqgQPy0rqzErCuUDyl1Ksc08opFdPlEjbaRHRraGzZVyorOj/94StcDslfTKX92NHKDNKp1pFs8Dd6X58pekfrhmIzAIzFFbwuSyAw+Jw3du8J5SF5u74MlHi+lak7KQRkcFk/AK+JvrQpLq+aTQ97R6+LzqhSk5wEo0Pb9syU+HGJDGst5pbZBp/MiJfp3APepoKelqSH0gWd0+i98D4kS4R9yMXhlAzFRpnBK+C2n8DRUoVijVD8Zf7CGG4f0GAZ66R+5/ZA9hLl/v2WaT7W9odrWJzEv082Ea8gpS0ldmGVmlW5uUr+wvbKqXh8fdYIxgM1kHMqTRapgH7w/rQijN9qWphDo/cJugfCHcnYdtbhA8148mkunYJxaVKrGC4eNbvd5Hf8y7Xi1H80XOq/cXybbnCnCQ0wT4td3sZSdMhI7Csi6K8tOBGq3DFlC9mCnfdde1n3Lq1gBKbZjMbhrxUCwlYMXxNUKUGDNS0AGibIabHoxrEwO/bQErBAgE4IRju6pOynyKOImEOZpjZmpYLi1C4iBd5ltNtcYX4GdcgIlUjyfHOJYlunlZGjhqeQ5faDYCm5HWbesLQ+R6VPkhGzUem5BJP67aPYtJXBiASn3gvg11MhmFpvsRuXkCxysS0gryrTDE9RsKPkg4tbiQkNHCSnvf2xZJSHO/ifZxKAJtAf9USnc6nxMi6Wq+A/TuvYlcTh3wEmKp/RC8/ko+iYxK+XwxXB6uBw2ct+j89ulFvw+lWezm+0J9EXLgAw7OBqB2TN+gD0onUN5OYIPnQaGHhlBxisy0i3pNijZGy30mqGviem2S42DQkIZzbnBHjM1HT1eHs0KGO3cMBOlenwMGGz2SSOX03PSiH/ucTisSwIkc0FZ06zooJkSkXStZ1NQZnSYPBOksjv+3LQPs4jCXCkENmY6gXuXbwI2Ul46s9F/lMYtBE70FmZ/fYHctksTSQqbT3ZJecBXNaWSDibAdkTixvsCf76uVj/Ee4W68w3UFPPmZ64V3T2pFqQk7DLXF1vSPmj/NZG6jOXftaxCsgSqQ+QE9kNtIYrH9BoUAmIdJdNwptXSsCpLptOR1omzMPLiOyhfga2huapCERfyeg76h2Mi8Mx0rmFGVCmzRvvUzwTe06T8WTSeNDnOrFnuWk3mdm4dHLD6BBbaOGR8YSWyXeB12TS/osvIbAWR4zWnoeJIwSi11pZrWB882Lf5MV2K+Ec8tH4N47lvDMgCOZ0XfOAYgjJGw6tZTBdX9F5YLvXRiai4ynAnat6nc9n+LRgTzphmU/OaKA3e1euzOLJkMwIpGuMRznKphJjYG4TCHbXYQA8tt6ChERm2E8IC/UYEmWYIBBBrr1IN7W2A8PlMqdnFvDzBmTViFkSM65nPTUqEEP8biaoWKcDQmPgKko7oRUu/ClAFOswG4jk69N+ur8Fu5c7OIWtk9Pz7uc73m6ZOh055d8NCFbnaOfO2c2lQDXJRp77zc9jLcdYRS035mTmZen1I3ZoDvpfrYFqcd7CcsQFXxOLexYklUvo//ouUM8GYjxroxn4jVDodevQR4qTO3V6twwOSgCkXz5T/W3JemX208itEXB9z8Ceg+cRNIU8ob490GEi+F+yaYgI+UNCT2p81AlD+WnwFD8v4GrYsg8N1kLrFkkwh7/6ggoaRKKGKdheAwyv9xn+VmF5sUQ0g6H2X0JH+F5N7OzVCHPVowIISIxXv7HhszTiGCExayydas++zMuFUz4mFymLVERa8CgToDu64JWyCFo5LxKGwKid6v/3Q0I1eLMJk90hqabLJGQbohx2ZPRL+NB6tVA5kywMd0i+2gRRh1AAkOkBb/9QXj6b6ZlVQMNdit8XLclHpTL902td5JhKq3bYqKjYF4d8ltfX2XH2OLh591MixAH0Y3NSNqZATZBaH/5wRhNh5b6j+4K6WNgNjZ/3nRAYZkYYgJmtl4CHZROnFIi2TVBIz/8UGBH0BJuEoWPQsOFK4H3/PgCfsUsuTqh6JF3jkPbei2CkZefdU38nkRX8woXDXBAjGtlsoEQwWDmz6gFkNZ+1qTMEyHA4bBfOjWu4jtoUmF0FkPHvQ+/nx2KbCEQYeDD4NnzillCqNIryqQbn66CGqh9xhC/PM5H5v7d206RQ+IuIC6z1Piz1Hln3lRtnVdMj6N/dsMDsRhSSMFxmvN7Pm7JfWfJDQtxli+AW5QuEkwf/lR7p961IfGO393qvYlKF06M9knga7ZiiFPHBKrqx5uXS6BFJJGkFF1T6rXbgb6D+Jd4QtG69DOPYJlpoH/xisR84Mm9uWloBNwhEASOMeK566KL/CC4iLt1S7gyRR1+TUd4wYdHR//3YULVd3ikCI8pkkFy38B6sIkxvTsF/eQ79QlW7gtlutopG7m9nsrHZNsUCGV8Q6z0lr9F53C64tpEvtg3Or2ORs7oOJhgsIggaMkd2OCMP0aYOBIksOeTqumJe6by2RRoEw+eLiOc+Pyfldo/cS/Rrv9Tes7EBS6o1Z+jlUrF/76YcDhNk3tRkENtnDfvX1fRBDOmGXMXnyyZtBzebQafczE6O4mlaAH0HRg6/GcT3vRu437/BhO3SklYRw9BDDz9nmNm9mtMr2puLlzKwy5wzjXqHF1f1gEXFaJkmEsxlgMGqqhpXEVetIFnYkSZ1w4wPW73exhayyXra5X8B7J0zlldvVX9EuC/QPvsWxC2UbUhWdSB3h90g4Xqz4uOYPTrNcB3Pu5CZcCKwoBDeBWpVNPAT9/b9nIS6kc2oW1eejvrOmNMUEsEkuIvbx/HpUmf2xHCePFRdGRkn2m5cr9EFksSDs0M4B+z/tFAF0HZgvoYENWwGOF9l/OIgto1dUm7s+zoBoiqOHYFjSmt9nMQDjpc8tg83poRcjxjL9SG/1hboNJzfuC02or5p84iPt7Uuk3NRmbXb0FLnihptx+WnarVLMrNXRw+swPqz+dTQOn8m7LoGa6CInFHfwkdUwhDjM1HohTvjIn1YM33afqE89n3g9OX2Zt//8+6Fk2/aXRVY8D0CjRLJj9mdwY9uTM2mU3vi1ZIPa8UMelBaEigbrEn60kUIhpXf8gJC730bmeZdNHzw8qMyqnc4Y8OTF78T0P05f4yRhVJLpMBYuQJYAz0CguzzrIkCxJfxcpa0jo/8VwxcjKZoIWYqpRMQtn2OYrLk2JKwbiZeyWTvEMeK+kknMzlrvDuENMXvi7TvHgyEkCFIwvVyL63d9WkpgIdKfRj1W5UdRbyYwtx8l+vbDprgivOo+tbeaeyhoMULetrlwedw/pppdD+vTEq4vszRhE1ivfsWpQyBXl3M0lQs7fFNev8zE1SguYUmDl/QAsGGJz/oV+CRLUxlYCH97ittNcb/a7/GQAfKkzmkl++zkfDad1CTurT1bMHy5sAvtL3YGEN0BPV2JFTeFUkjxCgxMxjkazrOkuWV3nl/honx9WQNbkzfW6sdnP9elWDen9BHk45T4NpKSEpS4v7DADnXBPFUI+HWt1JxuKAA+DjTuDLwq2fQfn9Q3ogEExKxv+eftJOfMOiOVR2kYgXTVOIO1f/1DY2owFQa3zhT1fNcKC44Z/ZDoWotaK19tKlMnnZCPRxcoxnsCG4ISQGWGYzsPkxLiPW0MOBwxZTCndtnMkahK3zFR+81oAAf+BKaKJs1OKkYMZO6jowQxhCPDY3OqcSAik05ExGBVbzFycQwNnnyrYiUvcu6qY7mARGsGBkpgxNMoaFxduXkk940ACksI2qpg733oNkS/oizSHZeqodfnpLpMxhQdjTQAVDtDX6LKKn1OFpId86jho4ETYJL9U1kj2wY58zcTUQ51IlEbc7+ocFDxR719LeJsS0wyaFxslWs8RsFhDegJ19JswQSnuL3MPoCs4a1hPYL5rrSPP2GvMV1NehrbB5D+kTPttapXZ10v7kVNakLK6Itqwa/diDedT6NCCGL+6ssyEspq96FQTdZD0bfBK0aYMSkBSpOo0PXZR8CiLwcEhT1xV/IFLeJAOLtxfo8jl9ft0P7n0Gl2j1Y8kChwTJ81Y99lPDWOVpCDV0yj55FA/x362mMHof1dG9tA8NOeBYHu2pDf+mgDsr+5npmHv2aPC0l9xe/l1t5d0KZDOFbRY+usEBG91S5QMhTRjagYKyg5FadUo3EZ86pPbA7TSusDEVgIapjBq3np8aPC0O7TNEAa1Xs3Si7rYagAVCEyItEkTByZCgdhtspHclJNxx0ghG4hC/dD3mHQG/kwiY52oFP+mie/JYu4t+We3odLFk6U9vMHzxGwmvd3AKzMeuEbumaDQZqsdM26f6ZkwrmvvzhXNJlZDtg0nu6Nf239h5UVAsFJGdGje+Tiw5aWxVmcUrUcGfbnzomsfmUMZqJ+hUtyPGauzXCYQv9LnsqLTNqn/vz2BJ3XbfYwrHMhM3piqUWCeEQMhlWBT+8MucDDn8o9p3B/jKXSiz+0l2dC9a22tBj7DUiOE244IcBbHfDcTTIfo+oKCBwIVEnuEJ9MPAguXlrZQV72FZbuxN2GZ7e6IZM+TeR0ZG7wXr3OGI6uB8/GBarN4zNNkLgYyHwXja0iwO26QAg1rpbgs30wj6bLC6y4zytyBfgD10bUoCoKxVjrZ1doMPk0hvtbuLb3ghjKARl2Uib+6CTky+7jEKjsZrsbdveeCI/8j3UICvjCMXppJbKjoh0Q9ccIaygMqm3hnVAPPwKHq3N9jlUmV3EkwLTNLbZwh5E1wXbXl4AVVhuyToojFTrH/gls3eFqW705WbPcAeZWiRaSUUUTdY483Kz65pez/LE2ujc1fpEeccemjjS66FZe9VdD8OHOfiF/HlVf8may1qqZI7KnTtw7SniML8wo2RWyDRoWQc6YPmXYoldIiXr9ocAU0z2IbXZchKfuAkvUyG051i6nhsRl+Ce04fXQEApO2Fz6vLvg4Ka7ujbv4SB/WZqBG9wh85yRpI1kCJtFFmsj8wbuKeFJZ+SBk6LJQHZzsVzWrBGvt/loJ0zQTblEbykktHj08gPutk9QzjNbEOHD8PaIJMsW/L+nIY6T0DMlpcXvv+YLAkmfX3MTgD0qpLysxPFes4BlK9BaGWRsIgFUAJfenSRSljTXOJIf6mn2kPnsyVN5B4uqLpO0jd4cgMOBTjzLqbfJ8g4OKf5bK27zVv7ED/5friuZDzxkyxZ+vQbld1uLeZvMl1xVS7yBXx5p3JlalRuX4uV2KK21O6msFVkXZKUgKNt5tUARLoui8wGFzJGsJUOKVGWKgbwvF81PhyewX+FWJGfLyijPyQgqCPjPwyTYGZYTZSVoqETSKQDtKHW6nqZZwHaSc5XiTpINFAJ6q6Wq8lQkvs9sLoIUMRD22beOfSRkvE1fk7LIUTF84eT1E99sx96QfX69PAvb/5P9Xjnp0up4v7nqpxadt3sSA1i8zqs/lref/mkOxTqQdoe1LijWwIj1mGA9yhOcGaPth2oNa2KZS42jeaa3FrPQoaZe6pmw016hW1TbeLWsHwsbkk1AYKE/bQL7FStMBTKgnDbDvNjuS5rLPbf285JCP9/hixdEyT3cPgY4iHfsHRMP/UiCfMbmX0IHbt5Xx+U+x0zmoaxJB1uwFvy9fTCVT8DL46ix4Q5rhqmp7O0JdgVjVwnpDllmvnz2tUjHY+VGdBwpF7t0qqT4JKkl34bI9iDJVGPjZ6lhQkJTbyRSMOljlAn5mzDKJJkhTZGgmUZ6mhVosrYNioM/g/mxWaWqzH5twJE6OpmBtvpxkqJWxvyMT02EK0zwmSVuWWUUzyydeSN6qGIBqQ37AqsGZ5DrBIWoBKP+XVOqcvJgsWI8xe0mz7XfzgFVFhnIXux7+c5E/sj4pvtthXKjRbECRE0vUXooTChyFDqnJSF9qqG22r2P1lPK7SylylvTn5oecenKolNnV2y0PkYnDGXZOSWX2/xAehxH/ah6stVQ6K1i5uA33Q8PeKHcHoN/8uMuYIl1Ce0bSlYp8bGtVqTpuoiXByxY9GDBne1BKKr2j9tELM1l2Oj/vTgvkcC7J8VFa8BRx+1kxuy4g9Si0k/+MjjR+zXxLTNVmDy/8nOBj885VNBKuP82wfKhePz+MZwCPqA4LXirdRy10Ufx25Ntt3h8u2DluSfeYE8XP48HgrBaad4uhmUHBRctmcq44wkbYWtGTTRHs82GoS8JCzT3+s2vmNe4iy0qm0mwr7yNgdXApWXu7LhO/VtCD7mEC+uZ+MbtaI92B4ApNFn5T40No0RFnckO82NtBcZO3ayeENkyIoINFSRFGrjoLS+8U+P02Gyp+LKd9idyUFTaB3nlbe4kGBmxl1ApDcQZ/0I6Wf2m0Mjy96z3z6YVCuqriRHTB7e7AMvgrZ4ImvM5HriGekaN2X7ajV0iBiNvzfKFksQDzAcRud9Ex3JPNzow+DBTHT4GQ0aDaADqFzj+wfbS6ZC2liwqYkQYbJgwR8j+A0pg2iTwcsXz6LXZVMc8E+deAbhJaW0eV/kwIYhS0wEsnojnt5pZYTnWzcFEDKnUKEQuUHhiyAfDeJRvdyaJThIroMW+AOsAD/eqe4g2CpNr6NNieyuoyzFkpkf6Lw4/6EzsUUNRAFtkwPzGPwvRKDiBfkk0YDtrE8pPYLDqQtjU82SQsz6/x7+E+iO5d1KKKr1fKbKEoMa1TDanq+4E4yABJzEH6cMNEmUcb4YHpLjwAbqxEMS2Fcv6YaP2w0JHlh9BA6Rn7Vg80r+z4Whf/CHZs+uhgk5skWvjm1Dp8uxajom/COcOPfhjPUv6n8PQIpDCUv4qpWvJurObvzN4WIU9kHS6eInoKp/9aNFQMTRyx0vvv7gZ01ysVVtMXAfVgWEtcd5gHbqUxalEXD5D/QlynMlAEZeA6OoyXZ14licraEzQZDgc5LFna5+DmD3yVkrNGVzLA6QQZdptenUmRgtnBIc4RCHCC8NKak1kafS1OTDwQEytWxQko+4LQ0lx2ruDugEBBCtFnw5KTpBwvJ3yb3YO0jD0yGpiy3hShH0bhKmkESj2DXohHSrPFkQ/4OeB2TbkOXvQsKywqs2ekxc/VAziYS8AZe9PdY3lc+9l/bLfWnIkWEEalEOvAgyvNEukbh0jz2T4c/jmFGJhC1RZkvdKO3k6cUYAPzd9Ef2W7T+yroZgQQMRQmvCnkQxIurotPJPFwr8AGmMicmHhP6W5DoykGZg6thdFltSfbRNMw0CQwZJXjm3Z0Vd8ceVCqRVDLTRQidJBUT9bL0xHwJSF6435SS3PzB48vORe5CfqxC2cWHnQsut9bO+Ivktcb4w92x1LtD/Gtz4IkHnuAKZ4y67tHI/RuzZkzCWMliDu00jNuMWBUUlglRuinnCpcNkjZc1Ub1ZurbsmzQxOnHsGfm83BE1bqzkRODF4ReMmRDzVaKgkCLgzr/r75o7Wm8/wRm8BNL4TOnmQ7efhuV4JtzMvKHn7Jtuqwkn+ViBeNS+83cfrOYEtmJ61nqi/AvlV/2z40vomh7vC5G8fgDQAXq/zWLy8pTrg2iyEEGBw46hOd1SyseGe9EUVOl2/pZxMAGQLT/660giX2Mw9oI8NmvSOYvJp7Cpjh4rKEsojHN8HCD3Qa3JhuOwkV2XIWTKP7zr8rYgX9d6LURtAqw1J10pffOONQWy9Wk4a2wq2vZ92KDhNFsrvayag6lOE8uV8DGhwjnJcZ9Y9fjv+T2GDSE7gpg9DmhlmXB5HUJIZCO7PcNNvlQ8ejeC42TnEJJfPE+s22Y4grsjN+g17cXxVHiweNiqWfuH8BXO+/wAExp20nGI3aJRC/S5qNzQcco82zAacSAFWTjXix7+ue2R7nRzAMTKHIsehIn0rWGxd+m7ZTCxyaqlR9GyWjYQXie4LP9zD0T6yBTYEwgG4kwFSVE0Szd8nDalMuczglR+32r590YfeYDfDrOv/FNr+YBYmuaxYwReYE0g8fIEUNvLSRKwH4RuYVKQckEO2KQm7JoxXH7Z9N8SlkdkjU5268VVvEBsVzqp4ExdKIAAb4bnJODDAGItr/EiWXQTdLw9BTpMBCH0LyQ5v4f9FrfhNLUhP19IJAbUYXDrcIwx5vOYB46o26JEWupnk6zhf/peKTZ+v0WoNgBQ+f+RDhrpTgBIJHBLH8BCOj0cxzYkBBElhUwAIUsPI4+LcGG2h2+6D8LI3lkjJubjSS6YDiFJmf8XheulDdQKYH3Cnp4drZwJrTs2HbkEGqRJlVd91qx5CNsheYvJwt1q5xZVsCn4fhFH3GEiW2vHs+edyhWvdT0YOAz3jhn8bstwCGIi/mtJDxZqLbmjX0hNaJfN/MJ4jN9iTVcnnzkCUc+YUS0JipFEvhoZD2q6qli7YSR2zgn7iPox/icYPvRwg/XSwo1tg30zja/awi7EYKh7G/e+N1F4t8ar7YhWA4SOSwScMhb183SdWZYiCuDH+DK13gWZu5gTLt2HENg9yi6sfcwRxPkDO4Yiw5JlPc74ti15hIBXkSI7CEuP1Rl919aFi1yZ8vDilZKsOU7QZObBnELHxwLJduBWCi977yfkFM4Kf4oPl0t1hfNkp+bSiwVCCa6FiUnfDNuDl9iUlYpwSd7RltZzEUHcz+xkjhBQLp3d6r/hMzRmymQ/DvI+eCMn3FxtRCFhtSLzcaNQxAfi39We5kBj3eCx9CHQDes5huEz+z+TCj2l2XHfgBXRbjMgdFY+9fZ5JK8eer5U+3szYkJleZ8EIKfm/I7v7jFVC/FMldElyEJkL3LNCPsPGGY50pJmEEYIFOw7Q4EzMBUyyyYpvpVSo32ibJqtFZxV+iRyJaXayXzUWpdWQLoF7fi8F8RfSbCQ8/nOHYC4ylv/dFWBAVhfyiTtRJ84clbhXjsDo9pRxuyHbrHxL+aVSUeq6KNo7wwujR3j03DZ6wafUyqeyhKeqH7cDzM5slLWJavVbtnNM+a6GdYoanBqjdFJ0c/xKhaYAu8H4ZG0gbHGdBOnTeNOA/WakdLh4QGIqxqhrpcb6jPapft9ZzwxGuo+13xfMxNOEh7t0uhejYDWXLpraRHYFWojaQayvKKQrUURP/kXhg5m9g4Lva4fAsUyG5n/0KXc70cI0Rz6Cx1RetCvBFLtyHrV1dn2a60xmOOfeNHWmhFffi9as7E8LAic/yDKFfwJgyrdm/WHd7ukN8cGHc2/rdbn6sLrr+b3CRG6NG3ybhVjJ5oniv15bq/gQMp+Auu3Fpw7yRMH4doaQiN7WPnkSppd36g7XBisobMMEUs1AfDktoH6GyoWAY6cunloTFIB6HEHn0EVYR1s7in3Nw294uAzVBzIm9+mMvAh4hFOLSSIUQ7EvStWEnKgwiGRP8B6bsnW4DHH90FiMbO8L4xhrj3OE7rBT3hPRFijo+Dd7FiElfESrJgLpzhPUn7Wn4MPZa/h6F8qpWIHGT0Bqwt30VAsKAUaJNzaKO8pZ3uMiaGwPChDH9rFzERmdvsn4aD93AJMxFmccgM58YnJkUHgfYXUFz6w/VdB3dcPZRUpVEIRLIl5yxdiNXnKSuKW6rSodK7FNRsBQi7ExnV3tooRXeMOxMDS75aI4T20BtPmmy7bVN5OIvvQFX0bnPN9MV1FN3PYA+zRTo8jwT0g16c8r4JQqgsifnw5HYl74wGUinr9gyWMvnzUEBBGCtobtPWvufiajmwHIEg9dXJGekTfNN8LeUfHXjKTX95gDuQC+GMzBlezesE2qhIOy/Hyr2pjcrSEp/VnQtK2HLx+A/7spNU9C4W29TzKuxH4FE4vfoaFLKf8aN0rgyCcKaZynB3HmdjFLenbTCU1RcpwIXpZbwKPS4TMBeS7xJFk9VWKRGO3lyBHdv9n4Ksluu9mhb6jWiAlQ8WxubQ9TqxeMQmMMWLT2SR6Tx/SpWk6BvYHNIcEPPdKh26kA2lZ04CqlBrXraspJTsGjxevVbOacgsLdW/sYrD9Jd71XFuGQstt9oN9H7eYLzD5ewtReGjTQELwn2+2AKUxYZ7LuJCwyiZNMSzuUcXlfJI80uzMSwFPUjrOdiq1tq2kvyMqWC2+YMyBVVW76r3YMvchulgiqUWs2Jo/8uHwYfikjqeoVw8Jjg+vj1ovU/szzvehO44sRiRRTIHDQQ1GEXb5m3JAdtPq/b1351upPDEoyO3KaQ15aOJZUiWCKvXEJ/5ucsTctnoYQPkStdEnAPql0+pKWBhGu1M5wmZH3LLMJS3hPB1SXoLm4PXdfOCE1X7qIninusbeEzTb/RWFNAafoWhmRCRuVXVwzJDO/91lNm+SLG2MI4P+irXvnH72fkAS4WIVFHAKGifYmPnyz4/5PN4XPGhgioelqCTPM/aFiH3+WBqCdV/NCHH2fpyqxL/pGW8tphAFKQ9Q4NwKigBd+9HFGasugtttmMPc2hNTwrle1bdyJ+KTvMQ2BUStmL4yDPBnX6Jgdw0xxmc3lqT4GmHgji2pC3ir+cxqB8ykSJi8RSQtKl9M3MTEV2Nixnk33U93NPZKBKTPy7OCchGnMfIPphtmM3IaNN8uSaheHiSq8ebVA1QBYdR6rSxRhL/URROQAmBj4B0vXU1wiCvFmohBDdFL0p0uxOduQXl7rEqY3W2AWjGN2/+z/M0HVHhmiHz8/pyHrgwYjBJtXQPnsyWd3xk/gPoOcYsqFsBgxZQqBhQZH6j0pSJncQuYZ86/aHVFvsb1LqLzcHLdEpmTG+jm1drY815DGKXLz4q5+I2KZwXXHIjDIlOFtRIsUCwhTLvHHIRc/dg36sehc7FKySFXg3ymeAPzjK0Q241EhZj1zIIf5sZlY7QiWnkp1m/kUrAcK2Jr5XIjy44mX04QkAnEPa2Lzz6QgdPVQK+Vg4GVttdAhvTNecTlaCwV52lu+T9V4JyudD+42MJOQr88YnXZWGp95Z2VVitt+p2353SRMR7hhaYqNuqh9M1Vh0aceUgUX7HtYISOVYE4UEmK+53OQv9rw2QVN+soozkkeQ8R1jvKwPuDn1gbZUdQQD2vyiK2m/oZxRaNew3mGX7R+2ZRGcKZlyS+nkOCItsNlnJoKKudMBj2UaopZS+RqZt6HVztWyks2XbOnlBPpILDlk+em+QIbrK9orXbuc2iDBMJ/EpSgA+0FUeg4yFhml3R2jMvPTJbfgHyXEXJxqBfAQS9IEzo7WNX6P8bZAut4DB08xUHrzVlTZqzbv0vHvlBrxC/t4eSPJWXeHJkqsys07p48t7hH6x2c1Dfm6y81b1tdTe6DxMwMwXkMFNjPifXNl8P++2fWM+kk5ryWVe/nh+pWHKhXdZW0SRiOrhfbpqAwQL1EVZeyhp+75c1536fCPbJxkoLaolsPEHZyBl+llc04zB1c/0H1ctc7J/Le4CxneoEsrOfytEnNToaUdz3Y8Bml2sF/lMW+zyOSNsnNOLTaQaDqoLQNs5VFlvRRJGiyuMKy236wSPVm4hi5I8LQRUnaFstL+gam7nRXdqR7Ph4fHtkHR73JJ0V1KzmfvLA09+hx2tMmOWk7cTJVbO1g0zFqUloXexO/PO7zq9c1mHeZzc3TAcDCpSUz15kaV/ISmHWieVq0r5wt/H/6fH1asl6iZbC6wq+2ThN0pcpJS2YhFZsCuneJ+pKYmrhTxuQlVqygSXFLEYkFN8iHtPrqkSFJ19mnUbvQOzhdsz2GPV8jCjbImvD4umTnkcs5EvqBcNznr+x2yNWZjWbA5E5Vs1XEIZWO6TeWkmrVcM3rVhVf1AcSD1I7XckzkEHX2/2r4AsBplFwHd0krteFktgLqpeefugYKg2rSPpx61i6Udd1FfyKqGqZ1zPelOBwRCQ9YqIZ5h924Df11vDsjXpXSfob9Ba7lqHVyjlPEUx3Uh8CmWMzTSTZE1rF8IlIXINWKoC5BEXj2UDeMbydee8YTgxBA3vpbwZkQtOe1hyNuh/UvKLZzx6Oo5zmz2Me6DgKVUcur2MM6vML3DD/A7urFkAJWg/a2R4eSiO0t7ufeHJKROEDg+1lJlvsTTCFCFX3uy170OQ6wi5tRs5TU14VIBXOm7y/5GZuwx24itQtIbUp6Nw+9NXRoMG7XCgreWZofQKrJLd+IxHGdU3kC9LX/FovazvCj0KMEzl2qe9Wp7Z+q9HPeYfiM0T7OvSrsKe82z0CJz5Fmy/MaYmi7uP0nsxFH7cLtxgbL12ImrkWg29YBXMIItoHPCJiCIdv3lj8VBIo+UQwHtN/GLkoAnKj2dVDErGVq75OMS9hMDMAlpliVAdyDp7jvwWvNDvDmoyoGWyQVM5Ns2KlXv4Loxa3XoHjIpy2iY41BAS15DnFcEk3dAn3yRVHcwHqiwNQ/7zikCW51mzjSaHnaxM6GHyTB6oI+hmSWi0tuoKM6+sbWW6cwXs33HvKjwgJFK/gi3YC+M1uJngmXbw4kQdJCqY9yf/1znl0sqwie3MnQArwPxQbtJKyF8aJ+KZoL74/amwNlQR7wxX+L2yJ1AMRIkG9g4cb6nE7cGwP8AYDQgODZO68z8kVbYgQKTnowiOy5lwjXhaXrwlWn3rI3qVe5Ov4tJFt4JF9TuvVBdS7qw0KDweqiLX0dgy0eWzEzfwjtBx546mmxFiY64h4Z40iRumuhNr6R8DdYjJNl8Q3avK5WWheStSwW4/2M4noU1Lg3tnONL13ei8Z6WV61S9gaxwDJ1gpW+XnjDLClCrbI+OWalfWZ1QMlXN6bru5LVt8bb3dWm34gYF6iHmtIuTqWCYl19icUo0MNtdpUeA++NObbNO9x1ABp6CpaMGQKtuW8Q/Zz//J08e80fD1h2cCB9+/55FCOEptvDkjPx88ET2lZbcIgDSKgeFkgz6gUjJ+q1R2YjhfD4CgCBiKrt9vyKcc8hEobYq7smDUqUKC5LUIY9tJCDBwJIYKu9OCQMx5VQdT5j0fJKN7X1vfPOGGPQYEkIPqDO39ozU7XBq8Wxb7RZO1f29Y4NMAZaRvRleWrzLsOgIRLMow8ZvekY1ceoQVKq79Cvrg3RcpWN1QHXvYCmNSSXcoJAZqRa9ElTdsfxrt0H46NYN+2DN4GL6FItO2hBL8THQH9HFzU8sMNWNjgb26xVsEIZ97QGZMJ9OQk3l21JWrMoJJFt5XSihrc2UHL50fw5MOvxxVji/mVm/mgDbIgBasG6qliyZWRNY2G/nZQVItVz+7qeF7IdbJx0ULx3RNGhoGj6P/5T3upPcZbt60d2v8BBzJcWlIv72eGp5bQrsD2sNw6szGzaDffrWRqdRuK/xt+1mvXGGKytbUf8yUHhRM4DHUSsoT6FsnBVcU5SsJnXWiwMpE3QOd5ZBcM7BCYDCwe/7ZdNTBhy3yeSyrxz9boyigZTmgkkiBAqRu4y00rNfQmn5mhtFCkizqqzobIOqZHI8B43dQXrAEhtOs4ZwbhknuMYOIH95slohRWGvcJ+M/2zLROQCTor0Q3/psrZIlL2XZ53xB3l/zFWWyWnzOhDcshqOYo2eGy8nbnbb7l8go7SlVwTxzDMTeX2qIyus2SZNLHHXpDxhIfR+JlSS6yZnOYBP1VU+a25teuQQ2yL86pkwzjZTyTOEpXaCVulj2BnoyStG3NLzDNquZQIO3wTqN/nSX7hMVL8FIca/iFE6ci9rcp0idaMCC1y+4lb/v/t7o149Kn4Wjrfh02NquOs2sLZw5tWzslyYRyEr9fzKTY8SSzwC+hb+htffE4AF051IFnof86zTU9FBhv0ahlTNTH8qF3IepDYaUx1dUdT9ErVBFIX14pkvW7TVAgKRq39VNJ5dnZ3UTxQxwqQSbp+pJGxzTxbzoOkEuvUIC80W6ugpxPjKe0rhUlJsxsPFF/DGiVLykLKIMWkTA+2TVjw/iNzSu1azHNDN605pB81MmW+KDSwCjlCCAAXH0y0dv6N/onTJQ+yaKvRB4B/qdkyC5y55nu2ty6uf80CxZqC1F3dKQX5VAeQ1i5p2nYX9ot0ZbzipYRHO3jLb5Rs20mX99OeY5zHsPox9ddFPyMwIu6va0CwFT1dD+DqkwkVpR2X9edjsxf0uYijIEFLFL6n/m2AG02cbaONgS1jdfQmBwsJIWo6J9VdLMqw4OIF8/s3dTgLBZNH/Bd7t09oWxbBOdk1cKAnP1ALPMKIYZ2GNv5Gg+TFceSTHqMlbcmOTV4LZSpN7Sexz6GowNzh7XWf5GF//ld6FUp7iaWq26sRPWCFUg/iiNB6gCaqYxImRunw6qsOJ50CivSnIxeVX3CZfa9t69lHR1hrhiUwssxK6SacnfY7d6Sf40ezAVrKXHvG+fGQyYgHs/lX4FILzzF5FnoLLFQkIUNRBN2aSYHpG64i7r6CIJAucZrdjuaFs5StycMaUI4JyH/u3P+ySOi3pJrPkqU/OxrexGPvvEJcThG1WjkJejJ/LkUdoVydlpO98EkW/Kiltt7gdTnyhUcMmn7HvUNZ8p1YcVxQJWvMKorNPKbcHNncuTP10LLD4aSt36pUpS7krvVZ2xwm2591mOr+IK4rNa4Nki1Jt9kIaSJGvTRaVXkiYEqnhh/IBzC76OpwZhwceHEQCToZ/ydrnG5EInejix5W1VvdVkB93Rb1DdZ4LjHoI5iRa4zvTRR7LeU103dIZDRZ8JiaWK2ehybHigOTV5G3HnQQ4NVjRGgvTAW3xqqCMVvTxkGETqATi6fth4BoWJipI3KQjDhleINDdXiEOSax0C7eRK0BJgy5woDzf1uD4T65PBQYreXvPnGwJYKDMQ9uVIIHlZKM969ep/3sBQg2HLp83F5Vo8Z3swS7pbmt63UE/RAxJwU4+Bf+AlkROpObAjKMevcVSRXwuY/Qu1sJJBy6lt6d9q4X45dLN3wKue1W7/scTa4i6MdtqgQtaa93dsizIaozAeLiOzlpdI6omAX4igu9iA9WDHx7OKpizw/pjpB2SjJyIIFARmHJNrb0e72EGIdknu0yPQ5utRbkdVogE1ALkWZONS2Fr+mGZ1t2G+H7NS4AmJ5AsPlDjevY7xAqqyM/YnogFKSaCwZ5bIM2dJHy5t7tIN7yVbyWKLGGqXMBOtdg+vLErPQ3G3gYi+Syb4Cf723jx1YNumKYSEri5A+wI3IyYYD23hVwOH8xfXatMrfDmfj9hF+QVFQFz8deajt5AoatEoJ1JmlF2KqwIicyAVI0WjsgZ+XF44zJNwo+QoQOA5A9LTsV+eJ2MGkOObLALlFciupov4OH4LZOkumUnWOtwnrxY1SQjZkg0XC83+OfSr/XHjIuZLnGqSn6ID009heIHFPGgA15B7/j8zGV8ZG/jjt3MFlV3JHHUUyCE0WNTUf0GWgRLv9ZUnj8pIIRY3GN1xgfdOamULN2N1YGhuuGO0PW1ng+ih2w6CCtFCn0LOoXNJx9h05vDR20V8UJCz7iLZUmZXtXc3Pau1U9FNPY1cMlPHHPURNTQMwOwylKkqMuPpnHDyuG7lGfXa74tcU+beXGTzJ6Lz3S6chZz9wfKdMWrFyajy0r0/zbD7VS/WiXMBF9RDmtrLG47gw92JDebMwlCj2XQjAvppLTj1Ouu/AggToR0iIXLx6gB0I0F8La5NZQ27nBYKGChBdEA/szw0goIPGH8WvtpYntzDB5VvVPV/umiS3UH+L4zY2w0BtyOgu2uPxuE43/dzLVfmWmG+y/3JaKMSKtn9YT04HdOR0ibU6OpVz4o3AFTDk2ThzWeelEteKp3XYU3tj5xmD7b1qxA7ZlQTuDDaXAwQmmAwVYu1F3bIxqx2YapCAM0d1iOlE7hv2MPk44QsUlgCktD1u/YGhMVM4HAXe1oPdpYABy0gHqj+andnYmwtSP/U8+2EFOgVAU+dVQTBwh1SLeOBZPrIq8OfspGszyJACHOGWb9ozaFGwlEs9QsMKDE4xo96Eyss2gayBbQCQPWIUxkf1qVr+wO0Jwl+Y9eAai9jOrmqGX9WFatzNnNIIjiEtnI4+9xbMy5gBObBDmPATDOzD0XBodggsvXLkwEKipKSZBUC7EnppdOqDdjuvcFPOqKGJF53i5R63y/TnCMU+Ai212pDbGqF6/Drpqwl4XYFKnyjReVoC+GX6QwHz3UuZuLyFSwwCM4qqC+SBvWHtmVsCE+G+P+DU/VOzNqZON0rZa9b2mE4wPswK32pDpOrmoIb6OlaHE9ANvPaN2Dy2W+txqy7qvUlhzDIgjc01nKLNArF2lqJCOjJGGjnRyCr9tPcMZ2ngRSr1wtHMv/KQjDIOye+ZF9eLfiedX6jmxAo0lvg9NX5PeFkKGxTXcdZb1ty0k4aL8kopJduTOaCch1kcLAtMUtPCq5X+y7T/GTxUfZnagZo8xgHvZkSJZHtRM/ZfKesBgHhZrJnKUjHzGIJXfuZriErnMll6acrDjsRM5Bqhr+5iXFPTgMU84WV4/Sju6Sq3ZnyimS347VxFNLgTOqk6TCDIR1kFTFCDFO8jvd6Alvmo5pMnrWGxf0XdAKHQoqahnUE9QsH9ii7bH8tVQbSRc8BkmIKJEMnq+g4nDwX26cFn/yduwF4lIPvX1S3sPVHB3hE284DIooGKCY0GfThRAnXxCOUYV66ud9SBE9mLKQbvpvY82b4dNRS6FvbqoKHpvWDGbL4U0RKdTDSyIdjcN/R4EoNw5sLrgbfJrkzux9YKR0br+GW+8nLu8EaPO81OGnZqMyYP6T1AAVjDoqjH8ltugxzRSsz3+qInmPP9mu6Nws7IMuTkSV+OJLUn9i3Z9yTSKCfbs1gXWfriDFv4qfF+tvsIBzwHeWJM+j6ELA0j9qgggLHQusNaZpUh2/xC0etAqsc2J+8rx/BRwcLW/JkL3Tl/Y//ZxHMnf4t0AXpNNiJ9LF+EdsgNiJZYYlME5ZHh6H9aQB3y9k84rVmE1xoPuVezsSU7ANNG9uuCWmSxW/03TpSvPgjSilkf60EHSJvEtUiGppywiPSFtwjFF1XgnQgT4T+X/A5Zt4IslMzDEPNYQTgrAr6dlr8ao8rutkL9kUAxgzjaKMLf2Y1E+dJFzKoLGqY44v0ElGSsqEgKZdnyDcz75ZxMy4fU4E/ZCXK9WkXhTtYWSIS2tSlDw6NojQe9tbq+/q2TDRDryPpuaGiucJJ+H4WCFM721tTm+ni1rg04h4Ft3qsd+/gziJMRuoej4AQhVku3PNiJ4KMVJOXTvWMnGOe5oCWLUkLt2g0M1XgY84nX5gIHTk2Kohb8DtH6kcCcNlHKF90Bog0H66QGgLKikcQq+2sG9NYhtzd55OSTeJwXLsy5MfFdtfp7pT7STHEnt/SQ+HHpMSnzb3y2UXAFcEFxTgs3ocTS3z9HyhMvIqhCn+8ZIjETZ01yMMbI3Mkkht5M/bgvqR/Cqw9aDB9loMxGKulMTR2JKmrBwKhr9IZ69bcxXZvHXnFiiIFIVf2TjzL59EAvCTC7w7zcL7cNs9QRK3O8L8lJnOx8iOc2+FwwucxTxhPThwT2zEy+fjbu/4Jj9qY2jIvsGsa3P4FEVeModMcHA+tkZNg0tOI5HXtgUB0m5bM9CoGmnWfvo+1dwYV2GXC/sp6DXuZHc+oOurqOBZ7PSgoRHhOMx0E+ApjmAD9QxHYVEwpkgq1Vm8NbsHmPxXGmdD6IAby8iXj9sXhYqbQE139yO68agZLyh8fMSijVsGSUqg5dQBdYfJqmbA060bnZVEazzZXCnSwN+TVV343osOc0OOJxNPczeecD919Fn9SvltVSwwBrOLngRSFV+kx1y1fSiFrSk+kaZIix5OoVs7b2Uun9eBuM2EMbnn/oRSUlyRpdckQwELGXkvHW10igJjXYtX561YcrzLvz/S9dEfLGHMoqhxRlCDwzHbaRo+rykHdqTlG4AACnbWAAysSnT5Af5YPT+UWBQcbZukHiNw7npS9Sm97/DG0VK19S80WWIfwFJPK9liQ6KPKQNCpiKby7XekSpef5pbYsRO07tiEideitq5nY9d22GGut58kygITG7RkMqyPDOBitQE3ySHxeQbeSddqZ7m0FdCkJ6SPz0YB2sVtKaoVCCulKhh3zXBm9P5BSjAgeOZHcvCVJlW6tkR6052q6D+A4k4T408OM/v4YE24QjSBotYv4gr9CDVTd03p89Oc6V7inWP7ZJMOmLRTBhk9v8BcUzU/ESZrHnz2nhCoLzas6qqVIWEBM3z08IxATEGhFtaRZuBdmM4uGccXaa+4o9KpsGbUjoqlVED5gi8kwScJcpgYn32C8Gb8auWWun8rTSRTLB+wjTnoBWMlmUSWBGCG9KrsOMFP/wj3hr0vJmx43x7FaxsV54057KsDjPfv6J+NsHowPL41+JM8UkDDRwcwulV1I99vp5W7xQtpXcPD2+TbS5f0ONnfzvtYeKf7T07WJY/MLreze7OvPZdM1IFPNVvoNd4F/jOKr2eSwR5+GO50TW7rTMhQXmkfGrpQoDzMbK/syATTWsBUsni0LWQQJyYFhp2/QUadCSRnFfsCbFrjPX3+XkuY65pl6LFFCexcBkwvJe8poevFGdyAXwPzV6pJ/YES/6HTDBp4yzZOFjkIyzT5MAOKxcJHwqWM6+xAjF95Au+iSkzy5OXTvcHjLpP2IX01XVYSBECMdJdWPr8+0SrvtTKCr/A6k2Qh7/vPHm1zjkX4FnBbSq9TeKa9fWYlOqWPaiJUTUZXeqXNefzJmE6yfNbPEbWJuWIH8FNKvjHcu3uHuJaM1i9Hd05K4Q6JQjPHR7S7sxo5qdryNiRVALlmyqRQfPnROfKzCXHz6NZNPrARoJcqFeEVAY1SpXZRqqEXZtN9WTLcNR5lFkdjh7BdwHjrLszQim4kdl9Wo3tWFAeqv78i8lh8y64Zw8wE3OOxXT04CBL/Tj63lL97fPhtjnVc7smG2HRTryJZzwyCdJ/01L3lDcKv+LPZAbG4K4YwrBKHE2V3pcTDq7o1ofTn/DEcNzDtnh133Qhc4H3yC8n68A4nRZOBIG2tk2L9NUTK5jXm1+BjADivLagl38wo7Q4zxa9DyNyuvpjdZTaizjK1VLZKzboVv1kh+kPH30JHl9DMrRYPDaxxbeKLe7slsxqGGg25LKKYWoxPlh2eEI0atBJ2MFoGNQeOoVmLL2To1/lKMUcmcsWEcDJqXplMWkEibFcT+t9YForNekggXutsGnkQvxQTMOLwN6Ijv24vqGuzrBmJO9OpTh8QnVws620A2Ej11JTETxgN8xFknI4OfTI1ZLSU/o3yVUECH7bw37+ggtC1Uvu4zrcVSzgklmuq/UGjJJ/+/5R4ytBzo8ypiS+3/Zm7PyFBXI3saxhRQCq1xCbC7euCfHqAU50gmnhCtMzhYAxY1MKYsGUsxh/Pv4LoBDpkbJ0odXmWp1pmRg5NHBySZzkFB2X5nXg1YEyM1FisS8J5xmy1G4yUJyJQCICesetGeAVs4KIRmR8tH02Bsi6o5ptZzQHsV/YuG8aqV4LFa5kHSk6HxriBmN6MRoijDXpX0ZCQo1ADuBZ1PxZdQcfvZKvMu7TkHcsbR1r5WEIO1Va+uvOB0JQkm9RXKOHYyOrtfmaLwta1EIeu5wNzZN/Z6rY0/dRINSpD6yw8skGAmIAQo1zwY/5F8/yrnrspVQyWL2AV9NpBrlABI5qQ7lJjXhNiWuIwGuoxCYhNmThs2dNs0/t3Dyostaa2aY3el1p6cu9co7sF3hl+aHS+nfFp1dQXN3dILmsMYEv6nJZeyOD91HHDfoZMd3TOFRNbIBboc1y1jVGrlPkwtummiQ3NiOeWUtVNeLQrQX/nP5ORVLQQUD+Abyt4pjwuVkO/RqRRTJ4Q6BMFtnESFEgDfMAEJ3w6jJhZ8zVa+bo92tmEK9aTvLe3n3OyZcMlU25jwDoYESqAIV+c3lYThvkKuLEHSGaKG9hE+Q6/aP5gvGHeTdxUAkMRvL9G9BziinIrah0fXD8+9CoUeqFwJGSIQLBCKkJpVLowO4j7HzdP/uKZniwtPkDVV+fiwVf/h8MjngInPXMvP5bQPmUMiWZgH7LCp4MYLNG7QK81FuwxEx2HAiubvmjR3HkIbrQuLt5ybEhReu4PGslzP/kDVKzyhmKDHYbREDDw13dpOQtRESCduS7FR8guiqUmkhuxPmx0PIiTDZpr7jtKlV1vEyCaFHqEfzASMPkdeTx4h7SGlHTW1UeWaU3I4dgxJ3PmI0IE9R0wsM+QXoFZVHM4XRix98wQ6iOg7cMmG7Nw+nxtJsNfhs1DaBsnx1WxsIO56RI0UqKe+Lis+8eu1IOV42qrBbr4PkcxF/tXwDuJc9PMk5UIkta5M7anEz9LlqtqNeji/P3kJtm4GNg49NRcxyXmPGrWZAPeNj4zRK0GqFw59L8q4xqZv81SgWrS4fr1o0e2Q2X24lRoBNCC2U22PmO8boKVorJAoCQZfgl6HSD3KOQm7EDSt1pwmShWz47VxIyIUIhCduCzy5sadi/FTBC82E3BwuqjhLf8H+69FTQh0wvLD0ap9uPyx6lVKt6HlmDpOlgRJ/E5KAT+MRqbVmxUds8PveiZHjG5QyBnEjPK9iE71e9OFvJkO9RZVPQQ6wAyDGebxcflITNgEtQcEtZ3+K0WBcTHvs/0LZp1fxVzzYZMCYSD1y9C83XsmK8801iFeH06dUjIceK96LcPGLMohb9s7L8eUho+PY6GQ/u4Jr8mmQtB3zz/uaARKiS4sNMBexPFH+SUr3FCUJbYSMF/B5f5a/f8qG4KaT6/tODCw2QSag2Gmdk7UKH+DHNFyJFTMeF9xVn4em915WaD5bWgmGscE1zPwsCnjlJfXU682+uM2t0vLjD+F3+Vk86Dx7zDKLrCyvPZWBkQpCKBZqaSa64zkHaDA9PMh9FWHyRLJYzBtmbp7o8hYmTXiT4R0rjkq7ExkocwzcdKfF8TikzfIwfQJmN77iFTnLcqmZjhNyZPK93Xni3QEaYZI4eSY2/RmbPFZW+LyNeHK6bY/gOF95lK1Nkvce6WI/l1O0AZ+164lRmhjuOjoLMjvnxCZ1Y1Eb2kl0MmVq33DvOreYl18bQ5+XpadhTlnp8Mhlt3xB0DvLF4D8PYWxRTTh7G7duO6p7O3nD4GYqY+aiDzVbQuQONQkzX3YcL0dUxrFV8mXDZUyLZLrBcMxKhwtL25x+d+Kbax7S1hTqnrNhAzQQkwWRl4Y+wx9lLFnPDmSshSciOvlIDKSpcmu7jInN3KqFrQdxrWBwREHjnaofuBHZxwPq0pdycdj/KME64d4+pTVD1JoHSeq0YOsntIwUvGvSMVp7DRo4h7H1IB8oeJtVxijDvWjpGfb3EUK9wy9B46ueFoVEKUKARW/9NaZ4MIKKNCwO0VRGvVJfq42Zso8ORBg+l7bQLJ1/KyuQc/Vdfq0SdRr3iLk35oBe/dwDnPLBu4ZjqtrhWdZVsiPcrKHO3capFVLRO4BpSsrwQFpNF5NDto5HDAEYYZQQZugPnT4CFwOTWwClQ7X4QlXcvtCFrkWgFskNiC0ujx9nAWjUJfCm1NI2yKQuNgUMqhgJxYpMo+nvnFwIcK3KfovSt9CANlJFGA5mUSG4y7Asc6Rzd25Wnxd5FZlbVg2DGNCNwGswxvCpwxUO7+mnaGxgWJzWCTF2VRoJFhA4aQ0YwHw800LKd+GbsR4YN7q4y2YkalpC6/ttz3L+bNtncCCcGEd//SBVfJEYK0uXDRXNFjDN7bMqge/NZdMiuytIDau2IfIJss86jPHcAQctRQ6tckYZ5eI73vBkvy7kNd66yIoTI0F6MMZU+PSU7bHFKvmPKJLRIwts1tMVI88Dqxyg4aGiD5NidTj5eKWhq7YUe4gYywsW+HXGj2TlN3hjoPBUU9RSGqPLvmizbpj7Q54Qr3HdOwVBIdZN6wKERg686b5F7g5Vl8CIKfETLgZovJcZlKziMLrG9OsZ7rkwmTJId1em1MeROvFxub6sAJ091GqdYjmNSevksZBoQH7pcMEkBEJq1kfaL/xL3/E+yB3EV9/Z9tx2DADRQzQ2tY80xmHb51rEHMW29J4w0Yw+XGLkck032t3NAAFkD4fopm97P4OEH/iowWcZy5OGnvDQfUQFrtMBoL8tT2unDTjemDtqfPnljk/Ke6rZxE6C8GBYidLZCWoxKEx/cU8aaIMYosFmm4/3JZbcae/7uxkX8kgcFj18C1aBfVJ/yDRLzanlzOWvIel3aF597jniiHbALzrUsGWajEhT9eD+MQoFM9vEUteSVwARXLb8w6BZdihnyY++Cp3EWh6zmFBRgOUHoi/PLs7B/Digv/5nafl/c4pYE8GzsX7i9Eep1x17lQqXycqXm2OFgGDyRgq8IsM4vGUh+iLjimq9yepUlAcwRap6+aaqla596C1yCMZjpsZol0dpDtCBEyU0gs8Zke1CnVezR4sl5NNLXtaHSjTjXsseB7FBuDyZS1B53Zr0eG2yvYQjq9PfZ56sTsyuv6c1rA9/21/KUbqnPEAuH7KFEmmU731YT3J3B3lw9FU4jLA6dX9MqIKCQ6wMGaDqkCjSv7zC61Q7+TentHLC4+uFrPheCHqahZcc+/RmRatyiicw++NWAK/7tm+h2sQgzR1FBgXf5oxGnpMvRe3lGyFizIQSh8XWG+FiT2o0K0/kvBWKOLZPyFhthTvBiTTO+aaOtddv424PA0K7sOTNZmeiQHwDWg0tU0pzvg9mF47Vd+bJjQN5V7HMN2s5acdbEO/xkVs3OG8IQLeFLo3xMkcva7H8B2j6sq0Qk93Gy84Aj+vHkIXCLp8TZyWaGTPE5J3tT3Nckq5AF4OgJJGiaM7mZ9LQOA5HxIMTjinrZ/lXPnXs151EojoezB4zAojc9vaUKqvy/WnrOBsZzorR3ZsQFMs+ur8oJw33vJH099SVmSlnemz0dv8qvnUKqJood4YP0/NxrW/W9eWtXjUiyHqJH4zSrnu9z4wCRH3xJb2C0Um82smlujiTpKoCcLg0VB807qy9pTrQwfgOeRPPhQWWjs5+h63Cj720RyckVuEL6Yo3Kyd00aAEYwO9NFq8umpq5AB2ZcIW3CUSBrS3e65072TBGvah/aQtJFCkrxpfs78yvMOIMLFGsBmx+LF0TVhJrXruplsP0eT+hUzpvLcLKUTx7aD0nXKcZ4V7nI6L2r2JBNWV87VaF6THUsMgLyA2qPJa/uDKujwTO89T5zyEnVvQSG0YU4LQ4FyZbTqV2R13E9hQwMesKALLG2Et5Xa4s1ToqMZkT2cjmP11ZKlaDtaniRr+pzBFlmoaxPkfgF63MKWLnj8Y1+vSVB5uZ3+CXFa5ixJKnuU038IbJQshR7B/Zw8qVzDv/z319TqJlX9mTmTpVJWQWIxvJH5bAR38Bydynvd1aic4NRo7mB9r24QdTEs6esr7ZkEyUSH2MxgnoXSrDHN/wyho/ZScREgmEMHh8siXTIjyFE8iUCD51IAOjQj+5154tBBMXvJoNE7tAOpn2mv/w4/wytGHZ/HFGVy5+LutTx0f5wIvosvpL3QclVZDNQHXHeMwVJnPMwb9mxHNN5SqzwY28mhGufm3j0AVO7J0TqMm7txtO6jAvO4JKA/kGFNVk+87iHyucFrS0bVEExaKVpubVQdMfIIDXMJs6AW8NpiX7rDDdd/awg6rPuxmEmiHP5zP3jQDvB9FdPFcOMEoAH5E5D2FDasI4dtKv1H8Cavmb4lb3nx0Vj6v9Qi5VBcKujrgTh+GjIcUdco47RX8DN1bImilpd0WOnA+rxHpCkAHVExcg+UlX5kJIiA3Q+4SEOjlwaUtU/Ytby4PfBX1FkjNUT+aBftVUaXOYn3L3EzA4KCB8KbwBpiKKrD49B7g8IuowKDAqDpGZAew5G9F+Y/r5TSwcXcweVFKtp+7xWoepSU35XPSwv0j+3LAunfPFoBlouLidn2faEO4reYf8FUf6ZJQ3+zy2d8ktIqsBXVSk2wiiNUvctt5XtxxZyJmu0NSEWuM1+59acnrHGSoqAB1roCN1wdIJN8ZWaH4EL7WYakoQgE/HOg9XN6y0STG9qhCnE26kI5LcYgPwAf2+NgKYXtHCXSEoYzD0PJTyeEGOLMy+MENQrwsaEPB6h8jO8d8MxXZ/YPR6mvX1BBhH1Yr1Teqz7OEASGSbiwIvMBDXjRGs97li7jtr1mvcY1vZ1xm6B8XPM8klkzuYXLbGU6RWQUbrGorS387llDG6i4QzFCVqo76Z9tpIlu4OfyOofw+0j3Gzs5AlbYeZMxlQJBK2OhprEU1Wl8AVjzEeF+NMY7VVbz7PqCOk5ejuafanD27dHow1bE4AWM4ec+6o89tGYCoR6Jlm23v5Dg+lI931oplWhpbGf9txxVAiYblJlQP1PJicbIlNfjUIkO7RBSO761ksmcpIQUjf5xRcFHIT3WaKFSgsEOt4Piyr54o4LJ4aM0GMh1upwXR0gC1TGYIPJ4sYbyqVm5dShQijdfkT1DlOeu+FoJ24zXfjZTdqvCJjVuMiQn08XH5E+EKGrSI1Sh28o9dmjBi2PU9/yhLmFGzT6iX9zzh8M0WkF66ugbXEQhZ3CefsZaM/RCN/jFgPC56hCWh3hCd2Cz53S2G0HfuHqfu6DAhVaY5ZWzRgzgStl2M6qGKKZSFVWuHhH5GbuPTFgWCj9VGjpKdBdjovk4oLfX6Cc40hk6zifHG6uW03M/R3fYFth2D1y0QnPyymklA+K+BJtp0xgJBIrOmWCXBiA5oOS/9RKPMHjfrVT0HxPDgDpp3eO4KWD/0zT+aKlEEyx+2N/51EPIZ4Xv3YUwKFGgOFJAWuZoGn29SypghEA1OUZLzHFydImbZgD93wMssaMoTbOpct30GbsG/u0ZxXpwYAX+MSGtf02+ulbr3hVcPJX2ZRzESdOV0AGc+QLqkR0R/kz90QdbbZrDEj6szTuzTH254YFyxZpYextors29Ly9RoguqIrg3FBev7xLnKcpzZss6fLA01jqhyc1vaUEcYdS+d/IURY7cmyoOqN7B4PNpGfxVO062XlSCz1AGX4zify22rH7wbYPpx7d9zkq0SJRQP4dMU2ciIftwVGMYRj7L2iNcpVvQWIoe+PkBCdmSxJ5z6zsR+shATVlaznBiK3v9BWTdYCGqV8hCvs59KFXLN2+eXoG5vov8C7CXYih7WlXv5qLET7jY9FslH2iLpzuy15H7NOBZN2PNHUA6EPRL48T9XJbiW7zkCHlWiSST7QKDRXzy2lUa5rTjUYGNDhmtUXwkaFMoNRZaRegm8ClHzQ4h9aElRM4t5cNlNIU2p3Gja3yNgUq8p8sRuC+f3p6omJPWynVBtTwiKSFGbOsXYvZIXF0NlFsUCsS1IsOBCvaH4ag2pb10CEGtjhzGhFPp3Z/t+4JHcgxWIEbS+lQXy88mQaTI7FOFhUo6wtXRg9WJnfgpi8/vAsqpMyoOl033Wz57pSzePHQioetP5XS2M/5rqwDzPun0phOo6iVJP0g2sKsbhDznA+G9tNg9o9rMIp2Kb0Oxg5nfuc900StvmMVfDDAPrt6dLY0P3vYXgfjmkjB23YKGTE445Tz3jOMiGeNuu0SEPAG+Lbw5xCWefQOCdsWz4gCam6vXbfRVswqyvhGJJ33lPvYE34aluCNMwAm3EbFRXoUEtgY8FxPpCEshTspDa1yMwq5i1baiOVwRzxtrlqcpiPlmaeiSXLTkB4zAa2/eJSBV1drZY2B8RfWYP13bCB4+QTXGZ1dIYPLSjZTo8LiuzHxbXJW9AB6aRfZHNWi8X/3wNM1tZr9nFKAcJRyfCewP4M5nKaVap7EfenxNkwCpbOp35FE71EuNRHL8QCf6OjRCjJvstvxZnrvplcytxQUgNEcQo1zjF11HE0ytA+ZZb/uVMjnt6AOsBt6/RS2CQsgrc9a8ZcTCpXlKifCOdPJs/BJToiuWxWKtqRX0UNdG9OiPcmEvdrlNNKGVhmu2AZ8iyeWb4o2neOIuVx6T8zkxaX2aLPrYzPbzYS3NDgVi6NJEhvkPiJE2JCn7ImLI8ZTDfY2PpbXOykxJx8bLwxpFK2sqkBSY++8sp158M05RkItl5dAYc3Nan8SWqa9oAWkP8yK10t+jdclZj+jWw8XZSra5xXWVKAYiRXcAIj+PvX+Ny4KSyYfr6nAHObosPHbgiKlWSEhCHxIwkRs2eC2WdcEQDIpSIFseylznU4WYhHuPvT1Bv4/mTJsG2jeCXL+VnpZGt+/PrAh6QstIV/hdokAPYIW1il+d/cebHtLZFVEbTe2e7DWgrnLOYIavtYz7C8mexN2NEVTnUV4MYaDWfttcTCfIeDKj3b8on0+J34sfAajJ27H+9xSAyeajXIx0fOAvZJY3cuCpZ8KzGOD/75sAzn6pbMIDbQZTZu3zxz97Ux+BplWDBEMabVFfaWqwYfjtAjgaAV/1Y97iAhaCwzqpSTyE+9m/fkOc/fg/fHf2Wfe5vAx889WKuxdDYlyu6OL0pHl+Leq2bE+lBCuLUd0KiD1OBwtmp/8hscjS+k0gcU2NCl77B8RFtNXRrJXr6MCA4/aHYNXsjYVEtY+JGYTLQ/+xz75dtpHaNbX9RTy3IfphvCvd8PySwS417MM7qPYefBaDZfp2eZ79mSobuGtGH0UVeYWtxriyYj+FylpGkzn4J0Vvj2UoVE8kHGkVQSLDvDZKkAwyTRyW5ALGN4+21RaRBMUaZ+U/Ao7guxFh00uOy1PpDH0oTsv4Pqdhlk8V2YEn3vtuvn3Od9loGT9kXd0t43vspY+MxUpk3JXCIiSxBAcKJUvkUQHSSdwelgXltc/f5TxSsQdwcXxc+UZWh82nq+RQmhUX0HCNUszhTf3s917eXdOEU/UegR2k3a3OKzis2KSV6wZNIkKNuDPNYgNNWnx2+sdsLqdF8tihtbgMngmvkfEgpT6PaRvSjpZCTJ99cOVluW1XIVYdBsQM0ESBXtJKBt2gLGJ9VnQoQY14jefX+SUCqVN57+2UP6u4uZzb78w0MmKO97RQO92t9oWPUVU9mQuFnFLgTWkYG9hrneI3rWGwQNI4QxfpJxXuC0AGfHIcgUZvLorGahZFZHSAsUKUe/Hpz1qlIA4dHV5eU17GwzyNNe8Af894KMr3BycyVk/AaUTMpaeohUQ2siB0s3BcTOXYMX8wV+LS513358HR0NPMrMtojHRO4aXEG9U+iLoJl22nm2UZEA/IRpol8zPFaYq5HlL1gZZYBlPCgX+M0bPVarZsInTY1OYn/KGTGvJOhS+MKBcnjLrmrgJmFCotGD+IPE3IHXGRun5JbUc49+i16EzxgoruDTeXa7/arURxs8Rkq40EjoUj0JnsaYL3erjZNPZe/4CLKiLl5FB93YU2JaCQtDnQ0R2gf0XsV4V6hXE5/PlhDNprqAFl22e5W2oxym4F+tza3iijUSoNzbf6ud7NdUZ0GLE6UI36li1gxIDGFjjBol0xkM2hdMWnQa7rDY+i33aSWFlDfdhT8OtgO7eDCKoq1/tSMGeWF9y+OjBfZUs2g99YH0sJg3U8SSIJyBvSY2Pdv/5QbYFp1jy1ljbKtkPHg4Gpv+X7wMfbZSLNNkj0dMOhmrvZTzzzzvII3FGF/Rsytj6VIsbT7nzWYzBXHtZCHZIEwshixn9YpgHPHAoSKYh5OmOPA2AOV1Fs/myozEFQdAeGsXilWSXHj3NBZgsJK+Um9hhMNcTEuDNon+WRr81oTi43KkIZ37l0699gNEZ2QI26j0Vi+yQtR166EhQS7/NIuux98tzZ+8Y8QKLZCUXfVJmxRI1BpFp2Cu1Oj/Vtr8j8D3Gwgb2ykQePIiMJ1PUFpsiqYVQn5RqdKAbrzbsjsD9XFEh71sXPz7vzLFsmfE3ElOTcU/AsLo7of2kkWM615zVRTMRycIRnYyBxv2q4jVixYt13UhdzJReB2pUewkdUsWVgpXgBvfBETa1aQgqk6xKYbhHT72OMdV5B+4bjN211PZ1alkEYaWGbRohEPVqEhH/q4vTW2DVF1+yStnhp58DQLtEQCQ/rJO/BomTZyT5TcMCHQ572MLBGaKOhORevhD8G+RwGfAWQpbeC9pEi3y4vAhSY2uT+m2RSv4qfCDRul8ek6CzOy32XhZmOQhwKbyd9dCUMg1+BJ0mPdZeC1UDvImY4gNjz2eFraAwnHFTiBGDwrUXPIX//VO017ol1OORXspDeSmszMobaWdLZDiu5SqpxIwziGFwTrTwKVhXKOoJ7pt28C7IF22OKtQ9Mvgbs2kUvmLzcGYN3vysuS1yYWOwGV0MfwCvwg8W0WlrA7b2g4FeLyuXt+w2HRkGqQu/gUH4WKf3nYnf1vvfCMPM36F0daJbE5H65tbBKjsV45Hc2twRX5rrAUaemLevIO8Di4z0fSs+1RQITipWtFXG0s1wx/EYrjwHqnFxIDGt1sFh8HotOxLqIBuNkXM9lPUTcCAHyUjjFzNeDqZrl8H3ugrMyf1/Eojg1pE5E++A3l3J0+thvZatxpjMlo7bS5uTe8zAReKamF87fHrpT3Pk7ymTH/Ilg2DKjYdVLUFZbFT5dnSDy4r7zf+T9e2ONr2x/egEsd7/qbZmRmogKQdMfkrVAxn8LYp63lGGvhgtOxcBULo+uMjFS/JcE/sj+pgs4aESU5yvR6jeT93j0QV928s+UTAgAmsNpCUXf+pLI+dCmsuX/UO2zs4A2EErvxGMXlI3Nf8GejwT5M1k3LDzvum5hKOKg/QUDZxsaJS+6O8e5C2OKjgEf87NF+YcQprnN+svvxzuQJSxLJ2HGiUP9pzzc2SfU0AErr4tseKnmVuKNLLbN9qtTRYh4+TbH+LtrIqWzP248zuKP3lehIYBvWSFJkqddat64VkBkEupkgTmZMDw8W4AmGVsaiB3c3gMthKamklsscnBU5J6fYudsyrT+uE8+O2UnakD07niF0rPuZIBx9c+ba99BfWZXCUXNCB+lkgcQQiiFCoi/e6AZ+51CFtU99YW9n3eKoOHNr2XiQxepWFz+yD52kDJFpw0sK4qDYYVKhn5IwhISJXosKdUrL/LVoV2wanjpsi0Enhkikbp625zgaKGse0d8wH8wPOe9sr5iv2TK1bkZjk297GkcfMPHoDkl6Qpv9ck5v473L2v7zojENQczZQKOjTTckqotqANvFumNH0dNp+Z52GyU5hM5Jc3JUT2lEf7crYv549GR/b2oQRzDCxn0GeMfckUQS+F4UfBM6unToZPChqmNNCmYKpr+ni3ksgzrzvq1ZGlPDAtMPBSeGQ7/9hNjm4ivzpYzwW7lV7uFUrFQhIxm4IupKVKPZqHIew9LKLmjgDcRHZDaVfgqpnaPeG3SvPLyvCK7hXmHpz5hQ9MsJbLvwfTn9s3ehXga7sFIIIpkMixec3MOdKMwifXvR2d1Gt8WRX2llUtFVRNmnff/Kg1QjotClnYrM9a4FtRpIWDX7Ee3SrgGvJSVuwgVx1iuQMA8oRqZ+5p/wJwtG6Ke0huslJKQbDjRS38JR9nYP+iLPEPEBcnNnEuztg7LqTptLM+QGd9iWFJdDdyHGHkEILI/IpZUZNX7fJXLvg9sT2qI6k3gNPmKtlmlqu2wntysNgM1+TJadVt0ZyauXXj9DSuhwcLrJ2p6/URQ/inF5/kfNUBRoacjlKCd+Ni+0VoQMz8hLkSB0P/bX1opuSQAX2OVmy9TgOLSCIitxHc1mbjqyi4MVaewBHx/a/l8RrmYc7Mp5Wm5rZ4T7VoBia2Y8Ap1S2stXzo5Pov7OwSEYzrQAtqc+SFw9is0Sr3LfCmdy7mQziLOL2RT0RAlZkh0CJBLpZ/ZmZoc4NupH/9Pdb7uMsNYzg6hmLfKuNIPio7uMs3hUu9u/277j3/eRjOB9wZFLQ7YaNdfISWKAIHC9OUTDsc20NHKD6keVpcMgSWOtLyAhk3g1Hu0Ur2Pp0s7wNUxixq6iMG3tjn82Wr+ceFw873mYNKLuvkxEGFOldUk/TvkzYY9awOHVbTz2eudFJDhlzGmcqxD4rT6MSRn+1hxyyviavZdMr+SEI7t/S4qsEa2KScjjiUufYAybAVeJTw94/82eeZNj4R0rWC45S7Ez8vjK1nHCn7VBXhmQjKHmouoGSSDFwYbGBOETJZLe/uaiVJJCDIH7qQ8Uo+JI/QPP83378mjDnxJ9kzNoPHfzlmBrqjLksUzlKxZMIY4vEF2hDzYC9MTUQq+lMysxgESHgxbdFGa8LmVQj1cwv7K1A/Wv9aeNDc2pwYHmnmo/aP1+JScioQ/sJ1KH9k/lFy5pYEENmkaTZZeps0yKSn9LlJ+UVZ0cfWfySU3MfcLUvorG6MAO9ObeceTX21aHLh56UfhVJ82RZsLRjuZCA/T98+lQ2fj+bLJ8Y8qqzbPz8Q28goDcyx9bYrjReH3Y3Tqv0TbQ6rpEj5csdXJkHvXsYg+EB1vH12f6u/hvzOqLvZZki4MRgNNRY2Lyx4E6RFnRFSDlfTbA3+08mYyfNCY4fSPaFL5vVTBgjl1nVgML10cFh3kySNRBOqpmaodtNRsYbiuqUGztTEeLSgG9pfr2nS9lc7lUSFRUdRwFkysdEYgOhysYNc12AAilDHMm7bkIgA3WIH0hcY8RdnfqVdPSRjvQJEzsiO+ZpQ5VK7GPxUMRs5WPAd2NLUlNubMFkupWvJynvjlNnSS27Vzzp50HAuLuikmt16ymeonzLZUEqgIB8JAl0FyV4yFoO9hcRznKKG2NpFulROZr167THN4fUKoHvkv3DM5cTnCdYRconD1SlBK1wWaWU+dg1Pv7B6wCJYJ5qbzAYrm5LXrkJPhRBZgSbp3M7Z22pvEyK2d5VBDhCTiQ1mZMwKLeeaRAjDCbs2cVr007UsZyDm5vkl13UQ/gP6ejdDs8j7EzXjSuolE2N1JY8JclJcwZJHAQBSql0FV/V2pBauUlqwayR5EtRpzf4KfHz+rf0sFJc/6mnqY6sA8hPmRYQSF5EwqNXGMFprxNKxV5OMzyBrRQfS/CFFuL/bmLnmgMIknv99aPXCLPx5BDTeDg6GxBL30YQLUNQVqax2D9mn50eMagdmAkiRO5SIzlt7jGuQAngJ1NLZAtsXvYS+tB5Bcf508DcCOsGbc5Ev+OUOe/Ulc7ZF9+81R7Eiqtp3OJMOpE9jEVKKwKL6C4UFsBvJcvIJtBDOKf64GVpMpSgYX8tpKnM+1ualORjnR+CG+iJivnUwLns1619P6j6lOVeiPci1Z2vM1rgIuThKDulCw5ZzNIXc2FXt5NeHAye2raIH7WTXMgomvwZr2+3CumBnS/5o2txiPX9Wm97R1N+e5+YuNGo4Yk3DtB0psLotE2oPsQBSZLxCQ7ngXV4nQyfd1iwiaA6vAptNJy16CSkZ3cSZOlcoRVHXjfzph7VLNvAWIZkdZP27WzlbgwU/5Uu5dF8yp2HsBm1m0vOUY4VZwAaQ4KJpdxVazBcYzcIye+pjYKCKRfM7EUCsIPQ5Z2ALB5ZukoUPSIWj439C/yv3IysublljrE4wGrvbGJS2xR1o2PC6NsDVqDfS9WoqPhKlT73avoGrRFt5oE13sbG80kqisq84Y3xrZ69pGcmlhW9YOMAe8+LyFSlUqnvOEHS/u8tMlfFSSDxLxFZf43P/8DLkiwsCP3SojuB+PTBgKe7k80Llp53P7xEIBYGJsQhlcWyIMsk1Q6Sshc9rrfv3RQXGUamNl6Xb1jem29TX1iCzWVyAMCr34YWuAERv+VFnGbXI+LFnKHLpdNGJYR3cpz4XOLx6KWpMpInGw8cLQNOhM+5nAloqBdjgmSKL8k4iOA+vO9F3xlSNmPq1e212ZquaPboCx2Qq/PJE+1jb+jaiVKaFkLRqzkF2bCcCEanRtkZ0lnNTxZ1Z2FTfDuJ8oiURT9T2szWazTc+y0JAuNLnsaBR0X7InuaLwrTF80wKQGLrwWqjgHPezWM2O8DuoIb5jfexw89GTdm8s8XVYrD1gtXBzLB297gc2MekCZqCzdQutdlHYZG4FJjB0gFmXTg0ysc/u2bR4cZBiZWmxWsfvRh/MT12fsquIs2M9kIOo6UXdvrJ+QhItP4dZvmWzhQkBo8DvGlHUNIIrj12759Fi34ipTXQ05J7dlYFHi4n/dl4LEOQopezYse5F0fheYVTuKqi+tcL4M6KKL+XYltxRJOVOqji36E0gELQKlxN+nIai+1NO5nlPNN5nIvw8SeywacBcsgrqmxptr13XjrF0xcPpgjxus0vmhtVxwTtLxKhF9q1wMXLqQbW6mjDqJPSbzDFc0R/Kdj0TaXVmxMUf64LD2OGpf2hEWe21ia52gWLXFpbv6l87yU86nyNY+6YcXcD1luZQXo4uYmenvpHNH1hoRRFH9UYuSIoameX2gDAKf+JLwRRbDemfkKrCaDC79p5resb2mvpwXBXzn7zu3qTLtCd9/NdEDfjR+OtlxQDLOKfVvDHbtqgZMM/aIPM/dC+bqUGYlR4TN2+NHkT+hgxgcoK4VuyPdlUps/KLIJJNvTu5jkoDmmNAQUYdf7SJ7IW+P396K91dYCiOC8iBLwcKOuWgn3wfyDF7xul/lAdacQHetfJP60WMk5y9E5ihYuy7RzOQRWNi+GWVzhbnIcya+HI0esH9WkGdKfD3BHaZuarViiZhF14ZQ8jhmqpsBYbf7goFW3aYkULsr7f80QRoFS/TjGvPI8CmPB78D+jNYXzC2wNv4ZKGFOLuC1+iDwULES2JM7uffIMdP4iRJILTr0fr/l4A2L0QUH2miA+G09lMCfqilDt2FhIe3YkjqjxI3LxCY/euQVlHnYvoFr+FyUfrMO08mHxAP5K98qCzj6vkA4XdJ8t3/ptpP7kONjHASrG92tOdgfQ5rdz+qtgc6ezuDrVEHm0zlmBHuhuMZjF/VYLs0lT7MGeLtPne8aNC/lWOOrIesXwJOyo4R4jPDkViEg7GL5MsJ9/nnRgfpLXfZXXJdXOYdJwa0pjHBbVz5lnmEp+QKPXKE2sN2Uzl6Z8YdDrEseEUuQvUDOLFEdPaXgFSYK2fdgk/cWlgKhT0cD2V/HB/NWiyC3bZej0428/nI0GebPLrTSFMB7O/t8t7kO1YQ4qC5wWHtXt2GyUdqfbJ2YGnXH7DJP1K3rjbXiuUCs6iySa7asCo0GQTrKWZ2GBweCxjinvJY7dW03ApCBcms4pMDmksm0kBqVmY5OJ8vrCmmxPsw8sBrfIMPmsH/xNT0HMEQ/prjJOa1/+MX/i1m+MS0S305lMow34BKw85cIoz5yFTPNpsGIYXhcT4utfO8Fca2Xl/l2CzKeaXBCPNyDBgzUR35WQkuG6vWa/w4WG4+JBAkax0Yqzqd490JbHTOOmA2fRZQ7BW9VuAyv4bx2ogrSQAfDsmFArQOyIh+dawRTbw1DZqzO2fHK4NYxNkxJei6kiFJN4ATKFUFx3ffVCcqTSukG4DNWBmjXrpp5D3RUWRsYEjvM/9X8UAz7scrbEpve7ONKgdohZr+oFGxBgBWtobNHJoKM0Z0GjKEkh2R39izi2T25+gNNSzxEvvmo5Rxf8EjuKQfNBkOimgllqjyIb8ul7OWrr94vEg9QH8Dy4r7UYRx9/etwsh5U7uUuJkYjUCrxkGSLrf38lZYdJMvndfxhF5fHE4+CHVw8ACxn1sR4Fmgqv5KquqPgoi9W09JXfG8T0TlZSIhd0mTlH52GMC0jzloZVPF/dmar5iJ7tleLLWbTa9S92kyWw7qDnPWOvxqCZ3kKOYByy64laaR3mNTvujJNCIQd/ccQmJL7CL7E/Yn3JEVBoVmDkkhVMoSMNzOV8Ypbs9fwCg6hB9jhbKQPOdtwoWcekQ9s3sMOl5NRSxHP82yNqTCPJMwXCIyvtw/GKiRlbZPM8H2j/8SijLBryspSccmE+TPR9wMEFSiK538x7wM8inVxQXyfU1RD+rQz1R3ooRg4bRrE06YWHA3g6GN8fwG8sC01hqbmkcLUDe4IxY4/qVcNAZtUpXOqugMh2DsmL+ydXHa3hAfar7ejCSj3DSl9bRfGP2hTNbT502SHeGBcjbL/KCg6Qeuzu1YKfa2ghN5T4T84fSgEIuHpXGIDb9lEM6I2iBbgfgYAGjlmMd9iF7VPLW6J3vko5ReFsYlyPszGKeLbTaDB+ixOWnt5Ihg5plwXCR0dCpL38ykb5cxmdk426pwjS3DbpocdHFcHsb/1I+vldyiN5fQ1orPcB9VH0UYtY/JWnXd6WFPyCNv3u8CNIR/zrzkr0rTP5LupJjmaiMJWijrj2QsMCPiTsEbDw9//STpR6ruf3dachQtewBEGsTP5zG6WUr35kScFDXYzfOuV107j6JM68bnqrvSsZz8U8LaaEi97rCftR0FbCNW4ujbunLQu98I4jnuH3OaNaIFwxHN//4+obCowZC584lswtr3qFlt7kDL5FjibuY0+/KX+/DX5lMc1SHovpNSTPcnQkph+TrPr7yM9RSw2G2WI2q+r8vWe3udw6s6S5iEoMCnvK1ievG9ZD6FQrCPBCmskIIv4za/uZD/5RynP8ys7sRTE5RpIqPvXRCaRjDElfPzNRQfmbWWy5O+s7CNycttXCFyY7d97MYMepa3NiAXjiy1Q1UIEZIHZ7Emxn2exNJXkvqb4euOddmwlEnnPvRo7b11XMAtugidiP06/UBAUDLYPLLymft3amktZqpfsTqqov/1gxFIIV+PYCls3wFqo8T5+17gCe3Eulj038jadNqBJpkM8vuZxN8ML/x0adQijqa8eueZB0PgcXQzCro4LG/+nee/s8EqRqAZD1sQcZHCRnN9NCzzCbi4yLdo7ZcOCmMyz6OFMCb2mykTxv5i43pX+awE8UYfgFGoVAdNw0izVet1Hc5pC47c/nP8kBkaEU6Fu0r4fco0MtR5ihWPu3edln9FXrUWaa/mrn3Rom8CsJXqzs+v+ymMGOli+DnRhGjNsI3rrm5ukgi15jz6+DygKi7RATPgjHeLpzeZuVwp8k8EjjJYD69kCIAJBSdlAA+KTxdhw0JGoUk1idFRX1MsVo1Vg/uvwU2xuUjZOn4ZXhyoUDyG3AquZdNE25iUmxD/cggPZ3pqqjp5OW3dN8vsG3669Duy0X4IYtpEJiI/HhH2FMuoJKGvVXsqpbfaw4OMUf+4PJOOid13HEu37APllZFz7L72/XfZ36Wt/vJlMfLRWDGjNJDI/5FokRhyF3uGNAgmpPvyz5Bmb53117exwkzr6V5GuEA72Xh6FQantU4ItC5dwcfsP9ILA+1rWjC1LglVTejahwg2auSGVnb8TQUsVzNZlCnhYOyIDQBcutCItF11c7pmFzJRJzaTBDrNuAxsboJulZuSaGM9BV8z29J9ZHqOPc9YtkoJVEDunzYor2zG8chNe+hYwvdmQd0n8kpRPwgRgsyLCAOm2v2QgpmXCwtsxkFCM/C2413R4H5eyFTNZTPvGACvxaOankK+YpCXk5g66jxFY8rN52XekMAAWn1vacuItWSrb+0URO5HaJTueKCnZJRzD1/NrdzulB6yh4EgdQu5WvVFN3uD0FC11XE/9vYDhfwVA7cezteddIXLqiLdRFan1MwBnUfTUzP6en75919hAUGI91GSjSjBnJYj1nIlIBH07SOhdDvXJ+ARuvQq0gayK2OkJtul8Pbiu3dN3Pqxr75CBBG88ErWBs4draOLDOxol1pe1oFP2LhnroGElN/zg7g15KbyuUhawNykMVHHnTWjxc/s0ecOhWtrgWl0OrpLyA7KgZml/pZ5y0uKefJ/YthvdRd6q5p0PqZV7uh+33WZ/hkmpYvfKsRL8XNCioGHBf/Bc4rsDQskwLJQpcqMkXiGOte/e9d5EMb/3ocLMax3dcKM42X8+JPwtQQ59uSV/VmI1wyOw5C/4Huc3kCtvgfBXwB9CpXwrwjlslxIzst/QsVamVMKHeFJx/eOy7tMe+n2khN1bR5XxEUy4B6ohmqyAqi7DA+LTpaH5KD8iR69JSDgcHcsDu2u+xf4LUIYkqwvmjyQh6haoyrxXyCsOIejr5YIj6ccDYw45qMKIYRxLwynAobAV/PC8z7jhCbbKVH8OfTisgbP6iHca9uTFvna0HCWYYk1DieBhrtRhtpLxL+dQCV/41aTqw5Ihx1iQ+U3IStRjwRo2z9cacWXhUKgdwXx2qZvNLZU4CRGnUCDRRgja0G5yFrGVQ5s045jzsT7jpHsVvxDgg/rPCJD/l/bdh47kSOuyNHH7T6UAkEqZtmveJLW7gooJ0+QE9MGSXz/0U6CiIOv1oTUZiAfpWQi4Vnzh0HF/cuqErIWAGc8DkfaF6jYUBerlehB9f0JyYcA5npIUKEEq3T5w+UwywF2rpKUQMWcU3tiSQUkMiD5VyHD0zG1r4ZujJiCFXgOvrAbU7dYMpjSkAJhCJZtXb+8d5qr3J6y7pcDXsfq7AeHkWlnKZjGj/ZAYMCKz3UnWq6ptAzHHdY95OM3AcJ/+NhGvdJQT8lIaeuCxRjm0vrWAYGcsPxdLJjXa1eJm8aTWPBEPPj+csiOow7trXt7GLzur9HiOsIppnt9KPopnikTsJzKfSgBtz2hKOmbgZVVhE+tQrsMyDPeL//+3+FLchQURWyxyTo6PU1hJ53dvKC3oV0InwMvCP27+7LQt7yG4e2XxXxin1kM2Gkb3t+TACYqVWLmYZNf4BUQkdb4+EbbllcDMIEVbbI9qPZPWNao8ly3fqtvUlLqwjz+/Y7sJtzT7iuczUIbYPAsiVMRRW7CP5HKoIXLtEzsasBh830HUXa0znAyCfoYO4NW1ND0fyatOb79A8SVkEcwNvhccUHsP5WN0ay1o/bVwZJYWYkqtsHRyEc0gcmgUUvooJCid7TxNjD+dZC4fqh+W7effQoboP7eImjoX3v2l6/p9ucyV6OujBRXw1lh/TZCtUdqt76Y/STnCl91cfLZI8iHGO6khWvS3qCIDqfOMki7KBg8gvAQ7LJ0nCpBfz6bHDTENfhiTr4HbzFn/4k4G9Ki61y9RT7Zr8JEFJw8r9vOD/2MkjzZhdO99BBUd4W6Crc5sU9GKiMFD84fF5spyjpQQ4qzc+H3lNPe/ucV7PYiEXijkHFTVWjvNjOZtCjKqWbM3PW5Nt9oGx0nMeOIxEfvxOKz9uDO2Q+ar/n+g+Xae2IgzYeNsKV1XE7KHXjcqgok13uz7zwx1cxMgUCyYjlM5aAcpBS8Ynlr+rR5t1ZvpdWYYCRiev853Dv4dtaAcXQoWlgKwFAncSamhKGaA2LCdXtkOwUD7ch4Jer94Imuz0dJo5ISKZ1bicD5cQHuziDRJeyVrVD/J0IocfnCgrs3fvLXFkAUO6WkKMkEyxFnDZ4HKDz3oA92KlpeCbKvIjRC5XklsOAgZh0P+oVQIN3P4UnleYunJLWIfAH9zlWJDR7Mp/Rq4svubjlNHr04MRDlI5xFmD6fdFqRPJXiPvHkT6oYh0qOsCK6AIXuvyYuF23WmFEdeTJdWLkYSw8rq5gcSYU93L1mqTCAPBBSeFmT0im8+eA7iX4zMg4/eks39Sj/H97J50WSQoqv5S+uQau7HKcrT532u3FzBMWXA/8XJvk6MaXhSOqlrxcivsg+R7G5KwV5yJFk0/9/NvW9PhPDJiWW5DXbjXNOMrSG9Ead4zsPgDjnb6epRTdX7DuwT2zpYGmOPdJRFtm4i93gZ6ftqjPDFVU7a7C/uV6AmsDxxkxEWSDMQyQX9cg6bQ5U/R14c43Yk3fSn2C62S0Uh1dUWMYWZs69hjeDgCgkKeOwDB8MaMx/5dEix4Qb27liXl+yYctvhA1NDeGazaoYL3Zg6VEEWYM4azWTCjgEB6TBoZ7tTmn2OUpaVrUGfApSEw1jBH2QJqb7kDGgp9OkABOanAZvEMiXZyojjIIwSaxo5fD0pDzWysLRbYsRcIoBweYZ56QlAdLwhqS8MULarvoI5oeRLtPhTAuJougw0lP5PgAUezyaQoVdXL0A8zOyvoSRPolzMr3uFpDpizOD19AUcOrLosY7mNWLbidHrQMJUS+uqI6P/PvLIIwvNbbYDD8HP1KxP405HKovqus9Nw9VN6w0/bJPPNQprMG4GF2G0CD9m9lhXWj+2nDb9VUS4Pb0RM56b9UQOGhFFtV+IYMoiShPsOHpsNK09LZIZzwJ4JQqa0Wsj6+LF6cC4eHq3cCTiFKYIiSTBEfaBJ0SrqwdM5nmyN/H8EekgF72I5l3tuj8qJIDQZUzIX32+VHG74A3AeEBuqSpNGp1c5pUM2clSiUwMIO4BRIaW23nb+o6e44qI4llq4ZlNk3gGzTFv9AyqFX8Ob9y6ZORonPPAMg0a7xga8eB7XxoZKIfJvFBQQDH5bOwv56kyKHqz70JTAkDOyAMtsI1X4PlwvF4/VMkOR4BaffqeWitMnJn7iqw0topQj4Ow8oiCKFvjh08FbRod7QCJGGNTzrzr5PfuZ11m3EC4k3IrGuSINHSD3f8Qno3a9pJ1YNRkwy2mLmQLA4xgeFCZVfU0I+1Y+VbVNbW9oTQUZ6IGncaiknAatWCiXPH/w3gWiBzjKJpktt5hD//HXfP5YTJDBdy4CgLEt74SqPBGVo838+nwMaWGOlzecY6dtv0FrPPnJ1HAeRH0Oz/q/2SCgBfpFtuxCvJ5KSYVIDHe5Oufsij3LRGtX45MSsiQ6lbVN/en2xwEIahrcB5A1YrkNw6biqcexvoKmw5rcpNZrbAf38ZVR/1u0hP8VuGz74jDCfNVIaDR5s2dif5nir1Zk+Uo2u3gpjTO5SN/AbqwsFXvjUcq5VibYechjj3tZ+p2OIgc5b0SglRAoLVEE/XoYM/m9LLEB2hi19/GDdFITKbqJnLbhZ+4nx/oTmtEcx1AKr00GJdXmD1F7Z2O5Q9XGRqFSklMMRaa8HX6lDjsh5j7rCfOyRAiWFQEJT95Z+6aMybSnv6AqJaauO+OH9L1fRTyZYjyH5fmOysmJSYjB4lR2rInSrG6QUqzr3+MFtE8hllnxgKV+2ql3rvoAdOYDqnOu7uR39h0KRL8Rfsbb+XCv6JpD3C6X+zsJf9LWFW2LXvxQ6OqvCdoDXRnHV5Nh5BbY+5U4uIRURTw97GywgOUrNLK2tqapyO3iw7A535xhl9D2urdLftqxM/rxkfVfa21zY7Wa8ZpBBIqD8EGf+LQdtMpzL2bOFso8MI26EMLNMVbN0PMzHmnfMO8i14bBVUnteUcng/Xafh4ZP0tXZIX07cu/O3sDmAX/nQmf/IgNexnK7+bu8fxKpKkhigHXs/79FPpw6Ma65wZpM02kuJMV9nf4WrJNIC4rRFmS06CQNcBH7IN+aQEUElLmP+ycPncRoTlg4/JBq25jahAGokW37J6NVitzBQgbT22l8jmTzf7cmM+ogVGVoi3BCGXeznoQB5RyBCI0nHxVW81+F4XaPcFp2D86ZR0O0FY0yFDqyKiDhlbxzjaQ4myycBAHxKB/ABDwfZuBRcVkLrX1EJpv2jHhDKGFj4fsMH2Bg0MSeUJYwFUY5EMKJJObR0LxgNfA6ATkYGWHxKHWClHoLbrRPQi+19Q77V7Uq4iyS1dMb7131NgRKJ94VlFLNsTtaxa5OUcskDR5J3rvroPFB1cWtzUBCU+8xEEYNieiLzEpfEoA41f9bYa/Mm/M7qAAkj3pO5AAjZRCEGU4CldTCUc3d8oftwVjcqei45oRvK+NESg0tFrPR4LSdekTQrLwubezQxg3SQH795hPMMvgqGQa+1loeH7ZNavUCAHELxqfJSaSFIHnJuEbef6/vUIcNCq9Cf5sFfltwvR+cyW4T6kepIb/8ATDk7DerOGBCTuczW5urX3Lt4vU6MtH04r3GWRTO769XJ3mccO+7wZvvnhTxkNfbBSQ9ceaUmvi7HFttYut7dO2wD+E6BU2TdXqqihTDjM40WhEtCUA0aiCxGXE2JRF6mJaLDhk5ryUiOES/2BrLNBTtDXjN0xdS19NlOG/j8UObCI4eKyaX1WDGlmC/uT8cxVocuwM9dOcJZXHEFagxGOlljbRhTRS1Eu9mhlGA51nev7Hp1vQnE+bNf7xdqPfQMRmCTL6YFvNYllUDl0FY5GU31RlwmaeMqQD8iuzdLPX99CvbbhDqpzxUidbWpiJSmtArNLbF/53OerVPJ2pvNyZhB7KzDEYapRgPqknPAMX2hMm4aStQxOgJ5qUkApEhIPZIrZCzsG13SI6xGgMcYYMIsTxz64/ma+b3iWcnxDazIf1JM1EUnIo3zaJ3IOV7Cj9LiysOpyPdxuw1hgSXDuW9R8lrPeH0piidw93jV5d6tAZ4Tnoyvr/Sv2/J923Kop3ig052AD1h0rYP0GMcWWQAO8rhDF0I/CCYLsiMy15yJSGkkbi33CoqH5Kk8fm5FbDci3JVeEHOtmxG2RdpilEaAJn6Z+sl0V41gj09odOk5mOUkbQ0XPdSHzB5gN7USeRMMWiE6esa/t4B3BlrmYuShda6/9W95e1IeOdT2WcpVIDOjjufHBFCcSgg5opM2R6ht2qbqDxaLBioS0k8hD3LamG6ojq+hv7bTgO3XKBgZWZ+I89RS07ylSR8ghZ//TE5kF3YwMbW7OtonIE8uRdVT1+9xHEHStH1W7GjysUTOuAC7y3ZkVS6D3OQ5t+NKC7wWUBTbFd+ABxGErwwow2QGEhwc0ktUNQL3ezIzKvTsHqqy9mlXrumegnmV96SPK8r4bki2UIt0ql2lTlTgkXx9jHNYsUbcH7oqpgT9AXB5AbU4T/EobaaGoK+ztW8XD7qEozl7q6tQyaljF8TdZh5RYnlFsqUz7LcVWGZOIXkPiYy4jiB6W+rNJ5uQnOuuANl0hQ6SNDbFY0EVV4iKWPPgR/5/vazPnLLxtZD+4O8Oh+AtSYsXvu41CZ9/WkzBpbVct5sHG7q6iwdR90rO/Dr98CEB2KUDOrNExaTAzCMu1tBfvSKPiTBnOXo5Rd259nJd0bn9TLoSwUqO5xL2mj7Mnq3B2zUZvh2+lFwAw7rd/wul61sDLOrwkAIt9Xlb1Wdv32pAfckEUfRJE43AxiFYCV9ykN861xmCEWMQxYKgOEfE3HcBdk9OElD1VJk5/Igc2FcElFR7GANXXn7ucN56bYF3Aaap5XYfOtbTY2ieaZXVp9+hMGWz1k0xCuvmx5PMCImWliFRlDvC6hxbXS/eUhvpuJvevHWI7d5zldCZolzqxa65UahB3ZXJ0A0YCwrU8EihAbuxl8aHLVLJULef3sLyw3+JllmlNoyljWFwngPR1ftFxz00IyI+/0rgcEakHw6r7xdcfEWggPjl3E2TECfS1/APafLh2yy85wCuA0PmCQiF/CzR7lNMtYWkkq4AVZjJIJTCSfFCE/6caRhqp8YARPB1VEqvFiCShx4QdgiA0Up8OVWC1r69ke7OGNErCVinZ77VdnYN9EPBxR50qnJhu1TzCbxyt/XFED2ag2swLfNGFJuLAu/uZjhD0jV3SYM2ocZnwBehFF/pHCfVN5B+X806BDe8s8EjXZvr35f8YW5qL3AEUKhcaP0t53cmEzk0LENS2XmCUmpvT0JOqD/PHZa4fyt0p5uoAz4H/+stNZcSLRkWqK8UuLmgpi7Xvi5qdvQNLq1Y7cCUu+ABVVnN6BJgmztwSRJVD96lxxcMy8suV3w+Nc5Yu/ZoMOsY78zCxzihXyWsNGowicxTlAszmCFMGEdNte5h5sFY6wJZz3WLwbUHvoQXsC4xndx2yStm8qzTLbtFwxVulrl1XqAEQr1/hzpVrobCZbkCA+dxrG2X4pqISuVORNUaELkxpwUCEEltQn9egYA+yJVFAjCWzDptZf3iuAZGE4fHF66pD6WgNhVL6XxsE0Fv8y2YpN1m3bQAOIDgOmBRJHf2YCZFmC6uSlSQQI/U8Huk3Rf5JjQfbJ/7RioZhkJe8uB6n1hbIszR5KQfikPGlKo58LOmCEB9eVIQCjTUXNBvVhnFtmPuCCpKG0XTyjfLS3DC237wa0kJZbmUR/70b9uQPfjTaBIvqn5XbANiRo2s2+sh24hxA4lmJjxbxQ6AkENg/DxXe7nL7KMKmJV9qDGHW+hOzA83NuCGcdibmNnsJH7pHVmabDqxom3bzLy/tMcKFrbBTy6be+zhk87uXQTzJxL8FEO1/RXOtN3sG3+mw/nkMn30Uqkrr/8iMNCMxkD/hxRX2PcuUHOuuha14aQ9VsbkdnDNybQAuet/iTUXiRr2OJBUyxDJuk+pEDd4w3v3W511CUz4D9cx5UhMiJekysFOl6vAzscslXnw+i1Zqain8llu5rE3lugl5AS6F1mq1N+ddH3qdQ9INGZjIZsLaCQbYNX3SA8NckGfMvg4INFu3kSPrpOJy703AExhuLWhnboqNH+0nlpF31resMeM6gvT2vHHunvvG+5mmN7SD9LMz/smcDa8dpYMR1eAsj1wFR+0lp28+3uVA5xonjiFLPw8lEjGKAXrttxPK9ngBLAyIcqNUEoj4Aws/KafBJZzpKGIPlXIyRLQdyOmPzEedlIvARtq5qOqMVlo7vKGjAcGhnuHvU7VwAGcc89b/6MJDfPSdpskNTHjZtKnD9l75AOhh0uzrvXIRI8bXw6qiviVJUe1CQ1OCw2bZQ0E9bwOs1Pho7X86zDbR9CuPKMn1Bg6gK69xX1hoaKt5CiZaMP2N8f7qZSFqtpvvGUPauS3pehm8lNErpV5/qJhCfGI0lzrG/Gbt2OKXIDIQSjS8iBRtFDVYrm+p7yOuSfSe5I4+BgZjPJaIUl2wWWPz0ORxbVWy146MIT2VarA4mGji6gs0JW/Lq6OgDAVRalETRGiIbgSc8Jw671ipA78fDHCUfXSk52oMd4FGGmAzrQ6rNbmgB9s7aHmzjREqy3lALZJGaVqTRjfEfrikzhaFLoB6wAhNDHHZ+ua6rppYDj+0d1pecAqEFjz43QTSgH7NwF+LTgFffez6chvigi8rCuo/o24SPx+c68po48sxn0fe2wRIGqv8a8pVPobkAzWwRSci5s3QtWSRkrBYpTzKXkyWhyjiSpTpVdVvilqo0JZrnStTxQZ+ABaAyDUutzDJzmIvpRmkYc+u0/QfmozQsjZgOrc7G4+qblsycw2CjsCv4Z8jEptZhdSs7Zfoy6V3iKRWYDB5HIpgV4bBCN/4cJJf+Cxt7yCxjOKz7XcF3IFw7MLF/2BWqL5RkUHEU6I4e84nUsybx58Z/sT1AmQoPAhlKF1PFZvMLM5LOrvqJdPJMGvNNHXY1O8FrB+lGv2o95ZrPVrvQwGyXvHPfusO0ATEI4nMtAGCmATgXEuqVwRjvb0JHguVmy90h3HJjhhlmPhBzOXRAozqYCiG0OU7v+MGH4tkiqjGttNFy5HBpXSe1a+/jWZcyhYM4gkhy9Gkjowm3cPcuHnR/c5o/uq84QwX1wAzVboGXR2qv1m/vPEN8iGZ0lDapPKeaVhlWFZnRcTO2D5bZ5GfW8tHJTtigtoFOMDschktE8h2hI75jL6IN/WcioLTaeoyfuicmGRs12hPfD27BNo1TlHSTn+bLPmVEB/2aJdGkYPUfsQpGxqfMWM0BMgt0xbaHrwJen7/9YD/BW1evmwfA3sxkLI4b1sRd9IyX7JVtg6wA7PxgJOfpVpDOziGXGrKg7J0rlINyXGpTcm9UiCxVKMnDZbL0KGde8J9g39/yrlu1jTfs/BAbKxCwWgN7KISbPxiB/1A1boGxlDiVp0Uds85GanpBsxeRjSqX8TwJuDK3nuJ93ycDepteOSpx8vUiOaVOsVVQaJLddpsIVjCq5tPxgZ5u1rsADK6eMrIbKZoJ5FL7xyQQKiXm6xtNcz0IxP3T+pqjCh7F8nl6FqEYPHcDllDBmG36Qg2dvXJOuiatzKOFd3TujOTnblNp4i0ukamE4Drvlwhdm2B9/b964egvr7UvQaUHTEUN/GdSSGj10uk3phYaJQUM/2Hh7SgnJia8/4cZRbQrp4miPaTtaXOatW4J3Dkag/MSBZfphVAF87YJca7iYM58duQr+ah7A+7yhurzgQEmbcohiT4i5UAVagK/DYMJ1p3lPek0RN9/dLCpIio7LdZGNM9OlypxjPrYW6TnNPrkSgQh2+UnpoCddt6Qk++263zUWakXVTYX85cRVBaEi3Xz/eU16VsMSSIX6tODedG6u7ZNuSJaIBIyfRUC6aoInjRMduKTZ6YQ1an2xAqvcGRuRY3N6sHCVhbCMNVfhnymw+2IHC2/0pU7mT65sIGRrVVJGfVDBcgal+0+v7zofxaIN5M+CUl2TkPBDnnPRekIxwR57yXM7vyw3wUkM8vR67ClUFIR209zYjg+UKzTVMBTmKfm1C1Vo9uF2KSpJ0FdkxmkRBKGIxdlVSDNwPyfNDxCz1dnTKGC7Uagxg3uyuZgMGfD4LUVKYgNsS+O/xaHFPBZ5EHldIo4iz3960aXQ+JhesTdO4EbuZqYDX5Tk48mZlhroSXZYu17hW7l3L8Z2rt8E68eU7sc/z78lfjQIkyD6Y/lk/THaxUXbPQ1cVk3z5h2ktDpj885lSWU6bADp9xtIEAqfOFczurkjDtd82iNpfXfyMsL9kV/KEBG63au335NH1kRcvaOH4IqspUgE0EdDCeY/05A5AV0JaJCWPJdxl6peHxLfM7L6ep5f7HOqLIRSHQd6/e7ylFTit94LpY7mKuDBaaOb10MC2L2klynwFPbJIZO+Y3f1GqUI1A9rxergXi2XblroVn2GdE2YmaF4pjoIFk7kqFeo47Vcz5Oaay7/nzF9Snn21SHm46vltq0GkUT9CIwCqIj3a29+gtgVl/LLbVHI245whIxSXNbftnLTeBpBD4Z9LppfEgRCpD+Bgd4B39qLPcbxEFAVgl8JbZOLxid6/1Hncd0d9NxJPzWgOamDl18sn/gQ7ChMc0dOtqcyEL7W0TvpzZfn5bMH4PMKl3HMyuP3CqpScX9InVIWwop83ozQnbeUstdSyM2PbnCsKaUs+u8x+T/ZJPqR0pAtvSOIzaUplHl+8QsR9HShAvXxd75q3tdpPQ8/Z4Z32IdGhCejwWkx8Qm0KVxiGsyYwHfs1MNcCj3hAZNZmOpztZeRnhxSF2+9CuUZlgrHyuy4qKl27vXXgc+Mkzv5ybmbrnO3qUlkKg9VhPNB5cHBnxPeJJlgl2UYsxZ7Ro2BXxRtCwK4yGjfSya/eFrtQqC28Qn09L33UUfX0hFeWEfk9dkEUokuNCYdQ/IithvIHlXHNzTguaSuUdBt9GP4H5oQLixImgo7lkIshxQPb6gjnAZxBy4JNTCDQ0bNyvfQs6awdRqsUkh8NLvIm1wcaZb9F/rc4eSx4L/rEA4v4NhcgdQLFQzxD9QaTjXN+mA3qsXEHspnu21scazweEgKSv4Mu1kD8Tdk22eAu65VH+AE7wiD6RZlfYFNl7Epjq0zvfm6mBXmHjdFfiPQAVymmQYWsQ1e0VlY5MH1yZ2XD0NPV6XDrUVLRYYyjDb/i0pqtX/xbNo8wdVlHywLjzvyKXyTypA+oYld5kbL2e1B5nmnmWDCkTzl8dr73ndO32JB2LRhh8MGWWuPEHAq4V4/nmHDQ4QGkPKCJeBrqYJnA4IxApSBKiVs0O8OV2l/giO1sdUBIwtC0sLOaMrW2cKGowky7uttCh9K9AKTECMrIbUZTRYQG/5lZ8upKIMpJo7ryWlG4MNXdlt3hghypoDZYiBbmVybUlPZqXKFlfX9efgW6DLJi9gcfpqo02EfVWrBr0VzLyR3MSsqyLXdP3cvlGJSsdsgR85fNpnpcq91i+4z+6LHB7NaJ204JPe8gPMOTmE5Z20gNltaNtetP5nWoasSKDD+xqNkRl7NkacXHVBcyshY68IayZDqnAMJVGsFk5vGY6/VmgXFLSh01yJUF3kbjqMsm7OJc3TN6yUhys+C3QIAjQAnQyDXb6Rrx/WsXeMm8ng10FPXEpNBl5d0kQ39D9uGKjRue3KGgqVXUi++d4BdiGczCtpms+bpptpqPgX/2HJZEonaOy2I5rvoSUpAdDxAT7KwkMiiJf/8A5T8hmRzRDWHTWHePylJsQpaEurnGi1nWjssuU/CTCsFo6tmIFDpOVqq48bNK0/sxBSTlIPs6A7REQeTcBlHTGPwiXOQ24kV+lg4FhRxCSERNGyIfDZ79vuX7y9LilUw7zJX/Ph/AYh/BVASnCL/+WnVf0ajHsSNwibDbmRGk0fHnm1zS0bjkuOmffTpgAxEy4OsS91irJQBQMLL4N+sy89JWUbFRXS6jlpnb6bj4fUz5PVnvtz6bDVbbhSCvcH7x/Mv/pHvXzjeZ7C0ZlDwZgP58PKTI3i+WwdC9lW263Pb2reqCH32z78sLlPxy+xI/M6/4BP0xY15iDubCv77fJoLps3mgMPbsOwuHHj409FSW8G3DWRN3dY3Ity7SFKe527R8moyOnDgQyiuD7jJ4H3LTlKnv0lJp5bfBTo8ySYK5Aq0t456s1ALFdH0DiF5Xz9jp9nXAOu74Og0GvCMjLrai3TkSLAvsj6e9xKLEL7R98OumglRBdCiT+guLpXeFrv8XYjROA3Vhb3WuzfPtFt0S2ssSa95feeHDfVY4bKj4uCxsa38VOGRldq5cTi+Jp0lnNRNsXPbhbMHd35HCYc6dYgUCArKkY4Xe7lFAiDe0QudP4U4Okvk2ITqVfyYrELkQvs/sfYAIAfJMMODajYpBSSwcu/70GHwIvH0ZH60QUf8MeXqCVNQvA1czMTq6qJvCo0AAVH0jAqkn7Fs+8j7FZQHhz8BpCWbT1WTbUqx+2rPGrCnLaWlnHxFMqcuYyr/PU4IDh+IqlKIuOWjxXkcIuQhBho55f3s/CFmsgMCppt73myZVGYNi2FOWin1VRFto+JQI4WbRd2p8wBYqdGL7L+kvyD0NUF1rI89HQ4WZESWuMePnuR122K5z9k+3czLbU0yo5W63DBCcF08wKfGE6UyC/tEovxl9vHoAOk58GQSDcQR+1KV7+zNqkKfSxHaiEY99wuxgbLklPbB2Xp+C+os6HjCg0WjFB3SsKs55zT9RM0bEf5gY45CS/HrOZYY32hMqFcdqVX0bkPeQX3Rqn4yUwiMwKPDnzAYxieA1c9+UWDPdfnz27ucbobKtjJx5d3Xvu2dFfYT361YugQGER5+P6aYIR90mNUBuFGfcvHqD5uWOOx3nANlCmgkY6Hp9uKd7swHyVod/+g3D9M2xi3QvvzekK36bVBCYx6qAbqI0xXoSBmV8ssKKnxi3l89P1WoXmzU9MLVfDstKCDh9bHywh7pAVWjrZ5kbtlAu5l7mY357CkzgGkMTLdQxo0Og7HC+56excGPnmXpFk5uLZRf8LK/FBmwQkBYayL2sjbZHPUfIScDZDF8xXhb5vrub1lq80wCcuunb9ESf6FHFwFCr8aH6cFj2HrXbf9Zf1k7zi/5tWkjUIJONAOvF+HyUE7tFy5D7HfsHk+3hMWoJFblLLtLUXaHW7OiVudmcJbPO/FJWx90cKJqr/2UPDMm4T7Xv8N1T1QX14Kp8YCfv4Rr+PCAwSsARyiUguSFbhrZe7JVqDaGH/uXSG5/NuRLXRbGt55qYfz3WxxF7Z0RRjHevD91kTU4jyCSNbAKsEGvpDzx+iDAOVpginqcZrTEa9sj77bFMAun9qD6mAI1l2j0vg4RYOHwcMH9yXZctna8D0Vs+XzC0Gkavj2AFtpRxeWJhH9xADOREKNtAoIklr5cvImTAAx5pcaCEpvgo9Ce0tGsy94w1gHVVp4fLC0I350Frh0uL9D63fDrfMb/9VFBeWa8kKKTTkY5EQ3dow/rKcsfEgx1mC3PrIkcqB39D+qGcFU++UdwlOLpN2lAO+RfIdz3PkUURO8Z9Q7q37NIZDQbaCnNTzep3QZnUZSwhWnaEGWP86QfNUxhFzQfqht8mAzlrSbTa2+q3UNYG+IGJZdDWOGWZfi8ruTDl4TCLdHOskWBMJmMdY7ah4lXgOnAPwuMB2Ncmv1xgByYe+FR8qY04NiaGIsQqXyLkNRP6rRQ+R3kqVPm2H7zLbZ4Rtr87+vdyMkew1se/4VxRzs2ohnAVKEYgu8H3PICnO3oAoQDppLpJzrQTnQodZROlJqhLDw0GrTVsriBJt9uOE9fCRtE/NW41OmNMZXPC5BhXdEgALISJoPFBm5B0hgupOxX8avj9/JBXwyrNbdWDXLH6E9VJ5166OF6ENVW1vC7KOlomG7voApvHF+ZwMYsqO2MD5rF7clHBsdrez/u4gS+BzjPvRjdzWIYelV+ZtoIOROO4UrdUfijmf+tYsO/tCdew42HIluROCya3Bhkxo/6k+3ZyZF3kwdYcsP2cAlwZG5ovcQm5j8oT2812av8cgVzHSNeogj1mVOvW/hwhqXEU/Fmq/ZUOSA594S/DfWo2aoNXjFMxvnYdqPxqyHgY01Aes3LgudSiXrrS4wEjkXUDFuhcrpSr+PJV/wRQLYLiqHegsLnNjEPGpxsCIZU67kzNWL1o2u/88NIP7thxL3Q1Jqw93MYIQVe2+ERZP8X213MTdiVZmeF30dPl1xLS1fge+61BZ3eL6XWbGvRX2O3Xn2l9Z2Yz+OIp2lK9JWUpKCeHUarFs4DO+BOMrVJfQuD08vtMugrv729BUKmasy/VVkRxGQ/3KrGW01RRlQiwz9Nd7cjdpZxswnHUJlQct8C/VdRNm58DbdVGcJT5E8aFXsMrQ5oRcIqTkdI/LmJjpOs9+8QhUY0K2fCM6G/mFj9WM6KkPKuKGM7dErDG6stFwxSBKXA+rIh2se3g7KQ6Cw7aHkgcPvUtWtl7l3vMHpvZ2s0KhuT/fTATLHUwpaD6bwvJjvTckwF7EmCPta8ksaAOXgEMBKMwHxktZ/b1myjRqf2fVMymgtoGY3JZcN0zL1b8dh21iRlVVKfzNPoGwHdcm33rFcD4dd+rVU6ci6IoiTlG+KwiZJVSgWihF3I7IoQjZj+6w4T7RVH8TEZ87TQ39GeLyPM/FChcW+etPh+zCikBKDvmGJXm+56xnbOL65Ry1VCTGTwd6PnAlE0I1iiekfJZvGwmdzzgeA3Q44+MN42cptUrCZj2PbgsVW2Q2OpTEFfVx2CqIk60p4cnn/Ga8KK9xUXZz6lcZlQXFUg+X8GVrP/+EvptRhCW2kXDDEBqVy7/ciza97nj6LV0hf4x1S+vMisVypxnfZ2t0rjR7je0u1sZhaHbQ+oESKo8Yfb2OCxZHNcfkMlQkaucYTbVgsANzoI5KeG/misG/Yhz7Lx+uST8FduY7jlFvpmsiImJI2LCYDql8NSYyDrJIYai1DmQc9Di11NbDi+fTuLi6Rtp7uh6cJEfxiVuNzK7VhkygfGuSmobPa+U0XyWhWBFd8PtVl3lGy7ZLeuWoHbnUIcqEFmYvLcp2y1CRYwLfeqb5cI/qbFRsFhsY4U0T5eE7Cz9Pu6DW7sU3zZ74Zr2qxeLI5i/3suBI8xRU6J6Qu2PhlBTCCzYWIE5q6AV+MjcsgEvoBxUKwmOFBjrT2n1jHSIA7nqzTt62mH4xleWqzVm/78CmEknzFS1+HpaoE2f6AlbjrkgA59af2wvbZxg1uDqBtaVYypaGO0UWLPKndzkUBf+MpiXebBPJVKX2DbfWpZY86IIei+n4LiRsRzVwfnBCit9j3NA4oFQ6Rbfg7wCych6Rlrhc4NnpMYUQwHufhU4jC71CNhWgJl++eEjwH9GS+uUBp9fcddJdT0YatzIBCrOuyiCHsaWf/gHg8PdJw9hOgwuYCKwtqoQbjwDO+p4KE0Dk1yjSxePfw/ci0u8Lr8+dKgulNRNBNxJHWdCvH60U+wfeKmzCAAyjMkmCyRcEqvoqPF35bqRhkeRS19/Q0yp8Uk1jVOazyPLyoUr/90eJ5+6TvPthvQV+6uLYzbGJFV9TDS9/GKrACUMRaIpTO4Q412tg1g6Z4ODkviDmsjeBf2pJ4V0u/FcETzYo+EfMRigzlLmTbK/Q4bxZGhjGwEX5tmfnDe7JvBna1DA4mVH6fJZQLoYshZzamJ5X6ZubN7A/iKVo3fTOTIM+Q3Xpdsjen6QUHjm8sVXsi1urUbJmGmUoyRexsjSZJbDy/BR381fuKY32YfbCyvWiMoHZkWggb9JDFEIqaHopoh565xu+NEXJwTUKKaZa6Athr1fM+q2TcNREoPyU4T1h4udvgWgUtmUb0RUdJJ8DSRoXT5UcfGek6uWFsy+nj8jGeLwO62KvilW0wOzQ5bIWCaruY9j8ACFMm7TN378I/2gVglLiuJb457JZXN733acUZJvMQkwex3gcf7OFl40SwblSndGMUgJsFBefLN4+Al3F0EK9FDgpuX6pHwQ0TwgfbTo4d8H3YU/4lHAY7qGQv+shDAAOcexXVNXMksibnRSghJz3mm9ymSxHsM1sD+ld40J9PKJwYWUEdNZAKi9XijGIfDWBgffJ/w9rei2OroXnQb4S+HO7E9ykXHF8Z6T4+OlQGA8rB3Sb7cABvdo7AscJ45h1Nd4fUTN8d9iaqgyzGoK1caereSmDtiX+UKxUE33W1w45sMtDa82sycy4HZzP8iOkgn5Lzbgkg3qOwrHQ2zToFSxDhShvbH4VDMqUXPA3L213R39zclwNyMZyCwN9H9H7kSOonz1okcyANMQ2wI1tosNYPwj5J6UjHix7Nc9WCi6YuIX0S4UnPFEfuxjKHQczPWz5uc8qcve2VlgyrWR/w5o99pWma+0Am6a5UBaSe5a45wiebZJuZijhUKk9P/pTur1bc48P/N6Tta9sfXpJrAfEYpFSi8NqgUcfxDNRHsUw07Z5VIZymojZNPK4V/OKPhKCM7G+z5GiH63UEMM0DI3JuKO0nA7aV2hTFTt4RCLcTh9u7efLu/0Ezg21/KoICXXlRLAHVSkiegSV2sxzoyp1phuBZH/5mBF0PP+llxj2liLCN7F+WZMNLJ6vaRRO4wK3phlv46fV5zPC5i3pLZXAhTfBDG0cIDu79uKR9U82VFs7d012dPLcJYvG3e5mplnrUvU4PlsWPdg6+1vmARS/O5CHnnWAc4mOC37Dhgoc1UPghSQy3g68KaxDgd3TFvPhyJZ00ociu4Xk7CIK7oQqT0DXnhI1rm2aYTtSRhYiwZDbQcWxJ+MopkmL6U7BUd7vd2ZZt+1YCIW/zzKhWmKbMi4N9TTmnFsKxqjfEHAoqGpZmD0KU07wXxtxvSnBnwK7T9Dcv7ioIe7oPDpbbRL45p66jUJRAIvUDsf64CmeA3l25FZXHCYg0l7uMbB8IDBt+A8PPBXrBHFBA+qGw9GFgpJMLSLfgFfX53Tz16hoVnCzBME9D9WTKfQHwv/tFPTOHDua581btGSzh51MI0SYeK3wtO6kIjyH+N4t7M0P+yMz2xvY/QgS+6OGiiYOx3y63e/377lRamMSAHhPc9g0Gi8yLLaRdztAfTvKVjHIrIAKGF/zj9JpUzicFqiKEUTv9pQaXm4ttzl+57Z7Oi3O7DlbC9crteGE9DHkhQBEytZC1bXq2X96PMhD8C5LGU/DmkZ2ZLzZb4dhFxOfyXkzyp8RcpvBFirGgbVvyu2Luk7zPQj8W9g4SdcyHpr2uySj6n9EU4OQkxn6y31LgEjOsffMOSsiXbj8/nZlzWZ+sLywF8vEX0rXiOlIw0tcerqrNDin++ap6DkOLUiNicBfwLYtJYnmpw93gCJbYK3V4ccDkaK7zUru+UScjTY8/Ts+O1C7yvmR1zfcJnbuk9Dd8yp+GoeWydSAkYT/c0TVsKIMzBZl1tZajuKmhRDE1BzFV0N3TG+ZkqCBivsRia3jCzLq8ok0ck5DvmbBbmPHV66dLA58fHZDAI6JGEQp9WC8ccGeSi4aeHix2sawWms0K4w3pH8y+WoQXZBmmOqxRKbZxIRDhsD5lZ0ivntrLMkr47XoBzIcAamK9nG0RBzMtPgGcReDVRAJoTQz6vgWrNh1/4UAFHdHQZkueC82eAeufdHR5skPP8aXTcTwn7YL3cize+cVlbAcMBpNo49SUfQhZ8OPJqezln8EdEV3LLrgHSLgzENS0WxJYymFrt4JNBs4S8cIxbJwANqD6jnV8+vIe16MQHtuTCwjmPZs6QPkb4ybVfZoC6+H6PoKHwKPrGbcKfGBrp4vqbYjKVkmfA9MYwjy74aDBVd1/iE7QW+V6OiPhZx+tG0MsoA9BXmjsP5KmjFwevThSnfCBqbJKhb5YHptUDYVnJGHbdW58tV7O7qGv35fI9gD6Oq7f+fw3oMq8+ojWrcDpb8Xkm45EGwgNEVYQ6auK2xKvs6ss2VRTudnPzXf4wWQXsqvKp2hebuDAjv9FpLsnTUXlx6xs4PmbBxNOD8HH7ogOW0KxEiKYvG10x1kDGfFyfbMskF/HokJRmw/gCnU16gOwOI9iDJwPN1v4R9qCoI+6hmBzlDhLlXWBml8PDiSbJjuHxNXScG3qWzvk/LeN7tJoHpjG4BGl1GgoPuGHrGxcteV+gJ71EGZYQ900/9+soNTxD4aIfH/ld/o/O58tX+64ZdOYsp/PLlWUwphHHX0/hX+lP2DiQhavmuGwHPi+Bbp/h4XZZRjf7YogVR7gbWniLbwXgn87KoNkODHCoDIuF36HRPs8uDathb5vGQiDS8Qk0vRKBuo1f0UnmmTV+7Vqbn2g8Is6lk8cKILpBVyO1CSWRjH9XmH+yAI1B8vTfgtXCZQshtwg3JhLsKm/QqWP/pCtNytU5wSPJ6yiNti8h3RDUh0CNFMgQ0ijeijXpo5wCdRu4GCWukI4E3pnu76qemMlvczxj8lijAxJ3acz6nllgh80K+gMY5qY+fOWuwpgR7pAupN41HV/Pho+JDgfyo2fHyhCZ0cQAzHTRjkualqOu8BcmEp69AV/GKfvdfU9r+EKkFEUKcu0JtuQPIP4kLmahb29McRYPoN/ASzPkvgzK1fb463tA0E0y+YxBFlLiwFNgC+tcjV1wVN2II7yexUJspftphbZpWSl6iTv+hqK1FqJ3yzDR9BOd1Qu9wU1X7iZOS3PvBaxEJqCtVpITr88THJrhjXgem9sDWdnVajMds9X9/lNfhnyKJC1RLf4fw+UUq/sx+yv+yk2yVzLGbw4FWP8sNC1AwTEn6Iro0cFT/xYbG3OTHJcYuz57jQybdZo1L6srb+UpJ/3SQ3JnXzqVIwRwSbVlF5TVNG+00OmUoFQYJb8wkLFiFtAZsgbyzUyFHQb6VVbGfdYK2RFPvv3skD8nJsTljgEuLBiHJeiJHkOWWF+E4/tgSaP9ApoMcgFVMXq+67Xbj3LeLLOMaHgAGPGSN/c9RBMXUKzBd/U+6QAbh7Xpqf4bw37iQDCPORKoqs4459GgLtiU/IPJnUYOQr/F/D1g6mQSIGIeuvz4TxmG+V1gSeyiPdMt7Sn+X+2y5yymXvOjJoLbi49rf2fgmuy8QwUL4Mf7Igsbj8P3EY94JZB31IOiqdN+6/A/z6PelTM63a5fKpYAl499iDIIMy0Y/VnIUb2O4+2xoe1jgPtxDC90MElrPkQPnWygJa+9eS4Z/Zr/Uew/1bEHQ+NRiaYcsy4fCRpTfkSfk/X6O+3OGkRNWg+qHsh3odR69vHhyepzL52DzETu32obah8Q1tXgHqCu8vwwHlcW3wehxf6RW6FCBEEzBmFyzRI68egHlz1KdQCIBpw0Lkz6UIDJYxP7FknvxpSEGoJviNs2NWSDpz+pj/IhA3soIkwQ4xeDiGebh/N1dE3NdEg2L6TJIaznqVJezEzjaHHR5XsldC1He3YH009FW/HanL9/lt0aS3DIbOXSGrO4MlD+MwTZW1vCaqb0g0n1q89ngBXQwUOJKK3UBdoMnBFXJa82kvHBrvgVD40YkEyIXKHzdjTonYCJPfig17cjRmqVshNi2R9Mm/JKLjI3iBAh10thvloWdtljwLPXFcPqD7J6go76U0Eb4FaStbGWdhXzaPd2063IBAD10HKrf2po1zkKmkODac6R/5v24dm1+bz/0BAoGlmHJ5kqmCxm7JIYiLAH1cFc+O89STuGIZB9chJTwHvZw9TCjuXK+AEAoQ9ayWQ0BcFSPb37oE6dlj2uGaefanfi5xDMfXVuGFdXEQL2UoTLmMapx6V4spXBxHv1f+jNprVddy46b89vCq5G04tlvgs+opVjNXehBqYOi25qaiLN3yLnDxKsO5VDrn78tMd0ja/WSKKQIKzKJBAKFJ9mXW0mUjt1595gltJbwGWXw4pNrJ9/tP3beBaewsf2Tc2g2h6IA5+E3HOp5ms6hqFmy7OWqPJT58nE6YU9OXDe3ugaAQctIk+fbHKuw+CO+T75KFdhf0baN0S0wnxtPhp4Fe6w5Sk/M9sbvSS7H8QZF8WOfOoyfUBuSxcaI1zHtHbctazG499RrkO5xohhkH61YQxwMjP+wSnYi4cq33tzRk66C6wWNFldWho1+ygpreqBSpaYNWpEMskhKE40Uy0W1E2pOP9JIN5C0+72+hw104iIDzVCRMseUGw8iWnPcpDEwRv4PdcHFZ7x2jyBqtcsqeiAJRQhrkv42MvtYQlHSAEba47b3mMrBFVzTuE4PnGIkaISdSexCTySbxLCCpf/uz9Qx0RvA/nnMWFbmGQJGQ+DXSoYxXeCpw8sdPMYgeCHrq9nb8QKiw95azn2Lqu8Zn+oQ2Iq1MMJ04jroRYNoe3BrCai7t4BST/bl7eMWc/OBNpgzI/Luzjifid5vQ/q7Zov09E93+P8eeUjvekb8/7Kxn+dUiwx87+1VfY4svTF9ek7Nv76E5wkU9aX9ymeiqeEv7VtTTTigB46JBXEStFderzcimq+Fp68dIJCXE16xqnBjlgtmmoisDMOLt4Et6BPScRdMYVz9EW5tX3XXUBFk8y6pgnZaydNm1Bm8WzmEjTfuOKtsdnQoineiknmM+0BfZUihuacHFoopEz6bU6RKF+FFEyLUK2XK7EMIhcVqzJ6zZ1yMC7tHPyVg3PsjoQXn3sZiItNID0LcTxEm6As5hjmPyB4AoXKldg+cQ8GGpzHI1rWQajF0elG2OgMA1DWQbD1D6MO2F7M1Mvxpo0yFuPX5ntIhfslcwqu5UKv4niwxX2bE/yWsiwV3G25X3P0Hpc9XD+NhpRO2jxP0R/oVzgh+g+lxPymMm3oDChKk2X3Fu8SjDmd3FUZ17KSEcMxE9fFKgPgIBC8qvH5aUBiS1OcVWRAu58KQ4iq67g4kybE4lw4oISEEmYyxvjcz5YmA0JAuahSe9PVzv4xnAfOfdp8GTX9I3tHyQrSOYgv6Thr+vOWyhKWzNAXXXAFLreqjekreXWzt2QS/YqFY2rZmVuoASZ8GZ4OrBHuj03kNdZTfSUZJvqLX6xoGPaIVeqXPQGPqX+ByZBgjd4hQqG8D8PEub+YkYW/rzKciqzYLYN4Ar9yPftODSuFnmBQz8SXcRxoh3IPOD7RVaBrr5PMi7poLvD3PgAftKbGX5k/stD3F6iGrus24p5/hMnSb0ctG5V2SaB2pm6r5aBBsz4iiSdkHfing8HRew+Cygv9/jRfgLuiMVLeZKTG4tU/Be92gdthO9pPaILVR/Az3bjojcwsoFg4LU/RLqG/bszqW7TbNJRHuetXrs26lyqKUnuYVUmfK9eTHgnqgMaUp3Ssq4gP9787oAhCraTPvssBn0zsO3o5Dllpn9Pw+HhmgfRtcV83PvlyeWZZniKKZMDtk4fvXReBtP5TMMb3+J/wMtHw7OHM+WorxCHbsFeLqtj/iceVWmOcCHSbQr3DCl7N350TwHHSRcx3iVicsU16l1+tsjPJK6nDQW/4h6QKleOL2sHbF1NnK5JujLVG7ZX88UwoeijMvPsWTwRQqGqfbJGeUUKbpxbq2oWeAqOYvO5guqw6IYauzaDsjPQlOnF2GXr84TyWf803h1OtcECyqf2Ju0sSqF8hzsZ3WYsNWZtgJhBm++yahqR4UbI/3dsUw3X92Cnq4TN3mt8TFfdSYafPP7Dal1FEoTCG7ysN8ME0eigC579uLPlzWEhcnusGlJancG7oEFN243RlKchMvEKZFIXt2qmP1zhTdS96aUd3atp1/ipwAOEUFQIh5qmPHNlV2S9xK5ZzYpB7YEGLI+979F+W+JHTmaM3ZhXOkS+ICOn/yhdW7WoIR+4dxLqXGz5A+PLwWwQm60ZbEiCw1sjqQOnMb8NOBCikLft/JJoTSN2/NsVUXL1LiLXYsHtAFHQlgR+JiXXNDRP/xa2WqM7W4X3TG5nzlOTnHEPuRuh3pb3iRWslGb/47M6OOphC9lepbgxn5Vdfl0lKMwVMNvP69UH8i6cqwOv9VQQf9s62tX4mG67R+AwUkBELHCyG+ncTqOiqR3s61VT8t0N9cfzxErR9eESmtkB8JwOXwB1xGqe5/iN4ZuGQoSh+04no//hGYqek167QQZ/ZIbDU5hRdRmd6VNL9PUP3+TfIvQw5yccrKDvt/3godTZRWns4isAaSKOhVxG9nW8g4Ce7GuirELU/P1v1VU5MwsucDfcgvmvz4s4u3Wx/LezkiVvF8bw3/8GpqMZHSD63Bqpkr2jMIvo5TqGAG5SM3LPOkfjKw3pafevPVxDPRdtnQsPIS3Y2BFE38M6WXEL9Sl8swaW3UMraF7/Cb8WfPgVa/pOMO6kUPbX5CuI8pCJlXXTtBLfpReFOsNVsxJfdyJfh+63HOcYlLKbpAXrcbjqNsYzVJv9jbnF46GU7sGNGrlkMmBFYHBAgTEcQHaGRAjz1QxF/pxFqDpD27ygbIbTxudAf9qk8+r57jTSO4H0mhXUkD+ZJJjAhxa/R3ie0qIA+0eFWGqNE0YbJ+gMdLSOFsmLPHmGKWVDI6kEbKjHXFJSMDl+Fm2xEyqfL0q7KNbITLbqweKs+atPoP0Huoppl1OkMJ4mAk/qgIkr4hkn8NZ+J3siT67Vss/+Bd3Xv7LuYyt9u0QmuR1lVD/Uht2dd0f+qC/i4WjqrA3EfVwb2REmUnZNtl2oGC3eEj8TKDunf7Mv/ekPPthRPbtC5fNhgtN5oKyU6ZlAYptm4O4w2kFCaTkWfc0aS8cyMoIdep6cw/9TP1IfbQIeWMpTd1aHUbgSOhPKgViZc79XpXQIQlmuhak5AnFHeNiHYsyfm7dNxrL27rtljQoVFhGBHlE+CT5R+UW4scKt8ocxsQhdASrOONE7KFSXJ5PnP+U1zTevKd9dnrz4TETCThzDqPgQ3FcLrBd+hwRI38aIVUHjcTWd45l1nufSDEfaqvejyue2p5erJCvG1kGivN8SeA9dfCaunOHD3wYb2QhQUVpVMHO2wsyBAmrfhMqCxaY0MAa+1yp4fp6nrMAoz97N2OS1xMbTCdbP7C2o90yVF01xLq3gGbrl+QwF3hAGut5EAvQf674CE912fbsskpdQB3ie3yKFjIawGdQrWHExhSwSKNBJ5d/s72K9eGn1zY24sS6/mh3WZLwaC8a9uF1u7K8AnXWNeyoUT6v/y6F5D8RKYUULLsjllDhGrf24zIX39N1gsGtQA7AwK4tnJDuVFcfKcUzJndl5Qph5gAmrOVS8ShSiUc+9Qz9tw0pF3B4UAI+LoiTNXqgXjecotijIu6Yax59SFuQ7xfmFUxq5hvxG1MQfCFac/uc/Jyf1hnBrKHTuiPno0MP1TSZBlUMtDXdlvhpsITJcLyRfNmXpo7C340And90+fC//kfmwd3HsvOxqx6Lsqcj3kYXvJSbrh6MPdvSdno26iAWS+1Gitomlm8Fl3k0KMhYT4DrrN7t7hCYwVw6/sniUdhD7pVmKCXnBLa0UMHIdCV7MvS9+o4II4o9QaXmafedGsCtVwWvfz8AvwlTa1tePVIBrUwkVIOphVe+wjyN8K/xxKieX4v74bUM36M5yo0zo/iSsICXlcmSthHNI5JxhGksOOT+lkZWV46OZUXQohx7pi4uEZry9nGtCyWZ/XAKeBSQevTtMxPCSwB8gmzhssEALW8FpX6ks1GVwR2AYPdubQzL4OgFvqhIdedOHBSm7YmqznrsIaO+jNfXF1OxKUHMh24vRQspCNFVnwoil4dL6hKFzKpXLMGdgKaudERSQGpfauuCHyYI39BY65oUy8l3S+FlVxgcwMyZpbe7t29NtTt4rNqgvA2gH8Nh19qRn8B/apncH+6qPkq9IHAe6cVFvCY/d3ys3B3MBOMBRceSXCbFrsEnhjg9XwsCxLfsHgtjlqjEHvFTTsQnhbzbAYY618iNbOD+9XXjwDzpEBvaVNPmiVSD05+fjBq4IeXYeFvziAprbUHQQjJKYvxD7Rogi3Lt+o3WVEbTogQ+crRT6c6FVXiX+9DSOtdBRtWRg1JDbXJa6cJMc2KB2AJ3LO1DmnWFyerjsWxj3BWtowpVibrRIiRFByUYjvbb+EQAQ+2wfbuXMJNeCnC+5nJRFKCA5MZa5K9t8CNqbvMytIMk3g/cn0dUG3MeGUsClEK5UGB6ZOGoK6hOW8MkatV9LVaD2OcDTcCNwND8E62gxArDeaFzEp1KZi3sayycfRdXtJ6QpqIBJJ225RuYY8ceynDKlW2lJ9MEzLTAPtuQPxd4M/4ymtNH9IfZyCZA/k3XEGRv9iFlbVvIyhaDUEGbphfQzaUXqV0DdU8kSPKzZgBuff5YVQpVpoRVLhR6gE5rqtad74FSadTH5Vn//w1ENnRVigKwom6G+adB5oUUGFjQmmhvspeeBqVZ8nx0G4NiyRWyfcK4DR02goP3EigtpdMHlqv8ZEeIFPtnsGwNKkPFz3hNUXasRvJMne36qnfsrnXbZpnNuWSZ7bP6tcolk3aLRWh8hBtlvnrYx/mv1aY8dMsMms4hQt0CyMh5ZOnPN14ZaXzf1qAvRv6uoQ3jqkPutTCh/pfOz8AMeE6Mc973ZpE1TYySiKAedofrCC2iIKindLZPIR8B+wCZjc+hx9n702LhGFZrFWngN7+pE95+FunMZlV4Ujg/6JvpR5TeRUu3grenhoKuz23+6djmLo66CYN22YdLD2Or4mrylnSvog/fLt9wVO0a21qKajWAxA6LncaR3oqxP2DuVGCnbCfZyLzyHvS1qA9Rf+6XSRMy/i5bDiCYn3gDo2zoslCmkAPd5HiUn/pnruHBxi2rEZZNTjq5Bddqe3QTxYYWo3gpUjguT1Ty7YfMNspJOB6Fxt7PfBz0j3QBLnwBeZNKaUBTdvW1kX6c+9e3e/Nz5gR5+ANKfhNEEtQJJcrUrWZufIhsNj5S0JoS/VAABSEcFxsv6SDcAJdNw9hrnVmR/oTCDHRSbxA/n1d79jKZmfzLmNG9qKZ8oYHrj7x00wIB5x0ndUvgZcyalI3n0fKpx+kmT2vcf4XFDcbbBqzqjmZOJd9BHqbkkH9uIpfKSyoWgHdGQM7Cd5br/9txRkNYvQBMKcieD57pJvMEj/uRckSyzbdGXhwQsNtHWP6g776AZ4oS1fQC+v9NyCo1ITn3XI6SgafSkhHtlcFlStEn2s+XawKGl52d4hLY2IP+Lt1ASNqz/gM/l72Xqph/vAeuqPN/i14F45M16T6UDNnpKuZkg7GFlzIzdOAjfXW78+QW7V5ute/2KHQn+ImsEPXf/PbHU8wBkFgVzFYjcX6vQ3WLiWNgVo7c0Y1lIooEEKFxvNsfRU2pqBaPtCXJfLMCW8YAjq2Gd+61fFOe0hhwMupYJPr9hbuJJnxAK9eXXEiEj9qInnTCTabGuzv6z+zNgF1v/XSWb+qjApMPwToXYZCWvriybs6m4e+SjOiwcFPKDip0yMZ/Z5QJ3MPRif/pvpfvFKblUYmKm6PSz86qDUf6wE7vvdZrRMPKyqc7CBc2vfjDnPtxoEzpRfKP9km4JZLVbOCwoT9TE9tPM7KyrLmhn1/vEuFqOgu1vdpAt5C2oWWpCR1n4jXHRJsfmJpuNjJhmVAzigzXmm8RCL9lmDMXJ0iIqyNmmNezC/qoVxY++m3TizriWgO75Tnf+wtTchc7XtIULWOONYOay9mt9fxAm0qY7wmddfy+dUNhrrh6q/8VmpQZBpDF3QEc48drpJEhSmAFqLTbjlQ2KFsjKQqwkc9FAB+JtPXTuBTerkGRqEnTjbLEamOCb1m/fhX+nIm+PeyLtKn6M3g/32y94dMVkLvIrXjGPKW8I6ag8nawqfueyUxVHbts5+Q84T857ckuF0qWRlUVI8tNf3vfS/qgxhQykLEYi24TIY3z38jjRUoRMMnQI7u5skMUYp5hIzTKgD/+mCH679Ya4rB7JxfNRktZl3cuQ2cZXZwegisbMtDm7mkuNmXb0jvuXJXz2ljrUhbWvu4evUxx+qGI1BUBh0JWEFGTs3XhKe8tEZpKbLuq3/ABxdlMzKs4XRMZUx09jI1g2jsEZ9lwjWPYFbS/3v1Vz5Jd313u4I9tdZwClknL/twaQUE83NiH6iWIm3CcrPS2Ycni5eUUmf8lnJ4/9aLKnGeR/0gtixpO0CPeEkPLIpB+Rcr38pcuq54+pqwpA9wkWznlnrBOugbren4sNw0d1J2yBXKtLuebi8zrhypzYW+SWEc6g9AhQd/CAK5RYYmPX7oVRganKKIaOXV2VVRAqitrYsvE3qd0bwsY/VTWA8LFC833BHPLizwUVeqhf3aJ7BoVLMa2/w2v+uYv1o3RApJRIDcqnyrayPGzf4a/mk6K4lBgcOA+ugX0hrn0Hn/+aarLUZhrRMoLWXjswCktvCWDp6J1A1VFVEuARS4Tg7DXb6tNfn8EqFDS5+UKA+IxAXj7RG1S6lbfwKtfxLMqBqnSmt1oxWR3FqRXvIcBLdN8jMDRtN4YPKEimnYCFztGnSRqHZrib1Jb0itb5XKUJ6X49t2Sny/Xapkc59vgQL5Fh83avnpexX86ATQGCwpfIaEHBLtRqSTKdl6WAGMsc7Ytu4Kz/x+929fZMx6wrpZSImvU9+ldqwhVG4Trm+qiTMx1iFN73xi78pCjGZ82/pT9txok8anSJ2ko/7Cg223/BzPYqYtMS4nudWpt8GUcDSVHn/SdW21kQ8YWEvctgIfZjU1xB2Lb80qscF/PtXYOXo+SdIIYnnYI0fhYkeqSW3UiaQjkB3DbooPsymblAz3tZWCr22oaN0eYTbG/0/jkeE8RcZNZc7Ajykr5MmVRu5QVr9jsQdX7sS5BWBIXpJepfv9cdf58FI6DEF8KBECsftKXqCMoFOKE/atoJ65oeUIHFeg64mDvuqiyCbKoeTlAxbWeKaYzK/zzfhLYD7THH8pCOClp6iLu1O4HioNe+ulUa/sakyt/tlv8Zxtsu0MoaalHjpmQXqYC0PzR2ndu1bhrTIhB+7BnaPEA7ZlcxcTeXo7o2jPgwDZ1S7o5kMwuNtrlujGb+QpPC7xLFTal3hGMdV9kbJOhZeCA+h6oLnZtl+Qg7Q/egGqqv/gxyr56oCSdv4z3+do7X8lLxIAKDFR61fiF9LCdgkWFqsaVWsPvCfRuAg8bpSemnZysDA1dGqane2eHaYlCc4sCKnrlmIH/w0rORDFOFVEyZucXPBJXQKvvEcQAIq0/9TLLcVnkI5t52nxLnth4LQlysqDNcPM1vMVwliy0onJ2+Eyz08hJQYlENCkvmgy+9sCbA+FcBKhfwYLUQ5zPem3B3HTvYwiLMhSHNHta90ygOPqMYrxUMi/aUwvJ2ONYM4Z/svYdszvAt1dPJv7HQJQISLYLmTyxkPkZBdTmfAHDUjG2HdkO3FjwGzLiQHQxllRTEhc3cDTjjmmXWuzHn1A2X5FxStqC+BhJWgIdjh9uoK8wEzcqrpZpbV2HXR432hbA+KMqO9zH6hFQlaaG6qkGOw8WrDtQSxqvj/LWaoph8C3zuzgODR8DnZV6ey4ekzeAKHjOzQUDMjossHGZcssnvdBxiuMT36WT+HRkg0UX5npKn4f/bI3+itb6Epfdp9HGzJyOtnxabZJTIN/59JBfC9s/WZXu9TbfoqZ4bqiRP0JXnJnWabmgnATT8oFCNgU5xqsGE19n7LWr60rIZIfAwN1p4y7E8EoG8zqG4aZUsfo8OzPw/rvx9Zam07jzJ8oFaGWBogZplamPWmleMU6Iuy9brkd4g3MfmLSa/JP10zec8lhcb5uICb0KErxmKfwavSBYojme2+LRVEZ2IDzHrJKVn8zXdTA0pw6y8o8vHeRAZhoyj4ZI/zTjytr2nt5RlNjh3P+zw7aBd6y9Rb56FV/u84+qEDX9NTriC+Fn5t/zcAupGLm9uzOLzcW1gINANEn9xA3FlR57k1/ctXnucD4gMCc3ecrQoWcwK80YYniRiWQz/A/6wVV43gk/R1n7NuezVHXPyhdxkA1DCKaL0M6XB0alRBJ+xRet/qtYOxbyqsaeIcIog1xPockEunVWz7mnlQPtvxCZWYSemnD59IHQ6zv0L8Ry9xCxJ3bpLVbrdJx0y35VYBTaBoXiNxlDQihKRwF7oh449RprsOzp7Pp3kBhaXNJHGvbfZnl+gW9ji1oQWXxHPxusF3Oj3JUkenpeZG0+x2KREv04maP6AIE1T29HiqhtTbb+wNrkMDoZaYu7VwekoKa+T4aCG5bZF4Y3MAMDDkajVJerx7ZR7unk9DyW05n4ViSAmekDzDw1u6b4k44/3LCNt6W/mmoGFGW0dEVtzyJfGIBGLe1GBRkjWx3U1iLTVdJEnrsvh6ECTkCrQfqmPpjK8ToercP8oc70q3wKGV2bzd4AFyJUzsh6kBORRbV9YtMAFaPUj5VPV0Y8aGDiDOxAMhbgEw/Qgd5MCuuhuI+PTUk9dLkAbqtNrND6HT2eT4LMVGLuL01B4s7+bdybxWlZBXKIXIuB5ge+vgjKgConjpUyOdZJqX5OUHSleahgFJB5fo6SO/sPE6sgK+s+cWD8SJt4mx4N4d+gyAHdd2xbt736FupbKmymeAGymHbiiEIfx7avZTnclWWU6jfIxbtI3OHTC3HOFYZMwkDtgA1dOE8hquL67ApErA8scvbGJVisar/38E/6QSZFJ0W1I2Twe4s12iLSEAczw/XNbwyJSeZGVvCHrsgHPFHIWEMRY2BwV7HbkeEQGnRW6iJ2FhpF3gVdXdj22G/D4fr23x718Sdxht0yMbCGU24g1dGgB0w3yJeZX2CEax9JDx9fdseyh7b0E7fGZn/SEJZyBNoRoajQR1sFMwk2lgIftkZPtlizZAdgUQTtsumvcX+zBP+b4h2Mo3OAhIWndtQ0CE30inwWpYylAE34YAprax5mm+wgp1MBXgpfautLdOLIU8Rnm9usD4eKh3cmLs7I4hngKdMm2Cn2f8wacy6InmKIFu7mu1sQERXzDCKP1q4kx86Knn6tHEn7shXZHEymySp6L+Gh3FvtI6OGoNEp9epxl7vRrZr+jOmzF+tBDQovQYn1OL7nXt1OI7Q0T3wo8FoakQACItdLLyqtRT6PacNCvcYFMsi4mGLFOwpeBIeVSh5uayYz0a5oN89p7HOsstGEJZe00L0DjlrszXoXt4OdhplMGU5pFOaU7ZU18vSBXtFq1e7t6vrKVt/IBl5lkQcH0MoPgGIMwfUaaqIItULiDaOmKbEhJafY4a/C1tuNLVsrL2X7CwDrZNnQ9Km30Blpbh5C+4ZMgr+fK3p3LKTVXta13CPn92Xh5wAn0diDR/bIdzfEAZRBVCulYuVyAKeZ9AhaPEj/NAJ8WgxncoYckrK+jURyk2JlfAiTZJIkGCRkqypB/knfU39GKR8liyFpV3Cpc4UERYzTS77F4e17Qj4pr7BV4ePnCHk2xOPaiY6IUst8F676KQWQ6aHs34iWd7d36bIo0X9DenjS59yMmo950a9nNxnaujwggsW/KXz5M5kdpu+kjAI9Ks83e63ROnHPCl/YFjPFj7oEz2mfbFO1a7R82kVNOoldnUmvcjI2bTY9cOybttuPnfa+kasavwkZ/elPXnVZ0uVda8LMHVMhWoBCHhYkpav/vkzX5Y1lFQoLBG6Cohund5TZeSx2jmHpM2BJBRs3vRqq5BUqkM0m11gAsSd14Id3sT3cBtaaZzTt7KDxsRGzOBuKDzkO1E4uIKbBIWATKSTLd5i+U97FHrjCHNUiiMqaOofot43XWTf+Gs2SpPfVZDQzWWViHMXU0ux7IG4BQJI7ugJZXpQZhW457dW37/LGsHXvZ8O3Aw4HP953VE22kaWQVkkRE2DOOlpt1wX8CIYnlvl1zcE9vKpPDrCOXZ6gYkRw6v95pedeTNR8UsyxhIiiL/WSGPf0sf8T0D2T4eJTQqYumIyVk5UD5287B4cIvYEgidUw6xix+RLb6srUkUqLOG3b0/PNDirZjtHG4qnGuSw3ra4WdAlqtb2oFhCUpSrttjR/MBkSRfq+c3flZi+8t+ZEm1uqv8u5x6F7khlcyhBEtS5GNYwZ4jmy0NJYA7TLuU3PJp3ugbujS0W6xEUQz3/vDLsdM6RTgu5q42G+98+Xmp5HOfH5m2/t1ClkFXkJXOxyhDAj8gnMdliDYIK8ysw+snKlRN0jrzOgf8VxFsxjCx2fM/Cc/qjZ014YOlLKo7Lwh1I3VrDV40KPtprmBx6+xL2vp6IS+H2+OvwKVoVArP1N98dFWNVhagvA5fa4CBjhY1OypEajM/NKIEU7Pupur/UWV5qXdbTF9f8DPA4pUulFHyQqvQFI1xg4bvCthnI4mWdwvCAcrI6uaPsCLebqC4NN5XHD8l1WmEvlZsuuuYJT5GB+msLiM2+ouarXlziWAcK9QJqe/8P0EGpvfkdZadXT/5cOF6CjoEH6SxjmjaV9XFssYT82OkcNpG6c6RlrQ+t7EiC7+zqFwU+Biz/AQNvsGONkbavfoP/kPKfqG1Ee+QMuhdagfsGv2KKXvRZTwhaXirCuXmMSgkyP3dKofQnLVoHUJ7MmnTBAzx2qYXl7R83JCLH9Z7Uju7LDaBRCbJjz/4K4aqDCdvDXiXMeodHA9S/nRWxItZDJUYZ70VOkppticvyixcscbb74sxlqXMy+XOhNJf+TifeuKv00SVFtuWhdSUyPL0vK+HrOPHuPjXPrzxnG+61TsKnsyvt7CohlFJX2ZWRM8aqnMjZE9eE3XkfqLfTsqWq0H2Nx8/shXXcwgHtso6p4u1JPxVnd8SPhKQovDmrXMFU96iO1N6O39sf8118HfHizs+EEmDWz9zwQ59r5ew3KY31ZfuCGvhHBzsQZLrPZMSwGaQJaVOLflqlcVOCEFpVZL/jmxSDN54ggiBycnfD7VjX8cSPHf5sg81XOh7uIHxmkaQv6OfdW3e0HCtcyee5WVxEFhTJ3QxU2Mpm+qcc5OHfilq5cI/QN+qX++WAmVWjVl25CAYlDjX7S5loQtQbHHjfmhUY9Q1aa7Iboeb8yWXAOmnhKnZYcG+/rbeet/MWgAlgNUmVKt5oqgNMv8JbAMl4XVb9UaY9rv2ysoMuEefHj0wPBD0lDowY3s76AhwR+O+NrPoEIesnPNbmc5sq4wNMDRxX7cQ4yIaP8kK6bSFJ3US15eOoh5dYs94OCB3vE9eDy0Z5BvmRK8r/3gFFqotYqGy+fOm8Bu6tyvsdO9fVpOWAhyHMxqRZFJWmy8gVaXPpXU9kjnlbdP4bnd8HuXg+VDVU03hde50Q1CbfHSsG+UO3Rnav7t/oiuSLGMRRHkyJyXX2o/9p3tcV7i5sg4H4gG4zMIs7nzzOasFtb7gOJ7Y0WGDaHXreQ5W1NcEaArOReErp6kMZnEtXSWO8960pk4U0MhEPg2oYLzTnEf4DQkArAJeIUH0wtC/JTcojfuNqKj5haFwE83KSm/352QtRrsMZqaVhcqdp+++EPbqqen8yo3JXvC0wqvXV87s0pJRhw/NJGxNaSjkipZm8HSi6r/kg6eRD7yZ/X/Pu+g81imWY/2FWkWJIV0ZMU/8z46Un/A5RPfZsLBXp6vmg9ujKzG+cHqOWcPtdUlCLiCTXvXgvHMC93embLepVT8+nTeMoc35vzuVq310Qa9F0BS26BXAiIzN0sCJp0olBh8RrT4v0vu4W09zhs8JoeQl4SqvqaCV/IJ8+4cuCVzDkXDkHaQt63//q8ADKFXOdGX6LhFhjU4yG0ILUptpXHLLyhLHJ3vBSMSpeyVm7lx7QY4IsVJknbI4OhuABOIz/YOc1Hk9GrkQJTREhfobDmfOp48mSrFlkBV5NrSbXocbQh0/598RJfTQolk0jRZ5hU/9LFAT9Px7K/HFUSgeA+0nSo70f0Ccpzp2fPlJfH+47XYlTm9JQxqqVK2Q0XjDu+kFGQH+k3wic1rO1j/RdkRjnXHROdT/IkTf3lx2+yruKSat7Ksa6+ZO3TMWH4KrfIbBko6kVOEIhP96cGOxLSSMQqmqrZVsNhYdHOoC42SC+RQGFnHMU6XBHF7HkhXnv02XN2VxWhNFMTZV4v6d+cejr0FnWdGmdTyfjDjlRZOPfnI36CR/KNbtmH++i9SBhPuHeJe99cJsyhlwjtS50Si5X7VPCbWHEQ3sp6KTvRknONJtN91KFrbosbgHSPQRjpop/EZCwtb5bRH2QrNiPSPJT4bY/szC9SYvD4pKtk6qaDgA/OE3g6hBh4EGUlM/Ok2tAd2i2Bu/qAsn8oM23L9tI+rKlFIPIPWGEKA/5zq05/cr8byCqbJjY7JEZOlHkw/xGyxtZbmPn7aZDLmKco5EErYxu1B0yRipqBCD9nZiiH74Jjh0LU6IYZkaDXMeawhc/iRcKrZT0U5dxUere1UmrzAUgUpTmW0nqb34ZN/BtYhHXq0ejdudM3LM7SM573G5q5qx4TqL4F39CWLxTWqDZmaRB9XFaB7TJ3tOGLsgS0guKmTwoL/jHzWwmWyM/U+cD3SYVmm4QVDk/LzjBweZ+4wQBYRt5N/uUa7Jh3zp3vmfXrzGWRbSGZYMu1yWLzfy7muoS+snzWiZTlwrLM1bxnrrGH6/IRQdn7C0FRWRohwi6J4D1QR847KYnl18hiLQzfk3b6YBxquwtGfvtCyS8T6gZP67uKKmS+DZdxuiakkWt03j7Vpv36pGb8WRGC0lSOWL1vpRRTy6oVvwnJ95kov+x4GLnmzX0xpuyylXljHVTIRheR5nwwfE9HTvrjXNitENDU/XN0gxmzQIksVvTKKpEiAuViZhQqxTgzPc7Gat3nDstSxzPC266fUtdZhQlgrhZpjH6CZJQZ3cZRh3FkcsEgVxq34iHGunoSS3JQwC9V2EyWDY8Gl7jjSJL7vTyCplmYHG5XO/G96EsZstMKwSfpOXv2NPP7NRIqUz01g9cSZuglySFttvowNL7m6qftYK8d+k0d33P5aa7mPZpiRypmsxm0GiugX+4EhP111OeCmWUgUOmaSbDPmZt5telMdN5w6bXdYFIUtVUMhvd1SgJVdWRLPQQi7FYOgZV5lvZthR1NocPnNxEAaNxs1vn/FtvRBxV4W/QoyhKB+6Et3IYoS3WwIorbabRZxy1Od7SayLcaRrVbjnJ4RHgPnKpOUxHdCxt98HJuQbnai2X1g+hrITPUEILwLwt6kYn99MaM2IBtfuIa7I0996lHwG9pT6n/hn+GvsLtJXqmH4OCRu084EShWBPawEHgJ4kHX2AwFetXmh4L/xQ7c1ytzcEV4frESXDRtdOwlLkpF4IrLrNtCIkFt8Ow/fDg9R5SWzytU63PL6x/nFo23mtL5+XL2/CkYXtJLqnih9nmVdpxHVof4IsbD2orXg4wUg4ZScdEmHdzF1wXw0GfxB8OhPwpjx0pts5X8cRirl5KcPUXwjqDPZAMpT1Qz0xKZOCuJC3kONloQPeCz96XXLe6C+DPh6m9pEUVxs8qPVtF0lLH1xs5UQ1Nqremt7yiExIK716T0bXC+egi6OBFasI7PwO6oY0FyxHSSUYzcqZRS6gK9cDLnrAhqf2NMjycErBqfK1NFwfMIJtWTv2XX32WWJLBQ5Nty3EIBMkoPWT2F/uGBxoCwkd7Q1lt1p4rMtTDz3sh983anN4lhuErHLk2P+LGmZ+M979WHc+BBT6chQmJIdoou60rupwrIphrJ0foVPLqGH1Yt3pQbL6ReniskjZCCH4fU4Dx8P/27piMmN9K5yhIQZwcK/td/DkalGcIyUat94boz7BJSFy4jH0tFn3u4L3S36MsuYJFCOCJPWNvgygJQWWzLKFNi2kaa1mSUgmzHM2ZRl4oItOHfblRB0CuSuEORCvjEyJsxl7kpkwVNcdUjIx/MTS331/dfI3e/uDSkYc9TFh2ayLUSRG+9Q1QDzSlRXENlzm85TapnyQ5KwCttWHE9bJq1KlZVUM5dh+0qoKaq76aHnCQ7Ob81Mj4mJyBoT/G//xewziBkqQY+UMdDzTBvMDgkng6rsFmxnnQI2BJX3sicQ07NreOJUpjLay1OfY4aBwz90YJ7IgcuIriKJzkanLt7Tjca9A7TRhWEmeIrQc8e7yOlyo4PrIyZ7nrMQiAzFpl9wlI+NwzNT0FmWwPSukflexh6S5LRO3kF0izLwrnycftlicSFHcd5RJaWXKpgDi0JWaKn8uYgtATSpNuxN7mbt/tKFw3laq0HMMrET9dgsWFTOLukMS4+LWxlbXTgpM5CganWR/VE7ed3z/0pqoLgZ+e+JE/mof4ocHDbDHQypHQXB3JIvWoT7gl1GlnNdJIwMthNiNi8KG599MW9Cd6HaBK6d1lGz3POn5pMej8CQXBg+BcvHQCD0fVyTT45HkrKQHs7tHOyaLBTJ6I7paoExX4KRE1m2pvXO9rmldwY/YHOV02nxZcQUrOub42WJfAmq08II7PZZ7BXzQq/9TFIgIfNtpYQ6Sz2Tu/OYU4xnLs0FsBfb34SKFYtBozGo1G033pyU64WONLA/U/UwE7Du9U2kmpNXd2P5Hi44gad+BL/LW59gOUrqqlzrmeynuSWH8OiRYOrPdzeOdJOG/mzA87FNWciLNSEx3ya6TNpSOO8o6nURzhYCKgvmkZUs0yCuCm/BRw/8EM3+CcIFVx0JqBoo8A2w0KERJjII5qHQraNVRASIHrQgGTSj3zPmxmwVENXf+TO0yyMx+Mr2bX15UY7zCXVWy4ob4UJ8egzkGW5T0Y65jMGe4OmiFuhCab0Xk61XVYKFER84DBAfawpJ6TExqs5yOpmCTqy5Fa2DJcFtBuz5uCNbsCUnu1YMtSNDQXyB6BpiVr0IOn6U+bNsRiUDXgviqZANCYG60NXu0uaA1KkCywWZT5LgTGYqU2sKUlVbGHvHTM16bjmU8zj+Qn3wdQY21ljFxzGV4R04yCz+EOLNDjetuezbK+DD1HhLUkEgQk2XuiP7wbX6LelOM2UEUpzrSDXqXnRN815Lud8WHvyIV0mwSXgbwlKT93+XJoWUdWEnyMFxFFDzl2uPe9C15fKj0CJdxGNoWWH/myP7y0zgFx5UIBBbAtqMwImLCI5/NUEtcFD2kbC/4rQxDIl2bd4wwKQzoDmFobX5NmSJA60K/PE4p2vxwzvVkII+Iqdo5Tc84bNopx8K6dw9WcKMYtufC4WRWYc4+Bq729LpFFts03r2KCL8j4sYVZEeg8ltZZ/2d4uU9RSPKKjQPzAZohC2QKqpVIy42MjKM0t0AsXa5FJJAu2Mjh43oI3cvkOhw95DdnpOzbGTlV2bjZoO7bPLUU7P15wsXd1HLjgMsi5METJoTGHd34mHpcWngy18YkPD159+5LykZx4/+Ub5vQdEW/reogntcFKYiCE7FQw4hPjTjqsYszU+YaAQ23CVR/zm3sNH0AM00bnW0xhJFGXgZeR9a0ug/OAcAo1HJO0b2t61DeOJU+6WCTv9qRIomlgq3DB16oF40ryXz3TPZkZO7Nkoa7EkRb+pKKoPQs9ZenhnHjdqeDc/hjvkH20s4p2s5YLPbSnizSUva9Rjx3KRvdqqlRr0XGwWngLcTEd4kNFoBUjplpXXj/cIDdewnzlccHBQMXlUn5e8n3bj6C7WBIqtWBZWRgdKI6JG7d2ZJIn6hsjugtrjAW2kLDll8OAvkNISGl9Nn/9/znjUa9lZP3IzYZzzSu2xvF4Ngt3MF4PECoMRlxejc1amAGXf7OWQDgIhUeW957ltq0wQW+l0SD1ubYhWyjMSxXPTUMrewQfZXWogZLCEF1IcvNOKzlGYbAetVB8Odgs4vu8Bb/M2rLYmi15RX4vFYYTnQsrBwg+M7c0Az6DBfKN71A7X+Q9Py1uXKr0rDC/T1yfAAZD/QraILgC1QktpjI5xxCeBYNbrZypBNPzOfQIb9z83EVp852ctV2ckMGnxI8WmMPokeJrmTGwG/1hnUyyL9tYnoNhrnIbfCKuyaS8BVjBix1wHRwYFWXUusOVY8YPOfayWKG4hPOIUeqtGN7zb4us7Zs/LsdogqK+xdzJ6dJ7bIH1Ypd/uYTwVV7HIJDHjlfzLkZMaE6JgAAb+bJ73byIjK2mMJEFsuNlwdur8Kzt6woVKyzuI8mi/VU1opw9FblnKu61kreoEO0Il05CDY/pjavnyI5SUCI22K8wRCYIkNtCyDhwqnNwr2pj9xQcgfvucVlBPfdhbI58arlUVXLT6u/N4UUeuzqGKyyazJRk3LqNm2vMn+NHznEMbi6f2uVYzPfN4MuaB58MDhapZ21YmipxS+Y6k7h4O5t4FgNAqb04Tn+lI1D0c/CfVLq/9j5YCrBwyNnpmXS7MAwx+2xO65uBhaLqDy9IJuJRNrQZB9S5WCZujqbXusgxIwg2NtI0arzhMhFX3/Us2F4ulVnk94t815nFEF6vTQ0XKuT3z3a0xJ1oOS2uKZazwMmEgha6U9nR+kmjyIZk17gCkRjaYzu9yWKi9T/XOar3L7Dugd7J0Vyi9/OinhslFaD2BbZ1kTbVPxpeTmb89soc00J7vi1j6R+xJEONst7SrJXK79WIhY7FJjkaCLY9TMOHz5/q+TkDWNJbMHDLYWLu4PwBqcY7k6HqqvmM1c4i8ZZa+Hef+zT1t4wJ31qy2PyUcE2rCekd4xjj84R3zcPqtOl5d367f2iPX3+kAXo/m4+Z7gaRcyftvuZZe3CXg2zEWjdhZP4QbW7Nd7Noh6+eyJgFvOsyqe9HAwxym1DIVIobv3hEuDY6HzLJZhLLj9P1fpLvisXyGloZzjhPfsx5aLTZA6h3S8/Y/1Un+uAMvuhNKygc1SfloualIIrTuzPwyVK0alpXJU1horlc1OhVqMwoqowbiI5dW08yMiAnOoLikdH3DfBhslCZxVx+YcFkxfYeeSOwt7w6Xq9Biy2uHkldTMyO/sV0qDougKx9P+fs3UmBi8MXCXSuL9yWE4VwshuCuaYGFclekzNyYwpL944Sl83rfsA60NoTDhu4Vr0xwyVo7aQi+Og4RDG8GSzVY3oZwr4qwuUcbC3k+1YRADJya/ur3eSwNWPKsa+hgTgliYMN9DzKiIrgSaJjDoglgtBL/7b4k51P37Nd/4fghknXo4Mqx72IkiG9qPs6SUgYAlgge+FkpqfMUv1bJbYE1ejX9L/Vb1ma6YbMSzINxsUFkRueu9HJxmmRls7QEC2zPuq1Pc87BzMRcaCUhYv1VHOq7bycpaeUah+YviFbJpVkCGXKYCEUYAuc/NHf9sEbpp475mW0IZsyfJt7YWtuzv4pM479uW03+wH5ehRMYYsUtw3hsbloIq6AyiHLr4Rx2/S41KATN0cPKNtV9NQMSHzeu7OBlJx0855v5o7l5SRArV/DD6f72GIuRsgWMHkkw109KDlgQCK4XQ19V7PlKum+QRRSUsKPfsE8Qme2mtDXYZAHf7KoDRhOHcvO8Z0WaHsFpKV9Q4gpeq7bbJpBvMp5LjozYoyEOO8en5qO2qsxoMqpslCkcywJpajj4TmewV09/yJRIOE2rnnopSpNVV+UNb2k1Xd1BRuuZGYP2S18KgaBLOaEuhVSVoqc6Nddf6eJr2hUBzh9HYH7c39Yub1dFln5ShJNfvpZg9AWAUFSlIJ/6YHJYOxjHhMfCNlNL6nAZq8Cx27ghHAOCJfsFRHk/xb1whlfEOBrR47XoVvxkO9wpXZS6dx3GwHXMLYB/LZelSu7D2Ux3gs5LJOfEA1Mhz+WP678g/2jM69+ThuBnx1SeE54G0yBUmsphwTTqVnDar9oQ1q8KRfExMTojhMuCT8yDcqhTaN8PXXAqYFDniNSqlgt6QGs78Zh9o5mTRI0G0Xc3RSWKmK0ha163jUs5usCeanwIA3Qmrx8gue8JbXJMUyonNBmNSbreFJl15RbKWWA3UEBvjbCsIhbxhrYKGP4Ij0Q3n1lx30t/3i4phot6de4krOT7USuhwdp9SLnslPjIUrnT3y7SSHUgrRZ460hnkjkcDQ/5quX6Rg9pLX77SXXdFubcW7yKF/X4V4pBgGRI0pl1XqOwyI6csZOzCWdibuHbOtFHGdVy3BAgdheCcK1bEX9Aw4fin/QY+HTn/UscQ6SWIDyBw69Yig69WA3jF4HzeDeiKwnVKaOKf0g+NPyk+lwM+0m9/ayT33iIxesNkNNJ1utpgCpeV3v/mL3MJ7gaKFMIlPHTRN/nCpNG00LfvPgGOSAMj+8R6R/nisGgTYLLmLsYSv5RzRHh+hq6YxDTD8ikA4GZpuyEBPRmOy/2rFud2NtVH7reYkkkmarfhNRSqwXDBnkfGYZwV7jOlYIBYlZ7o/shxRmLAQNkLLEU/qhyZ6wzEFathWoQ5JAMYW/mxHFoBxDZWqC1WPGWKCsBwRXRjFMhHGRptQYN7JhajLDPDxdZCOS5y1MYGImZS4lXpes9geo3DfGi/npUWuNkwPmu4sQMUvj5Qfy0T3AeYWRzkVsAictMo5tCTDNEYBfKs9f3s/nkrGKD7H9q+ym6tJH5X5Cy0LwZbjPYwHgkMc/GO7u4sX/Aa/xGgfHQjknvyP/+O7tohUUw3gJOUONA1yT3ubpn2LMkbctr3vBjsfe4OmX97Q4mEfi9ODeG0cmpHaxtJ9CX0A2fpC5pd+fkltODGoLgCn2yr6AlUg3xs9O5f2sH3qXKxP1FTExdk+AuwBEpklSeOCsFxYf4p5O+DHnIEcpnYvRrKCCHWA9Yv0gMGaynXi+Jco/bkzcqIg3zl2L31BUTF4Oi0yWJuDjwtu/D2NXPZGQZ6DtDx5JfbrrXhWCIuIVLiifW8I7YCOEcsvVQQQ0yGiswUgf2VC9d75C8O4533qhe7AtkeD7ntSZDaF0cw0Kv7TYtf+oppcx2xhOpNTsAqleiSWOzbhcExV/AzYtGIsEIfXOGlKRCfeMVWsXtNowXjW1xuwoQYc8CuHyCHBZLa2ZPRmft+RpXwpXAX/31ted8JoOOigYMv2hRUooTjurvUrQlymqd0+jzvjM/NANY8NXYasRUrZmqUOGK6zYpwabRLDF/6/xIMU3/aEbg634FinT3EPQaAHkv96hGJV2Vm2RM3NXCsETIqIUKl+C356vcj2PfwsTs8Ou/P4+XdH/oTZ4igfVDJVynELrR1yMRaEpXZsGfxtPH56dPTMMih8pslTDo5CL80Fr+BMizopIJoRR8OFgZvZ3QIPbDjT0XoEwRrVooYQss7Hc2utT0EW9MuVg57gpTZJ4fskZQ6WqeI8KILv9+a2Y1m/tZFoSEjjXiSqu3ZVxKNlLc9K5KDE+xncx4g5HT+GKNPDa58GVOSFEv8Fq4b2Q41Yq7LhPlMyaxhMmQhEuVRs9+/1Yd2ZzUuCaxNT1bFxeIiwVrUBy2ZXmjwZDfg1ayYqlWI4R4juOHx5W8GkYFO2GuINqNn4ewdn942k8ClWQZBSw3WUtQci9rhj2PW2iYiUBTrl/aT9GPlIVrMXO0GvdTZcYL1SBHuSmAW3Xc8E1NrJ08q+YLlHpKXFL7Gtcu8/6TY1rxrr9xnMNpdqqOQNIQ3M87rXeiiezJyu40dYL5eXoeDKBSDN5cyMQaiNasaSp8IE65Hy+eMoU/xiCn7+kEgVWjuS1FTsV2TfrfWAjEisOTxSduJIjiQPqQ8QuPbU22/28iPksd1JsOZAMb/alAfkde4m32ltWXMD5Y8YBZ5jekFOBx9NmNmuwGPRyL0D37aElesqhS58c+yEN3X9pgytRKoEbSXBhyTmDBNjU14xtI9M0Tv+Ia9Ze/YGgp2G1/XI75euVPiotEtBTnLpiRhBCCV8JbhARpYDrbk7QCliXhnBovl6qLgpv1MkLJ2qAdP/r8/KIb20rUdzwHnWbUF4EqSsy5rrWQJ3R1cRrKHX/b7ELhDMoxMKiJ5rTytw8AfHvFQBENk7S9lAzprA9xiFrs85/gRvi3EOXBcbNNpPz+WVJtvVM/clgxgQyyown7qBQnj3j0QFvqEgrgeYdXNCuvBBLUMRx0XV34fZEYBqpuq2EdOMMcpq5+fUOBsU/fGWb3RmTNGR19roU66COKJzAJ5w9AHnuabnVdlADdARSeJ6+y9Rq3Q0ZeS/XaQh+JxTqKaMD9sS80DoyQ5afTw+WXv8XpGu709F4sMRUv1JJDtEmFuBGChyT5fukMNnCz7OlsDrbsT6BsyioC7TAgETzon87HTOKpvmBlVGd4TZSEz/FDTS9/M6wTMd/+w2ovp5jWT8UGZlA3pVcKgPPoqd6T5ASGGMmMxUzLwHc9lnRgbmL+2ZhlkF7CZZZBPPRNdSgbHtIMUz5i+8ymnKLAteVwhZO2UnNYGqp39eefMFEDozFJVxTsxK3fwZAOzNlPOJ1Gww0YLL1joTb5ra4tNINmZCu8Djb8UG3N3VZ+aeGqWR3vm+do8ifXwIsTMVtDYBkdPvguSKG3FU1cUST4ZCVusExfcKHnr4qJb9ubFUvUQtfbVxLdex3diLowA5fXagfLJMNoyK/1xOcp1BxwGcw5WJommEEOZWmRw0fxjec0s8kvivZqmJVd0KveIlZC2+8RIrLyZWwNk0ihUz/VInxOjW4IMjgMKLhCCkyRto0yKBjV9NK+aKijtEjf7n2Uz+oDj5HumLSfxGC1pWVVKQfXOZVD7QKmRG8hhUkyA1XzRuH5nBM0Jun1Kmrj+dPP2UGDafWNfAQ5eYyKL1jEgKH6ChtIC3gUbJ8rzFEWi6I2xIB4WH67fTo/40wypzCvtOTvbGnFSElvsYnLGOa5APa6rjI7WOEqaL3D8p3zAgdPN1symc3TG3iMh0KlH1owFsUGTr3boDM10uXXg/uzIHFELotTQydJbQgtD1N2beBmih+sZT72Y/vlNaR4RM7wWSvElzecQiEkvMMYDOwjnm7au3BXRuHWqf47wNnBE2cElJNqbzu1yO1N1YQRPDCHPxJxr2hv1LzZ9JABqWj8R+Nd+1wx/6RRbbCRZB4OJypfopQpR7RYW8n8j/NBXeETaA4bqkthtHrtE5UJVutM0er8xgmo4TpK4ey7mEObLjLQRULZikW5SeYnQ3EUqUDJw3CsMPBvxHfGQkPLTQHgYN6WRZfHPF+0lNIkGWlLoYsdCNyLgOhAPPwx+BpiJfkExgOzQhRyNUt8UiYM1r1bVUeTZUc7FUj0o4KVwLMJxwYNRYNCly20N2J3svAYQvvfXj77Zel+hgmTDuEmBC8396H5R3fFZ+RL6xqar2cpofGwZvwvWBkq+efm27YK28QVBEPAkSJU7AEzD0p8J70nlXT+ksTXP5eqA7FlSguXr4r+hMAVwgpqePhxRBJbE3lCaORgofm2fAOJFjB7pVATLvN6hx8gQ8Jo5t61tIKAxt8GYbmLHySVU9WqjY3fkf7ulnSkov6LKNyqX9c7aFodxKqJdM1sTcFBrn3MD8fhuwFoOT4GdX0+9bzJqQXAYmkIuDrcIG3aGSdNN7x+qNLNMo+mEjw8/14zN/IrBGG74JvFuBSmtYNGYR3Aoq62ze+BZ+CLXFAAHq6uftSCZ50MFoendhHYIybwLHZvnLDW9c3aBXWGdOG76bGjYDcde8SYPgLrvehRtQNtJuXWQ7XFTKjRJVreZ/5JB8/EqvSY6trrwRUiPgEVNjV3RS25YeKkHTdQE+miWMnetS8tBkpcP35NHK2r5KHoclb6DSqHgyKHpHZX01iWE8zqN503m1uLqWrsvPpVGXMu3GFq7feeaN+cdl7CiS3084PQBTp+kOwtlRw1YQyFN82dsrk+YJqibpS+4z6qZ9S4993R6VGiBc5H6zVit8AesFOjWjFNEqzQFHYxRfiDiGXxr57QA7pY2wLBSNmzdRWB0tNlO1RnZFeq7J3DBac5239WQBXQl2WvYdHJQjz1tr4BNcw91xCT9JRcGZH7z+v+hQAVBLQdObNni5s4vmiWVCpRH72HEXo236v9CcUZSSxzfPX2K7xjkjiYCFmnmvLQefrYhEYKMBiVMJHGRy09YUDYkMikeG6n2FG5XgQoh4Z+g8UlIizDrAJIe3XwurJ5Y+ay3ZGRRrgk5Pq+8NH/CpBFCL2s8bim/fJc6m1keM+g4fCuf3FUlb1GgQCrhDriwBkp2I6pDETK3wyX6c1mbWD8/ONxQjl7KHVBhoL7wol6PbTWnrn8y0ky3GYFguEP4mkCABHBO/BSmaWowJ6AMx6I0CAV6+v41rSUSjlvairjdMu3vlIZroSklNA9rnQoLDb+VTpQ9xa7AxE7KU7JBY5jHSksGs2uw6AuuprN1NgMdDFTq13Rb8uWSENaBLdAKRLMxIetWb6iANRIqe7HKpxBmyN6z5S5zFFLDBPfmQxh2suevPdIjke3R1mhL5mHNILPQMBOwbSwtk4/60oQfwbwLIjpaKD+r31Nys8ZD848UJofXCSrn1e91YUu9/uLo3Ne1vDm7R+bWsjJcMrz3paHLdIlHx74hPFBcDq3sHPc90TKReBULBydAj/rQ0SVQEaD5i2Q+N5+lb9CQZxChK8KA4KtPFJnN/Q60C8u/RoAWOMZzIrjxBuuv8dJaM+B17FPhh8XioTLmBXSCll/51zlb1smYDTzNfJNTL6tGkn6783mJSENgJd2DjNWhBXZ3B8SC5DbbKtCVnR38gfNJTMJk3kUMMHEheEFaXNU8LYpq1y+Urep42Zyk7oJpXN9JvAKaezLgP4V6odUPmjK/KE08+p2RuDEmnglL7bwH1EoYACg0um7L1ZMMH7Cps2Zez7sBvQl+39LPgunEuMalPT0ToBF0g6ErNkymn52XXP5I2ekyv+XXckuxMC9b7tYa2P/7VcBrMIFF9IwtBlyJKZx5yf6AVkZlYweLb4Od59n6V7ticiTvnmorF6w2sWKk5UdK7I4s7ssfrqvXsqjYLVh/LlcWlMEZYVfQYU+2OxAiro1c7tCheY8JNWe7485HtdYFKD6UwlEPgeylVxZz3iQYeXYryBJ9e+jVKC8En4VhwmlGDNrsaap2JjTY8NV5OgtXmBYMxHUMcaDXM8rA31mPWstaM6R/KvPe7B8YTeFsLwsuBXC20KHvV4MmghUmfBJKbAOyUGK7Dh/ykbUGFk0nFjNkaolz4n1vku1WKWbur11TfW7GU7UmEdZkUb9Ya6Y7HbSrdcXnoel/xvHXnZtDqffe1DsQ9RrLGP2D/yvJgFCsDZfTVejubuAoZIQxmVsv5ChUPnspNmiA11IWQ6xkmZGBj6ndnqnkT9oXZ9gQEbTQRsvvVHHP+5jTG4RnFVB/gnq+4BrC5LR/H5n0V315vQ4doY3860JtI9RN4u4jzmSE3k/VN6YpsU78wKrvABrb5EZoSpKzN+DsjsAZcJsD9k92gCQaiBlgs8lBjCpRwBfRVDMmTXv71ZIK6iYzJvulh4b2rYju1rTCeD57l8qT57uzh47YMPVFQ+NfH5FjmJ4unnjgz+SxSRHbMZBxxD4eCdzSmi94kFHqYIxl8fCS/mSi0udATiXytjNJmv/yLdAkpCbtIF3Vx5Z5s+cbiowkz/QWoUhrAwM8oDhpt/HfVOLEYVcvKdpc8OzY2qqll0SUgVPGMPnSbwX7D1LdT0hGYQkI6qHxQdVsWXLFgf7mrMSueZfBh0Fw+nlEsmS6i4zY+hcGzt+XoXv7zl7U/dR7YtNfV76Z6AmY8loXiHzlSFwlzKTo0ywdjpB6WGqwhwDhjCs/4Jv9dykW/4/ax6R+PNTC2GEeKz/d50t1Xqo/MwlfIlqQVEA1lwJIOUs2rpw7JQNBb1XIL5F+WdTGUph8yVPI3xPYanghoy+QzpxlsY4/Ka+otumR+k4DgYITyYCNfuFxDB9SDFFvI0Z70x2Kya7H5dWDF/n73EYjxWieTpPQZ7qsN9/oaeoSxyHJWkWXVvlm5LC/ouxc2/eE3L+AE5pMQv7FETQBnkjYNJYCkNd6mUTZjKCw/QH82pZ/fuiFIQJ/r4r8L4vRkFHZoHuKHauiYcvs4dlYaxq278yvTUIX/yev6fZ/+8bPEtuoA3Cp9ZWZssa8bITjFXdlo0rZQX+9/Ebuv7Q8zkVT63HJxVr0mMFx74Y3uwR+1UbiZ3bL88xBG/nGoaxZtiRufkX4yJolM7HrI2EDmQpWyc2+WCMcH9qUQPpL3Tuy0a/ewB0UIIgEoHEN7Gz2q5WYRzgOb9WcCvsn43UZFZyQQk+VU/rpgk9E11tJNDuY1bBHikPbG3Sds77UgO7dgmeHlVwQNHQMPykh8nrReDgp0LUajwRYslnNgruvttBhsKjquJaLrQa/t3lzv5DDrNy2aarOIOxNAe/cjbRNlaMZmgPV1/B6F7p+vIvDwPQ8YsscJ1phG1zr10NBhf1SfcBcI/qTaCUgdPoojE0m2SHZmp+tLUt1emF+xAeIR6DDL5+AYJL8ZSeH9yzBUwNDJV4dG221lGBpJbM4DYKiawpECTsare8F5+yKqomN4/T7+vRjvlZ5VW3nwkK7tv5duAbjXx1dwsh73gE/2MXK94h4rB/HxcS+CY8htnNTGKsldrb0p05rAIlQIH3LTxvrYnxkL+8rwB7fIVgyfJjb73wEmrkB+snuMkZ1rybS60e+EW42VqW4gEv9s50/iftxci0urWRTROroVjQQkq/UQXQkaRTnmjEjaRY8/g6np12/1f5Ecf+CiP/aPEXRGvf47ZSQU+1MowKzu+eQyjA+xRPCacOFEJpnYVJWG3ohp0Vohl8lIL7Io+bSigiILm/LGErE9dAhrjHAYZSgg2raAKI7Yyt4vmnfoU+uCDN1s3wgW6o3wvgk1luEq6DG3sC0vLsseweOiCNH92mfxrsN0mQ2vkyjs+VWd6l8R+4NG5FY9+fmwY9l1nwoNVfnqqDbF+u6TV5ia7py6aY3QVTh7DOFvomYmG3sTMVBVzOLKaqCRlP/beoSBXP3VEKy+kob7mfedmc4sF2Ir3SSMVYXEpHDRUr9bdD+OiHIuxJOt32E/TyeRViKwfTbeqTMYfGa3A3+8Abmx11l4Xm18GJcE8+mYdBdFr3hybJrxIG/fMck3SkD6LSPTPcJQjOEM7PAQnMUanz9rVbkIHWaipy+cwm4+K6merz1Ao8zvECnTHD6GENbhvF2tTweiNxOc4xu6eTLZvbLOznLIdBo+UJGSiO+lzocew6oqVK6xiHg7pxDW8uHSpNmVFjUU37FU5tRbT7dyq/UmTgDy+DeXa1cQnHelkzWkoPt2/im7j0IrQjMIDNKfoAvE1wApykSsh2geiG6kkcwvA6p8aYAj6yHSEkUF1VCOc+0BFJw1c6/h45MrMrN5V73PaW90h+Caa/teWLhPfLZCP5IqchuG84/GUBEKNKHCwYhOr52V/1sGazeDdIfuRAk7P8deY5qR8XrkOeJuOKAQ4Q/iKTsZvZWdl7vEaCv2CQsCHQJRoagnXMb8cc/PmoAK8eikvCKu1A2dGTVnzav4o8LZEVCeIOXTs1QSjjHUp9quhCWOm6RuFHG4CPTysObZgvjOa54UNH2DDRvx1vWFGCKPDLGGMm4sRWZMMyFO+lPU1ad78Aj2haJo2YKqiTGaY+4UETq3t+aJTZw8Zt3Z4db5d5WQPpL3xg6nVh6BzwR/uqhNnTOi1g0WcfkXKMzRzvwuigq1m2yJCgK6mfTSsMo4Jiq6I5NQdppe7uxXdeZ86f2Ywm6RuruY/1mRxF5RlPbRJpGR1tjhiLwaLqjGWW0bXhPEhKXLDbt66OlqjYj7m6BGIWlC4M+jGyCFLOp0kkUnOjWv9Z1p4SaJZfZSXha+U7zcnhmt07YyNdOeJY4QSfuTYXv/0ZY9eXLwbZgXhRgwe79F12d0dZaSX/X5x5cVld6Pf4tkbBzU9hDN/0XYMfPO/9Q5UEudaR8hvXufCusPvjE4DQGsglHM1rSav/IpcA11/qLPu5n6zLhHhfNsj2Q7RGhSjj0g3wDuQmM64izp3kebeukD8esc/3ioAytr61oNHFFv7T7HM9dM/ydDwlaZLbw8c+tMXoQUW0dFw4VkL/b6N7az6qWzO5Ag5/cWH6gvxRqsvIDUMOk8Z8rTcbmDi9Rxz9nKJnz5Bw2zfL2nHUkfMUrRVex+MD69iNGWOIazZX8zGLdb7fIsaGxJ5H03dTLzd4zYMA61HM/tJtIkGx6K2AoYXoo9QvaZ8o2yZZkib+Y4Sgmm9WbhdIGqNkMpQIYGbwJGPuTIN0NELhgucGar5ZdIcwNZ+zYpdc0KfH8tBqiurWcLt+WETmkt6xuWxpIOjj5L0wBcNz2uhL+wzXax9aX2rwqNumkih1w42fiiGdtPsr0w5P3nKnYF++jVC4TaxLRFThsCxwk0BWMRhe5+081wP32jc7V7go1Bd1hWZWA4e52s+Mma94vE2RDAeRMiV//aFxW8RiEMRmqVCnr2bQbJd/WZSNpK/zBL9PyBoT2XHH6EauInmalf8alPQtPEz4nEuptdYllOAGaZFhItKXv+E+x7JfaeQzrWBKNOiqR9m5xmGVgGlOgpvADXAWqv41IV1sJeCjXX8d665uWpAwXif7DicrVCgWfH2F6b9SkYwlKB34sy4U/4reiWLRXRU4XT8Mp5RFRPZ1FFCsEvO5QJIgiq0MDOY42jyfF3Rp0+c+vdaYfzfR0ZC+uGHm2SyYjyTQlgqQwWeFeBi+grmZXgzoPQEAal9RRhAlbYEiif4iimOI809y3Rcf+u3Nb8MHfbP7rjKXn/FQFEnWJxH2RIncHL6E9jV3mOym8XCqO4wmYODAYI4kDgJorfDiJRuruvDy85ZZQFxO1nKsCwI1HtuEHqW3BismZM/T7uB4HuD6srm8PdknKgkg0iE/ZIKPANMYvNqUpj5Il1Egek8Y4TVzNVcVpio4W1DGXtxMyq6PyUd0pNrLT7aDpj8qS5AHoDldOxF4f5oU7oSlp4uN/EFTD7hivDo4tVBYC45SADzm2+NuHh0MdkQPdd7Y+wvpYOj+2/5VQVjeh2qg1OR3sAJXJ5Xs8RMRHuoZE0i68fpp7BQlGxI+3lfvfJCXzF1bjS8QVU0WI5Fhi+XCQbeHfNORAmMT42PR9SlKxxGgCTxCywbRhBKHl/1+fT8DNCekPvkR7VRhNBWFW2FN1rzQ2xgQo8l4pp2Q8IOgik/mfa7WMfu11m3UX/8rNipxDIV7rHLL6IPlqfD9TkKLS3Gj+FOmjPYbkXMIC2LANrt3ny8JwYaMmoAGjtPF8XgV9l7vcZTbqApEQd5DfmSR4I0Ccd7OAttIU40fHzr6zNM4BG0XrSquvnffpYlYwmLAsGEQHQFRIQAQ+/sReiRwwKIHgf58iCFEZT9uEnEE4AS0FYkPZQZPmO4Gvk0VfOL0o0zAX5P2xhh1hcoRRw+iKkRedm/7hCEfok2X+/Q81IBmnjuBWeE1m//x5CzKO96F8wGHI6WHpiIkXPDIerBYN2vzIb0Osn2z1LIaxPpYkq0z8Ei0bMpKRgYHm4vyHDs5peks6VlNDsjVo6yHEn+1MIYuN8sVfdLk5DkICMQlb1I3OM7cP8ozTK1c8T8uGFE41dqXXIo3axgRf9OmFuopqGQatC9C2mY2ySrblvkSyBVeUPy/jDuWn0y5u13vO1ptOJa0AbS9Nt8SkRNpfOpjWklXxoZqKuLSeBSqY1mRJXeYsPrfzDX8E5Guhy/RMGCkPJNMJt46ooaXfinGHxTVZdpD8Rhik0fUleU5oZmvSKUCBSl7nHwpZZ4RU7VC3gnHIBxJW4fAwzoNKk2h3zCHd/hk9YxpCGjCfcYGDw933cZYFR1tp82/bT5sZOhlaxWSQ2lLyYa+R4vIrDdLQKAywhS5n1w6rfcXYeNUvFmGX5iqjH/2zcdsPWNvM+LVroJUqD2RznRm+hWYUHMlDXlPrQe2avtP0CsD+6HicdweSEvQjU2lGcvgSe0B+nASaQvFoe4xzPR8Dxg2dxme9IwHw56/D2sfgfpJ7Za4z/TFZcB+3JR/zbqOSlrMptPuMdJKO/m5iejLl4cKjtAZ1WCzd9tZUQFPecHc1QImVBNAoDgh3GtuWQt6q7/l/8xxKPvSQHNRKwwaBSPph88wFs3gI2DjVc+zxP1TxoSkdOvqS7m2a6qLWXxBylcZ6dh3r2FtXIFbQkODLcPj1oebjHW3fQ/HMmyZAfXH5J5owKGcNkfsdgdQqiToRIJlVv61UpUKS/UJEgQjI+iCAB0zz4lY8RFgd/p/wDO4U9hWtlOXgmjE7l6xtpr7hPRdCo55htmyAQhiXG8WtCP5i1pWq2GzPKTStd81hM6iIM+47tlJCpO870SftRRV00ImdDgkLMt4PFng401FB0uo/WLc8WtbO3UXmY2kBKLgG3TcNCUFCbXB+N3c/lXLu/A1DwzeyCncypnwuSFQfXrSWBvw5RvDMN+s3EBhwIRINme97RR114jXy3yKDaq8tWMBoxGlNIt048MjNhQ1MxsLkICgyyLqeNRCz637fxZsmChdhmppk/AZ/l4utIw1Jnm8cV5+vJT0oMmw+eEYKT/OjWk9W8UKMff6uQevcZRVCxHzfLuPqgq0bNYa3U5GUI+Qt/N0QBgMUcyttWKbFQ2BhTl06lmVxtt8r2bubNnvtfG3rFRBae7zN76I6nCIcpPY2PMO54/3kk7PNe2KeSQDCWBKoGDprfBXFFeQ55QO8ESQsllsnhWUslcor3I9voZqrJZExMBT5zpeOQttE5+0VUv7sc7gZwiPOhuDeKAzSA0BWVNDZ6ducd6LZr3OmEytCtfjs4oyOLcUFTCYzWJm2MHfzsRBDKAgwSGyEHiwFrFllYgu/NREK9v4N+3tgEiN1KDAKNXKANhp9KtoF7p4h6lIdhg2q7v290R68UXaxM49dx4CjCxEKPXbFr7Jzy3MGGsO8Ix0z6a4VIDImpkxhp2NWslfUL9iDT6BZe7fS7ZUUErXZGwXCnwGsNs69IHilH/yrN5wJAViR8OAIBGA9K5Hn1knKsDgVHy16XRQVJ/qh6TVjpID6cU0RM3XgrDCM0vaLXWgMq7fBOZtrJzyW8R4FeiZQVPB90BcbiT2kOWgdvh6S4PibvGqsxlzYScsOeivRnZEsdZIxTNxWUoIKCcuieVExQ9XprkFKYUkrqBn8rft4IrkdK4VKoq+0Dz8ZkCoEOV1rVeM6orkjMzlo00UCx/scyYUpCdLOx5R1DNZicyTcBVWXM85r7CSgHIUT+EmZMqVwEbmgg7Oq/X8WWA8eR4oK8xMdZcxkD/YBZLO/UBBUCA0dk2U8zUfHZa7p73CebGD6uIKsNSHsoyJx+U6g+zFJSAqsNy5JWJCJnCghuvGOzXwu15Nyj7nZvFBLdpgHtBuJgjnUu8De0NdFc17Gaj6eWHw73Cgthn2p1XsbAnUR4+Z7Xsv5LdsQzUobQLdcHsB53QCADk03ObmMkXqFWAhCyI/lH541WEgjv8ZVuuM7/6Yjm46ecXqaHhDheNBaEvxGy42z4g3rivOcAIZHYm7hQAgnoKGUVTsq0tWGPgG86p1D0XZ53ZfwDYHpqS0seH19vWKk544cZGz1FS18vyGjtkABHnAvmVsfTmUSbziNz15VBefg12FSEOVTTBFxfDjwukBeHbIHpyQzNyLMl+eV0qfdVkx2BNl9GVYA9Sx9v6Er09Y+8ZjT0UGd1KgwHl4xv5iJTZspWTNyU/dpaT0KoVVu/3j6qQU8neuAHqUFkY0P+9X12WuJr+G12lRqMa4GjC3OQmvM5k43gGpkWpk1LKaKMW+zPAwSwxJsT6X1n10f+2DteEoHW3dkhRuEMfjikS7lA1kfIKZpXyn43PwEfJu37Qs6kGBNtTs+tveEstXjy88g4dkvmqkvGYP1sAXfaW/vYSpIcmDTNNLC7Jv54PLfmY0fvp7pUIZeCcJaQQfSSX0tDsniJthHx8BRjhWIrxy5W1mIChly2QjOGx2B+o2YAjLmEap3NuVc8cs0ctcl/6o1qMOi+f2QNheZcbsKiiE761mZZYizrlLfaRshLUTsRlDksqHBW0uBvFOTVl1Cfi8n6qBwvC0qN4lmSKDVlpHNqo2nzRxW2qw0tGCuIKTqOQRuMHSyuuVnwIfzg3Do5+suZXUWL4uT+TntR1s0YXJk8KuVJy402GNYFDAcoHfXAZp9/3Q8zhBpHg7FpU+041UtOM/mFlh7Yc3+EOuUAPi73vBXUWS7vRV9pGIOFebLedJTYg8xHptwa8BgG/kGXBCkAZXv/1zOM8PSthqlg08lMQc7fK1cb+4oDmGLYicVKh2u7lm8pQB+sUHTDQXoKcDpqjPQ3ugIeP+d56XLsRyvLXPxf0mFNEtCRNXBmum45kWjLEYr+AI6sd4KBKTQTguSpkaTU7cIVf9/978MkabuLlrJZbYS0I6WGCH4SEtiE2TbTAQXmXXZvz5qpdNFXeOg6oec4Ld7FTHQBm7qqi8NPB+5jPBrpEOhU3WOQ3V5sKZP7dDzLhMD6SJBAolWo4zOK1dU47EtfbX6KH4dfiWdMdKRxqAY9QT6m3D1PWW42O4xy4Dv+wR1ZA5uJmKeAQCSC0qeqxXmIIZpeSCr/bCY7H0PnfB4uAtyMQ2ULXXMy3ZiM5brmbHae96Y9vLHkUJ7SUvQb7S1lCk+XcQ3kC3+4a6WT0q410/VQLzyC0WFyj9dt/FGnh7CHdLpOojCtNSnml2UZ0QSmEV6iq0c9Zo/dzI/xjyeQIZ1mmjueJzZwOWtv25YI/ARFO8UZS9i3p6CrXKH5U54A5F1aHU5WPoHPXDzqULhcXFmqAqvbThcyodHaN4HrbDlv8QATBsE0W6gYG/EAYB7eFqHFWT+FNaHKwYdzxsx32y1w+MwiqgBBKFUiwHQ1891nR3tz3VhcFgrxTkUUz2vbqgkE0xVPXeifFpPAsdbturDOggdo/R7uYy2QgDq0knU5S+7TxzhawJ5BmGLgZAmWC+KNEhp7ZW3WrhnU0tz823+AoSUVj4wNshy4XcHBzHfRDKPHnjqacoXMRVBnJ3mahFYdcALx0Pk7tWb31md/4V7Rchk/P7hXvtRcE+Qeq7r0n4+rAiwcFpAvY3qnWZokft/S2ARfimTbGONvIlDj+zsAo3Rw4UTN26rywYf/HKEBOh7T/QI1l9mDrH31s+1Lmmwa00hC2uwQ7akToxG7Ld974VmHI7XGeKYY4pFrWONwIE6uqafUNGM00JOG/Wp5kcVd5fB+aYrxeNhSBEHA3GoKHpf9yLuD1/9e1NRo7XQg5gB05Euey99BJ4nigwzanSBeom2btHlcEVeXG7NwTegCFFhap1qEjya3MnBln/jY2Z/QG9x0FsVim+O3Z+4gP35NdsmnKaPiyWWwyWLNqrOr9/fgvkpurcMp8tkbaDZWWK0Oou1ffPoXzPanfJX9pfPLRRa2hOitZFVzeCHDm4Tj4OYsqVu2DWRx4dXPe3IXo0r+cjlKXP2vw8wpW9sWSG47kpnZhKbR0agrNObYcJT5/rMjwyMel6r2Ea9Xsw6Opclgg5/ubvuP0TH4QtWx5aRHb4WkpYonNzKkD0pBJ39l6Jqvnf8L9AwlDCYVFQPRoAog4KAwF9yjRtzSDjXxYUMWk33k6iV53WE5pr5GkOnw3Aihp9A/DIEkhHYhLGMN6Kkx5s+6u99g8Pd218K0GEvJGwcFcjbQ0Gzyja0hFpkEKYsIm7pzh4ZR044cFh3xkz/LTkZ7dGoZsi8YZV78W3LeVT0EAUQakKt8LvwJZYghbD+AaFM3lB5ZCDfTUhEsycZt0E7tpmS5OA47qw+Ak+ej+E4N4/BzeGrv/DLLCNiuVlYdquqxbdaDya4gpGuDtDXo3s+n3H7cxGkmdEkmW+F2rwTkowtcCbOVyqVgxT56Sa/wbJzoHAyU1dze75XiYOf7jG3Ke+TEw2cFPeTLBA7IUSfqe9QREAyjPG6eXkLpimRBtvR2mOPcD5PYkxau3wkVM+qj0rtWlktWA1drGQ+oYc00evSLkO0bDbw9CjMroSH97K9zGyfhaOPX5HOiE9smYW6d+QQngCjpsDmp1VAkjTeo/ESmA42cVXcTmXGk9k2VEE3t6UfwBq5jdZqojOVQd/hnJngZ6BPbmcmXugxFEXqjsxZnJ65ufB/0hseo7xsfz9UJx2RtAhuoHjYg87jYsDVcvMdpT8O0H6EmJ1O1Xu6snKqo8lN3zlyOZEnD7aRtpQduo8c4C5a+Gqy6eDLwTkXHQ3Rccp7qCqclC5zsxBygMC515UXJokvdDmZKJE2OLkZ6DN8ODc6Q5fmR69+LaTZNtRYVQR0mBJTSBYFTx7eAa3yq8HLXlStp0q8Ocro+zQT/81xwimeCZANTuQ5575xxTZhAoEwC7MAqeMpE4dtJaWeKrYo+sbTMSN/m6FMeLufSbHd5Ncpl7s+fUq3CGWJJQSTz6jW+cEeZ3I3jZ2dh3b1Rz1rEWys97WUCltPsfONRB2kl1xf3N1puhMD1JVtUdkc10Syz73g32tTddrE4nIoOOPFtfqPaY3Q7tNY3VakaTMvh2aL6f3yX8+BB82E+jqnsly8N6nV8SqrxTsb5LpXKEhZvXh/qWkCVx6og5qLKmba9iQEBH8AItg0ZDB2m85DvTG9MkmDrJExTY48Juv0lwHsIkIQ4mwX888rY5lJf4f5oTz1o+JNy2ZA1DY2qmGaUdkNhvNWSsKQQoDHwTM3RFSh5GBnmepqbLGE+piQ572jRlzfHPSOt0y6ASYzTqlhH7pfqiO4CCmQBuTsG2S4qFQxboAq0IXr0IkfKinzRdcyx5PI/17hLvaVPTfJjZj1HGOcK5scrqh76YznxbXmil8zGTTYknDuHEiSHkC7dRuDmOEy+8qaPQI9zVKwTvC/3V0Oawwb/ZdGbbR6z5LViOAdzS8xM4NmQv84+Vpcp6EA2LJtQaHfcraRRmwN6KgdY9a+Y3lv7prNq2WQzGmIcDbnvclx4XNOIT2wVucnWQJatj8ztquehLcnZRErFeNK39HTuC80oUWDzEAl7LeMYfSbYvnNDk5omwvnywAh2rIAM75O8pKuKNl1zAYiIak2DZtA1uh3zuLP7A8v34reGUwQmq1iLmnSgpYZ742uCtEdVU/AUH4g7flsQDAnO8cwO6l3csEGPM/+PGnMb/22W2Py2s1WxB1Jz2cS75AQI+TX0bmYB7VcgnGdvlebg91MCzpwzBTJ78rIGEMyWMhrgXliJ/bfNrhuhZhD4xUzWGBSbVc1IX1nLpNQ38u1Fn8hwZCE6eAQ3pAMpQH3rzHDBdnVF9oGG8PK3LS12vFaGLclDWeuw4yDa89j0e2S5jIQJRrrswjSgMDsnfhEOnkUvcaZTceihz+Ka9HF+9TiBiirmpGYzVLsnFenb8RAeUaNWt/P+bOTIMYPPFr1KgkgNmKQRePTwDOw/fRgT6X2wSxGOW5PjB/31cQOptBvGdSocvpgtEgHiytx+4L48vaiw/knLfzJY6yar7M4uLwDsy1GKWpsLJUQDaS4Ak7TxGn+9Biuw3I7oPwswrJR1kkzoMiCMPzz/R1h1idMFkBaFagBlmtBqYnPWxCvJ4eVMas8tJzjzR07V77UVeMExqa2d2kwUPcMMUWiusQJwaOVDqFME6MWRtX2CdxCL+FoCPgGVA47HUmmIwhp6b4VXj66R/1j/FLdwVx+MuvxKQPlkfsrzW+fI9Nh0nms5YzVTv9HZ/UpWZ7Jd22EHVEOakr7GkK1hoJsfxEEretY0/y8B0smWsbMpjbQTDmczZY4DgogSiyuSHBz8/BEPzpNAf7UaQiPIfY4pvHeZvVC14QLBt/e5oMQ4SQjwGVKoqclotT6LxBcffyIPUZft+xK2HhR0m1JHF8zaWwVC59Wi4EzExiTv7TiA6pb/xulTIqgmqow6mFAonv+UBe85k92og654mt36v04wfTyCAEX9Niz55S7b3zsW7DKBjvWsO4w2Vkji/9FvKSzLF8YZYK/oaW/z/r+fALsDoW5xih9TvfsqKLPXYImG/7kwg1T2WKqtu5Mmm5POliykVeeVbOWxJaWkGDQtTSJWImuO0iZIwSWijsFfId3uOEmg2nqYz68nTLCje6VFC0H+vKmDTEa3+oY5XGJeFkEVmFNWByQpYmG9pY/mX+tTeT8/FdxRxEUboj20h69i+xrXRrdJRvtImxlWLt/szpQ/ezgTgSKR0VYd82FTyfObk/ePl9sYgDQw+iZ2CvpEubjqMBCqHDS5Oi1UOW/ikm2HyPKq/33beV1jKP1yT416rTqut1ugeZv0FsyejUwjIthHJyRUu2QfrMmvEZ7NN2Th+wal65q8l+Tomfzu4ewOWzEtiVdKZGFVUrJbxQBSw0mad3TFIVPc0mAcUyDC46i/OuABZ/+9OhCcZbwZ31t4cbCBcnOmUQ/P4jT1h7uBaHHcrhizOCXuoLecSfeh8YSvblPSSvaahunUrigWJFLSpsHdc+gkknXsJbQKs1Eb1veGKzVekXIRJOr9GxLsTAhzofWRU9ng5H0KRWBLbrKgrp6YP/ABFW7m2Slw6zskZ8KsHsQIsO24vmThznikGjVjmX5e/m3bIbrw9m8qPHa41K+XViN4MSgR+rcNfO7Qrz34/bftUJyqCyBlRZQQdl6AEMOmrqA9lDC/vijL+ditsUzPu/7/HQB5qQG7iLo7B1Jl6h7Pktdsj6v9RRCGLDgxE27JTcAWA78VeUfKRlwO7HWSh1ZM7X4deN/Q8M+BKwc7hxTC9ctkK15PGDmWse/qLsPw88mpNC62SzywS2Stsxw6q68iQiWgQ5lCjGVlun7jlVk98nrmhrV4l8CrO/Us2L/SROODgKssFVQBzeP2/Iobm/yYV08teIP3qMJwznWfmjQ9OmXzYXAiQOyNrI6wa7eEJdFL1todtIg9rdEEa5TivrWTW5CCzk8efnjntNtakIWgHXCflizo6LwKCybxjQcw4YIbVmU2xuL7I3mWhSmiR5Yk5cGLzL8wnueKmU5TPVZCx4/MowOLCy88CLvghb0JLzd+if+8Juy2rN9lGz9PGyQZcRjXHb+6qgH1BdMt7N3cZLZzl0MtzmXXWnKUfTic0UStScfvKKNHu9KQHqJv+3FNKAnQDUdXZHyw1uX1Mmie01jVpnfbdNbwzDvrByt0kBqXnwr0byl0irx+sGYdX0vghx/JZwH68CWHB97J7kkBnY7y212vTZssKHFN7Au2QnWaZglTB4N47xAl3He3V4eVk2LAthRkE9XUo5wmJkoVRpuHh+g1iwmEcYHbTI2/wdPpbDZmpq93sew1EYUkxJHAuEzTpfMCtMbfbuMtOaKPFaanDkmIV2lXdkCQI9gVB+AARFcs5Qf4zy2jw9ahu3uNZa1QWifmvhNFQ/GhVON8fhG83M5iHvakdluT87IoxzEQhDLS4bUZ2BKzkXlR111DSZYDA5FHtYC3YM/ilIhW3HRGrMfrw7SnGoKoRufl/BVwUOtVpNFTjn2+/sA7J7TOTtsJ43xAm97GY7Fjv6RCGuA0KH1N72bFaFKyOQdgIjhJE+3SErquz7ekCkLFziKGLrO2pKHWiGcD3JiQtJHAk/IYjI72Up7M3GeWm9Rd038zjw5leUEVgR/s6bJHp35x7zvYIh0HWjdFTKjxa3ZU5d5LuiB7gbX886ILIWQwNHMebJ7oiXziEHU642XETGsMaIULYZLALP8GVLkrPOb9eSbPC4Fk4JodiqZNdIpgqKjmU/mN7oEaIcCIepjO9LwOwLQtIN/E+QIIwkjq8B2J8Fs5LcXyNt5/gSSY/ZIQh79n42zZ6unW91+/jb5/u2tRiHAMEgqIb/tNY49sE5kX+NxWLedo8l0V926EyuIaQPRbKAoWl4wmzgKM/XvJ9Iq9hSa58joWpQANQSsUcLuP+qYEdNlUneo5K2gDraq76jooB6Uin6vGWnJeZ/DVzvReF8Y0xJDd3aWUjupcbOCsrAdmT/5/3bTPLjEHKw1minLettj5UikBOKVMfPe5IASu7RS4yET32v18yf0WBHmttuL72TOZ0hlsqw3faNtDO0/NKn2VjxQpW6r7FazwF+douMY2uJTdJRgLiHt2OD+tyAt7NzelyohUNqjMgB0r9lH+i0HaBgCpXx8+s70L4ROU7sldXzspphbDaA2Lmmkkkt+0GW3rVwGnjJ0WgsmCxRlSPl1OitqxXa+px/8bGCC8w3BfCvCMdqlmSF/mV5IfbG+wMC+bGE8eSZz79swUv7hbeyNOB04TlKokdo9g01TTZ8ot+a8Fy+g6L2G61RLAkU8v266TMMZ13/ve0s2ZgZJJ0u5dd3VPiMz14p2g3FYJjZAhYU2/YOVhoW3yGWMY25Qvfy+ny80qEIPvULCI3vEOk9CTSVUg2TrJSXHnfj9C4KkMTfBd9OTtNTZAGkyUX8XTf0W4PzH9oQni2jJ5A2qhsE7EcyHwve1syI9+4TTlV/gAxwSpDXQWoTkCqWDGX7vyY+CDN1WYQ37tXZCeQvtfwbQLJBdIYfmLfxcyQfYFCHpb5l+GNtONZwbnQbiE8LaaIRzJBnaSDs1KL10ZOsSM1sYmwKHfYKePHw5lUsEG+W9BFHrSFGxhF0NiNDnB09ZHknsHglmbOFNaLW1sUpbbsbr+U9+xjho1nlZpPb7M7EV9PAC887m1l6LhWLua8wYL68O/vEWZ6pu0QUkwQYOhnpftxX7zorAshzGhnobGo2pCKaXjc1PqKFb5UzIkG4WQoZq4okcTkXEKOXEoNKWU3wzLnZ4jopiusis1WQcXsYWXb7lBRoZmCx6RtJ2cT9cH8hm9dFNFAnnEE7kXvuIE0w2lKhPca3HMC8ajGW0+PHBSxGa7jn1DQbPGjYpodkbcZG1mzE24Zc+d0seRLOSSHvI4JKvPXi4RYMEFxlC9jIO9RSKM1i6L0QiDbmHxM2UG2WUhrfXArPxaWTajINzCCZWycNNV2ucjxNutuD1G5p26wjelrb6lW5sv6E7wNFQ2xE0Il9I8fY8YLXp1J43jYJn2eX5bYBTqUOoUEIrhaQmSH9W/16BQ7zRuvOtLpmPDkkSnwbUY9T/iL0xNs5OorWZ3ewjO8tLiuOawbouwVoCASJYu9dxjhNPm4fs2bsQPCkZ+ugTv5G18rXqRuJJvMI5ZAXGk8v2+ChKXLseLepHE9zu9CQKwdv7+C0jGYtqo2fYnZ5w50h49u1K9pS8UosbT1MLd9IkNRqwTn7rNfx4NVgYL1nMHO5iGEiiyd9oi6h3APFWmW1tDiSJgffNL0Kn5KCYtC1ju1odqrTdQOommqaAB6NYe5mJURcfEn/1PwBkNwqFEUqLO0G4ON1rVJhjH/Kz5RUcKqih/qzMZe4f/KjI4yJrdGDTtrEmyJAb8q4sHJ4zqL4dJfXhrC/D09LnajLJGN5pqbZ7a/dRgyUxUwaDAIEpDWuaEvhowuON+P43SkDMKAc8jMblh5n2L4YNfkBah7RlY1O7YrRDr42b/LgY1HH/NQ26nhU5yWIZ2D0RVdd8izVeqecoP7Gc0GRLAIDPJIFZKH3dxmXO1eBZ+Z1QOP0JnHt8I3ahkzGO/hIJeZRdPxv18tHSLrag5EOdDcXyEgBwA0FNkwXdQ3gA4xw9GFag4/ewu5y0bxS6MGKQIGncF02FfHkWKUPhG9lYwbJoFCdocIVgPlKsWutmeyiznq6K02rsuGe37D6tRaL562d8ZzIYCGNKHELlSpew52Dscxg1GNDkgr64+mmXmHkM2lKxZ1CkyK64vIyP/rdCGzubyFbzt2uNZ8fLNtNLk6h2ezZp4iN/CHd4NH/z/8FiGLATmmHdc1LbWaKKrCtpStrbgHleMpyib2FI8s/5C5KQPaXLkGcXGgjtc3kddEq1yKCc/4aTQbCgLXcJmU8+UAuBxcM7V76PkgpeYEoGjd6Re9c8u2L5RmYiMOUCeQypZxpsz+eZCn600LRpKnsbLEklm90E0+n8qgAML3xgfIJNkHlRD+U1CdTsUWF6Zr1iz5R4etkUi9L4gjg6tGnydoIU7R/68Ys4+W2Lm/CwZ/0RwRwdsK4L4CzKk5igFT3/XhOcUx/dSo//YJQyouXv/UJ1c6iKFc3CQxDnDM/D3ioH3Y6suWXNfHPGc9LJFipN91516VYQ0T5/EPASSTZJZGPq+dMV6MARXpRHoDRrUyuOIe14vhMUp03f8H3sEVOkK3AAuAyncHE+wrZT09MPYJsgauJiBRBv/tVm9+Rii6wV9ee2xUF4jE2KvZhP3KYWdF2phaMdWjpoMkC9iNmbODKJK3Vn6qDEH00LGIAepQI6rY2zYWFd7J6XLeaAbYkcBJGv52kov0fOFZ8cWvPZ18xtMJUKY2hB5H96yMuAd2Wdv+pJ1qphr3Z2z5c8TlM6pZLBRYZK+Y17v8x6/DRyRrhmy4c1zp2Ls0827wLXqkU7Z5jqXDvlDosW1WoLz888AsoHJU29uCzO6GD9jh6MJMo1EjU+auaikNbJX5B/fc1CDQqseLuuTqdyEKKLfFKi/6dCWqfZ9j7oiq/OzJZYMnh/Uxk+xHJCa+LFCQDu595Z1BNyRLB6Nqp8Rf0/Xrb6M9G1pOkXUdezYQ7RzfWsNaWuvUAWjQv1jthazgaYvMU9JlrG+dENe7kY0IF+Er+/dKG5XYUzmgsef9FToDpexoeToUfy3aa9Op7jCa9r1zKPZH51nlT9wyDsalPfEnbB73LhNUM1/8g4rsfOaXpndweZ+VjTBlRmgNxJvPDIrMhMfGHjWsikQygR4dbvgdx+4LmHT/F2TqAKbdIt+X/jQienZBEHLY3R+TR0yKE0r8NDjdedx+aE2TsZhMgrRG3vRH+MN04mzF5nfsXfgQKZhzzKymb2cIRO8XIihEwtW3QycP/v+xudP1SgVJEvT9Nmfj7pXhKxdc7OuMjB4DXqtw3tZTF40OooOxPx5mChxCt5Nr2qeqNVWOjs5ZDo8dm86QFaCNuNDc3fRfPU6VHKsWYg8CIKMt1PaoL2023VCbo0DYzr2SHbml8nR/bOcV7V8ZGvOG94m4qFsKfBHzZf9Kq34ZzQBdQOgUMB02h2dtUfR3xo6ldoAWNigGtVbkNrN65DADOEdwujMe2XjkoLcaUZS+fHQ1wpu+cL/JuTuWwpVFHUhWW4Et6FZglb840+hooq/CXI4YB7CJOt4WgETfvwQXU185EeCwzPOkQsaQQbMuqcJdmFC2Y5+//YiDUcrSYET3TlPpJqM7B9p8OmJ85JS51Y2Eg1Twm6jbxKighVZoxT6MKih5sPZpRn9WleLKwq8MoVA9w6nhEV4c74amp1RuB8uM5kJ5KexxY0cCR+4X1QBSbC+YnpQmqk3jZ1/ffdN13sFVEPsWehjAzgLk1Sm+X7C0Sb6MRGWRdXcNAXc1c//oCZpQeUOY0RNo1AoX7EaF+VjaxWYr1513XfAiijqmqKbwi4moWdyHsR5E2+cXTHuCUHfIyYj32M6WU0jvU2F5F/dL9zQNZF6UgvCPKAPJq5kXGzbLM2dc8mYA4t6i3fkOfTtRbo1EOsxzVXRQk/IN+rPeiagom0td6h57wssegga96OlW9P0lTIAI74XNDF8ygYbjtDYDiBfMd0Vo79dyp+S8A9qNHCoUNIpLAIZQ/uPykDNCHF9tbrkOOEqGTKACbUKwtLvwTmU6SzWNYj39ChVk8DrWwuVSdeEZcG8IYE5n9sslj6blvRRl/DMvWpV/Vc1sM0nJG8+SzGRvb07yowXWtFUanTpbsRUg/wWj/Gyb/FwGJfAa10ztUqjc9JTjKpD4QdpvB0ojkgaTnmF6UjZ0t/fFqzyxlazNXaVZkF84wYxJEN9MQDtXj3EnTNijTC2xStvY0NG0gZPKDI1U2lPi3KpthOgIf1tuX13z2yz/XBaso6ORdv1pc0Hqa/25rs8v7Mc0CciCS9loxDFR125yU6b7LsK7AUKvfTjiz7zyEwDdwa49mWbLk7QqqbRp7dCYCn3PyBIhPEGYXsgqy/hUsROxCG+ONpCa5dIvN28CvraqgQZuDKFosUjp1Jda5sWuMqSDxUSZRlTNxGtJUqPHiHoRJODM3Qjssj3kjwMDGtk2P2OAKhR6ucwbSL4dVegJkXkMpODA0zKv646qYYK+Qy1Vs8DtUNBVligD00kolo/YUwssvNVZSfkJFV4XbYUhYDSp2S10RVAIGhjEk0Qabx9TBlgt8HhFClYHlW9pQWPWQ/SAlBgSk7FjS6c32eF13oCy2z+k8RDsvv28gYSqJyxvIW5gZXD/maSwG0aL8K2kZD+YLivpPkHJFni1v1zJt7rfnrjT/2CjCVRccTv0m/9xruJ8PJoC5j3BAUMYrEt9iX5140RwHkTqsH6I62McvSc1bH0K4+J7Fz5GfJFIgERb9k4if3x2UALoKG6YUcj70DLZNvN58Bv/HTsZl1itIdrdvT9B48s9DLw5VFUU6ID7+SgMTC4N0uFz8dQCKx6Qa42noWfwBE755VXfratEIMXvJv5llk9cFjAHyoqjEHmmdY0wuzwSqNh6y3x2Y6CdAIx3yeS7TwPMOdmEVnpwjiv9lkdWuIdxewpWs93r+/eWU1LSbk89Dwnvs45zTikcsgrPN5ILpDqJ2ZA7QAvTE9jevzEbfglAmN+Cd4GQ6ShUlgreeC6IeW1VkZIBmc0sh5t1ea1iwhL+lZXpsVB9jGQsIYSKb13VkX5T6KqzbqLBRg5iBwfmixOfiQSIEp3uOOdNt21HdK10ObVyZkgHQPUWLZS7DOc+TliOwzUxLvdwl45izI7hS3HwMV90YGxxWM9TDQkLNmRj1IHiv/1oT1DIZKcQnt8pmhfRryjjeBFLZcMcM34QzPMcBmkBe8K1h2ynkljgBrguuQROzaE0yoRfh/DvNX6VMj2nLY7qE+TR3l1uVjtsdwbAnpcENmpgJ2OcxHrUklfPyfHyV+b9q4LqmGyPXcvUOEse9OnucqZ6nE4YHkFqMps310R9LZYO1opAf2k2NoVRE5mvs5pbr5oklb6pKHvGFbBksKWgvlIj98Enp2uj+kf+Bsos2FMVp1ESveQPMFuFbRVfJeNjIrkrgVnINMyFa6rh9ivGwMqhpeQ8GxacG1UEXVJKy8KR/NIXyT+9WTKY76fyTwxBS1FOtoBwEWkiSUWG6XCvCprOXyygEUWBpIovCpilxgCFezvB/Spg+t/6a/FsyVdm2NhHwZLrKHMxUQE+1BICcs5e+xTEqZsMnpGfLuWzs2Nq0lVHEuc8KrQdoyNj/EbOtWRjMTXPjtEHRmeTf7NA9jOez499deFFQvPBrBFnsK6/CA57EpK6F6CzPkXaLIjJ0nipmrODHySyxqLJvCfsrVq7bMbbfecu34c8wuLAkptA+Q/z1kRD8pExsK4bOADuSfPSnTzCZGzvzhify0mYMO4YEPjQwYvXxrRQ0Hthqf25fs7f+LJccYmRBiByVzBhcJfK5kXZ8wP61TfT3ZM6NOXsFrN4ZDhcmaQMzS2FOjOkh9mfa47GMYLiLVfpeDwEy8JC7hkcIy0NzNvlIvHCDOiGLpTVWJ3xDS1V+kLFYXP+PNUDNaptz+Dzui3UugrvezZD5oDZLAyDPh+KPNWZh+VV8zszpHVXqk6pjCSJ1R/Z4UhXwQy5Aex+E8N12/f8n/EHwymwrwJ/1kj0Xsz945CsraxifgQhoxhm4+FwaQiUeXwurlBsgjtxuGApeJnnVAaDH7sZHwDq8dpxdlUknemCZXDfezIwpaT0R81UFpPVFRgEcItv0RVjmRNyBhElJ7E8jyBPxwJqQB0zFJ4/uboAPG8XO6aSL5tEz08S2HHmCVTsBwzTsT9NeiqZ8RAACK++ebkKT1nnN2cstrc6SkeBxg5K0LFhnFTxMXgYzg60K7e/Q+2CQq0wYwrP05s0r0MIplEzVX12bM3MCU4qDtJLgZw6YkX8CA8sZ7sMSR246qClxvq8AlKsgwa7yfAbiDQhr0lqufYG2anN4kN8NThA6DIUBvJcQWB/QcnAD2T8D9ZQPf7hVB12eIJfKabAcF7NNlTzDr3OcP/qQSAuxC4NWOA8Cj6W8jGjAF5tdxknQzcSWh3IxbJFJJyyvg+5Zd8MtC4X6SR30RQ4q7JRc1kmH2hadLfsrjVx6D5sEV8Z9CDvg2xLAjQsmCK2Q7LSrJioMhgEP6vp5XNDZnGOqA78IEgT7IRqbdbm3vOnt1qb2sspnyqO+zy1z7ny5N3aaRJKbFOEMlyRoMM+KLbkvCgotZubTR4y8eInkxtupzFCFF2IMsuBnHoyvPMhSayH37/a3+TG9Vf3TgmJuHoGipDWcTpSZAhHhlgZWJtlt5hWwzV9BF21qgiYkRLBAQdGtkjWJOR0qBu76P4RpiN4mZ22LOyxvstH63WYvVcPmyhUTdI6zO3KplMs5DWpPi9cOIxAQZP+GtTl2O8j9eTG9v8I90NUxLcxj/jRZPb3s9pCJbburoKGx+wmECKiT0GO3L7yXFpIDnRRHneQDVL/HoUwRKQA9PysV6loxxcaFKwtmg1PFov95irRk1h83vj8Sh1wPmhSyNJj5zIBD1Ul2NgbkPr6/oAcF8A0M/IeRA/Qb1k/aqoKx+0Keg7/44gHRo7scgrh163McNmUcdRvPkrixiiObUDzEik0Seewe0/BHMsfh8BwGAoyX3AM1ZYHBnINTueE26QIJkhL3xYQ4O3faZgAMM/7msU7816iWNzi/LZU+1ebszjRjXpldh73v9hBJTs3F0W+WqPRlXLV+tGaNUFpGGh16n7Bjb67RMiL5HlsyuZSkiUHbtT8AHvG6y5hY4pN/fUA4V+gwmVjcPXYrOhlO9Rp5MWtJWCXN9qbNGH2cUKZECdAzP/IGbuRmClCAByIKKQi7/rY+qDPTtPRjtNv0As+8skQ2QYfB9+eQVPqMNwt5EPT20FtFFFKkSxpsTFxjxFse5JMSLPEHWLrbnAfdJU4DJGB6Y81/ZR7+sCaxw8KeootFPNRqW7OmkRbSFeVPNIgl8UQwkhm3h3ln+Ci3yCskbBfq0hY4bUNw5QYkaoIVHysLqn1ohKzyExvO8n4nWXp1nV2ea0GK0sNQAMYYGsFTVXJqiLewDOZTKiPgphybFdJTgrOctS/tnCYLpT2s2ZjVSms7kGhucStKiQf0GYQLFB9GTrCE7j5HQ6rDCkHle7DXa6p97FsvpRtKa2a4Gl8j+70V+29bhu1IF9p0F+GAkiZoveQIzOym4JG62rjfqnsrRpxZTQRi9UetSaGH2GWmebLuKvWyv1EdI1w4JvhmnKc7eSn7yCNqhed/0V2hA4XLA9X2v38okbAbkssbRHrxVGIZJL10Vb/TpDMBhF8COgluA+vpYrZGzcSJYWGSJaJMGbTBT8Zo6VNZdbUvnjq+0BFWJ6R2kPMELAAeIyMtvQjzpBvsZPIb2BoEgXC8gFrBd1vpv+DbIDCbpEfmFbQlQsuuaQJBVt8QRs9/He5IoXq78n4ir+8D/l+ZvadXk+SOc4wgNnSE0oOLgIUmzVmejJcV4S641mt+B5WYRPH8ihh+Si5FzFqfMBCUCaY0qMycC8tJMlx6GOupGziw317f4HywoDg43csXYXevkZNvnRF2Iy8+9tgUxz+6r2IVFhjRjy8OuDjX5MC1Qveu7IK5VF3iht1jHxv5eSvuqSJiqlyKDmZNK8IRyCfnufTwr1YirO4r6bmP6UMciYVP9mDlJ+Ae250eYbv7aOB3U5yvNDnBZHE7h0y9SubaBTlLlujflAvp0M+kr+K8OGpLkGBlhuZHUucTszaWBIL32B3uxLwgmG2DUDr/RMVjn676uyEculjdR28bh2WXbo3gnX1HFwhCi8woQdTgUbNklx/7DPVyrK7v5fbE4eQ0YVlCQHpAW+dCqFWRe00LroG0hWo6jyW69G8HkY93ZlPJKLDmJGQbzkzswISPn7z4Y0Q7vA8jK654LRLbqlNX5VpFoys91yTh4K0ecJfpZ7aCyG+sBpkVn7XsBTaPPakTnEjdTREgc0YFmaGgLXsWZtKApeHBlMPN2AwQf2qXbggj8M0Bky5fK9mhDrF4el/5nU+z3AuUYW1cK1loTYsbah/a3qGgoWE1xXmcFelP3tytZAtfYI97TtpQ2xsMMT722Ev152HbnfT8Ocwg2eRkujGpT5Uf7dp+AWvut8JISYsoUKjk3TyY7PI54XXCxT0Blg8UaMU5aWmJLItbMzElP2GVHM9DJmjeXAaAfBlVvx6nPuNdh1M2eEqTqhF5nvnfJ3FXhqYeEiS0vPVYM1v9HBtgF4v/SCQSjj6tXDhbtiCOMVZ3LkBCjqkJn6voOpfBogdH87TBqJ/WmgdwiPEftumISEMs80S/jEVraKEF+puayCh31tr3F5BKu5CtVIeNmmg/Ph0uschIrYt/kRIALaw51gA0HKuhE+3QmAslRBGOBYoZHonQO7c65jmvLLvi/1Tpr5cFyP6yrcL4ruXhpLC0BqguuLABoz20lwD8/paMg8nhaOouZxMXdGoGjSusp1WwrrVblNaVWfv4NptZsGtmF3HxNrNW29lTuJtL8au17YQc9vhQkrETL2h0Xv1V267NF2D1UFFLA5Xtv70G0YXkb2oJsRIrurxvwit32Twl3W3jURaLQ2XEaFmsfuadqTBNJ4cppI0CvLzLJQllIFWyNk9kkHJQ3oHE9qnL7mgNiwRQII4Bk6rQRcHlljJg58IltBpfdX4PpsIvP7O4WAm9r4SHYS7JDMGKpv+9MIzO+sXJ0TvA5zliqz0Wl5iH3xi6hBveRZZ+zf+ROogz9i6Dbh1mleP2pPoD/2ScqzK3c1BbnPHNp1YGYDDjysBaKJrGQ43gAnLt7mP4Oven2t6NkzchdABZ0hW6qG9kHPV4PnOsbjEwyPAxK71RyZios/yQhwzhMTyc/nv+dmPG9z2M6q94tvKReaTjTs6Zb6ZylfTICuBWoleYR5Sr3zZNepl8oZfKYzYVMuxxYNYXJzBXHOsHPbtcV6QZXgQ3oO8R54MfIlLeOqUs/0lB4kyxguUJfzJ/ZIKaGbq88Wef6T2VRN79zAOfFbePbu6v4kWScsFwPSk+L1h+ikrRgTxfp5dx5ZtWt8OJk8RBXlagq1WaX8qYXI5LXTPgQ8/81AFUpbvLUxDZiirvxzw/WcLwcUg7sD8jVobByqTroOwbiHmu2lO++5jpyH9p0W66NksxepUJ6ozbNqdpcZ8uORwlW6xkZrufvIYckBFoifzKr5d7ZF/9RBoGl5jWzfrRAnE9lbHnlTEFXo46/B6N+TNLbXufsLmIl2+W6EFoyNX4CAhI6YlBtgWScfinI8s9XrMoBO8/BoI9z+AC6y+ePgzyjq6eqJ5TW67CZQC4IdnFfn6MsBv57IX4BYwtemQbwO+WR8ikEwN4RH3z32/VExhFM4b6W8r3r1FDs9GBnSrPfTrJ9dRWPJDk14lLq6hlFpqFdQr4YMweND0sw/wMp7EXeP4+RjAvrZCppwh2B/5rBzsQLHlNNOHTYRxxGwwnGjxb1mTrXpLgCfmgQA4qBmEWe6gnIJpdO9P3M+n9ZjGJBUh1VsJV6HO0zJu0vGblsq4iosndXdlpllEM5I7e7i4F/M4f6e+MdlZyQ3lOR4utME6AG/oNauoSy+dHdkKq9IBdIjZvubdpbc/8oMTOelBU7zhu/J51gw27zGHxapAxidqOTHf68DOaM2TQYUDoHjRSzNFSPD3gQhJ7WuNlqPP7Ri4VEUfzBaLD4a0L5YYHGVXAwTBxptet6IpI0sH0Sn/ESFnAtgMPFCawK+lvrtNQxflWv6PSHW64JFX2XaGHmUPJfxFQOSqg65maCoxq/VDuxuiyB7odMWebY3RkJuLAEWsSrWGKvCV4+x2qKjcqefcorG2CQHEx9fJB7oM9446Vzba6riHTl16qkuq4dTn0kWVu3/RauEgG3Img4B9ib7Mo22BIi5suZxXW2tyvoc8vg/Uwf+mkydZF3wyjcj9VWNw4Syfb7zLpGYNByFlGdug/OaswXeARs4vQPrBacO+EUeRNk062b9BmJcP/b4ESvqApVWi6VJ44phVLPSrFJaBuHu4XAo8qqFh03RM+ui+ZmQKywFWdjyJ0SB0XpoIOkkjBwYA0g9bLvK0d2eiYyg2ajW7Fx/ANhBLoBHBdx6APlDGtpBToXr0hNR23styPZt3EUNYPRPAwb6WQC46Tg9LQxXd7nL1RyPhTvhMGin13E5GEtwqfNFmWcgXejawTFazs/IBuy3tnh6TQ1u8JyOBqqewNK1Sz/FYNOf4TOenaZ4RjLI1hwfbmO9cGE/+7UgVp2ILGr/YGt024KtSEXkt4HPeDzgYUxdXLh+HStr2Pn9tQpxjc8Ik22vOstydbDiX1fN/+CBGYG9la2zWipRscUKoEiI+C7MS+Lth5OILS9uy9vJDNfroCcu1Fijqm7ENTFnaHtg6+NkItylZp5gVgaBr8Agcs/qtoD3daK/XXkX4Kefe5h3LkZMd9PuBSqt1g+N1fQNn7vj8lpA5gxI2cmAAIss+9GAlLnhiPqz81D78dlbKjEup3w3PvzYxZ7DGR4f5Dnru6lZDPUgC0qGiz3azpCVqERV/0HFVVHiEe1MhIFRi5DVYPwr60Ul/31As+oDL6HPJ+/pprTYES0SMoC9QvVuVCmMRbT3VJt59rooonmpS5YMfSYsjgqWFuRK/PAqI8XCSXnfPMYDaAPIxft0xGyn2gRmu/467YiIpYaA+oAWe0phXqZNHp823ZzGykyOk1ZMFYO8qw06XX9UWyGnKNZuQ40e4qJvqBX6zx4fsuNWA5EPg95TNxEgiFHGFRTJNY7HSmVHbpmLrUV7ppdYZ0OZdn/cMrMTk+GyrQlgGiE+X9i/9mauNJEKacNOUxudrA58PP3hdc7kasdANx7uXQVOsy8dN2FmMNRS1o530cl4z0twtvk/JktCKshUuWYnXDK2W9GC9tgjar6iBH1eGoZqKbpzLTY9A/Pd4QZj/YEz0wduKTqw1KVbLq0+Bx08ThgOagk1BsUDowqBYFvAPZxUbT/uLYc4kmkLKLNu9i8pq81twvshp5aaVDNdHoCrTHXxv8Cy4VuTBca0NDk+3awiyd2kAGdzNmnUPDJyERXzErtbU2BapfpDpzvaXxZXn3b+eZoW2y5U2vdL6Fmj8467xk+sJfqxnj+B8G2R7BbPwO0Soh2WRwauUHdUePsq5/iVT/K/j7j0XlJ1B894TcvIBcMWUneqJzw1UUpopWCpyhVy8ikql/O9ElH1Y98GXO5vQOO8W8PwgvLHeHuDpp6f7aQJVPEmzxuNDSy5kIBwzVW++XRGVfsjvrHgcnonthMzSZPL07v+UFMHW/ZexzAJRp6dVDb8Arn7PWohYRxtms7RYSTMYT7vP3Wun5sqHJM2gwPXrNKII+51tjdniQCBuRkqlRVTvm0gIow50vK7vlqjl5nCfD3a56llj5zA/SSmUSNljM3NkmYhiZnU/l9wX9JT+vXR5/8BSU5RVXZqpMz+sFXZ0BJt0MSc1vMYa1I/CiVd6AIxw58Pbxq/Eg41q7hzjDTCa9qC2IwwXtiOAcIjsfA0mi/sKIkBM649ugzBr2z05gl/02421sQ9PLh7j/gFZaa17ejpWi52flpoDBZNwCnZ4FdhzKjtImYZpaDolsQtGuRHyvVtXtg9RUrz9eUToDfsWspZHhD+naRT6POZkD5qPdFSpjsFpGEPesayqHr+IRSdvaz6xR8AFC7SHE0D4aH1Pao9V6aTY1SKAJFoHL2OsZpbwe9hZQQg/Dd53SaKP8cVR5F3c5pqVRDbuJmhgNKBm9KBdOBKuvKbm2hiM4uJjJn7EroccM+USV7I4olMteRdPzyJlkAoEG1AsynE5BTSx0jakRSxS/bBC2lBFjaHbZCWxtwIjDPtyCQ+RLK24SfLkDESCtIj7KFzNAXfy4flN5rw9rfcM3auBvHOmD1Ca7rsguDyqs5Zd9Q8COTRWOVeYjHyCwZUOPXZQ0umN3QUdSeOJHGFTVhr4HUG5qZAeFtjE7aZOzkQcpZCXbY2PgPEsEHHap3GkYLPCLk7Z3VlkZldKYFHhtPaJbY2zaFYM+yDe17fpzoIrFpfT9/9Uzs7nfa2E2pkoHonA2mkJMZBE/rEgechGofElJcYBYTmHD1x/zwot2dTkeOhJLlVttMwgXnCY8NBsRrRJJHaoU0YNCWs5teUPFT7u3KMvzeuwzVQUlrOIUOi3WS06f1KbscO6ffm/A8aGlSuilIsn60ONeb04VnDUe/wEqT2ZamoUVrf3CrAvAag4YQBqqu1GNyiF95BF8RP6HVv4FlfTcU+ehN9goOr75Gv+vkuejEmhti41SR0+KoDYek4/xoikcZm9h4pU1xDSeL98Lc+9v+AyII6BQMgbiJPqLRUDUI6juXN5DSssiMTv29iDPwnzStxEzcdcPANUkWPrjcg8IvPrpvmPj7jsj5zb5CRaJM3fOnezXr+MGBFYSaqH8uJfT7CVQkn6UmfWOADkfUYVU2DlnGomLCRiHlE2hP+494Je37HqjFeCmRTOGSGfAfjf84OoTvxhxxCk+8kOLu8MNIlma8i37rLMyXfWIxvY/IPZ/H1gwrIYPnULZj1Sal+aOMdAG8x9HRbpPOgvVjRY/uHwF45Mvo5A/atRVXBLzm5pnjte1d1BJGTk+KBPd6Ps6hqIvk1bpTCbeRriFlYHNZaPv5RjeuBFM91wO15vOFaHpQLOwLaty0HEOH6/Qh+BrfWXRVZvsi+9z093RgTXyIHNQxrI4qfWZA+wZy4s2VVHTfoD20dxNRphQEb5l3NKwPMqaCjMs8CQygTekJCL6/GbMX9HwRqYhnqy/Z0HMsiJm6zdMAPrOeBhlyg5x9H761HjC1IVt98MLGcJma30WwN0bpIUtQDucUmNQKGeNPhKGhzlbjH1P1Czn7YyRxYiFogXLxF2ZfPfcVdMBFnpfWjyozfaNrcEgXOtRzV6ZDV3A+Ke9x78D//LxQan27S6LtzINJ5Rr1XEwiVz2+31Ww6O+5M8e3xRUQI743wPsZVEPlvbZ81MHIbMaSazkiowSWnytpIKyNY1j/RGAHqXwkqONCseL5JZs+2GLbklqgMXNcBfhZcFizOuWrudGDYa+cy88yRkhH77dcXt4IxRGVD9c+bycByx4EsK0CUwrLrX2FHkVYjuWQ+tpLU4O9gmtztj/3zAyx8QKJoXiV8bMzXJReGWTQJHwJGN5AvvgliDTuxXKsb+eCZFFNHJvQVSTxZNIoMPN/ZvcEZN6KUEGGxXJwqw0i9m7pr8U4fTW0lcFP7jbak0Pr4N5VQ3QsGfOnbO47EwVWK6+zBKdIK/nwzptfz4zfKh2nMwowub0P/JjJgfVVSF9kMZsqrBpbNjC/HsMZ7pdLjhRu9aBbfAG0QfrZbZQoYmHAXAepFVIoz3hsa05PKnVT6hhr5CB8+3Jjj7Nnb5t+o6p4xrOsJ5DsZ15vW0yfO9EebD73m1R369/5lHpRSw5HwfZBSg8hfevIkYTtis1AtBPf/J1ExV8+tXU3Y6sotzIrq8I1HMhzZVOyngOXJteRcc3drEL4OmNu0tw8SO/JtwKMyrJA8lWtZQeF1SsY5ajAmsFOeLHrI0GKwSSsJgEEXxhSxSXCyDr4ZzwhZrjm0Y5D9zAqMrJBUpreeR9f0wS5u4EcZoqEr2iOP1aMehFbfH+WAcYNQPYPddJYPiT9VKccAPgXgq8X4yIoJoebKdg28d71trbZxN895huerf/CiNc/CnYlVeTTzx61z8ZJd1crouYvxYrJsddLOookya398l9EbehSz1uOI4h7m+M9v74EC7FtOgRBYIef7sM7FCPTV4ML3h5Bhz+Gkd/1IWwbwMRbDPIMSgTSmtDF2BeShISZGCs2L8RK74zaOGIbttG7nPrY3srMPC6M7fcPi5YHAlvXJIEBuMdS3ICwsW7b8SvDWHeF9Pmxq5g6Jlby4T4Wj+bZbHq5KKOeQAq6SZZLfqQLSZb8cQcitKXR/bJ8vYaontfdFph8Bed3A/ugpSSahik9Wrq7BzvFuCYMRU+9M9h463txYBNzntI1BWwZpYjygxyoF+eYwWP9+WMV09Tt7Eta8hpOPBa15Q32gU/W3KdwQp5/y3imA95mh3gVWkUbsZ2AASBzTpPa/WSt27PfxtP2t+MKKe4L80oh1AICQSI81IUAs4iHRGX1crKdhJqSlGpqS2T+OZUg6bzA5HZ5jaE8FRGnxbtiyXeyWfFnNRKB28cilHHBfG6FlPm/2TvMTXoJEtDf22Z8YQssKt7t+/o+LDpTRZuRSA5iSHYWuuEwFvTJW7omVKWvYuL7Ozt+/72K8csZ551OzuyeF6dpWRGmxYvnD8i/POyGHqgTDYikvjaJvMJu9NIjA0U+EjYEojUGuq8T6hbEJigLlkM+ecturW/EAt3Bz1C3gJqc3ZumoAg/lk2OO3ljhb+G9f3B429uF2MMGvQryau9pVh14RjTZK+0q0Vs8cQbjoZuQPaZ/0j8nTKBq3jZlvyn2oQvdoIPGoF5OBm0UUmSVb2SkH4+eGf9qENnSH/SAduOLLscHWZFYJmga9nlyY4RumZWodu6kqaO0FMAabtxJVRFFB+g9mgNMFEUKlXdRXdng26pTgxGpQsajlRC7AlNdqFgW2mOmp0ILKBBm9hcVc+fs3LKeQxunWelICbLrupMu91KZpT2pg1NyaEJuBMkUknJ9WYK3NdDjJBbUuAGAY6QZw1HRqD/HIeN/NKhRnk5lKNF0G0zLiJGu6aruinEEPAx2UCjla3pVDOrytcO8+pEWyny30MD549uoCGMpT2Kaaaj8p/MjVokb0YQbPew8z65ZcXnHN4bRG2LBgQIR8JGLp6pfb10LhFOkgc2stWzlrk5shHmOyNUkpmhbIHRmeN3e+ndfvTeg+sddXPxk8KXI+H0juDl4Gmi0tjnbzrossMfVmVF6liSwpSUv90LJ/CUCAfsNadEeyns2+333EBFpbvsQ0M6mi1AnvDAvzqqMwvXOy1v+czZCPRkCqQBLkzn4BGm4Lg3Ew1oh11WiJb+FSpcheYIOiJdhUrTGHEyelcP5A8WHtTDO9Z7L7V0cdhWtnqML56XZeHuPlwKrAI7jj4kX2G/Dw4H9FvfgepGLSA6zd7X+GdxqEUexb9gUT9ExdxRgdLtLDwteQ3w7QGHB4N1MwsMRKUm6MpAZawVZQ9Z1HY1OLkMXvyp99bWFQd4x4Tk1QWiQv69c79pidWYEM5htjnaGA+lmeEXxc/pn5I6vijU8/pOg3aHsnJ4hJJbbs7kQl1bp12NPbF+XAGrTKjkzgJQPuqLlLdJ74E3JuYGTLQiuNl/xSON9NsfLHGsyrMIt4po9uUvw9NhO1ljs1R0G5Yqt+5Gyu+3sY8r4AmvUuHMumAnla0LqKl7A/Ih4NL2YBT/1xyoY9GWNb1g9lxv1/JydQP/o46ijbMGDWeY4TLKBgjKMRSSKTTW1jcB/b+H1gkASxGTzvYO2pwSi5DHom8oBJGOCA15yD3DLBEupMaazzSPG4l1PSA3UrzF4MU+Rt4n6W0nDRgkLtTyEtHkm3fiN0EXzSlSfUT6LpshcT29Xp4aBS7zOwvYyg5Q3nxxV5EeyJYh+63CYNl+eqGYTNZ/y1Kdmh/TOVAx6rfEkrMYAJlG8MOAvzk3TWzGXFodAwNhGoZKBNt9rO/zkAis1Li/ElGQiOjeZZL7vKJuXfpa7xC6E2Vh9zxhQ6iL5mPAUDRcptwsP/707Zujekq6VvkGNATmvyi38tfxp7uyTyuJoU7qFfVUL/Qx4F6D/d8mFPTqEOMcveTJbFT5w/3lh2DPkckEvcm0aiwUYPCKdNeUevyOY4V5N1rSkWb5urLRzu6l4C1tsCK6eC1/IAsQn7a6eht9pm/trrCuonkjldXQ4LwgELMY2R5q9ereSczMwplTMhxtAI4c9ygUAMsTJDo7DekRRRilPbO63BVPA+qpEHcxCNBeESdKJxAMJFK2kgiFeMTfey5pMVNP3Ctb2dXx0HMJsPWreJCLd+0ATe6LhdNfzQ9I/GItWYeGom1baoN7I3CK8xAMap2wCe3wKhgvbhdRgjAGOxAlABjywuSXONoRU1uCoguID5aH2y6B9ZvOZIMBveDCThlQOyyYK3Nd8wbT3n1QvX58Yy4RGXSSAlZWhf9qsQuaMWT6BPN7mZWSZGI3Zi/cilHwBndrla63S5hHrYpOPcLytOQx6TVappQozRZiOWPrPu74kyEaGEngLJNYuTLeD2ACZZVei4EXS8JI/dvdDUNax0TetS+0l/gIBqbx7fdcf34ZZM0SJYJRCl8CkhKYcoUuqIDoej7n0Fv4Me4ryrdwwZUCOzQ4AsOD+kpx+WAhHht0URQjYLXOu5sgdChMzZ9oMm3rEpofuA3HiFk6wPIYjleT9xLS9WuJ7MPlHfsyAKnvOY5SERPSb4Kw1wWMvx1UEGAYp+DA6i7sw58X7sYNU8W2wHRdWKq2/toXbNH2+z/sDqyfa5ttLv/gfZ5g4CGD1GiDW5Y636vAcEkcX8xz2ttwfXtoZCmZXVbd/Mr+95Tw+bc2LhX30+OcEdJ+osCJfjwBWzJUFH+sOhFN278xCL37KKNmpt90xiLpZ4bK7x0+WB8CfCCYrzR0Q3RGGFcQrUDcFmXYKRXlsAFxO/vzBIDLWcxszR7T8KrFMPlcMxQD9OwrEMVad0+xMW3qyinLXejxO0mXOE33vwC+OjsBddGJHu7rDCXjZpcE4qgMZOOVgj3kR6p4UhYBk9OKm/t+RiIq/37jAiE2EWgsfAt5y/9NGyVsnJ94tG2sHHzqHOiBq/NkUyc2OEJHGgQZlJvHKyl3wNxsymLvZAGQxgoqNs22CI0WXoAufH8fJKUMv38km20z6ufdANebdw12yoDbWATyk6dTxQbsg7cn6axqaVT5tJ7NcU5wbsazpUFCS+ME5qjVfHHqmhUD6SIJMMN6wOvyrl0cOg9W8AVT9/MUjyHDeANA/SzWPBn/rLQt0aaBa1kXHDzh8CRJ7syuN8sdWuJ7QaiuN+gAjMZC1WnFuxeui8qIX1vmLLzH497ymhuA1hKc+IQaC5buwVkxDqI6GX/Cd38EiJwfI6N3ROiCGU0GStYXoTJQMR+ZNeWFCRZJWlQWO8ht/RkoTqehiYapgbhUflpAcGCVnApGP7/Nt/4W8roHCFq4gXfCcvg6DsEOE0X+GmQqw+UBzU1fDvh3UUXJq/I1pwvCRcgmYUoJQ6VM2bWtWYN05ebWVvmAidETIVvl9GKEpXht6abN4hMR8LNHXNC/q3Wr5cM+uSYeSLxm4xHZnfG0vlSCEVX5i+MoOe7y8j4uQhqvPw7gD3/pdmfYkpRSSYPR4RmP7atoD2TqO5oylh7HTFGmd31GZ1KgWTI/BxhdFxS2/1/txmJSZEPys7XOnPo8n1vza4ifE5pIoTAII3fHVvANyEdY+7eBbDuZM/n21b4rELgbDka9aZBb3lSZBNpdY0oIqV74TlG8wHAcJS4cTxK15Q3sVH6NavOZ7aM9WeLClRVSliAPbzlXfSpDATq2ULuhHhULnj+C1SslcnGXTWFLpYQa+aZ1E4LPXW+b2jd2ZKSYgboGUcgdszk3zGbDXKvElzWXU63BKa5j3K+HgCxwi7JVpVC6BfN/0tpR5AgL/h8W2C4jfg3a9cCpCsSiL1xXXN3/Gr3D2DFgPtavJ92c0hdJRJXNjN4dGP5RmUqN3PlLvZEyxWF6dznX92YjMTe9YN2yJCRC54YbeS5A0Z32PBH8PImwoSKTtgsyk4cfvNYdPUJYO7Otm0qCzSvHLQnIAdbh0HHVJ2rKLmm8754e4MGuvDs7XCJiFmrgDn+3M5qgoDLX7SO+peNq3lCER8nB1Vk/zEabFV/pCMtaJcGAT/HIxLx9wifkrbp4wmBME42bVORe1z4IeIQXLXJ8bFLIYrheUg1xe5swJZcoafZ5uMifKMbQRcbiObpb9EGn56QrjS2hwcyNuSGXVUSQ3FgSjOtiOCTyLD9jty4ajb3jDd1ueV5B5Yixhf8cfLDOgk4s+pfWva9n/wjnotiFOaSnj/AOm614jyEwH/yORhUZFPSGeFcQjE2u4cfwDsVqgzI2bEphj3hwvGOvlRPorHado5brwQtwgGnW9mty/aWr4r6Bumpd4h+pqbWK62mvIHO1o+42PQSnj3tUgmlN16YTEo57g9KMEe5hNlTU666a3UmHgoB5+ZDbSBsBZA24MXx8/OhzRERZqxCwPoBmkKTzoiALDvwFyfzprMH8J8qNMLphcwhBU8SCGjAjURKy2rI+qt/5LoXOQKQp1++rcZ2dWqgQJCxmykh/ur0nbLsiG/E2LD43dQZ3Xm2aUjfOAGjb6C658x6NCPMnokGwzFsof4MQgrWzWJaU+Unv2HsAYVV5KdjNrXKgWyimDgetm3SLkbwQvkFiqBDrXwT2YPJf2jqGsJ16AQKO53KepSWMVl1ni9Vf3zptEBB4C7kqRNWMwStqGEXAA2Xinv2NokLnaAfaj6wiEpXidyVdtWyx0gPYZMguOadIhdgi6hcD3kLayzKTyg31EOtLC5XLJe6Dj/IkVbANWwQDt8X/Lhvb1D47JUl9mKPdkimJqsbhUUVN/a47Oi0urfGfY246k8yIoSAMDqsg7RdnJVginUGs2L3Ou1mfuesqqxYgbpXw5fBjHXY1z4LS53V0f/WH1o1G7jS3KOfqPC977kLbw5IK3xnOifMlLiHIsAfiy7+0AdQ0WeSbG+tCFZMFZPrre6fs/Ovq8JH/gU0T7kLSQBD+mnGzAtxtYvmshiwRzUz8oADWoUfrbxkL5LQ3m7oqnnF5mFT6Z/UtZaGU8XAgzbiguCGY1+WL/9+WSksxhhxAf8d9IMX3eFjB/xNkNCgfse0KpaHSmG2vQxHorsDR4XmYdEvLczNzHqro2ni9J0czHQXfdyjD2UlNalqyO+4wnySopGX/YOjR1zEkB7M5I/1A+rD98oo8z2Y/EXf65VYV/4shZ5CRnFNFjDBjhME2e+jGeOka+uKenyjdhxSAuQC1UvmXQOLgZieMTsZAOhem9NAawS2X9WkMHIp6klEZPHt2y+/BdWqj3au8ro1kqw4MBfmEQvfeR280WnM2C5CXZtpAQvaAlDU9WHIry8xgcfHSSqS8wy3WQVl9e78f7Qv8G4uWi6Lj1tBkk8naVDtweRxOutBX1aSd/ofigbP6MmCN0AuXCPCHzQiwUOCNLlmIEDUbzBFChGmAm207zhN8GGkSzdxeFxSckZosZDwXFmheyg1UfWixIpE4vSOtSb4QgGojoppodJ+TR9DAqyrjPQYhGO9XOY7HG4L9c+vlgms5xEIDkvSxvQL7YwZ/vX4yV8TMfc1xVjaMPTR8J1d1pZ3v8vzzQ0VENju/P9TBnclRELtDW9dZBUIH+oDgYioCVfWCcqo3jqjARVYP0EniN3SlRS6f1S+HfW8NwgsCnT8IPTw9f2do3xCopLFbpjrEkpxSrazeDB1FAo+Sc2BkI8taBXL01Tr7YVlslMu0BsKycF+kFCtv4uUAqfEMTIFhflyduib2Nsy99v66Gv2UkFhbXrO1EDT0gR0RERUsF7nK8Lo3UgGxqAHcNb9I6W+mjWN0iTCvnthuNfdWPb0aXo/u8aL0+z+R7IY0n0sb9S4jCnW6W59dl9npRhjFNDR/1yO2Gk6KqH2m9/yk6WqOK8CnXBPhoqCadNrbVjFoZ+085w5G8APeBIPHPrKcgv/8mf5XYGJHQQJ6sQ/8cRbCar9ymd/qIdHzhT5OoMFoolOIHyQLWkZCJf4BLhVrtrFrmsdHopwfkVAhtSRKpkDIx72bFYYW9BGChY3hNeebKwscqqE0Ki3KXMdAIgWbaI2hQzrAoulJpyWRdf+FMCsSdmJj6uJvH5devO5k5gj0dhzj3aqyd7lwdOGg/UkbDosYPkIzKklbJrDk3upvPzXKLMfe+Ijm1lReFJfjwuWTEwCeAjev7Y6B9iSLiqyAvpqWnyvDYLxFS5hwPkt/RlbvLOe17f8SJMz+GlZoqXoJv+naGpijbGATpVKBJtUdlEdyLZGayp8M6972/AjJkS964F0O3PHV9GM0n7QhhkvX+kRUExC47HDHhtqVynCvWZnvPygrQJlyOAoGtM0gOuH77X842itu4zy2jVhbH4EPUanXbUSAYgUuSbe+rszdT81G1qg2TUN5CoZ+8r0mrk11ffDIPSmuZyVRiRPKhCWkTzJx/4m3/lWKQU071STmKMfi/iadk0XLwERmOHxWU4Sk9odmC+XaqQqVeYIrScG3OQhQjnZPd/V6nqAnZYdcN5y2WMEfiY5M+HSSZVQRHuwdJ9HBneBGQLjO0zqRuA0vtdZk6tZt/kK7IjsDW0oDRQs6L91I20p7JFJyTdKRvmkUp5MDTWW/gmSPZUHV0qsHb2Txu/bqZ9v8SSUMCNL6qfyJzy0toH2Ti6oqFKQ+ur/8/JpFpT3V1a1WSDmGWpWLDAuRa83ADHCoIuzEZPpFwdiswsQGPHVRl2VuvI65zfqftTJ0X2o4kA/xPoiTpnrCX8bZXZD7a8GLAqhwF4pUyNpAVrEmYuVzxiWefbZpeBaTx4T/INYTknM3tjUiwHKdNWmQQ8kZBLyBsb74g6BMCrFNS04UyZ6PqelG0UScF67SSIVBWB8+1WXHelwzzu0BMsEwTCGrecX+9e8GO0TkntXLNPb/EwgwYU8lQNEYBoCeEy/xjYT6BMQvpWhHIbIzDLUz+SZONA8048TF3C9qo/jySggz7S6ZI4KPaWvb+61MnCBJtP0o1qpkFkFh/92HhqN7lzSkzCAr9TNUClqxTur6jmtrXaP5HK9/ZyBSO9sVmUAzlYU7xi5h0HTOuFBxYeB0aTLd2oVNtbRlyGZH9dV8BB9LQ58hHvehmNs5le7xdvvF2+/XlF22c4ncKvN/SShjWaqz5crVTN/hAQ6Ez/4fSQ0cCxU8AUil7Hq4eVnd9OP6S6FabYpseX2pfNHQzo4ke9VI/7h/N2ZdmDoeNSeqPK9B+j+DHMKX/anlaI5d3N5sTLHvt5fkft6X6ivk2KhhyxycmiaFgAlnaW0zSY0g3onL14HgLouwyKcIX1U+8Qt99l/zDdA/u5Yl620Ud8s4D361PALNgPgPs9ycHGSm9pfBbh4/C0o2DOnSbXC/Wa94PfCQDUbzrw/UHkGJQfbe8SJdBHDAnW7QFbQHRvj06SeP7jAddbRA7s3nlPN9l50TOJrBcfxjyv85hxSfm3hQ7k+BMQ2P1tISUhS9Wvuc0ou7XB1D53tBLqKhmHS21qgwNazveX9FXYv+UjjBSeh5IpVlT1u+eu9WkPBa377l59ks4WOHhQ7iLCKhDsyXQr57j5F9e3JFlaFI9h19YMyDMxtEpC1jIVg34IvVEl7r55IcKFCACm56TOimZ2Eyoml9lH1PXH7A/effS5RSPCTdSOzhGjm1f6OwGPRe/lqNSUKTuycVB/bBhSlb460cEjk3rg4KfZtwlElccp7nquGeAJwoLrzqjvinvK1VWAMY7ZtxzSpObRvgKfIDEmLLDQyluhjmDgsPOcCmpYv3iuNVu8nZydUM8QxSxy8OZhSBnpmN5ASaL5H4Woydwdd9YwlxBH8DhRGmwfoy/6r/Y07aGrc480MQjirlXifu4XF4h3Ixf9gxDTDXNWin3B4Xpb87NgMGv2cW6oB2S8K7pYLQDcO00fqGirzjGs9CRC+xb1cQWAIzc9Q2CBzFqGYFtyvN+qx8yF9FPi5sT2qJ8p536zsoOmAyWTfZ37bw0adgxXUoyUhfN1ZMdepmnTe6bs7Rt39HzV4Z7XyvuL8+MOY8LiVz58+m0fokfIJ+nc03iHvVAjpVE+BpM8DBAjDbMkU00XPZJ+wuGOWHKjQ0TDnEhnCaSvUjilLA4Hv/gXjETFd70pFil9pEXlSSHAI4aw6VqjKP0/NbOjrHyZjOK+AKO5l62jPVVJw5qY4gqvXwG8YIC4ZVsU4wiXu7FPURB24BRc2yd6mrxL4f6bMBAR9l7j0nYdKAycWAqVgjZ9cmnSzEAmtC/eILvMCNsPfYdiD8xDSOaSMo4KdaMChlq4CWAWSvtYqgm6zPbRe3uKJvW8xKaRJWbt19jToiqHmlw8f1mEE9DLHtOD+QpBlPOhDxUFWB2wstjGCWAMbh92wWtwRDlsRbEMLfrWjpLppvW+zhlskxi25PGR0OnpV3YvFj+F4/AYRvcBTMwRVfeRiAQGE17dvIR83OLJXbIxqz+KiEClclR0r/E3c1obc1NJN06USCH3ttzucs82Pks7vvW268BpMAtTNmcBrQWK/TzGHOpI8nI5cIudSAUpo8Bohin2Vresmok8wh5R29KYVNix3mxlgkW7ByCKLlQfwDOWeP8BLdSrR54hbWBzcmeSy00U78BRNme4ZZ9R6ubUsrdYW86gi8ryyd7kI68MfbLTMjncaGUVSjaDpqN4a3nZYB3HxJacLdZhQQV8/Jvl8hkYMPK2avCfb6a0gN690oBQpVU7GXG8CUtVqBSTZSC3STFv/0zbmEMzzBWlEMDc4vSsB5T5YqT7p+9qpFFFIfSq24SbQNF8ISr6z/YRx6J7wGtFB3bDl/NBanujhByE8V5HTNE4G+5UKMQwKrg2W5oWeco+/jNzvY6CbgHHldlXiTqMDQ7PWzGfJDG6MAQmHRAs7aSF/BADkSRrODK+5rUDFaxWWDINq9oNuRC4Q89Kgq08htRLeL7Kv5HE2KfKIAxIsV2ovkOiDB8I6DfrfO9OO8RQQsqEHIbk7X8niy2oFY5Mv9Xgp6TYIjfJVMsDwXxycPLbCnpXw0REE1JESBDirglbD6tV7aXlFICNg4gr33kgGUKwOdpyvDxbGgAZBTz+RbW2parx3sgmDzJTR8yV2492pB/H2LMRPNgF1h4d69I82ZFeM5VMyB9W6nOrNEVgIZoga/QZbScYPThZvg0svN5tBYZ/4XXIGAhLmgJW1uIL+AYBHVsnOYfLk55z6USys0lhBdDW2Hk1wKfreO18oSBsE9VH28on03TDqYS9sNmcqudC+7LEXiwI7qITZp+T7kU1iV1MMr/QnmmgsmQpvDjb5pqcHZbuNFzJ9uVrH9mLwE03V8kr7ymWy4FUzsNjQjdkmqFa3B2uPp184/OWF3spq+5OsX6OFZZpQHOsd6yS7ZfhJS3Dz/Y4RAx7vD21KHlfgRUZXaubJ/36xZQeSifg6atGewP22um8stiNHV4oUPBSQ+wZphJZ/ZNoHcK2kbIgEPBhs0qfqLlsf3H9N4pRIj+695OM22AlX+TLbXyk+OvvWEoFhgMETq12VWpltx746RQCVxqIp4+CyFkPhodcJts9uTNKMCjvwfVJKlEljG8pOkIfW4iBzngqxgMgSZUSqFgD6gBnQwMko7iS8IlBXm/5yxQnRTFRz/ZdPVPptf3lqP+bxil0LVNvUI5H7xe5i02CiKy5pusCpD8VKNkZtOMonytORYpx/F/3z8pzc+ZwekzcTtCcPf0b8xvcEAeLE9JXzS1Cd66inn7gAiRO3J3WDv5hGE38IFpRRWStiaJXsgoHADqlm/90voIa5LH4KFG3CV489CEE1x26YlUc7vbtMVmwEVFZonGbF+FzE+USQneLNyi9OYlSlJDmxvSwv6gSpwvs0pvIM0CYHJ6Vzd+7pLQwV7MNm2bOsHtcVwEhNs0O5dMsOXIQDR53MEqHSp54tGmrmfIQr4P2a7S5SHxnoKNStuADyD+0REnMZvOF+Nu3zQZF3mEjusDLtsBl4E9foLCBirDRQkP99NY6U4FcJA0zvxc3pgf5nD6Pg3LtoqZfVjNUdWaB3T+BkDjMWG40YQLynBx/Ms3Rv46CpjawMKZA9PbWs2n7wPWZDCMTGsmrr6izn5vzaWMsO6IrktTOxE2fPSFZPYOrgtVPT+IikxjTij3hOksnThx0zHWf2mH13vLG+doYpiMbXfbPj9nSweXLSNvxH7wc2W59EyKSuFOeTcLuowYzZ4jCVYGwTqoo9dw7kmYQlRlX1Yj//65eqhtkKJ8ijFMK0l2Ne0a2SAmPFM6H7D4lV0OpxRtUYbkaz9+onO5oJezfnMjrtQ4xyiT+IKazm2y7wveBUoHlO4HOGBemGs9OMdfbowxvyNyBnYJSqunXutZFdEdBXKgkTX2aSLX5XPQ9zwKsj6zEFXnvapiP/3o7Nhf6iIeOBkn2IzkqvU4msnN1OJ0vb9qy+nXPRnpXcs835qrs0+6+yHDCU3TOr/wk6Yeupzl9XDsIhpjNHI2W8R2N/j/h3CyItNEhw6AHKMoDiIuDxbNFI/xZO60yz0Wf0yCINbfZuF0EElvKgNFw24SX0TFKpdxX0+QkpoZEYgKNY5itNN3xRffX82jVWjIe96PMCKIrIrJPO+UJvjs15PQZbqlibngphScxlgxu2Owk4yuB1/OOv8do0bnXLf5LdUa4XQBiDiYGOSuu9tHyuzkeW2BldTVec7Q7E2lgndT0PMw5ySYrLlfHs2OGAH6/ea4ZuTz5eBNMOpMBwNTJa4vopFNtUxfZS8SU/zLXKQagfm9Lwv7BgEYkMQ7chyq0mjVbHUM/jEnm2QHZOxFRwxgArJDVZe3Och3Oqztl3zHejwzp9nCpKXF+UBCfaO9NAkGKJY+sqjzzmtugTmHI8iSYzG59iehKrpxzMoMS7zoickMr4FnD2mrpJdPPukqdmBYcB1raSrFfC8N6cm6YjRbUXbTvY0MN8ulWDeSR9oI7ODOe/WVwx3AvJ76dXNJhIhwBWxfYcX7GqdXNCF9S+I1m5PQ48dRb8aGTFY8KFBiLRdM9aGihWjJ1zHUPGM2pqzl65OyybAWVoNv16iUQ73whIBURj6JFOgVwgDj8SPCDxX5yQDTwDjSTKnRUcGQIzNVP96B96nHy/uEzIFzHzJLMDB0rzj99rzvL8HOObOpyH+Ysotk5GyOCWV/AvO1gOUQXNwDJ2NjrcqcNWWXz3hV0HizxeIlUkuYA9i5ZAQAVF0kAXOcnSId8E4g6CHBnIiCP0SqFnj9oK/I4B7Ir24vXTt15Bkhcx9DumHVKipTT7Z53NqSIRT5e6JJgdCca/k9K+jBnCs1bGCubfDHqPXq+EBNKmxN1xvYCnoZ372k29BvpgLe+DTmK2Kq8Xlrbxq+4IKefqrUsmJymAALyTEo76P7nabYkxwdCiCiqtBR/yqKsgWt/2YnMx5D+rqpVkPK0kauO5+hgbMwbc0Nd7i1A/2FIFCK5oRsj2NavSGt3cZOSCWXYQK09FY5kNe2K9wDhzXbCIx/hcNIFwdfn+GX597K0lrUf8rfgN7Z7JWcxzIoqLgO+TIOfA6RuSiRwPHAksDPTn0OxER53kNppM+SE+bY95I5h+f816lpv5egle8QkPk+Qx99DdeEYMutjt7EnvwqMbephLiTSjW/xK+arZvxDtAH95PbByLCLPTcQV356XO+ET7W0tg+AP7nARmk/YF8kheh5yoCRtgqI8YsTbY0yZT78yKD9upPFZ2cF0vWdwvzv9ZD9XKcEYqrio1yomdxMk1wjaBcOY2fASortb8ELaqeiih5uj/gdY6yDBqb4hYyd8mjwlndgv/320WEQiw17jHnXIJWiV6/lYSL71HnFYXEtzOLo1t6G0l2Cz3FJRXukWmTEQ9JlO/RPRE34JgSfLNjV5sVj4z0NNJ+g860p4d48kiZAhCJ9mEMrqOKW0ZQXqjmLTqPuuq1r7GZMZFb7CthDbocI3jJSDecZt0tJjQAGHp/Irq3PZsR5ujdASHh2zVggfJYINdZQUr739mSteUxiSkO5AuisjLxpBlhHeM4nWcke5FmnVDQb1fO7Ovi+eqTYnWD8JJL06Dof/3jxnSoqvEvGKEs+vPg/iUrv+oLak6jUKtLU1ssPmaV0D65wOiUYUbTJ1xQKXv7qp5Q03Dt0yGoS4YYa+a6XfI4gSZmsteerTmZEhDh94FZzD9VvjcoBnuWBYa1UF/0UHcw1QXWoc+u2kqayYCLqauGo79mShhm1eGF83pxClcV03GkgImi2HoAee/rxX5UaPZvZi1qymQklJkCA735y6nf5lIW4bi5BTEXKuRf1KOn/Y2S7/M0fJC1YOnQKhva5AMegc/3A8alY/xD/RpGAHm6d2MvWSvQb3mZcmbJcM94aKabpzqLwgooDG5yVWjNKnKy4NTPV2MRsA/XXe92ODcZzP9ZuNUxxyhVDyYp3AeYMi97TW1Pns9M4N1ZZ/7CLInI8Vfsj7qA2tq7Fi4rn11kgfPdpoXrRxX8XqI+j5lltzzi9KwzKt4AmRQk+A2DRcP2TMqK+8KKqzEamRJDr9b8GQ40vHSJpkFbYrlRLSfecOOwwa7SnkQ5ElpODwWIZs0RWrddgD3yfAs5l+etYSMXTQAD/HXtVXADcbHQDj4OW6iSC+3GjhrOpIjwBXCF9azMlLRF2pH6Yqo1tEh7zOFXaL7fA5/dmUnYn5Uu4kM4vwjXazDNKIUnA/GJ5uBZtjtEOhEusNNXldV5SZ4FqFF+vEmloCUbLO9rqdh2ynXedWPoy2k3v5L46aGBS6NjPclOiY+hAOj+AnInHsxInvttvX7P7uuv36XzMfnhLxX4o2mFuT4iHl+7xLEQJIwicvA3IU96SYs8zXDZ3XxuItaBlC7OuskW9yOp2iFOD6jwxwAr5dBA2OAgiJDiy6mHSAq+bultAbb2pnrrESKMly5oUxT5DX7r0P0FkK1VF23NPGeM5agbhgBvyUYSIJ59NSSmSGrjxo+lgBJHZ5kD1ZWJ17eYA+ww7bjOipLBfBCxsXZ/Yf1aXwJj61qO5FhqbwC25TYVN/ZLkPaWReUfYG0VJLMrOTRJChTUIc8PiCYo+/CDEXAxmuYcXq7VU2xKlOH78jV1sGEbSV6l7xupJcktnjfrqoEAgkZC4EluV8fnSbzLULh+njeDrL1dfoDt8P1XyFvcPgt4L7VddDAJMAtNCzA/vAQBSFCi1GZS1qNcTSMJlKrfa3+EPXWFY76pRlc4LHhEN9CmrrM1MuQaSyaL6POx3PsvKSWnJjw/tFsPCFshuut4+87LUiZwN4Do444yAW6sWsQNmEI57AoB1mi73PiWDd7TENgfiBuRM9pF7x77njR/3jfhq8mBqh8jPll/H5e6Msfjpq0kFIGA2VfB4SSvjcXO4n1O7Y90fQZ1X9yQl/dZybm6F+cxlBijM40MrWolme5HD4bRjggd/iRSy3f0iz7ZHcZ5HA7HscbaWwJ2oSRDRjYGdmVwm+nxh62rwR1daAKJcwXw2n+LzXmOKSQkqe8lO/7wJWct2JgTgy0ytx/qwbJggwYmYP0bRJxMDdQpUPGQBL3hcBj4m12iWbmNrdrcrEbkv0CZbNxOUhtLm0IXci8L1wg+yXpgjkWO4PEg9/gjgeseWxI4UY6JjJJhGdTM3id9Rn4Xph9zcPfdQVrEeahSKszbeVT5KDu8mntzGFMB9X9aXvxZQt5MmEIPgYB29xZPeiEWhuS69b56+WrSOcpHnOS/R8FP7wlZx4y04tZ+Dqu2BZil2EdnvX2yCH5XLOMmLdFhLd92196AVbaiIhOSPSxFKfd3i9MMfNvOuqEx7RTA6qu4BbwiKsfFxGPBWFXcl8gA31mc6vNMAOeyQVddn37PXriUF81pV/QeEQUMUJSy1i/d6tu1i3iGU+kngCucGW7CWcLo6cPvDDsPD5iLxGe1LPZ+0O8B+0yfxd5QP/P+2OOGb+JDS5HtFoLZBuitNDwrR7NOX7ktNZCQo2VsRZt5ZJjBey/wqyzxsHEPKXQX+cs65B3fHpqv0fwZYFSYZGW/1zmd/VdL0urSF0A9TJBTZqNhVmAsj+2EfFvvQwEHML00ivPPfdrlD3pj77XV1NsYlRfpmOXWZePwytyOUljis2pEpQHotQrtNWUarnmWoyU9rNLSJp9x9APpbR+OQjR+HpYYRaOjr4/HgwYDCStQDQq2xiJ0QwZMnVe7TAqLayMJ/Mq+qqOlMGBuVaOnRTplmYcD2tRzBqlUl2dqbvyhELrb11+tZFWKUA0Z4oTI75iAM5v5+Ft/HVExt4MUbeOBA3T+K5VHYg/rlNLTn8Nd98BVucLcV6kGWoZSPH1xlhoeOZcnyd2iMU94xXCbW0QZfr3z1h8FINu2KzL5zgSMkVOQ6Rl2lB/EYPBxg2q8tLSYrFCcIkCx8OCQP5RrU2Ovr6oqvgaRzYmYy0CZnJY9lsbMuqLQvlFioOxfXsVeGbSoSw2xWB1oWLPHHedRlljbsSfKv69D8+iW9piqIKOieSiDRe7YRd54/43yhNI62uBEDW1WvPsQJ7YtLojr2b7wob97tSYWSpYqfAWPOwZW6wDUfmOu992I8oPjwawZ8v8QAWCpyq7iA9UFMMDmfV2HjHsSObSGFmT0L7SnKhTUhEOSGKONC/MxFS/kVuuiAhZGAC/4sTiIxUC/HvO59ScOm7K/53cTksOT/aMcmWu0/Rcpt/PEysKgK7K6sbP6sAWe/A9UAh8+OZCrxF9g85GSIkSgBs0Fh2IBA26ZuFYJFgGWKijtm7bEtoKgE/zwLJkYor7A2IWoCmviPwFfF8DVQ3omKAUPsI5qb6IjK2RmgTHl/smRSJubLVuM20dX7t9VuIRslHwLKdvkyLkKRDz1juoLtHC/u+gppvHX6U23eDX6Ox8rMT7Ww+QpcDTayLuAPPpPt+UtGh5pgEtG9v/XXKZKLNc3LKrBJ8IqDiohpic5LR9AsYV3a6wxDtgPK/bdYd5OO7njMWtFXh78smeSOnJMM5j9q6zbTPTyTVbkdDmGxkfRDQ3qcNz2T0vBs8f59cDBAp8LX2fiaj6Qj1OmhJ4lFeyOn7TB0Rhzb24z/GMbiuKEqq5ZMqXQ0oKMkIGVmaTBfZF385+mjqjKhq4dbyqG80PvKw7fvXEpBqPzmxQAw8Obv7cm0Rmn7KaH4TbCsP68L4GewS+m1kGCAZp3jgh1p9cntoFnLYMm1u7w6XYnZeLYIiEvMU/xbqvTddP1vUVLMDA15Om/r2Xg4iv5/tyyQy7h5ruEoVPuC9gD0sUEZnGMMJgNivWgzYvAISDHjWldNi7gPvDocM014+dUtNXHe6qaLMaygkzY7Q1cZN2/EuSyeXsAbzo/biEv1numdGYdZYvsyEixfdsgZOhPI2Loik5/2yaHNxF16vSJnSEHbdnxuK4Gzb8bNLfB9CZtIHsipiM9VMIAvo+ya8pq2Eq5JNSJ8ip+sruLRvQjprr7aeqO3S69flgG93pmXyLy7oKsAfqEJPSoUvHzQfKPxevwNl5T8OnpzWvqkI+NWoLpuFE1KwhIwHVEnht4KJNlmZOydIJCcJQv02mYJbkPNFuqD3PSiyRbCYFbvjvQJcH33D365ei1X2RBhcCNlct3m/T0wuBhGe7yVyzE0JjsWwJ8Uc+JHjU4AaR91jaE4Pb/CNU67PgnIlaYyzwamaWLBv5sZNjoDY+qg7DgTXtXyjk9AnoJ7lCcJwNd4XZA+6KN/RFGz+23GFE/VG3sDFrZK9k4G7f6/P/OUsxql/jMCY1ouktwEFzOWTLZVIGjC6zX838LdOUMJNDEk9+ptdcDDKs7SEJ2UHq8IikfIgtu2C12CkmBwzfDJisRliyHHknhOWLccrke5JQQsflALtvGF1GvLJ4iZCsjQba7T/gUsJSX2ayb2XYtVzhXqVzSU2uVQFZiPUoKj9JKIOkkGjtbF2XQwNlOm1Dp1SaynHkaJxXqS1bDk6ekqZjb4cB2ZjgGXSXO2tJS1m/pmjj5XhFlvIEJ9SI12FSuWW2WT/PDu/sXF8mkkgUyCMr2c3r9T04S3KumdsSetibo9qTr2ZS8BkxlCLtfWjlb3cfmiycmw/z4qB0BENDhtcWvVeRiWTm21LKREXEe4I9ySxPjzFOdUIHnRKde16X610jPrw4W/sy25KQkzQ/WzNutJz2xGTeANesRIPV7qGxHun7IA9X5Vg7P9PZgx8dTABE6pyvMAQQyV8flYOGDxzOVwXhZw8OPx1Lqnfx5yrkGTompzFmXJlF/d1eYyJ0J0bbYsPmFhpzQzqHTZJU87PWIb9FHPK5mo5CzQxQm4d8vApTXRbPafqbjV7dF5tLkA6tpn44FvCQwIEgUgkuyAL+1IxIJxgCQnKOrzN+rap3bnvrXiRMV5JL0QtvP9vE+1MlXdNmcBAuSgAVBeMiC2eos8i7khg7R+sNzLHT0SNTXpGI75/BQHGH+pXKAYc/IfzfREt26nCEjtXQLAXPi+mGgNBKLLXLNFcPcm1JsmVHDvWFvvaEF0mZMY846thj3xuvQyULrT0cAeCNuWwIargycs4xEymTCeEiVLH9UyJha4TM6oTkQfhglwQgFPOZZY34mMVd4Go2ykPqjeNKQkQdcBUB/vOH+xdftEEvPclGCPAdTaiRS7TxQntfU/zRrQdNiqLeICi3i1UI5+u/bxlcT2vhtGksaoCiFiuIH44r/JglMnm+IeIZ33f+ZCn8brN4j7CncJkRbhW0eBslVqE/eF9eQjvc+lnFTI05NREIIfCM0TNNPCbJcJ9RNpTjWEx0KWLnUsHgogJa76898GOfculLq0fhs97seDJV5h3aXv2xjKlzl5omRsbN8qfBpDxtXcl/jS++al6L43qkGqfjRq45sWnkUBAoAXZo1lTElbLJuZ8X9P1n6/A2GU8/6TVT6RatCxKqxqD9YYXh4fv8OxhzhAJY2sXiYgYeR/ohBll0D2Ka891okZIW7nKV5Y4D2rIngffYJIoO4ZgaYAqQdLUwqL05tvogaW9PhVUoakieIk7V/xq9AQzaLiYtuyLP7UZcX6AcOLN01qanIFXs93wIqBB/x1cbRNxMunL/eqq3jCcpf69V/BQjDa/7kXEYuphdmsFniIjWCIFrPPMvhmxar+Ra5kqActlPMFSRUG9HZLCk6KGgCGuIoKkURVb923n//QI/4wgnfuZ7iDNbpz7dNZpjcqYnupAnZNn3zc09V004+68OUZPpJgr8j8qbkuTmP6LtqiVYBuO7loIxBNZBt9w/x4XtnjE9w7Fx5Gx2HTP1ln6qhbbs+ktrZJT52AB42X2PdCijP5KSHpdDEDxMNmpXQJ2cYS59t7v46IQUsYh+mc30HQoHQaCxPgYmPOydacp4Qgt2fm/v2yCT0sHhFrezAjH2XKpteT6ioWncmmvbIxm0Lpmk1jZ4ANKUdYIQmYNsf2LQEx1v7bIKpg5byVs44OFNxaDI7AhfGky+50WVYRW93UZTIw1JerG7Xwe2XG3NDEF35PWvXtK9XCc6N+GFUJOrsLyBB+sJK2GszgR+PDvXcwXwrXf6sB/YKVQbmHqlYXFMx9J2UuztMC53GLaNCVECpByVmTtPz7VpPL+fflEqY41IZbtfzX+Dltpg7zIwU9I2H6kiQ+z1ExLAHGysiYhMT0glbHwTuRL+vh/SzKOxxKw6+RugNADylPgjKyXqO8Gha3rNkFU9j14mksNAJ44j26uOY2+TFEnup+aoPy7KygWuLG+fxoLMaDwgaw4KxFLmGOtaTbWyd4T7wevtUbE/8H2FPH66TpDSqHDZtJXZ6ZumCTXsR6fN1rjsMAj4uVmkvECTCMQ/hc1jziNWQIamr6+YcXZysHXgzCf6JGWvRGac+M5fMFoLyE8DuPdNiJdb09ebe4AADqJSG6bqO9gsnjDqZ2zbu58SZJ8DdaU6ro5IEKj0Pq0cUdXQoZM1W4gO3nOLVfC6PdIlWr0H+8I3cI0Rm7/3NSxfE+tk4WksyAJrKyrqZglGEFYLGjq01H80HNefG4YrAZhkDsQusoota/MEoxqwenBxtfJuHF141y1tSlV+dVly8ahosgCRAEUTzlzatlknjcYYzSeIQ73zs5+oNyqyKLxtjhvsSX9JAjXFAs+AeFtRuCXxxEOWmWAmJPlmmB/j1RzXJGPSX8soTXTe9RqGhTSmcj9BDzz9hn8Lm7D9ibk3Y/gYffyR9soPi1IgKtFe6bXrzOM2ER/gqEe1Fkm2xAJVS/r7Tr7MQ5RnRKgG2J+UdTmCsm/jPxSQDiojiDYOJoFMM7oV8YY7m+7AmtErnt2B2N45rXAagGi/jvZn0cG+FB+OWZeiLDREJAB8IjSkQ4Iwzibhrd2Cu2wpDIr4qEUowgGRj52DkF2XMA45QEE/Cwvybg8LbljW6IVI3SjVPZNOtiszBlYre906PKpCrE2iEqi5ibTB3NbcMOmNNf6sM7duXpMxivtl5rucUxY5yQsr5ZrJ53O3gV4NrGF8OJIP7nBAlLq+51vjuwwRk7rp296EfV3F43eFKcu1Oxf/qBp0T/3oQwdxZ28zbo2RLpgFfx7AeD7TVy2zPS75W9E4HtDE/b+WOW5fkcfwIllAnhisilMqdIeGB5/D0wDXlUlfJxURwLNfH94tWsbPpYZbXlI3J0MZOpQc6E0i6PAoHuGHJbb7pV0SnmynEutCccvniBlVN7OmKfrnTk2EoQSOeqUNXmiKag0OISusUztYe3ElGMbatJLagP+Uwew+R0cJgC2RQGxrNpJaf7//tUQlshZ2q8r7ydE0l8U6uOY8Cnw0PG4WvBxxLyVaWimTIb8cCRcQexJkyxJ5c//LMxSGSDU5Z+l786ekyUeFU1toeNuYoITnspdz5jJFaNVTLLvyxLU8cY2m2aZCpKyqZ/R6VgiEbLA/4sjejJi87tHLeLRkFN7tuDxelsdhwn622UmF2z0sffKxGgAL9KBxgU2W/WR0WRDO4ZucUdQyB8IItWsVxhV47+lG9aUTH7ZtA62rfH4Q0/6Flebk1fItLjNEjTLnsrmmNMfOS5VYH0xGetpD5GbRabaWXVYO2w8g1Ff/6yAPay3ohEC9/jsSYNPfPqUCL33WsugZPHQuKMb4cP59abtFcjNulOuTgDLh6LBhZ9CSC9wjixNgscR9ExIOXiYLo0EQcnVoW6nZDqo9ZiCswiNoUO8SrcBPQmOXGfbVO0HXx//kcU9bMoGgRtFPWVivxth2id4/WzG5bqpt8DhDVU/Zo8xnqXxIzifr7IFawVhPzWFLI5F1qN8ZOfUZa3pWqLoO08MNe7MIZC3EGdzl+13PgsDTTal6cgyVAjojQRXHPKUOZfHEKJHsVdB6VMAPhvHP0WPUajFq5IqP7wDnwIItg49kRoll2UxnfLQV89950QYyR67gLoTAS+op3PBL8OWEpIc0/z4wDfFRYEVgtKzeoJgYHTnK83opM+wexH3Uyh2+IyT35vGunzUcq+ZkkbrGNXyiMszclXFSRtFtKbzAB1tapoDcjpbeT8BbWrqMhrellEfrOFmRu7gJbMKsY5SHOqeHCG2WVphKM+7PMYIxmkHwEeeYVm6eDJmKwmi9x24mE6z0020KN098Zcs+eHJXxtRepnkuE9VRfadY4A+xUWJCDOO6MuNdB8xYbs3YS8KXM7WGeZN553n4XMiRg4OgEsrLaKONquFRUbaiFVtcHSXCvVzWx3wSMPFi6SFarx4xWgKJ5hyk31nVK10FA4C7gYS+rjrhbYYyBjSyGTrg8SrFXTHVtlF14OI/32Y5svE7zCemdrQNWXcjTD3Lo5h6s1LAk9DK894rAcsfKTHZmbaYVrHIgLVJuOxrY/8CaGkDdUgEwDgNDRGmXWBYqDcqAUplOY6wG+d6oCnyJTcKBkoRNksPbtCBZy3uVTr4EyQX0O9ks1QI6zUUVE/DUd+Tdy1wANXKQMuNSmaEpOgSQE7IiEJ4vlFDbK8dNoeNjRCPtMwJnyx9Lb9u4E35ibo3qNdP8HtQX2cl6KE5brZMrBY6Xs6NRGq7Smapxs59omgTSP/TzqxLcyJo1Tevaf4PiOP0RKFaCpURVVH55G1qpf/t97bHgXebbKyR9efSqg6W8ywqrXuPWyaUqbRFXUkEo3vFt41Eu4n2bFAeN59ExwkqVC5Tsp31zKd8O4ka+BO2vdI0BVREnRERUX9WAN543RVOLLrBWvvmomFG2a8gctKArAlvulHE5DUk8Duz27ZNtG51F/i5dIngBYUeyD+IY8xl+LQNAON63RDiAYyvBKxPPw8JScUEkfJu6v70GPW9AwZOGFQkTmpSPK8Coh7rl5R11oC+3KANUznHD2qjU34pFr08DbeWhPR+fRKIlvRlCG6GOWRJF7JmY4rig8Jmu3btXTcO75HlyrwABzchE3Od6qxRbEGR8GjrH1yEn179Xnr2NP1bXoCPEiY1Q6nfR8WQH7ntoviUlW7fQVqhrFObBm4lGuXaJRzyPe3hJjny8DL93k5jphtLrG72MrUXbOqXIszpp+A8qsa8I5q+66NliI0LggiU2xll7WgvD6BMxCaqcyuR112FnpOMBFZzPHlaDyjn15h7LtUnxUzl54Ze24TpZDJW5dtmcRThDK+YF9lEIcqrGuVh65I5gt6mAth7wSLB3O2BiFttak53WyGIfKQ57fgDJvd3NLgnDlfBRLYIF7C5fuDDY1UP4EvKc3niSf4ww6ZGenUi3tU18g7PLV9Tz2Fcj2QgGvskYrupb3hDvmh7OquENHfTTbozmtTzS9D8eOO6nchJ6pip5/DhD5LTZfIzLG66OKoZ8i0q4trmtUCXlM1NCmB9up9OEG2wZFlJgQa0SmRohspctkIxtdYp24PnKXHJ/EClQbjAHZHMYRcApaRndR90p8XVrve/73mVVv85UXEl15FHUGZLZ0y5kqP0TRsZRYuVFh0SC41Ii/LOaW8ND28q5WkosdysSq/ic0BR+Givcl4Z20RlPeKvvgTCekfhnUCDqqiEYvup9UTqgy+CdDSieGf3EVsb3izArGEm7mY5oIm0BVPG0GorxNylcEeA7RhChH0zwcVmeYgz+IrT5mO0U9aaG/CcX6Nj7kvlSfRDLMPS6zLsBWpIXp7ozyg2yrJtPKhqsv3P0LDOmJoPCa7FUzh0axvz9OyXu6Xah+lyB1vzZ7f0Xp0EH52m34ZyFtCKrMcylcUZNsWIruAAC82PCGAYpa2EfeZcQAHZuwQYxnjk4vGKw3mXITpMhqTYAtpV+m9CT6CvTQi1psNwMNfKkxnHFf6xkfGdex9Gb/aTpQaGnF33EZb1digfhuu2aMuRCkaK4dNWGw4kv1M00BO641VLfZ3DQqR4PWjZDZsL0KOWASGcOkPf3aNjNnshnCVRJGOIS+C3BgPorxdC8KSinRvfPX9BIahOt6CnvW7dHFnXR8GowpLdA6cqKcAQTXsuDwq/uXSzzk3WdpWSSRihi6cbfPBpZAxCpX4UbWfdVHvXJuL+7T+uTk50HBJflmLHXVBW66UDGHMTvTFGaWQqsrpSd9qyI1wz9HxsR81gf5X//68bzI9NfaiHRoCdpDuQyJ3n19T96/JimBHBt+BarGaM1ChSJ2HW66JDa4jqHonzqaRarzH1v/wQpK64RAeFm7dbrWBP/FbIjwxXoExrR83fsRXcVlIrZUfSRVzhADLjsmWlcx9UA39JdeMyCE4UaVIuxo6FVzCasVC++NU6XzcRsT4Oswjg9ucxxUjQKwCSa1ySzqkGn9OXvljv39XtSykUcf7YW7OGm8yZwIltYzhYhWf+DA9rFQn7MQQDKgWeJj75+2M1KdTCUv96m+IET7bodqlcSn3Woci6Wm77fMptFZrRS1QmXr/YmcrpNfRus/D2m+rUL/lvlTUm+Q0XMXc3XUNbDSSseIOXL6FQXwEPC9S1uk3FtzMnpGxNcNYrD8IAZXAZlQIw5TGWt7xt4M+d/QTBvG75IyvaPZ/In+dsHnHyEBs7TBWct/aCl7b/leTepHubWYifR7BJ+p45F936i6dzIz04Buh4w55wcASz/ljJ/rNxWl96mzWyx0dzEL/VGWG/adJXNZUgZp/Ag0GpA7DkUhMrNirkW3a8PdQ2Q6CdKx12Iyk/7tcfcXC4IeS7bw+YgsCpUliF/3hMWVWwHPIrkPkD2mIwCCFAGQf93ZEhu4hbolJfmfHtwKrr8ExYmmbkKlOtU65LVXV6mjrrbMdDcLkdwO63JWgwH7751mC5w8bCC6SRTpAjWah1HWYOg0VCRUWE/txVerBY7FCnx0D8Crzp9HSQsTPkiBgLhmwNs0d1Ko74qXMDWgu36E71nY1wsRKo3n8zLsEIVoVyb5COjsHyBFuDN4TFeLDZWvKndHM3qEl7oAb8ctZDpCzGRCQaB6pUNT3vxpKz2VFpdJnRkn50zigr7DbO17oy4gbLX5oiT+WlVjL87wzySR/cv5vkmHquCv0S1nSbS1d77EEaZFXnkOnZGuX57vajb1WUqA4ny5Z/MzmQDwJ3UhwY1t+LeUjw7jfJzMHyTaLkngNcEBkofsRnobmLAGRs5URFKGiTmNdJ/tgJTp5uHg8QIQ2OhbukMiGtoUl/4FHqUV3viWetDYDIJTAua+P64B1t+ivX5GsT3g3qW7GWoTpRiMMemwaTLSOXCLqO1F6w99NfNo4uJcFKoM8WCYTYG2CipboKJnARer3i7DXcnii+LU10SRjsWgb+oL0NCtrzhhPxnXRoEmpZ/Kde9Tvq1T32fUz0XVW0HHT0cFkO00zWcbMXPjOOKeA1507XmcpcX+KW5k7MXz00V8Xx5QKiWZfAlynjhDW6dx2o2W7lOKAACepuHQarcKx5vVbLi03AUhhhkeK2c9T0wmgYhStHVW6dcmKl0a1IYd6lmkk75k4EiTUVF0alybi3ue+ZeOvI8xHmbetDhiJaFU18p5/4neqk5r9xgN5++cNascc2Er5JekJlJY45bcp9CbAQTOsr245Zq6atb1m8Y3EngDf66voYL2/a5M4PENINy4PAFrwjTHCT/hq7MO6+uqw+OBW2g1Em7whsNbtATLk00nPZ0I7iL7zlU/HIrLumeT60MfnOQE3Q4RJKFjD3TY0vV7JAZbkMEfBj4ZyNm/SSCaBHWhR2pUCgA9rYONjE3r+l3ma6XWqVavyrEEPGYwGLMz8P7SC+h3xlpygsWlXkdmsxy3fmAipdsMs+AycbBCXJdXwXT4V63bBQ7RRnMrqwxEgI3str8EmZVB9eriMi53rG8Q/xCpAtnKH17e0mfmzTx6zYFkyONJAstmUJRArN9rkREzaHyXAjl1PQlRuQ/WOcL+rU4iC//AliIUrDGZj/gbKHSZJdng9p/dQO0r9lXoyWRn7cSkgln0n5bvZjYpzpC1etsO3wp1ZCDUfQSgo8IQgdk7u6xJeYDFLQYkkeiCKdNckuEVbtZhTPEevxpT52dsQzIfY+yzgpg8Pmf/uhjJcis3IQRsy+wM4LdHbTBCplA4aS03eOeZCUSkbDpKWLhwTaSWx44XXY37TMDpt8K1UoXXXdemliJ20qsk9GFVnMPmDzThx5vo5c+y5FTYoAFKZ6uLnF6kRfGu01w9hgCk1kmiuxGjH/36o434K9mOxV0ICUu84KAS4EtAHtJcrIIfmcD5LRKj3Z8Wo2cPMLp0YkDioCNlZxxSEyitUCKp4UWJhWjowlvK05RHRrvz56dqq7nikvwA9vg7yjMamwYB1w8RBvxWtpbUXNha0oWIh5HInZrNYN7tsu1vthzovsxPCpqBTrMY2eySVqzk0q4IQskaqkVdGqke4vA5rUSSuix6X7V2vhT2XgiDrhLD6A6PG1h5ETC2jgXOufgJHyHWnYZQ1qJd9+8dKv4xlrhIy/oiJnc28HQ4BQ2r9WRBBUR7db+0TMhTGa8bJMp+jXuMT4nthItOhzZCdAhdSeau+06zGqc3fC1rxs/Krr9yYw0KRKmKNgTJQr4/+5WyXtaI+ZecNrHMrfjRC7ZiPPkP+ZGBjokRnEj5R2iCb5bxDv3PZxza4/3hpWQxD4XZCJVxTFZhmT7oN23L+VpYeFpCm5K4MvHmv6hqixMAdc47NY3zha0Kaz8jjSnpiDLneLYD94yE9PKSv/Y167U5Kr3gIkbkDsTKSefgKjuhR8YcMHz81Yt/bH9Kw2WpFyTVRBiBlTiARv+eDWS4khPSSjNDg0ZeDwfFw1tzHLr+NQQNMyu2E/Va3vnujKU4fS/8QCT0FcM5XRCnjU3osCzttHwRoTfQT1hRcI8/EVB4YS3u8x/GtWxNdaAbXuucYM96o4leptCn6HY3Z/18aW1Wz9QQqKzhKEF1SZrewJWiPbvUySVkFRFUOKfFlR3yY/7LSqj/8sPxsx3SgUlXpp7in/p8gVADAY0CM64eAIx8R93tjxCnZoASdJaBFeuw6CNduaFS5vByIZnpnelREFayGeRocRJYighV0A9VsrWjmaJMOHzX1ais0u2lo632MnK+DkUfe8ndIH2ruYbrPOAiwJL1okk5g9xfeqjeQiIY4CuEHqJMrln4a19eT4gwUQKOa7eMr0Lr+41JcAm4/7JUrSKcNplVjmnav/bH2pgFCGra/1/TT27dEnBQtR1vKfuaFMxi0Y85WhPKhK6n5i4D1jc6WVsOeNUrOu76k9bPRGmwc8iXSGSFufCDJCIJxTMLq8oNgZOuxijr6TxwdANUUWlKJ7BXXUXt065msPpYXawI63v2ZW0RIbXjM+FLvKMGfxTe+9YqCegzaX43UD3FuH6om5fEkr6uOB2ymBED2QoUFTAdaPgj1UTR58e1Kbeo20ZYOD7eWwK6NUG3gHU2k0vSghsEtd+d52QvtzPu9MLS+dNaJjw0AKQFPLEg/8Pu2uqPiiEwNbLDfBH21RDb9KI4BCH/Qkr2vwUHVPkrqsEVxXrLCUkljHAwG4Uvj/QflIgDqfU5kJNG7VmmkZnA62Vdds/9eQ9oN/HGDyrZXS/zLgWf2miLkDDsPbJSf8TioMDSbiKA3+GNsqIzG4KMk7y0I7rSjRofpQGW6TNpqT45eM+nSyLqVE+5vQwwJ7Q9ZIUTS2HqoqFFPxq25WlMoyWJZxy0gUJCQDZUdjO7wIbu6eK2aOItDtICUxbEqvDvLWHL9JX5hWc+rc8bKwrQl+8E0M5lpGZXC5ZKA76BjVZHNauJtd9FsJGEBfRGqrIv/ZWPfxIwudOTCH6PTem3vTJpmGn9/InjluufacIfaRtn+GusDo+ACU46rlLfSRaRVE6qOfHMmi166Hj8i90IsB/6OZuXsCtjS9s/OFWLTHTlBerIT4TGEhK1BjoBnVakXo7VO13X0FFzhGYZVx6BXJ2pTQOZNLegYgQVbWeWHNg76QsMyU5rL/uLV20K1Y2+t9vDL48zwF8sJvqE/wIniACjdGqYQZRbiVrNIpnt38WaqnpLhPjCbXo177K2PdSVuQNYdhS7HXnP1apnJnRRfW1IHnRCtE3FGHPufLuTmvQwbkbOum9Lg3lmUC7vTqSIwM2f8hYKj+9l8PXo6uTvu3g3jl+wW1YnTlVSjqJYzLlijGDUgYxcrA9ntlXlUHaCBHfWI62b0NqP79mXHkItyvIN15SR/t3IESINtQd5cNFHBBh+TPwkOR+H2U1RUgw/tcz9L88GwQqfv1tS0q2Je1i7HbugmvyDn7Wd0zj1hXfDd6d7t4faO6T4eTkwj3f5G1IuodO8Ed1bGJ7E+OYwRM9KJ5DrxpcSxQ8yK+IsOW1edAVO0otStjy2IpQueVqqWsBJEI50kuySAwMrPX2MOLNTlk3nr6B64D68rI96LOp72eh9NYcaBYXjuiXA6lJ/paYN1bOXMy+SaOmzgtRuyVwMcfyi4e01z38E701cQsULpZq301TJRhBAc6BD2rG0koorWH1JF+/6nMkyWhsBGL8qMEE8rsPjzuzCwLkZHI06xws6/RjZISiVfQoDpwPJyViI2rSzTSYguuwXInKff9ylwRVzvlEe5bmyuJ1DlioxRy4u6j6m8iX2iS+ZzsQQTXddhorKavSHZdlOqObzJY6otD3bSWv2mFuMY2n6YqjM96jt1vFnsrFiIe6QP4ivRxrGIR8Gx3fTNNQVBORuPN4C1nReO+58bnB5a5MycBPj0rmZsjUj/ywxb//nfQhTQM3hrUt1BFHfW0pv0bIAIUA9/AQpqOSUSlvjudJ012bnOU6ptBv33P9vpzD0zo8WKxbP1digQxfaTNSn2IU3Js9uiIEV64/9UrGEi0tutm1hODAqG8HMtGcOj9gmWqJp+cMCTJHluG37LVWJJJyPl513G9Yi+tU4jOOWhzMKnsMqnq6NVwNU/EQahQCk6AOFeHkmfaS5/fDm3czXY7ptH3lR6q2K0b88N3FS/WB3CJJEaxBGwvIZONtg/SFO3ih3Uhcf2P7/moN5JKNSm+ayYfv5By0wY1n1FDnFd+BKvg+HQIfHlWzqS7eujPMp/vWRfMHy5mdZy7r6O9SWD+ZI94P7Lg4j7n1bLg5ZEzgsKPrSjk3ZOfmbQMrlKM29ZS3P1DLDGXy85e7NEmljGcbLwOk5uw9qSPdLm5DwGYzhBRYOBitYYeMC7IWkGkE5N5ZgD38/kYNRJfWCZxUFI6GfTRJPAMdRhadnT56KMVxw8BPAeLZUn089z7EgXPmbh893h+l/Q1fwc9KwK9X2AhNtVjXWE7Btn64H8v2sNIYLQXw7JYll0wmtJ76y1FvkcAnHs2S7sDblE66i7d+Vc+nGahZ5/yVTAVb21SDHeCugMO4ZnrOZvcOKqb8uUJbL5RsbsJaFOk4Ga4R5CcmUN0imNXwxUpVEQ4TTpfOWoPS/3oV1TvaU7x7yXWcQJCGUmd22Msv0wg7nR5KTcK6EcqmapuxMg7FH9ekteCmS0B7QlwFwgwFsh7c8mkMo52ovVe7OXfqE4CDC3tCQKVdSIz8WVzp7V2YhEgJWlkHW3UNWVNUiVr717pFzAnhSSlCxhxYy4I5VUGVdv7gYZt05RB8a8nRKprS3JZGXTOSHLTxOytFE5Lmu7x1nrL0sq/g/g+eatddk5LEQ1fg3pIBDafM6W2zVKb/J/Thb0EMNFE7sDnZVjd90NR9a2w/crxHacoWG05tLWfEDbbYxGR1JD1kX/2hoN2TiyHRJwjaTaNTVUnD+RvGwxziBE+YYdUu2w3ESK38nO4PEFpH5qFuDhPxKDBmkR0u33ewzhGYDcS5Hy3sM/53yzX8FGZEYkOHB8ggGz5r5uDrvfnJGtHS9X9FRf8gqzAzRkGybR0/E7VaKUyf7czMHZNL3DxdF6sx3GkrlhF2O7zZvXeoSf1xkTCt3ZrsACNYzdYSUGnB25CkvBKCXHMBHnpl9S7nUxmD0QRzXqkfzkJStXZ9GWhT91hMZW2NX9z4EhCds51aasW8af2ZFwcfzBYQv+oTJjMd3lmZ4/2L4g5yjO8MH4i3Lfr9gyWy2lannlLZ+SsSpMMff00D5kpivvPDgNeorRILfuDh2U60TesmyXuwQjHJ2WUxfeBcOEWvBTz9i3zxDCRjv3fbM3uESzmUZS9wtX/9/Ld9GrUzQw3/z3ecTGA6dRA3VeS/lgnTaXoEXjDs8PqHBKlfKG9mySlu9zFROELXuMkkZOnaRmWqOs/vRErSGER3c6MZHWghtyOM+nToe9pe4gTmmCDnXwKdgJeQ49/vAdcV830sD4x+IBfICIHo6IKJPd4uPwp2ClkjlDaLGe2b2DYhmR5N9CLaQNeI03GwNW8TATIRjxwDwpdy0A55freQjTEmqMMDqBz/PJg8lWf4JTo4KqgZ6p0rl28vK7aZ8r6a8zr/8dfGzEqLvUF5MXglmiVp7qIEL++Krbk91pa2uhHppyGvc7BOXWJY3esfzhFsyjgbhMKfP+0zHh0QwaA9gM4WckyKwPRMXx+tDqu8SMfv/KfFfAAtCwvLGIBQi7Ht6qnqU3TFSxa4QIP5mNH6VU91tCmesdTHWpjmoyoDHRDCZ0hEQEjoWhV6ST/QMFGZmIh06DUyoCRqIhy5up9Ax24BIevKAMoHbEit75QiUxBPosHxlJOPJ1dWdExJQhNvpXyypC3P8vWHSjOCYdfcYaviYgyOAhLIWGN6hHjMTLkYhJfMFAWbTyoEwPJKbn5W5pXO5HjHa3H8j75Ktik5Pmw/h0YK58I+s5B4KeguScrf29eBVUVUozWWysvfn14AXsy8vFeH7vq7c9BfH/gsztI9FTBCmjkXIu7Ub81QWjVDt4C64+TB+tAbqd/2+3jb+XWOwoCn/aQ2mzHfmWDnKRx01d2JruCyypGGSwH+toNZTlntOMKWs4ZFRk2IueAZz5I93R2+wbCIVKI20nLfyLkTbW7G1nCahZLOODvPjz0n1S/IgQrojCYMEZ14umu/8GA/fRUTWW4ba+L5pVcV7ZchTKOYNaY4aA9L8KbX8jfISyULFNpEaFbE7U/blRTH6mfwnZ4B8OvQGSZKdcx+9DujL/685pOZNItXk67WNt1sqHaAoNGObBcvYXiG3iUu5UxF3RW2wMFHvCLDIL1LZJz7HfJAsZjCDdNtzRxL72NewXkeO4thHozum7iOLOZjsS0HHan4srsUUsfFTBdCCY63lt4J7vnuQP9dw9eU3smd7ZLIf/eJUIxAlkiuohZ7QFfmadZsGaYuDZSMZcUyoH5NVld/dCt1gyjkH/A4VhyDuEioAIW6IUg+TFpcfcgl8xVxsXVv5XaYRj2a9iyiV44JKZh3lIBi1FC96b223UBIC9O/VN+sXkNI2Fatwdo8SyPiLB2WNj2ivQT+L9lnJlxRnx96k6b/kJmJi6DyeocWYrWU7yScrfDxYyporlvpn5f9QWEmHJIrfA72VypaK547JL4Pcvm0gS5eRnZPOfb1puW9T/BJK2nGzdLAb2Af2eRvkNinb+rr8ucT+Ea+Klh4K+jXsX68kZ+lXR1P6zRUMkJgxMaYxU/iyCBfMFDDrXKYiJ9MM9IbnADMzxzlK00UQfyV/0lXrHMqmhl5PbHGMpxb26S7hLhO/T1qCYciOsZwfmX7OJUmUtc9xOA5KkN0BkqQJlYaiP0hFGvKlUzXV834ScdAXXLVY6Ia+QaJdRMXumhVmTq9UeJXv5qC+T4XyCJZz3KYlDt+3dXSWGxaoZYergcyiO21ucYq7gzg1DrVesT8J4cQFTWpcKITZ4/w8MxeOOF99FY8Sp68K0ibOjCXX/WOxDuqu3sHSBHBYru9wj5lXf962p1vAYzCoAlddBqcBdg8HgLmSj6MtsSeNK1RfQSp7PY5PRyJTY2JvwHvHd+JrbcO7gAwd+MBShYD+ih5vIrQQ4D6RFcl8NR4Qp9Qc8So+XGV8VomSQBT3O3Lg/KhoNNR0M77qXhliPr6phBoVUyotkUD1bGmRvMKU89E+HlNbN1aXxw7CpmDF/cF7rjorsqZ5CeKqr0wPcAdHlni91Pr9hfe6DdY1E51Vmc4gw1Q+5GL9IV/ilKTlGgfnMTS0AXethm9r+OFeLrkX1tH17SJ87OPPCdwfh2+ZH9Kp8rObY8QPZ1cONcQ7pSvcKIoYbw7GmtGcNO523FGsuNbCpM8RdrsqJyytTPAYM87+vq6DPXmVpv/f5jGxEUQ2lnxrqRwPF483BVmc3cbDecI93a1TnzHXUVeiGpwa7pbOa1IDQqUQEYvdpUCRoMAd/0IL9gre7VrjLLGiHWprJxzYHw+Q3nG62sh/NBRD7VAofHCOoDjePzTVefzAOr3kUWO1nhwS+dE7l0uazU+/qJ8e+2U+CAzk/VAwd5e5mHqmCZ6lvqUSVN078u04P6fRHd/7+PkVTFM1Ovc/WKroQkV3Yce3fluw8twszIydP8CluLksFWl29B2JcRPZqpzl5pTXaV4hrA4O69Qdoz4Qxnr/8U/kAajbHFxKl5087ML/sLOWf3oMgrXORIFGnYRi8c8NO5bune6LhvpZ+Utjt/n/XAKJF/CAj2QCnpzbXv1/xfyp2w7CgEn5BNI68SxTdzvrH0DKOP0yeqBRKyxn4Df6GTqJQd/llSVaJGqWuOvrpr9wibMAB/sCJ92zRX1+rsXuOhM0nFSQVnu1YkTCNDjLg3m1+JH69b+rDX+f54w7K0rV4BWIWmzBvAs7Rh6h4nLagrQIQOyikOanDu+ZqRCVQAtsNL8lLzjZiO+Ow9FjN4LnKNakkPrAYl+GSrsmulkjdXaMe2XhYBR6rl/a0jBFfWIyEX53p0NO9VKHnVicXm2/07jIUpX1YnZ9ka+Pls8Wp2P80EP70TTNksmmVEGhkaCbWls3yJliLxebibjTD4NNSBIw2wGQTskfyRIqq1oUkqYpBhxKJNIHinWL4hlR745l4BwyOPMntAApJYIXl3Cx+p6t6Am1Q2KrZvm3HubC3n2SfLJ+kUetK37Ow+jWW+DfmkdOb+i2UnMK5BFflOmoHWwDAjBarMXOod2OdAYif6VIZGcRfV1ZpL08r5EEuMWKIlY33h41igqdrog9QtIka90NfxqJ67UxYLM64gsnxtTal+MLgrto+5sln+Y2PPAf3E4kyM2+Rgd/ws9APgJ9ql7HlNdnPUeIL7UnKYPOHFeWxT1PRL1dRW0lcPVxV96BvO/f5aQwbRtsPGedgyIIl3i44WSt+fnTXGKWf7J7W1/ntd3IICUxnnwgnpqpdWit8hM1xye/WYRqA1emQUSkg978QMDjBRiGQytUpfaeRfTFxmbwgX1kxDBx4C4JLkTru5DInNDxlIixMbgtV67RLpk3ubAEVs/JSLytcM/mxMzaJQSTj9ky+U9q3iuznsvvQbczn0yQ2iUyfIWPr1/36gXwPHU8v0rJlI3okgwoMgqdNnwNlyHwf/cg6IF+kniax8gSZrIeTDwzKo6sUQpGIC6vQ0zK33u8uuleYMhfXvzkY7AkT/lWEgIfvaqGNtzCV4P2nPp+N4timYBpgNHNqScG5fwYhPjAhUWYMHu+D3gZ4a3EWj+ugj0XCJ+T3j9t+Z37doHeePnX1x6V4AyTNpjhUkn7nen8bYHbsWNpdJb65bKEVW2u9OaR1yf9OxSyZstNexgM+QVDHhYDOtKdHYa3SGFEbQv5NK96xmMM2iegZUHg8Ao1mBznfAlaKs2qlYuQg9G97qzkHF99cH0zcMWHkTe8dYX1qt2nLzIdHh617KL7x9+Rk3hlMTd2+TDvhSvFWlxlNURjIGPLFQMlPwUOK/EVhGxV7OnpWgBO3mfwM50mzHQQmBhHS0/httP4dezbQnAtxxBEZcJBVyo0keA7POvBXgESz278X7JObFI8SmlpxrEgCrpo9AhJLd0qWgdd/o4mRaYRpY/XlzqVJLR7Vq9LM+iR38XCOcejxdQqG1uLOqFAtQHuWtDseqYfb2zdwxVSfgZpKiD0zX8cBtrDkUZpn/WG+lL4ZFAqiwARCOhjGcOBmOK2JkMW5vyKmuDfJWD15N8yt3M27QsZY/JiabvdF08KJmpSj+jLJwvoI8Z24aRWxdEO4H3N1pqqlRSHjZnNARzVEAfrhNrXKtuvNmzArr+ZUGZ8Bt8XZ/RPI7BJr79P/XlflTAMOHNnSd9KiVvIKFitpXKy9dhQ5N3I9CKy5k27/+NQWFgN4xsqMIs1EfLuLC4qSGDI1Z4yHVR4xMxyPFlYZqfOSsLFg1oXOE+GABB0GGr5miRab0GUPExFdIPIksA1iDrhXQ8U6uT7rw5KZ427++GDGLHz5HYzSpnIFGHy1kBTjPXNOnXIluQaUWIGBK4vEJ6xRRrcHQe0c6HCU68Uii3iBaphuy2xs9+m8k+gP1fG58I5kDG4IILskcZYiOBwEPrC+kPJUrn7OVw1gOPh7AC1GcspbwDoQY41yUiGwh5XHOWaVw/FxHJwa6gZ0XxRxWgYWX3IimxY8VFaiA9gZKnFfzHwH8M+HMB0IueuH0lOP3wwpFax8nL+Q5xaMOafNz5r8iiUcygwDcZJqDc16LjF5UMKV/xZX9VrPz7+Qgw12b7teJzpr5m7svfZuDQYwo5LpQgIreAPsiJmaC3uHEA0nS9OBapfUsBdIweAIcs4xYi5YOa6c3JEiu1MdN6mMoWRgf+u/FpDRiE2U+Prhu6LnY4SfqRNmivs4yQuvIfpbcVHdFMoOt4n33z9Ii7BkW3oCVuGLiTJr6TX0DzL4a0+CYr6WryXbBlJIQSFwWERWKaaOmctcEcOYGTs6to8PJ0cxzJv4ZfUFAz0QGwaQmPfhIBXqG3WkE9IE+W1MJkAAFCHYg42aqvDq1/x2Olma/c0dkD6SZ5g5CNLUc43T1IhapUehga8WF8P7PUmqexlwavziUNleDDsR77XigJwNvkPabxvRbV9xDK/XSxphLo2dVAMFReTdYeBjvvRpYGeQyCAW83F3B3VQfJDIDk4t3jEEcxulszjoPGXF9vGzAvTl0XY5I3JG7M+zM4U9wBZArms2Vrox0GcRajyidkUi/qY8Pw5H02V/TBsB89CSB5/beqxMSufhNa5cQe7+5X0sWCmoDoFe563fRFKkRLy/EsZeFUtGNC+BRSQOUZVCpUah0yZqhJ0dMNpUZdf9X3anquIJjvquS+tkzgKvsZ5JHu+fcg7G7YXdFJyyuoGR38+Ye7hZRysJMIoeh/o3hwql9t8ylOqk7WbvgtgF/4Qj/Jjju7YLkHnfvldPZo0IE0GHQN+Yo8UiOFBm+iqwf3hEDenZbTXZec/1Mth0zeyJltss9OvHLr/ZqUZJ0ptX5gkaK+qj/pGyQtAds1k652PM0q7sbUBzgG883onipnj6nJlttCNL9XOf9SVYPdWmJxu8xwEckp0eC6B+J0QpgXWcAUXOu20OZhRlPqbQclxxZWuJmGKZtilStgHqM/vJEiAcGlbzj70ZLxbUJHFp6zqh60CPktesmxb1LDWWXf3uoFQXhQGh1C53kXzQD5kRf/H9+KRwW8B7DSDcAJwRR0Ph0ZCgoaqK3LtKF4YaN2uXNButYZxxvKqzoWXskg50S+Rlahjz95Kd3saL4VFQE71SPm509ehAWUDShgK5JY+ZgV1V7RAxaJ+p5so8nCV1FWBxjL/xuCmFh6YNL/qkTfoXT+8H/dYuGg4pL3ww6t/Vts6w0UknR5xR8k1Vq313yEsKSEJOpFs2fexbLL3Q0eDQaHUvetcnCaXqNYnZteNrNVE4IzjS5GItvP3JRQDXueosHsjUdAH1LLYrDF5ImHUv82x1D6vj/Tv6wwyJiUOm5Zqia+fyytKGfouKW9DHgVDpsZ/zthaJSz5ytNFLK0coSonSHOXSnFkdNmQb0QGod8CHG+MZ+t4Ydg/Urx4d4sHtQDqKu23eu0Fdb1CEcOrUSs8QTuwUb9uv8fG/MsSANVlkJd5aAZwnx+vb2zX/CpJqcJES095n/6x5h7QTpbv9LNI221hMKnXbnn0pF1nGOY4kJluQhThvkv5mmd53u6+S9aR21jCrDnQgPIigL94wfEJxYS4RWlaulV7QXNYsYeJC4uhBFBgr0p4upmeF2pJIY3E2MT19Nq7SV9wmkBpx3B5zLZ3cpm3ulUFBq6sH+WAAalfLFhojRODfBqc3A9EQCJcBnNdQC5QixPsYA/a3OOdsFhurcNCU4biBHZscKcABFzlqbYcXAU1FEf+d1guNZ/BPjLEQB19UMNbXzd7LleUfRsQ9n3TXSfCtv0gaqnrdS2NxT5nmkbQPknB9nSYdk4W8rfmo2qZWdcCXidDcUCIKiZAZanGRkiDWwBlwZ6gLyiqkn4xSWYr1u6+gz00IphIa/MAd34/8Sv07+Bqj+CfMiZiQO21IBPnJz8jLZDy2ZGvhOnC6OzSr3nwWlefRj4fmCibQQhxZocHj6hXlVVR23f09iBoHT745QhvJwOXm1qafGFwNg73CuhhH//XgJBtVDDpmS+cHthbziCXtg3J/WqrLp5AyAy3STh2fg9wEIKWmRDdmrh2lb859RToKtcrfnpP/UrtMzpF22eI4ugg01OtK5M20XSsnE46AXL004s4FMBmnzA3YYQ+YjVKuNqgyYCdP4toq9IrWnCZS1Ev+367V7OMATQ68J2rc171Q53ANQHCd14pFEEOsQRFHoYbmGS1kb8z9HJBUrXIMAmhdF3E2Z0H9msQjvmzpHt9A4Q+xWipQcJSpE6CFbr37vtDz8T0Q7hc7QdIRJqHL6LxQx2+N1Uyc8kNG3pp8LsS2tooqwZm+cPHAElSaQKIaU87FDdCW9SSA6ZcCIbw80vuBMXtKjnCCW8n7pB1WyhNKUFmMe0pvvdy7JtkhrsySFOvkFLPr/8EIYs578c0z9+MXQgkbyLPbJ0W/8uaLCykuWx8lZ6IghOkpCQd6z8+Hz611DlZ0nb5H3XlgjikztxIo3GtjJc9OUtDm81oFUq7i409YCFrCD9EJKgxoRgZv4qGtDOZvSTlWjVHLNIqQRFFw9XBt7EQ78rD7jWAQhHVIb2ZT6Dpzvg09VPJwqicoGt2FCgzRzYHTqJdJVzCjLqib9dX8vFIiC/0IpykegxcfZhhQxI9D1J6bOr0P7nw0XPFBP11RZDX49AVyitczya1DqMKVuCKRptsD/6TO1IUwmKjSJDIkFf2S8OS8/uiXpVz9qSIzGQxditqMOZGmumEv3BGxQbRQC+Y8AzP+o7vW1fPKGKkbmVoQsHV/F8GzJTtJpha+mQimUTcnQKH/wurWgEA+7714JvTrQkjO252Nc6/QYZpx/QHFFy5aUDANHJ5VHTwTDkuLNoZ8Zz1DOQNmZoaiCG7B8oSv3THjoN38BI1kc8rabcZACN0zkFZ1sZ2tvFU9Bpn9CGpqGgv3HbfEOv28QyMjllwe9iSUzsSUdLVy7eAH+PX+bFtpXxoiVjYEmB4JDOoCfHKijYmC3B8hgXQ63D7h0ZfnykSRrCP/S+AF1tMfi67QfM52fCqzZJcj96g+s3jph7cHhbfquGe5FFsjtSJIOOwFYReHwStuFkUxmv5+XCsZ2owGCPl0FuxXFX3sGc3/LzVlCb4XyIyl0Eg8CkUQg1NjvPWMWg5wZVUcLl7RXdQpaSy4wRzP/sYHTstBtXadMpZ47n52rHL/5C6V3AaWKxntDO/D0B+sUYYCabrfz1+Fpwss3dE6GY4HF2FztCJk5jbEMCABAsFcjZ+ZVE/cYFIB37AzJA+43Q15S+ORflq9lF3RjQWklbOXJ3n8mVida4f0M1W+6PdQ1rPc6gpNHjSseAarnNseJVYRlyhj5KURwSVzzSNgQlLcVKiESRnGUtAgZ3/948Ht5BWjPEEwXdpJk46BYvlLkVGCHeXTciA1bEw/95rjnckvtxb0D/zmRybRkSU7aB7ZH29B/5ljdH5MQ5dwKgx9YBHzjIKAzEtvPdtCSF4G5A3GwWKoHvoW2arYWKYQcwOWNVZOka4c3VmFKq3U1IMn2dFI54MHrPlOfr8lL/wKHxK1nTf1W8tm7hCLQPhk4wVmkEPTi8/g4P8PvaSkDTpLGHuVYnpUkyCzrEwAjf/7YZytSl1UnRjtEek5C6m1jFoYzi847068Idu99iHpVINgsNLAkN7Bzmqj8YIckx1IVptn9DEr8fjBucCXDptmW4ClOQ0BB3m+j3ncDLSHsyGfV4hnOjOoeJEJ+q6eQfy1ZG/wYPTp6ar0p9HPvPU+jeNLcFZB3ngjLXmNRWaYTUMf8S7k6xu6PQuXfud5sZHh1OOArgcdOD5dz7kcGkQODDjUhAAZ0NoNUvrEojkIeCphxYdzV1IbYNnP4L2zBCqD/DEamkfCoDbF194gKmKgmkMfp4OUdI+V9zS51jrYM3TDspm7neI/zQzMDIzzs4hN/yyOPT2NZK/2npRU27Is9zLeKANZ1OStAyNIJzjsN6txOgrGr9NbyZpIVs/Rn8XNIiC2/WzsnfbtOrOOE65Ve64riTNFLJyKcdPEQCpFA9vV7GWYHV3qX3ZTZKY2Xfpva4SVjTrGjx1dAegRZsldL6ZjFFvS0uIKgnXI4+B9lfd8BQKJlanZ7EHxz2xD9Kt2i7gfNWnIHe/sh6eCzvHBNpAkcIIBsgUNMpEPvu87ILy7vtcaXIyOmckxGr10dEqgdb4PmMOK+Q04xy5koNLatjY2M0nWb1yBIze7NlB9Bq1qkgSl8kbRTqR3I+PtYpLR9MUMXf9AYM4RneX1BVlo9PXz+Ktq56vhhJzFvpO1/hbaU+qbJb25CGS3c9YLg4wcfJ7MSyrLSiEA6QNgnUG0ZOr1k03pmPM0Re0gtFwbJFbD91575+0vtbL6FO5taEDXtZQ3THkJ+Fwqg2T3Oz1/5T00HlE1Z394tfyv/71OoAEKhzYULH2JtJdkR6bL/znz7K0w9xAwR5EdCVxSWCijHmVBces9FUAMQzG866Bz50jQ+62CSaNI1fzxAbly3NdBsWaWOE0/WbmbqlJwpRNo1HxG+rZ1KYtntBXW/Qs4+aL21s3LYz+fxm6ZtjIihqfykR919/cA5gHfDv9Zkyyd2cgudONeQi9NYoQfieS37n0F7ZToqyiKfNRwChRbNxqs7LTEphfpnxjjfdAe1lEX6Ld4Lv/UIHZngn3yJQT2UdvwVQKrrMBYoMrTBGK9Di7lAxOTPAwi+2s/zqVcQkEsdv1xDm/wnWI+18IgS7VxsKeHHJ95nMwofxWjw+DP2pCO2Fx4jyjIRivH9kWCdrZyODdLfQfuYvq1dNKzS62AXNB6JVxQL4tVKA2V5SX92YivHYh0z8O61QqTVpnOgI+NY8rd7GLFLPwA8/IegNVYvCzj1KIDyRhxNEK4NaAwZzRznoNcWk1N7UFOwnS0KO/zGx1Y+5j28m8EVGrOkx3qYhzByS3RLHXQcrVcD8/NeZcIQ3OBTqqSrZA5JfOuz/ScKs4HSbDCfmoNf4jv03nNqxUnXFFASXupTYhFUUTAIQSY3YmZsETfFiyaPPAvQpidvM8SH+0h0RojOYtr712AGlvZMzre8F2cseVIs12H7O5pCKLldsDEAy7e9q2yqp66cGOizALxl7UF7K8jElwKnrPqMPYGHLNrbua1zWRHsrDBraJjoW4AK7gy3mJl5zHV2tsAEClmV9gZ5MPZAliBsQm/DrAGP2LaGv2uYmOCktHAA/nrfCg6lXt+ZsDMKOoSe6LaO5bJ9GxO6W7q9Wr3uZkAZxj46zUhG67MCOgQlJotKb3aZQs4aSEuFAmzsAC0cjgmRHug9kJOzGu5oQxpv8Z/P1UtC7aB6g3SX+8w8VG0YIYKG8d37JE7ymTZ0+l6BJjLCJwBnOwmcuS9VpYI3AWli7Eeway3w8KxCO+09EBpC+zkWgtMaD9kD7VFoZKjiMfXVR+KLRcL3fi8i2P2lHW26VcdrgeLA0OwpMqN10dbN+ynzspAAlFuDEovafC+WtXEjKP5AGAQjj+YSVT9RAjUDqPnij3iuYZQVnrMbOziVeUVBidQlR2dxydap6Vf09EawooxKtXV0l6z4GuiRjYa1wTit6Abhl9YsrT94met5TDQ0lgAbjGPs40BW07ui1MoZuhhjGDrBeHo0O3amthj/biTgPLQdhwGsBHVrkw2sr7fz/IFE16ZKqxTg3CUptnvhO7/UuTiO2e8mPiq3sAbuV75kHhKlzYf28cO2pW8okFI9shm9H8ddbqGGbJ2jMRMy9e0mc/+hxkasGZ2GBpl8PHg096j/fMGDncO964Dc5o2VqII4ZrD4W5woc4JnjjQEJrWeEk5K+vOcW4bCnzSu6PxNcLPYSIg7ot57rle9XwQbEjL9RWaixcRWwfuYUNhpbA66dN1c5fBtUL5cSXhRfMEmkJrZ2ZZ5q/E6HeIyLQ22CmoIkQbUe2DoElcRvM2Y6QQ8M2E8DWJO226wGkDdl6VZU0dhDWnwJIDzuLHm7VPSgWDScoP+uTn0tyvOCxcqSsJH05AsqBLb4NWciKaK27Y4w/UC5FiNWlPsS1ryDxErzCZZwR41/m55MW9/FpOaY5UvAHAmdBeVJY0ZxMaFnfm+G92TY69VefgYczl5/tM+cZYqmzctN3fl6dr43c9Rfm3yJahjoKLu/d9arGwf0niOdCqOc779BmP/jSeOzfeR/ytQk2N7vcBU8DgUX29pPb9Q9O6Ymep8NpMO3Gc8Ezd7bCaiBObGW3QEZpRHvAR57TV92w+X7IODO+7OA54LVdYTPJSUkvjv8uEfnE91hYc7e6a26fDIHOxyqrD03lZw+yvs3+9NF0MRhjfLrVQPRwfpfscy0ulyAdV7T1h2y6tKdf+XiBBPwulZMmmaKeWYlhhkzrbcs7apHxbKi2sx8eBEDNSk8s4wGLQm8ZcVtHO1sJZ4d4j2AFOAXSEwlRSDjaF6CSOKMCriKmTR/w6Mts8R3YjLmftqHC0TtfqDfi/TJRrmEFUS4Kk/zNnjoJzThOda5gABGAfKF0TSgCEqLMjH5EnGuF9J0Slyy3FDs+3T03TE7DNC/8ZjtxY5ZmmUKSYBzKQ+guiifQPK+bVGkw1wbkDPM1gu8PkQJtWj3l45DT/uqF3BGhmpyUQTo3GhPdecDlr+Cy6gIsIL/t3/jrFwbGSthLQ95Z+MOjMD1hZzRS/uqMvvhZf1ZoX03GZKe/OGFeU+LQfaqSXZqStGR/NmvTW72M6n77nYQ6XPXxDUTDnJEmmF5TxTI6Ppr8zxP2MuIDNvlBGcqegy1Iom3kzWyWvPgajTTd6X1pZw75d/IN9B6kKefO7X4x3ns+V1aXkxhIhrGBJt3YuRC6uI2XG72X5WW8x/dmngDyAATvo0RfHrR33N8rnr0QbT2aL+Ves9ap8K+uGmendX/1j2lP9dmyR3/oHiRGnNJx9iPrxChkmA2zFXtu6148B2SuLDxn8JArLV+mBTBdOcj1DVYG2fNgr4N5v7IHwVCCm4kkNYmDtLMSek2lTzvzvjy2YazSylXl2k2bjzRdTL8EPXh2/80/HARCtfM4T/epLDv5r4VJNYEkVkfBvW0laqo4X45FLLqNkHzpIsqWYFPwFa/HCLBodzgMF12mwOrXgjXQ0BcRGx3+LPXFWqBTVSsj/UI1uwA7+aSyDdTitT01tcsKHD/uIOOzDB8tRZtYa9l0nkwl9Q5ypsK+iSSIG+pcAFbvI2gm7K1U28KDfrOQyWgokuLtrIVSKT//RB3SUG3BlANbA0yvs8E78OClVv4Ctp+1ILLVkKAbZKh00zVK/5YuayKd/qFHdcEUjyERyIBStKFHzLwUd1DK/VJ4ACGF+EAkooN+IDsVZrNcBTjVRKSt+s/nqCXEH+OZuT12i0UTE/+cGSZiLUa9tb9Uczg9N8onX6t0miqjhTFi64hQ93EOfxVnz1ji8jNs24U3p2WCepin0Z7ibyH1N1/THoc82c0SFAcZ7xGJN7+l1euzWWuIVamEa0OFKwUByCqOGLWHc74gNrogg0X3/I4tItWewYXcSRd61EKiIGab3oU689EmvXuWBoIIYtHfZY7wRamXmNR5rhjkitRgW5lIpBu3iE9M8Jf1Q+Ylu3PAnMmFKNu1b2e9F25ywdAromHvl5WhRPUa6BCUyzIqyJlz6Y1n7s04gzUGQHaJ7LgPvrk4YfmRGEgCMXCJ9fLWqwqXbYgDkZMcWiwpcYsx69A2Bcdgtq1aheXhLwsO2uhv/ca6ng0151Ynh4EOfWUU0KeNwCnGFnT+66WQwtMrTkfydpZv1IY3FdNrn6fRNHrbO8ADwDyOA/U/62x6mS6Uz2CClZ/+xTu0nO6HH+2Wv3rlJbOQmgp1v6UZSAM3ewx3caeGvQN6FBFOtikyf2Q1s44J+w8tZLKQ9aM5RkVHxiLoffk0CjSi1mlvaZIuCpX9dZON7vQBt5+gYiy+B3we4bCGsRDmaTR+5JhZ/z19nGUOjBbc52BsSNw09NiKQkJMwXP2YoYjAJfY+qC6KucKpCsvw1l/OEnpOuE42pBPgt9khtn9YbIMRKKIUJsSdI+g71o4l2XnlFEESoZoirCVjUeX7Ka9h5uxl1IXDreptjmuwuVXE69Fgzf2zIUHgPNPj3ZQei0V370URJeno6iq+yumX5mvRT1PQgh2fe+SMqafBjHP79yuz8mIa0w+YMx2fZwuo9WzJrixbsZemaWqwQJBjOlw7y/wkMNsumwvfGHaTGmi6SeQqDCO1GbUXYuKlCNQWvZKBTbl/8BDreLdBHUgTRwLUttMjF3JnXNE6+wXETEjTNVn4VQGO3tWQ9T5f1YWdjFbp3EenKD/UVZcYuNMOcLtgeTGDCqbuekSDKFTJK2mxzZolpfZ5WgYBv5qXutHz6LC0RVkCp6cGBK87TvjL6MyatUDKnTUkVZIgQ/id4PAh9zH1mFYW2wz4dH38O2l3BWs9hH8nM7J6Ib+7GnQY2ISGZbTdL1zWGnb/MFLRhm1HtQ+RheBrVgym3YT6zwD9y/McOGYK0mwFvYglzTNQMzZadAierFbvhXPgcwvo+1VovqOV+gZV5Ei8M9SIqcMQ4HhV0obDwPLoYpgOi28wmzMWVhyx0RxIHXpNNeIyb3aFzOpxWLON0XvKBh/+/sybTLcvzqSxOGlOKIGlEqAxbxJ9y3cYLxd0Gm2QSJyzAEldjDeJUZ1Zkn+I4Q5iay0yU2HlKqkvxSB+0kWXT3yRBMKHGBk3/o5VWfWnW6rJcEorlsSJHih9rlY5LU744t6nGet+rxpIHSLXyrGXeKMrFQeJkzukfF7bn3MaXiNngw1/oEJ9qxdvzERaMqSrDCmBdDHNE408JqyYd+vdNEdQdsPfCY5s46Rx8YCnpG8sj0NGgeMsepbgTpxehlvx9qeD0YcvuCdvgM+6piYtWeOTPoDoPoPf/9UFRF1jhH75T5wCfidbXYY8QXMlPs5zLCnpeCT0iKc+9T8sccxohL1razHVyKRIccJnWgxRX6522nScf02XUH6i5N3BkWbpFrwTvNQtSl/TkSUYsgmg8IYyKrUnQVAvUVlTLeE7UQ+G7612B/b/4JA0AqvON0I3JWi0CcK+YvCpGs1yDgIF8ioetqI6GLARNsshkKsSUd8R2dsOVFhWRzwZemAQaLj5T2NIBDBLT8fdmyKb1N1pNqSYquYIPfHpW05jclxfBFugMUlHLc1VMAbh2eMgEX3PApg5tCKQoWEh+zR/5F4H9hjM0NtVHTe/Teirudor2EVUPhfMc0A3fnMdUK4oJOBoKA1NNge6mWrIrlqJwLWFp/iHrQQmRG/NcA5nYMucoCEfHxxiczc5Y7XIYbeBPzyg5f3SPFHPe3Ke+FnekeNgzVJy/571qeG/1Mvp0ahel2DBCuwULEaEgo6qOPiHwKb/VP5sQ0XFVU8xjLNVB2Vq99QLKpsGdBKlWo4K/09C7t/vEH8HR9qxUktmmsDE0iwP+rCSQL5KCyJBln/5CKmyAbPx0PCy/kB4tW7Qr4pEEKdYLhrJH/7Ro2UZTBeF1EhTUlThbWiqwlbenaBPH3gLRIoak1fVghXcRZGZJJazd1a8lz1b0NRkYj5yQDVFVvSCzCMuRLQswubAjipjxhziXNJ7I0Q9PcFTT+Fz28k+YkuZj7proJMXpBeiBXwi54AzpNYMFDSFqa8irlsXXdIDO5QxtkQAEbgpjYvE3I7E5BglS1QstaBg0Krt7j/bbruhFFnnlcN+vj+bPzYKMK2JW3RwRt5aI7ne5uRxOLlod64TUCM0nL/8oEcssip/JA/HPpvKcxtmUwXZI0utUCx3WpWscPsSJfJ/+YjKMW6h+Ao6cDa3BRL53J3sjxNL4VZ6oTnloDf9OA/arMzdwPGLtj7+x/XCPfRpLcbzchUiVWuQHdSDFJ6Hzwil+Q5J1Nnj16C0lAt6FdeRmbZ9uRyyou5ZZnSxB62ptSupVyYAjzweCSRIzl3Zb89/hdq+JIIt26Crqyflp1O/96aCKNajc67uU2anjTpzlkbDq7wIwOzZXwGZqbJCF+AmtZGtBZlICB9HUNUtWAQtkdy26h4BV0nHto1Bt5/ltdIJACdnHGGuju4jV0pNRTS/i/IOPlSp6VzzJOPONvrRQVcB4Jmfl2HKzdetRKPIrqDrXslDussB8ySiUx/oigB1VWu2kfsgjUlZgd3xrAMUH37Lckwayi6aE2fNbLqFDGhrUone/9hFdZVCA1GOZ6ZpYn6/0WUgz5DrOqvpYwsn+am5j8+0eJ/veaGdPxjwcxJ20febV13gVVe2c4TERn/ANZ04B1+zFwiWfCHCwS8/H3SiTDuv42R/qkwdHZxaKGDrvv7oS1vnNnAA+6r80zdIJCYxMdlNd08FwuFq2xVXsODOroL1+LyrjhafDSNEOuKQNi2KN/jI0/taEEHmhthMmsmGF531KaJwGGSPFeuck7NAqaR3Qrooo7ZmA1op1X0a2QaLJ4ZKJrysgDQLqlZLq5oPryzadPpVj5qdySgxcAsh2/MswVIY7nKA9g9MgoKYg+asGJLmR837SkEdKob8D/dxz1+4mQBJg2xQBMcWoJnAHdbqKLaN+VSRk7RNdK/npaU7fbLxCQEnQyjIdqLAGV23n0VBqw7f//GE1xZkCnia51ambri8QyzTcV3DO0rKPybNClO0hxCD4nfWuDfM5VpZXxj/ZQn/Z5GrK0YJe05/vqCl8JVXmgSpRu/s+xwFjhdHj2kMbJjMGeelRyj7bE/l5YB08zp9OE4FKMSx2xCCEtzZxWSC1WLDZhiLQonAkPopNZkOGot+q58nJcn4cykm9wyqV1SvhqvEG9Se7mAB1nikANhRQ2wmNcr9jM7TULY8gJBl/JPmAYhdqTWIc8/mCphpUk/7SNx4zrRnT+rZLveE3xs6/gxCNumm2lkA6ldywpByWqsosP+ZUFrat3nmVuh+KhJDno1KxdiAfiXqqaXNoQypGSIYu2VH3sE+L2O2d/H/kAKK0Ewj+mDrFkMKwXdU4ZUyt7e3Pgz6yjL/vK11up21z9gesfp6m48HmFuVOUGvxPmqMuYI3fDnBmuyBtvbg0O63/5UyGokcMgvXFJEisAx4tK1RoBButyfB2bZ3qbPoIt4v07JwA/g0dG7Ejqg4uMOcvimGKwiOT6g3hslhHVp+l7vTaPLPkA/Sr+VcXND5vwEVYhJIzDkFR4+Q/Xb9WvNp0vuOFxBpI+YZuDPbPRIVpkFF0LoMO9BKCpApBo2CotWl83RtJWtIJfOIwPK87XkwPKPTTDxhcEkmjvMtYku2tvxSKX+BHcygoPLOYm+1kqtRgZJI1DlsLic8V/IIPAezbXFVMWzhrq7bCsRio0bRa9flP6BQMWR+aP3cvmMqLAf1r0bCBGbWjeI1Kcmr5UGpCW/1G5+fMEedAifpISUytIlefGVaIc4/JPwQ+KnFcumnQNQYB7s+r2hTqAnPDopC3wW2ZlIbaL3WDj2QCz760MDnDBMUFJfgJq2MZiTilOmzxKsyJN2xiV+/os2P1wJe4r7ON+aX3p/kt56uuW+dhO2H1jzvH+ZxtRjLzFJ+HKw1YURW+ZPieXJbjkspmGyX3y9T0AdP2EovBYWl4Zb8BHR6lBXxvS5svIYNBUOqb7/bIrvKQz4sLRAkb7mLKVkNsN+DAZZYBkiU9EzSLaWAvIhytMYfQ5BgC32tuwXp200t1G/R2NV5rLF7lK4efTZCsoC1owo9kZDTywAJnmRuxmzJPzfSC63ua8O5DeXjfpkVdqXNbnz3ML8BNS+0RSsun3k8k7R6zStKFh/ln2UEfkWqQiZLwDgqQviwevJZlL4FJNAO2C/u7zWzqpM8ydm6+5jVcRh3sOF1C/LtY1ExMP26cA6ChuY/ypXxTg1UMKSI41xq/nF+IyNzBUCodpzpfCqsfqBWCR1+7nl/BkF0vq4iMksOfoLSYdN7kHNnbnHSkMsNJQ+WregLSTWEwGIeLjtpwu2SMFN28ow+SnWL4Xrkjv61T5qujwhzC0GRJBHb76gh8clpU+bHiH7vAZe9ZzuFACtVkTizxrdRvJmnyOlovh0S+gMtWo2vRIR4mZiBH+z4TC1xZ7NNfQERDTfjGTk6fyvYvTT+UsLEJZR5YYJA02zP/HOd1OIWxH1iZV3zwnywZq27cyGUHecmqxIAAaUO7RkXfr0yAHsTDTIa3Nwts5cTdIrfs3JoDgq8u4gFt12eWo6DsZ/65+DzQ/trdLpCt5kw8gcDJXp25zbriGdyPmYsA90SH6e5UG6gp+9C9b97VgQB+UhHULfD9+hoc7Z9HNqVzG7/pK+g9lmSr4OMJ7wypzi0NSGihtLOVQQynKv4CIzQgkyh6busS10CVwlLbRGE2p9zJ9nlkVPtBSCXGFYp1bMjHQ24ykHsaznKe08IlSPSq1F8eOQ4F74H1TB6eTX/GCxOEYsNjBzlWuOGFWyFjwJeYVMMMcl+Dwoxqo309F/n113+DT7fWJiHe5c5DMS3F/pYzpA0JxRiNYfP3IEgEiNz9IOC9tL5jyopD58PtHDml+dE0KtHvpACDJMv4c8v78iBUTmMij7lVerQ4bpjK+waen8wasnot/R0X3SWnxs9WXDa3Hz2lyJFtX0cgw0hRaH2YjQNJY+DpN0MLTZX31q5D1qFM/SBTxzDfihEb/UjnOLjDt80eEFYlbJ0yXJnOFrv7ICfy0rdLgt2ikQRuKcIsXfy2OxZPqTM5ENMJ5l7uWxBL17FJpUPCp5f/MNxBHpXG9sEYNXhrblgIFPMXXac91IVGnP3qKjOsqF1p3g73OCye+5EPTrBo1zUcmawMmXqwIAhkvsdJq+Xjl5qdwqn2fsVC9NVPXmc7ETSEojb4YMfkfLFqDu58/zVxOFV3Nt0Dwfgq0wl10WhGNb9QmD1uiWOvSZ8OgsD1c5pZdIEAx3G+F/F/HdQneAXebE7ukDk1aF+nl+nmR2OZ9zx1rLzHeguK/yo4W70Hnq0NeTrBI7GPbSOZmsBE0hFYjtJaHMzGqzwi+3w2GSX43oc9mgJuxTK0oELuPq3kQBQud0TF2vTCmVQeYQdr3+DFQWDJpKf7B1oxh9/cmjSyiT7/6hiKaLTnNdla9Z6Ep+F/hq9nEME4f44Q1yvDptTSwBkr02dEzdhykwl6iy251PhoRH88mrb1azlXIMsmoz0wceOWawt1BbngaIWxUHYdw3czXFzIuelBf1kdYNUAwfKrCWVhF/lykMxwm2uEU/Z6pAe2zM/wcAkIw9QIvax+pbOkOthrn8BqNwQjZHRh9HC+j1KKtUkEMxZp+TJKEe0ppC2/aphV4xn0Xy+5z985e+3ZgcRDVsFRe19bnnfDjixeMEhiirIgoow49GIGip49YSIwcyeWI5OOvejmxi2ghEgpjQFs+H6v7MhcAJ98FqHLBl59IO+IMayuHVzbkTmW+GDZSHyFrY0CkMxVwztU7HCHssOKZxUJrgG0eMBasG+9zZrD1Wc6DxmfC3sYb5sA04U7Ofv1dHlD2xbHi89renEkmJkE9lvVSPdEVay7PeA2RR29wPLbuCjtHLi6Qo92UjAYnzFyW9SU4+PPrEXIawaOXMOnpRybwapLKujap1zUUtrVuqeoyCKRipNFBOyJRP7rqMTMXp55eGJWNbRLNGHl8pwy4jUR1LCRPx1ZhcVps4dF4TkkGL+DnD1PJJsK6aH8y11WAbLo2IkPjAEEoB2amis3cIM7k5nVQcSMy6Vpx+olMVEPH1kH/qr4r/y8zFDH0uxSOySI4zGUXfIMIs767e7Sd8R2aYBkFWENy7oClJc3vdm64sVprHxf04p16akIxa8lx1zOXL1U6Ejmo8W9DsntDvS+gtNpDsaKyOd9cLXFBdCrc2sV8z8GOiJJ2cKe/Xs9X7DxsNcjmVW5Leuo5uLp6T+BLd7iwHA/UaUeesJdTaVkYN9DEPfcyqNSMEdm/3x7AfdshhqH/D7X63AkoHtVgcMujaxKP1UGRZ+1JpI0Oi/vgfMz5ETiPRCnQCZr2mDh5fCqAlrXr/LMENZ/adHDg/aQjaCPGf10ECX3sxEj6smwZ2TxMjG/z2haLJuYPl/3t28gk8t+DHEt9OD4EGfp+oxscnq0BXUAvVmoDumhKzPq4OyxhWjJAahxUK0rrWmJFl/GSxgjTkU1zdwteR29/BUxvfO7vHfr2G6egYULqCWqxtthk7EWFVvg/+9ad3V/hcAeB/p+FK28iZfh5t/c2JnXN8I7MZct3JzRrR8UadzraMiOYw5os4+7ODAXHWqlzirOyULax4M8sfKmn4P4EfCJIzPjiEEZXlT0ib8utEgzc4/dl72JpSlWnqzvGsj9FzydTXjyFl82HcgV7jQU9l5aPDRq6j3N3B9ZlAPSxWxNpK+wmKdnshA0Ne2e1GrjJt4cPPOA4/WWy1EmUE76wyDtiD+1ukxVpMFu+MC4YPDFsFKlpDErvsZ0JIDmH97kmnOjmgETrDmFFFnii1DCLpF9tkUuTBb/eQMQ5lsxHJMthlwx05iLFADnDaQsQ83fQ/lYqcB7h3Hy/C64Y+1QCkCEwc81deJgkmVzfQSweY/AINYy+TUge7NPja8OBQ+1I/gLvmC7itepmey7tIToNEtNZIbYQT8L1UANCajANiPO+hFL8qORNvzgTJk8HzKxzx2AtrWZXXGkdZ8O1TLUIIqCeR9afW8mx/C61iTkX6PrnNbr9PfRBgcOpsMdPuujBgnS0clRKQ8cxuLUTJh3Z3Ew40G/6IlVLvri4qcohlnnT+VVr4olIsiLtbnH1IjTFjhkUF07+TfxJ5OhSJL/aUP5zqpIAt1xQXbKFqEWVjf5m6vUbKZPz5l0Dgz0FmuKgD+dwIc84r/eU8yCZ/YS3BaWBiEkueKO5poMauU2zAEDobs0Uj5Kl1EJCdi6lAxXd0GYxBqJX+paBsgbDbteiHMehDGUxczFbCn+8zCDnMDBIIZ0Ej5QMJIL0jFvI49WIt0Cc/6sEuF5FFLq692efhVYZVx9HQ29O8XlPWg7ITvl2sgMRy7h6GfyTA2heae5vceaHokg6+qckWwSjGG2Wt/XPLU3h1Y5XIjOlDaiKQoSmvAqabji7Sgpsbd054lgNE12P3YPnVRkm2ALNKDlrFTg3V1ubCaXtFNdlkCi7VwCmFesGycZ171zb3BHKi+x+g6xSPmHEGVZdWF7ujROST+wSiTBI7q9GvoPjnudjx+uzImcrx2ZeD2dmJibDhK66ks7gteVO5sKKgMe8wtFx7dreG3zrmRwUhRp83puMTm/1eWm/L2ugfLEPLkxTQ1QX39bjRSRKCNW8CwuK9l0pkMV42gDyvcVVGGPFT+s9yZsT0I+NgrETb6ExQIJTSEI/K7ZWPbq7SA/p2kphVmz/RaCFNMCdVhCSlEt+D/zScQvvEuCPhi8wVUzm6YRoGlla48+esEz8xvbZ+HzDhr7mo6S4CGwMbDUOFH77M7ctzBjt1HKDNW6t2phxuRWOP9J0Ety3nDAtoxY47bQb6c7oEK5Q1TiHpKvVPU/kl3ApE3VqOvo2vmzXHkb90A1U0srlzkIPnX4kpesRhYevAyLDzVcLBsUBA+JGXM3gv19QjqAuieklZ/2sfwdTQCWQEtTsiTwU8iEaGfIaap8ldwygzuVYpnv84TvMnVtXMbDl4p1QvykbU2wFbv7bHB5XQPYm6/s7Hxs2ACjpBnwOQM6mIcPmO0OnxVtHN41Ly+B7RdJZ2QmBFtLezB4Oy/QOT+nI8039Yh1eeyAoORRau6hZcgiFHXWlkrrWuaEUE9Cp4E1o8/ibTMYLpH6QpGCTwVzmO/vpq+sXwu8uBSwk3wzDca4TY45Kr7CHfwOYc84LTAVF+aa+7L3SrcZZdL1oA2X1QjqE+GiA88pBS5LJRUFzo56ADCorDTd6n6UiDeJULSS5/B75nNkVJKllih19iV8vZVKnn71qLqr0I9Q3vKika8W2LXi4o9nUhmufF0+FBusG3MPHTQoc+EQxe926wdLlJ2NlmeDj/BpMzQ74WQF3TRAxWNXei3TxqnXRwKmj8Tf0icYfakX2XCyvBSkiji1sCTqpW0SedII0rZrWE9PIvwkFvVlUNx0/TnbCPilrhJyNNgpzVwzZRqHpJnIaOw34FLtq2U+s6eKBMdElLKrDXHgSy8zra6vJE2tVRw7pG8rnDRDtVgyCpf/hE3fK//pgIQsgYQqNoO26shhdBoTPpFb1cA6wDkyJIvDmUF4bLQC0bF8y8aQtu7VL4gNKigpk5x1MN1i5cIhQ/yPZxdGsgjXSEcA9PWzIeQPld2vcoTq0OkQRgUzKLR7k7zctXETfEmK/kd2T8s88BXW0SnK6ggGHZtxaKlcLorTAA7VPW2YA6lz0xtNBdsKs21oc3rJ6PxRs1AOozZQBA5/w7aV8NBNs+ypMox9O6Ppyalp/xUOpfbGFmP3YNuXEUnIEqQNJj9KHKhSZGQeQP6SR6sxu4B2HPPRN9hzCGyEV4QPF79Xl7XSzIOxx8H3Cb06SeFCW+fru1c41rVqqgNsbLYHO3OqFdhDQYAEZ3TEoo4w90QOjuizL/xWVOxccZXJ2bguDMNvSWXcbORCEJQlJeUZWK02F94QuzBza5PyMM27RbwsUwIAKsiah40v8c/Tb/JNNA7u3Qmt/R/UWb0M2f2e1jHcme8cy8djDV3vu7LNulULRPlwWPqbowy7Q1k72beOtbOOi9OpYc41lZJ3UIL1V5hJ+0Pq+lAr6Ur8S8ZPzMbsWqNefQhdLo2PwTUDVJXCTPe81KjpyONfKVPWsY1aVMTaybBlEnpDJXY+2uvNK/TPWR5JLmKmZHPaTNxGKITsoGnciZano087/LcXPPNCdGEMCDJxMqVOhNDp/6GCDzRI37FlTe5Fm3+3fUcGoVnFoJy//rL2vrls11yLcNhWVsyTMiaUbSgYcMOrJAmXYVgeSUFLhopLtHqmsck//lP076z4f6ZYFX7go/Llp48C+SxguFxNGi/pFj8mcpbI8slCtZU9ek0y+SAlIqSh2OfnlA2puhr1RT774ufYrPu0nlQ9C5EH+FpUQz/RjLMPGO7/B1rDdhqyukbAux5mtHz/I3RMnWpg5MpGoUTyzyqlL+wNAP+nwut5q7zZ+sntSNVlLNTV3o2nETR7oG/Ub14VhCsYM/qwZbTUR9btX78I2OX0kLbgVbgv2HknTTyG1BVr5mTztGwYd/auw0pP9YWh6jNsWTXsYXgrYLhPenAXy4K89dqyLxDVthskYyshuk2Te1n2Qzq40yvdCl+mbf7vlpGrazYFv1TkUWHaoPXn5P9vyP67xtcBusRiVTqrugiu48uM882Sq5IKq+aupn5QstaE9dy47pdKTE2LHEunoOrUibAZ53tMk5kamQMKSQfVefUeEXf6AnyilRMcJmXVQCtKIhG272Gyz2fCNCOFlr90hfBnKM0+UwROX97XcWpHeTYCzlGkjun1RJ0iw5QvVhD699OfZ3i/uXN+NeGsorOKngbc1yus7sZdbuO83e4K6Wnl3WZhYKOh3059bc0kZnqTqlNi7no5CxVzRjP+Kx4NH8vA8xhnTvDh+kgsGMjQ+GTUT0E4BGMS96iDIKTg+aI/SPIHwAg+gNMDAxXdGwabv9DJsOIWoSMOCj5g+M1g+lXv2iod/XmTjUPxTZvm758iFLEVsL23bxYhAxpBTTLCYvJ2Ix5MHLsl97zX1g9A1xy/G7XYiL6+eCexIF+tDUpXpbrud9QRFt/NLY3gkiS6M4n50Mvy32WZoWHLFZpmJ2OcKYVsMhLIWvbse3liX5o7fGQNJeDrS+buOM/EBGdSVm5xNSmAIPAxPEnHpdqMbNRmT54FrDi2nnd3QnYyXNV2k8hJN/AQrXJfNwY5+tjgdp39L58IfoSHbzOXw23XOlqCsU3ekV+9Zx/rIIWLttZqfDvs3iRNHBkFLsY45g0/QUBoiMepLCEuSB6EahB6tsgozozimdmO0YQQRL3qv7oDh95XGP0dEnZfLtby1srwNnMUwMfcguKyfues4AFD+tHy5IGs4BDqYb2s6BRh/D0tj4eQOtY80LvG1b86ym7CZ8Rv9F0/oyDD9nzZ1goEjIMoIVYGnRXZ/mlXi/QD/6TM/lokxlKE8XgbkPx5Oyio3EKa0oBcXEA/S9juTvcBk6A9wWUwYkd3JcLcW3yoq9sOgOWShefpkD/Ucc6wYYllS77d1+Re4UMHVN923XP7Er5S+a4HWPc8czoFKu1+JL2MMiMkJS/5G9XfVJinztgFCcAPOV1cCiibzs2NdUqzsch9pwC7I/iXYcxoKEnmRsNxgkgnFsiaHBdfPds8JGSGrSooSOUpVkcDvDdX7SGwpjvH7IcQyHRbSo0gov7HyprYl/nXS6rB40jXhXcMxlJrViqPP5F2b1prVwdmBBYP+Qklff7mir6ucyg4hRXgKm3YPlMH/v2KhTIwDGRdUS2tnfscIIPfW4jvBQF8eojrc+2QkGxRS+7A3HGDmhJctZ+g3H3Eo2XUXAbrRuJK9710UXztULjAwOKecWofbHKIvjDFFiIL4nO4mkKiu/Qa/fC/WrAjPc7tB76PL0HWtZ6aOEraj0wHyifWIvrYEYBlxEy/LuslUnoYVio84Vij2QNG+CdjL/xnOKbt2vm19JgQ3sVOX+r22IpjMUDS94xcrswG31/z70EdlKcjXKTOJjJu4gupIt1wWAJw2Ip8FJRrPLhCilvDkgGTIrD7hdbe8/rPw8mN+1XRrlVWUzJg2bsO7vITWxiQZncCWbGaSoJIysJDHlp/Y0dkAMVePVWKPSvXqz8KLXoUTdcNKGr5pKkboAK+THx7csk4B00W5MBeXQJti7QfHZ7pUMLSVc0qY1Dpm02MqNwCWCvEawaytsZkJDteeTx0a5Da3/KzuVTHknKP460GpC1NoMOc4d6KT48mG3ZvPfVW2PoGLdeGQSo9V5oXCfa23ceez10AXRaFFslssyOX4KXSK4Www1hmw225tKhiQBxT+S0jUxAUuzs37AKkBzJqSTTGt+mqzfK+d4PF+INEncb5+YqVON2+pKhTn+rpzxVj3XhEFoI1Oy/JH2foHVYV/uGAq+8nOtsqW0PmOzlLdlNJMxkOJeDbyt+XfoxsTLa6Bxu5eIc9SANMIOlRWGL9X/wv6APvgZYf8VEQwdtngaW1xgbodHQeZmG+rYk3fOKdIu8dC2DstSVGFRviTKv5N2hazSZusF1RbgT9dlazHD7A7iIJGVPcqksphWdblV0ZAAKTDGpwJyg0eOGmA2IP9879UfXh7FHCN4R4uegbhk8vJDEZd5/hTvDOzaOl7CQCmvGSlKiv7MWWAEdk6rZyd5iIXC4K71+pm982PuYNLmAOW1zrYRGHj9rf8YZSTcKYLH/8SCajsdXmaAk9fP/kwbcH7Jf4Ku+truzHuleFKwmXLIqM6TL7PBP4OYjibIW3c/G0mNKlXgG+ltYJkQV4T4dq1aVmHRkpxna+1MYojhbatcZ8rRlk8TCARC0O3BQWPdN1pBo1iTYYnMOplDsC1qJg5gsvWR2VRt5PyD9pcOdP0O9r6udeh19aZdmILvp7CPkrifyJS8X8EOTYQ/1Y7zQ1lM4sFREF0RI4tApvjrwpeTETxEJhKNxgsm+KzimARyOVN2p8fjMqjAYts+v4yz78RnxyKeGT3VtoAHywZddnGmWpnBMVemY6KQQS+/pS9iqt+SVF3AzR/B6Iu8NcJy3JQXNjnj142EaPo5rfdcvvYLvrmLh1b6lnT+AVy3fPCkEm8FlLxyKqz/k4Gw27f3dMj0he7MvmDyw/YUNg+SW+mSuJRue79jC3KysaQOyqkbLCjm1drx5d8PTgahPl4bfyn+5j50leMkZEKXFLm8+EpQW9rdol20HHdxdf4l65SR1GUx2T/G5cgpJzJ1m9nyqRCO+e3QB0Cn9D6hsxgEG92qYXp59bRjeSMdf5+qcvy3PmVkbVE08pr3hXAz2Dt6soFqJbOLXG0O2ODmQrJrlj5+0KwYDuH0HCeKToFHKNYJC/HSvzrYIv/3eNx5fdZvN/wQT/5Z/H6tT0gECGWoyr/TOtqRnfWnM9Ljw4zOvfnsUneWO0aSDStIqe2pydh8kq66zTXetxktcjHRlVS9sk29FtW62ShnY1Hs4Gi54kXdYgKlKLqg4TsSJXpnLT+HTjVZfrjntE4lMJaehjE2/QRdWfO1b3n+tkmZVtm7zdcQiX0Zt5lkk9uspkQUjfyEuzurSnPlGs7iiR9iXPg1+YfOVe4KFYGeiq6Tup7GyV/S271Kg9ekY7kj/aMEcskwixHkFiooiMg3UnXK6llko03sTzjI8ctMpD4CL4OnT/xs68bFQZDhq6hqTZhy9jpM114dZHN2VxcRSLqAsN6c3dkMOoUTd48bOgH+DB+A7ArtSD9J7AOxXCabz++w1wIE6xIi4yUWK2udG9u4XbwtgKlMOr0t/UZzcmmnEANnld5l3uXWutp7Vo/18ShRjBxmtH5zRtX4ux/ONgFeJFx51fSBS3xhw3hpu+YtSHY17mKPQBxBvz7D17YexJNp2mQhyOKiBBSBHZQnc/+fK0TTiOoSH9IA5+KTY+9IUvr4DBFe9Uwotiji77LT9MbsCOn1JtKKN8EGJX0wX/3oDmvAB6cc+2+tPUTL5CzFlXaDuZ570R1a8mZZzavZKAMIqq0pYlDATuR3jNr2CRPZ7PObwGTmES9e+CXeCaJvoseKqRy9SRqAgXuIUz2TldTVdx5tqCkBVYud06SK7iUNsY2rwngZFPH129g/md5rRtzR2czW8pHFDqNzAdMapunYDUEvDHvjPdOEPCME756uDZ7WzZ9WjZ1O3UCMxws8eDF9ebZkYjBLZ/z6NJSnJHRr1DeaDGEYUQ8hOK90x77Jw/k0MQsh/jorbU3q1O76KH7x9LHZGdXTBmg+RG8ERnIedi0ktMwHRDxeAarGuJShqSQsHgWOaoI6xi6EaIu9osUIHSnfmEepXt1lHNX9BYmDik+yxQQO5VhQFq2gfTKVybSI0HCh1ZYt2GZ1LlvR44SJhTtf8IjVMQXxj3JL+DnoZGmeFvVbbcOWLTowBcOvK1x0dLQ6qVIyARp1K9pFbNqrIWUf36e0EkjhLg91BkpyST1ylf/G3EWBseyOBhu0YK+StlWwjZDGb8OtijAgoVTTIB440/9QjIiMzLVnce9f8l23rszvo0fLUTckYZPprhUetoH7kFo3gySplwgd98JnUOO4CFjlxUYRgtvCdqyj42JUpvetTPZ5/D+hDYsIMSuH+SLEH13C8lr/RNYG0lDMtzg9recWlRjDjGmVLtTrCi7uyaru+HKsxkLi+qndTWFam5OoQgRauMlgOyloGj4iTR8DSQcFcH+keTpf4iaK0KSJEofPvQ4RS0KF2VksiYyTPsI4dqlroCUuuOL0P5Uo4In4nJLW/umnP1qpnABnZyhmCv8zv+4HWm6fsrztbrhF9eVNx3vLtvakW/Foe+uLr2eiUlx2KA/kEI2bhp9LpLRKhE9NJ2MDdMZ8YQQNHXcLnNyMkZ692//YcPPEHITYga4JgTDMrEY6ngu7YGlU68wji+/Qgj8hvvuULAXMyc6eqz22eMwH+7a6hnHplHf/7bdmB74nmes3nGcJRZHrlnmlUm98QuOBDTdK0VIGEHsTY/QnvlGEu2Y84HOqauUOrIg2RDIDotJI2fj5IS+Lff1+B4K4Q1fLefDmCBZXWft7BFmxGU7wjbCiw+Z0CK6JIhy6z1/yTk2Jam9UVz7eT13t4eNGOHiQaHf9KaMpDIosQCD4+9UMD+tqB7Bc+/7TD25bi8vkun6wf/jTVb8muh3orGEBpjg9mEtYziieZeozyJTsppcKLbuarOzrLcRue9HJm7az6eBnnx1aiFhyAsYj/lPpOkWOnJUDx4uel1qH991/aQc5LoxviNRqdkS8H4+ZfHSMWs+1lCO4q2tDC8pIMgnjseiulzV4eUjI/mETMVychCwcNmekp3TmXpwGcwDk6dQScfIufBt7ePyD+/dZ0D3xxuwaNqoxUTICtBG5DerFtHvEnAUQIYqaoZnRvcv2ZSN5kXacXvdN+vEfp9afyrxjQOxynpLyj8fVsY9cMIhgwgGiZhEsqdc2Pn7GagbAOXdvDZXlG/tjQJ4zvMgIrclE7voDRt3fgtIbcj5FPtw8H5pJGtkgmOy3ie0zYsAP5YKQseMJ+c9B2bF6uXcrqwesUnHBwPDci7VVmMElav9hjkP+pvAwjR9TPk/5TNPnC0hppRe8pDK5IyW89WSO3/eq8cEcWut5g8ujHiR4/EPihgzPSosn8/29EiBZgDMtSpeYZ0RxD1mPA8FhrI+yMJJeIL8S86tYtV3wJBOUjwvr4qOG3wDjb5LqUArS9KpkoNab9xtX9iz/ugJYPIYPt7iPS7Xx+rtIiKLNQU2077QZSzbXGRv5DBeIL+3zqnH/xF5SJsbyH9T25WL7jSPiqAOc/UrOXe/mi3JZ3QEokrkinZNWV9ukScAa8LXmg/owoiH7cNwrSfGVzj4PdqzHYythowA8FOXuEIY4hpPPU4+liIPL/etx8ZVPtIqTrrMVBnBt+aOOQybUd2BvpmF7pNdrdhssSHp8HbDgiDyyejizhM246eCN44x+6/KVG50NsVKia65jZCGO3S3vLEf7DEP2DXMivUKabTYDLf0ylIKB4NvCIOrJ3krVruQdUUuTaujcQTwa4CBhVxlc7U4Aop8GbMMqSFAr5Zx9EQme2CuQb5I3rNMttpbZUvT8tn08ItATyldmDZUI7FylzuryUsSUkD6t0d77yWY9V7KTlxlByTCq3iqJBzLOTztIsCTT50pSJC2AgHVJCbghHwFBrl66QAB6/2J30l4OvahVJo3uwEfyhtDSWsxiFuTpSpo+x4K8/cQkICdEfltIAOfKggI/9pC/5R0+XKdCpNnkfVZcaJ/cZ2EmnL4Rre+uFYmaTTuGON+kCFbWPHL8hP4/BodHVVuhvIZ5kPPWaXkRyMmoxDw1GqDX/rB63uKxC5sHCtoe8jkaCFHB6mAQSIJr7ZC6sEkjFcNIZBO7flJtgaoZMsAase1/C1ZUOLCBq9VHi76o2Sx1oXZ2CxxUBV0rDkdvpyaJ3B0lVFfJFhKULrPmHdu0zdTRjuFnAQgAD/2gSVatdV+DBuMu11Bob5tOMLeO02Lf11XoWnMI47QACW1V9oKQbRTUYvqKIpIO0TWlYq3ZIksX+DPz3Rc2Vjv7oFXwUP8wpBFNEVptMHGc96qcVuNOj/YalTkBqfHgEOMmcMJeJHhR28zzGx57SgLb0TSuN73IaZGD4DRgQjl+cnyVLUNSiVsQ+whJPa2zFFh/fmOHD2f0Q0IEjCNiv9wwb6NaT3ZZeyq0mfkci8vaoid7pVUsSDGhTQWg6lbsRq+CMD+M3WU09iQxmS5dLyHtoWSqqBSQyYVUHAf+tNn1GS3Y9uEX9G2HL7on/kmUlTNOnPvIcJpiJPm961+h7p6sGcQtJcYTjBlTC4fZ2EckvV/GAkdi3DYEih75M3f3QWD2NcaYM7diFFsSWFW2C68nT09O4MOf5Ev2RpIi8DptUD7raFh7FuGdugfiaHG70Y+PZkTdQDLzAn0jDo5xf0GERrnUIaRyHv4swk2wbXrrwxMC8MTJCWuLVmQZ99RrGlrO00k7FhrnTBoI4j0DFBaeEKo49iLHSYiw27P3nhqrGV2+CyuSOvsacZYb5LLlhaUWGthFJmsH5JFw85iquc2c3ULXHJ0sb5ZINLU3bOiVo1ReSxfPcp/MWCeIlXmtDb0Plsa+0KcaCk2eskBJGPLJbeCPbq20Io42JPYqLvykfhiuitXoK2WFRyRHtvBe0JJfvY0ql3PgiIXm5Zj3fW51imqtRsrTRe2Fg+mdLepwNm4/Uqb865SVH/ErA0CF7gV9qPPRZKahM7vJpBlOEdPZlFM1IiIWfMHJKr4Iynw9m74w3MykuhPPCuDoASK9tf2H2rmGBQH0ugsJpcQcE1rm4Bf1APZxMdqykKPvK/MkawUjgqgyV2nvBiRUtzd4HU1EGosDN1HjytLyTm6k4gcVVFpMsX4bwzz6DlH3hi1h3KLULTcvsmCI3at10FMRaL6g9PMrqvSuQo7giZzPH9r0qNXU/Jjlij1kd3/ttEBkcrpRTwGsle2uEqie+E1E8JmffhANSQFvW875zumSxBcgXhN1bqOyrwpPT0C3enABzqjPCB7QwcRUFjg6jK6QelTtVZuIrtJcu/QJNYANbMfP5u1GsQFs/TlcGxckt5G5pSUuoA1uZYACTwURCaGQo8JH/6r5l4zMYu00uhvuHK4Zt20bB4MO/QVwrwq36Kad9aDhEZHHPQVwgKf5HCkfKrLev6Gx34q58J54H/dbfU4odcrbNYRWvg5BhObvk4n/9amCrc8BWL9yGGw8rSI8QYWFgV+n6uAL4wp1E9EK8fxMQ4miHsZkAvZS1ipvMThBr+nm4HXanN3iNdkQ2c3zEmcpDbRpAV0JK3G0L5rng3RNaZ7xmogZh74T3Bu6aEYVk97z6uGCD71DLyF9PkchD6f9sajSvWnuTOmIjL46/9iRMsutZcpU/6K2L0mzYv4Jbkgg5o+mZp8sTQNNQ7+seklGCoXgvrzCxFPI7aUrmoJf4GbHIIP0DSJzF7AIiK/Z9M96coiwilc5KTwmoi1JaDusLeFT9svj/2cbYV6JiPjtVrHPaW6ZgJSdJDqEvwAb7N/qQBrLG9mOnCwKuvf6o3QlRLCtuBK+G/OcaPw9CgXzIw/Vmi9qEPf7Ot8Im4G+HI/YXc1Q8T5h7vZpoCeKYEZVmpyqBVwCaPetlWqTQvXLWztjN6+ODYRu/n9kxNyFJthNZgpWnd939wBcHXX4g9XWfB29+H7Jrft0guJawtl5YN5aU6Ux8qjGXUFNH9HlCfDgBrbKyWGK/ws18taRpEQYQ6QG5trVTxAtT9F7khTDSbKEDlMZLsh9Mv3l+aK9Doo9aU/Tt47F0xp0KFAVnj1UnyUmrbLuNLIoV4oO5/RIU8KUz+PE7LU0FQn02VWYCWjhjxcvrELdfwi9Gf+c64RR8cFtpI4nscoQ1yyCYDpOWCBKRZkiC/tafCB6bARhcGEwU8kIhTZi+0wCH1ybcanReFicRijHU8cRxknGi1YwZ6/BBx+1K8XcHHcbVLxweMb6He7DKyoeycP/yZe4vBPNqrSwVSNUCzHVd2AMv4Z//7zaV8pQmlGTLU+4QmN96Gb8OU8xCQoCr1C0efeI2/srQa5VO+uatKrRPqVpBM+0sPmHguV7fIXpkW1s/s+ofwm+Fv+88GBpzHCzsAyNes3JJ34EnZlo9lFdS5phtOiOEst1twur/evvJZLSsmVgYJaARmotFHfvjd3SBwzxnyKeLsulvgGds6bQ0VphYvy9s1LuDIcv6h9poVDeE30l3QUR+IEBN81zrxSLq8aX1tmMSUGnu4FljjtMgOKAKQlp/OZDDvtb9288gtQug12Eef5NYXBZ02fXXKks7rCCWPXR5nfIT64XpsB6wzN29Q8GyFlQEEl4EEgXIzjUO7Xay/9cp2qjZ17kOxi/V4APyJCQka3I8Cz/PJpLGEmc9OvasAGlOpD55k88QO953TZgiWSQhdwQQUX+JlMJCEYoVNYwbuiw69QhsAfmiakdlyUJ11rXD/VWQeySY8Z9zciRrg72y6cOn1Ztc0jVzP69NkVZM8BTavQh5lb6rnYiOeBQos2O71yvY7UbrJaWxKNkYKPwkMZQIGKIUKzqbdBxvS6ngnoUnEcHpws9PAyF4jw0HFEuTmlGVADXe0eiZ6+m/UJumlcFIaUSewaoKNzzIBN4sOdW7o7ttTRBuuXg1qR68ibgFbm5WivQ3ZxNuVuWaNF6z+GkYZvRzudJYmBS96XQiDmHfc9ofXJPIJg3dDPzbaWSqUewf0A0dgrTINNNHplcGdNbQ9Hri0sMgVlF+mcrugQNkrV/UDqXS3HkZ7lcD8LVcVxz8kGRiNYWrgjzPV6yh663OTu9eGDbxBSjWNW/HrWkPc+/ox+/i6v2Ps7iOrKTPH7p0Es71EI2h50+p0uHkmwS0kRiNs4wgRroRf/G3cw5GDV9qTeVLwrtk43q0LuSdauPa2Yzsh/T68O/oI3+mal17J6iyEHKMkChICWyuSS3340phj/8GFIY4KMfV8trc/Rht29wj7fB36tnPncprFAJZn6OrwZeXu5/v9Q2un5rn2n2mBv+JeE1yNaYpbCM0b0EctWIrKufmU+oLoMjofxyKxlmqqjkkAF5gYSvtTNBsY1VWw+Qw2UeO5wNNWSWCz6uRX8prvAEtCQ8SYX4ImxBZTzgqKr5ri7qb1ldhD1J8BP03get9F2zX1O+ZZhoDYKLN298uK79OyuhPLLqd1g2ajSi3x+dx2wQHMyC8bRioElfjl/T5q7lXKhGD/RKax/eoTpr4J+vSmuFDZXEKL6qyFpAd1mcP2elXiQ4GUf73bB+feSfv8+Je3Y8ael99VYFtv8CUqPIL2+9m00yQC0t6+HUM59AnYfxxTiqxJefJfAbwfhBe3770/1A6Vy3aJs5QUT/+B1M0TB7R5ExZUFhsU5k3ngrO5aKH61ck5V0slXJzwdBBCIeEOUo5kkQtxUtHy4Y04o024zDw8iiUSskrZcVxJyC79cKLAeGxLXzGDp3fd3wvZQ6rMI5DsXriP3L88xnxSnGMoZ7QHWlh/qfWoXJ+49MBiDz2TotBNW6KeCGxC5KNUT04WJOvIY3CYyswXZgkVRH0rAYOHO58ZuejVE9RJgDeJON3bRxpWbgjEXJJBHwEQxLzFyw4vowkgGzjdXWblx+L7pBSJR/pG6QrYNqup+VMIhMRBJfh1mwloVJ8octgS0LDjg2yU9N3jKcrSabYXEgpm5r4jFe5QZpx4fi8xiR3uXPg2YzUtGBKQLcCJVCZpY4V5q5S7UqB1ZeHmhPMBAN+3a7dguHHORGeZbHcTRqtV+mEPu2n/NzSZFBmz045+CVbSuQ7a9dSoPtuC+fbQXs395oiRrR0LveI2Qr15EneS+5e6RF39wxBRw55z2rn7Ltj16U9bpL8KfaMyGV3sE9DDkO1OjqnRxeoGR7ArhRnbP8rYaLhTR4yXqvlt7Ev6KhEY1ArhAbRhqtC/HEymeKCmsUyEFQF/LafPrgc6Tpmm8PMjdhV+6xfsXilF6X7B512S6AvrYFtLHtknXyLYj4/qGWy3JCM9RotLY9MXAqkkZZ5ID2juhEsOUcjBRryE7f4l9JIkMhC0W1v+fR/P3nM+BchfR9plVEBxHj1ZmVz71bSLsfY99qc1qhDdDp2X7bPSfUFhb0ihndOGVVhxJC7GOCX+e5s6mc1mQhvP8fSGtonY1oY7iSqYSH062YSK7LizaYodZXLu/srB6UlZWGwp1LeY369o5cJrBCMcoBECXbbXanfZZW+fSoMJG08hebvAwQBp/tBV6EvqjVCnIksMpj+K35hf13Kq+A1ZTwid0NDDjgAgRE/PUcgmoo984ClmGQ87dedQO08pdGfC7goksJLfWo/Pk/C5/Bg7ve5j1ZSBNiYj0N2GW7dgmASFjkbfTXR3z2igi8rGP5W14m4Jx3lxbel2FeORThZ1BBXQlRc4OLk6Jm7+476AfdRbXycDOoTo3WHeviiILNT4GvecLfOtCEZtcqY6yX9z/CCnqPBIJZ4VX/E633eNomDFaFYQDYEjtk0LNL3hy2PL5O5rpUH5JkK7fMEi7avsV5O9aGZmdV/oP+Rm7UcarZtm+/eOm6vxtS3yl2a+th7hCUoJKWnzglhG5H5FsDAEf+zu3k1g6qp8RpqYwyKN4b9JJiuGMfS6nGGeXRQ/JswEupnF5v8YUooIm2x+1prP8FnJzkF2SgInOsmoA9FgrleorDGqfw8HQYntBdfxiY0jqUTSm6BfuQIWZqP4QyrA6OFRfS67DncqmE4mrRsNqp+zrbNnXysIzN0im6kziFUAAhj8KB/Z4F3xQh3kSkf5/uA0anLliKkB0J8qCEgdCz1DNohvlrKJEz7h7ngisJIDQYQ0+9fvpqBhFAPyI85k+L5i+hfBjVbyAo4yGINnQMOW65oZVCPmaIJtazhtN2RACvWov3Z4KDORFSkj9kWNvB3c3ZbFJli5Xx3Oghe8IBTvlhbg2jAkc2OLleVRAl3m+V7xAOzr2iGvhUAQH0rpVBfG4nW1eD5jZ8ufC/vDGPSfCo0tvXFlKUVrswC60yNxtQ5GEyQCDI5BALxcUQMZOPSllbk6Wqp9gp5wAEgcRWM/jd9PS1Krqz+QrBz3WNFE81Ye8TdsXGaXtzU7Wlj3t0YQWnfkxTorAoo/v0Qil/qdZuBgjelXobYyNoY+Bzgtq3Xg/+lcUqSqKvGPW3Jpk69GndKuAa7TzUBVaoCvvKmw1QzfYYjOdy8iVlR3mb3TFfv8HhrHXx2PV8Qj6YfL8eFGIksZ3CkC+Psq59JMuYv1R3X24MlHE8ANl1J6J8xnAglzptSujQeiE06SAWzJx1EkVXjU4/Yz4TFBZGnQUqmpxyyBay0br/ax54TPbi4fMLcDvEBXGxkEC3MoquKysGx+mIpfL77ruriO+8M/fiLDAJbfGcZelLmttLEyaWj+zUo3uqIUhLL6qR2KYhfhwIcI5yEtUWf8GpHi8dbYzWvXdDcs8Es0jzD1LDmeeAGS0kTKizwS8IfS/uYtlzcwr6ytampWPAy/p6Jl235JhGu9bAWNpSGBjpmDTOSqVpGi7q/yZstdw61iFCHmtA3ZOdacZI6FBTZb37ogeDmkKFYZBLHD0soXjeS3AzuuX8p5GBrffcnzgG5lGIh6Qq+4+oLEuZHZ23EEpYvK1/UkF4rn622+NThxjr+DJeJRtbwkZIwc1ACDgQN1vOkH7+EsrK+/vU20U06kHBbHVtn8+4BGV3UD+ZIqjTDUi//E3Vo3gDb0fphu8UxHPDdloQRgbxnF16ilN6vSwopxkXJS1QYwGAGMyjQuxmklG5M/aFJsmlyYNawtzdyeGLEJaDmQbb5V1xPMtvoRNd9D88q5vEzocuHi4FKczPo2Q3rh40eGV27VteUKfi+hd8VUDrbHFdLw/dM8ASSqLiVWnqNbIf+0BDo8hAwlqViK7L8gV++RN3jETJNiwvrR6rkH+QsJI9xCLBVesG0N6STqHtbcxUEXcIxwr+pQU3j0BBjlJ/jdRk3BmnIBARwLCtguGEOxUINS4GQNGVTZ2m2wL0jOJa8j+sUAh857S7odcNjMycCh+NZnxuNfixxYLQP3IqAksOwcijBYeBPtAXQjS7atU1Mz6Jj12/kxuufyUgc8XX5UpYc8PE3gzBD8ak55haSoMfynPgg3rhrUorTtjnh2fgdXOoWOLlB4jEbhHVgUCHzonqaTEmqIGfu5/VKmk6LN50ZHrOUQ35q29NLbAxyzhfehnFleyHHv80Vg1QCD13UXffKaczeXJpKttDc1TjM94dr41POBxhTXpuplapqdU6HDApTsZGRE/BnGLPluj8zQuGL//Cn6dipBHXXSyadMKyfJp+6LY5s8Wv5uhirbRRrcjHbWkVevQ49y5UTHGQCxClf44IJXOGJ1nN5Wnqum26Joz2J3GP5lRKHNcBlCNURrpHqYSmOfS5la8a0jBys0iexGOFHjWD8HA1/Rmunrja5NQfOUgE7pKsa1QvLgGOSjez7BRKaMvBQW25wWx4vj3t3QCbl66T3AdP7PC751h6pwdOq2bzUx8WKERuGzzkA2Gouva5RD6rPLMrVjGi09Nt27lsh1vMzmwbTIXnhyXEObcWPmeVEu5Ue31AC0mkh6y1LFEJoL0SEiqxVge/AqRBUZONOW/aroh+43UEQ8IctEQCNqZaLP3YYtQTGNydiZY0blGv8WHYac6FqZAKg5H5pHY2j+Q3qwrSiy7oFp9IZCEZxZIZiOfF5KMpSyvYe8Fa+MDnENbj7hBSiRB4W2ELT1+5qRFuWbkjY/Z3bA/8Sn8OAr8Fkf8OpLFbnE5X+HckV/02Jk/fArWx3oMOk5jhdSAyQuXgaVIg2GAXeqF/r6hntSVlyirSdAdv/NSPcH1Q2OEiKFxi+aSZr0k1jHMoKJ2lZKU4hN2bH1OMtiySK6HiCJtkWb3gYUQE5fTPSM3eDZpsDZkc/pyZH7pUk8ZLbc8oSFqAvAGMcCe/sLMBXAL6FM2tRPZw1PRjsxsSr1NDkeUkihypNa7SMesvUnpu6/D6LCu3cqchRxxfZnXI6HpHwOY6TXSbwaxaWHx3WHDUtcSc/3D5rydI4EwXTLjwOXWR66vsii7w4jbkrjhKj/+GWaTP6PLpONRBM+d/Es/rC8vhdbR/Cr6zVvJQfhA9VQQLxuD94RZgqEQ/AXki8QDSAc7/uRfGuLtgh4YC0oSUYi0LF6Minj3T8SBHYoWSp3Y8oT13zzVKudpvoDHhwVg+Wi17iUXwMC6yk3BpUom1rXk5Gkb1kyD5TRo9l3SB1cyYa5qKeH+dv6r/hmkMrJDEWC283r7mKsa82wgaHCDI4wqVpivgVAwMOHg64bCRYQu1YBgaaq686pYuVbDMIdU7d6eGz1d5/TvSNfwh2MyWvO7m4bg5SFiaf/ljXrV6Ox9pHrFjvmsS1ktWKU0DB2cFtXZ2ysBWX6v+G33rDr6IUxxyMax/GIOdBlze1fhxYoVekazgsbNyJYIdL86yzG/3THf9GuZE9hXFk+i8xxEni85IVbTR5iP8GNyoEttnpGquv8TGQf6a6aLVxSqAuEJNmlYUw1dfFFs1XEA+pU/kqe0tgYh7tfTFBtOg7NoDCj67D+mJzv24vCHCYDzNCwwHQ36LdsNrno+I44XHkK0Q0h4ZtT6XmnDGYrgJUpMIF/+liXxgbNXE90MVqXiUeq+FVaVVlLz4XydjGZBtKquhrSxTexackSS7kb7GpbR+CkcNAOT91ycgaFqlE2icvHREhE1/jW/eCpGXpGbuSaaW8+7clhOQcI1h/XB833It1+7X4yE65WcDJs7aKPJS6d0zM8yjdwbAayJGkk4YXp2/y2w3wschiI5qMwf5Oi2slifn21Z8iq9Vb+k0dHtv41fJkWO6SuW2I2U/NQqwDWkbHNRnLArCtJqlkrt40w78jjWEq1+ewa0EQr9aRWMH4NbB3wK8+5251HMJUNQ8nX7kcSNx73p39+tlj/PqEeItf7E/9VNd0kcX7or2otXl0DDourLOn+NYQOPz2IRObd14OQBGBdoWoFrqfOkfW3QRs8ujLvVXggwWdd+q+nPynPmcVh+kA+KsK/87uduup/qAUa4pyTRviBX6z496ZC8DW6qXNglCsiZXUZxQEXplrSP3e700IA1NtgSP4koEMoj34VdgsywBh/HBhA6JzPf1MMcW5T8HuAShb7u5m7/YOqIKsfLBL3Wd3dduJgKXvJGXH470isxjrh4sRJCrtDRE67/OQaiZdnXiouIeYod70fkAoaDjwTrhdM+xwZxJXRDiRWqv2la5yFmIclu9r9J7HlwNKQdok3swmajAndydOJjO8Fyy1jOYGMQu0wzNOtE0nG6+kp2MKfjRaB8q7Q5Q8JAEgqX+DJ8vuqYhSGiIx4cRHrUmYeuC3ZhdUcuqZPdcddTsspaTwYhBxnfeSiuKq3kEhUe9GnaOhgGjRxAVT/jvJK0vIqgsYgBTij4AiMKxfpTectjj1V+jskT5WIwdRkpbFvtOir0Uk2fnsJTQ6erA8P++KYI0hjH68ohk/vqtqc3WAYeIM1kYsA0WPsrpBYdUS61f5j7XmWn2A6AU2HVA98c0Ps0xL+pwfeo+eNQ7Q1ATek/gmfNRN7T4nsFv7pYVxTiqt9J2vzUBDHq4rBInCaYpexuMwXK52zGlg0Xo4ThH8DnQs1SejtBpZjF+XHHB2kBMvh/+rlZ5XHz9WhT4Ygb65V8d5NgISSFjDDf8OT4hIhozQLIjDuoguGV5KTymUUd8whHmvvuaE4o3/YnBP1ffWergfPhZeSngVPDABBUiethdH5DiT6W4CGSkc4x4Sl8lx9yiXvlLAy3g4IuUlxiKS9vjCcFrjoEoP3VZctPqH7DsM08+CBDMbSyxRgjnI+QTKfOg8izAXRtEOg4sxvSqu/kq+Z5smpUeqqCWu+cR6WwYQ3enNIDg4muPiNO0tC+TN6WtahNvAygZKNGG6plHlU2tnAyBkfmHY0v7V+Zpe1gkH4GhXa3ftaIOH2i84hq4JCA3MokjZts/j/DnoN3zdFB1KR0Sp7Imt+TMNH0UfJ//xgRVwY46fFyoNEIBUEdU+lasciUidBdkz/Isi2cJhddr/yW2OnKe/SyQTyxnRKPZZNsZ7ImCPowDwB1sUG/vx9YM+NzSI12XIZvU+OBHn9Rqi6oo/nI704ORGm4VVoslgPSp/ohAcVitLR9t8T7MNu+w+//ICe5N2Q2rLX7HWkmafj7FnJxalc+cSSyB0v0HqegIvCN7ZnixttEJ0SOkDIuJ42uaOfza+/BAB3ch48p7rATy5GBcfMom+0PJyAEWTRbN8I8e3e2AJHJ6AZ0nWWLO20wkz49hZBrW1Q9XeliE0492e6VLKaVteez4qS9vLR4I+BvAPqXICngjd2BHFIT/uezDM+8h2IEMrCQZpkg3qp6oedJKDsHf2qKLKh0TmOND2iMOvHfoFOLas9Eye3TrvT9Oos/Osx5Wi/UdZ2tFdVqdVbaPKXAzZi6Amc3Mj1i/k+UOwfOqfCWah74dXVqOmJjBUXR0cmwNzVCLa5y0XDyO/lr9XD4tZz7auXbQZr/007jH1FHa6AA4ud7vLmvANxw8oTHnJxIPVlDsQeQWgTj0b+ZNEJG2ZAZLKVPCgKwrJj+FgJJSTAqQYIs8iGs6HYeLsTDdCbOwA+4cZdTidUeAgJcqMnk4QHtr7tpPqHnfxBnGKtYwKZxCH7qAZdnX1VsDlIk/EbIUvBl1/W0KxNN+ZE4yN/iiejHJrWPYfiGVyFDG6H1+nic4mUVaHbq08H/W3obcH06+cnwST+KDELHlN6Mw+L4RjJHsHJ87DQdHlVw7v+S747JTvxdOE3fVDw+V+uomdiffVr/v4fs90mFwohorZz0jFnMfmiUF2tGfb4DXgE405xaXOZsxDbrkZP1vCmDQQArPbG/qoTouuQHnNXdZZl3TVhjJuF+C2ciqWCxoHUZJYYAPgM6QS5QNtEzD+hKAod1/8Umj4faWUaxSeM5pFKxVHiL1uT3mVcZh6kWsXSGLwR0AFCQsc+d3FvUyO9xfgrTGQKh4sl0Fek1/TY15oHHNcHUCssHD2IYhqfZO5nz09+mKL3CmNNKfyKBXv+onVnPHXbWBEC5Hldcm0rgiqA3XbE0wNVdJY+/RzVGfOlKIWcuwNCtO6KBqfhX4DWbA4WWuPCRK27cNkR4J806y2wS23kn4IzNALvKTOuaGG3z72NTGJkHaPQXMLygFYPB/Z0Fztq/eTgNUdA1Mkb4SVzl+6BhlrGnRgT48LOhy08Oo1FLMbIGtgw7ZPLJoNuDHzJXxjqtegFDryS4pmWNuyKeF7N7GchBptjJcycg387v9hnBvErjc/GdQQM0HEWJXqG0NVmazxDaDwddWzp/c/WXOE69+DhjTZwB9MpD2LInKDW2Vt0cBNklZ5e9sgFDX4AAG8h0ToNVuWlTy9UZvEgGM1Juv5hlG/RcMmbJFUuJB2S7IC9Yf1Xo++WCKP2mBBPZUMdzbJ8tiJQgPzuUS3z+p8JCxwDgPTSaioNsH7L0U06RMaJAWsy9aUnl8UYO4me6Wmf03VOKGt3X3cZPs/pltVespsjhZEGwpJhDHYYa2IJvGelkKzv620lLavQlgGAWtpzijRWA6wb6Lphi+DEm6ZPBenaGMMP/eBY9gHowiAyvyl8rne8JQjjespZ9vZZAqF+VKPkgO5HrBE+Gqi5sdQCrYNqSTo6TDN62B7CNoL8hquRjIbndZrdgC1HB+TdObQhgQ3JpFaWqibfYwf1Yfp193P7JnkD4O/L995oMtZIrXVeREkp6Ffg5nFa2l2p+/njT04jdFK3mj4az/uvzm9nJD+17uy396hgj0hzTWzvEwv0Yr+p6fuVj5WpyVXmAHTAFT5YGIFh7xkHzDo4OR7ScnN0tgjl3g8BI0vrI5WpgqOWbO+abKotWWF3jJzpL3Q0XFWi5fMc9r7pD0m//NbyRHcUi1AsJx9/DXjrAzCI/vZK8oJw/LwxIHwKzayS2G4FmP3Jgm+EhDFuK2sHUH2bl3GB3ai+Z4H70T2G+xVeFsBW8DpXHUzsssXSbK1R5R1ffPTr65HPWxmxACoFZkkCl2jk33bqj6hXT3pQDW3abBJ6RUywBpoOl6MRTI0Y+44rJwlCHMDLnzRW6U1ccVKUVKthDWG1X4ETGiI7+bilEw5nptm2PJatVrM0bYrGdSDmqXScfqD/p6XpSlqCiHyLb4ufLi9PejTH+QoNM+8AXEl4vrGEvf8SjaXsRhH3VGHYqaQ3NpRCdeRqm0yRX0a3iFzgcsjvq2K5p9LaQUQiZ+mlnZ780LdoedvLa1xreP6JRyPZbDfdpRWLfU8FP8wY9+oke9xAnLqW26CNf9DEXvPkG84EUzku8YakcmAVt9koDcLHTwsKYT1CIyBkCTtg+cNbpcd6wFPdt1rUNmmeM30RbgTt/q4GgviNdzNBgWQlUaV3nUBz+eN+ntsc1dyZsbHoxoFjD68lDDkusakf6YjF8xltnQIALZHDOQEFPGAGo1q67FYlrrgYOv98r6NIBPwatGOu9pvXiYa9DtK13VmUYMHe6Rq4mmEFwG0KvcusGQJk63lIKz51Aahv+RdUKKqv1PyVwBKZpLQ1zUPI1eB/IKgjWI2N2D6/Eq2lq4MV9oEapO5pkIRQ9Vkv7ceVThtHlHQHuTBDMJdx3wdB7vO9sBPGQIs47TlWRlN8G9WREHcMoCy6erfO1fdLv1OrxXplEjFfR4XNraNFVOwM8PIsht0yLgaUpnW2DOsPeArHE19TFOj4TMFDkoX1cTFsBZT+SPAH0zBp48rDRfNb/WEs/2JxeB5LrOXgu3D5CnAJSae67tJ4+uH1CXnDAe4ZoxavXlu/L+6yA1w5TUu/iBZDqMngwpTMqDkMtEvz+K5MNqsT1qrxjXAfXUvrRjq8iJCmFJom0pUcFHGFgKb84jWPvH3wrwzGWmA/RT1X1Egdlk67Lo0ABNejcg5pqtGSLaBnzQ2/ZEzudb0l6CA4bzNUXVfDcnshjWAuq/Q03bSD0eVGZmQ4V09ZAWcOTTtU3eVmAefOwsLL4BewM3EsNr+ODbFwXWDfsLicGnxqw9OTOpRySeO990W5fBj80LX6RFzjyLFekcLXPsd7yeru5n5fOt96CAmsqu8hPf5vhCAIVj1vep1MSuu6qvpRnqqeip6LhHJjlkUYlWU8UDLeL4w54x9wOSK4d7xXzYpUlmHCcIic8HGYF1t1NhQJDVFIFSvj/eMBpIJDe38G8EhDVxHoS9U2ED2Vmw9Q5tSjcw/3w1DIpTB+a0/y2s4V76teBYZTdhdKZV6jlJ3E3qypyH/UmU5jzLe7LM1uRvo7dIAgOcHzaGakYP2CXhtdmPTKa2XRdNixjfLZ1hVllmthPkduzSRBKRVi8achpwybsh2LVM1RdCP8ZeUOjyCJEAnBLGpoieSkTLa8LJNrWlz4qtU4pkf8krUIwBVT3x36673LhKm+sAV92rPswZji7sZB5bzATkzUPQdZMUfd5ts18xeCh9zVs0i47CI3n6bKTlQgr3Nahw/SQ/tDCgY0b5BmoCNF5HYyxA3i7aHhNwXOVs90gKCjSud2Ld+yq7/zCphO26LwH/4CAyT2aTiOg9f8M8DJVBjYObSaKs5tirsV9jbvx1Zwuw04MT+IrWt/eTC0r/xr1n6LLDhBKgaZvftYM5qyoVFU2nqJGUTeG0v0jVJXQ9eriptdwqupRNGCXSvX6sIWAZ2wm3k5VBEKsZHQDfYFQv2VWkBQTySRq7fN+NXIpm1EUfS3x99BCfjI2e2b9Z3dJkoWCyO1h31dp7HXQYbTi1vP+mb3aOpw7Ie2yx/RH77/SSIjkUI4rQ74AsNL22g+nqe931k5WmA2ziWUaQwkxBmnjR2FXKHnZoGe8sEch3hvIluMdCSNgxIJYlEFo9k3mpNxFM3xiC0t+6CqoCCIcUSoc11PhCjzrD9uw7FczhjpAD0bamY70bIIese7G/BSpVoreexDltzW8iJlRAGcZ5D1D6dCnFI42MysddM9EZA4hKc4YHZNyeZCuPHhzTz0RjwvnKMrneLVdd2/3b/ms7XhHxuFxXM1lSVPWEWlF/hE9mQWAfR5qnzI1utc85gl6k0gLOoCOOozCYqgMfAVGuGfMzrYe+n9ICZwHV56oee409GNZ5Ua72h5xpHmppHOJOuec3EbWd2JjwT3FZgxpiyEaryRnPdLEOg0y/0aUoWnE3lAiCiHeAKex1e/fBa4ALVDChdJLXoPCwcEK5fz8O8Se0ZX8LNRp4rFKou67UeSaKkf/i4LRFvXrLUB3ST6lkGWmy7cmDuDLT1v5460rSPAEIeGqH5mKk1MkHZ4HGyqDYNR/jhU65CDccPgpToyuYEfgPJsVerv8WMUqYeMt51JEfcRLNWWUCR5+Zg4BpZlbmr6mQKpQT2hvRmGm7AbBTULrxn3zp3SwkdvdPGMqKJjk4HR+tq0kFPaYvX3H2ietKqcy0CHzr1ErCnxQxgqqwu1PQ78j96fA3hsJJFNoarWp9/SIvgyV4w3LYls/semzWE/P5vvZBWVxqUMvBaB4j6oqsv9JPAXUwrYNuMYV98KCx7H7hkpmj2JFVpyLVeHx7qX+F2HBqtkNyiNdV2VuIoF1h/afTLdqCqEPFuLBm+dBJ5MXBBlgo0chsD5ZF7eWBrwx8Eq1gNWCAPzXLGX/XtM6r0C+8bQnZ0OzVKZ+pAh5qoGcVMjlhSKxqNaZ1Hpf7dOjnU0hc+Cw2chhl1HSomF7Oc2pNEiIB5BByukrX4p2YGrXw0D1DKHV3cOW7v/4IYDK4AZZfmbUDn3X7PeLm8TK9AYyAadXX707uDh4/kpimSc48aTCQ76UWcFZQ6PUHUOz2rXGf6JyWD9xKceeiTZhADrPxiBffcHVyjCcS+dcyBCCXzRB/H9Fw/CLnzTYKg6JTG1oGwJFTTaEXikKOfdUrfoU6DzbidAPNPe7JJFCjvZa/oyuJmprP/kxz6Uojxqn7YWJbCyHnXe28O6U6+/WC4TAizuiwequvF8S2tdMhJF3UcL5DwCmvLBbAiAdfeX7FtUBFTE5g7HE9ImwwuZ8pOGfbdRpEjIncdR0Z1VZbd8kL4T8gxZOANbXzrnzZu/MxCx4UGjpU5Qvrp3t0EUjIbiiuGqU79IN7w1OTHa54ijezwsxabijXhRyg4SPcHXM5PxNg6d3VPAG9+tTSVaXIW+10hCFVuZ/S4ox7qiGoUqEflmxrAAf5e5V06/tc3e7SSVCkODU9qxZHcCu5PAtqSkBseOXGp+uddAIKi/mxcnEqwzaR9ZibYdaJMmK0+N9GkSDyKiRYAVVyW/A47H86orkgkUWAJsgX1ibAfO2VRmkywvwm5KO/+LmBaHmVVDg5ao3xr+FJi/WFIySvvkdOuQOYe8BhCJZjb+zuIF96tUp+1JNEOJRvEvl/NyoW82ZL/ZATk07NnZUtmhxBauKqUFozTISIfgBnF5GyEXAotuFCynPVqdzjk/RmrxkxSecuplpyHNec/0g/bq7jg/hQdvtgpg2JcZp0If+LIfyE/mn7ux4JxJIL+D9x+k7908Z7XZWgIbZbkmcUlI9k+mO0fJTeHV5bdbRiRBAYisvbdSFGt+wquDHWHdcdooW+VqLtrwuSVBuvBUqX1+d8k+685ZjGcYMcI+Zb89zYSXHPNngjN+bd3Cx8PIq0JslvymAtBiI3PpI6S5B2E+6XAsqguM88rcSKrnnOnGh1XW2JYzto5tFMyfmD5MPFh4TEuBcYeDgtTYbusP0c6aGRGZDCICE6pTJ1AsHYmVON8NglU5TE4lr93zkkLc+B6RAWlSplYGwuRVMG6jmKsIK/Eh0mewsR1zkQ1wSO6UKbsgvEfJW0OOZblLpj0ae2kSEx4kkMDMvAriLmfie/yeUuZfSepq6UovmPxMJybRf8wySFqlk7iVNvHO2iJkkZFe32ezsE/HBJLnIj1X18GOyNVsj6f8r9adIXWOSjHuV+A+Te/o+LpxLrbH1BTm/80nvDxfOIhR7ZukOnYgrMRwZA4c+bXPqkniMyCE6641cGB8K6M+obanQBaBSx7m6EM6mTSkKcigRd0FUCckPiSV7eO4fGrZgcfMBsNFdAvdtmC/EbBe8hwANIlrioLZecWpll3vP/507fp71GIbnau+RVUf1YjqkOkNJxpM5ZWsKgHoIKO0/GjECOq5ge5r0ymSgrjB2afR9Y79ll3r2rAMOj+xmjArVhdiwyme6U3Ek5SU0HnBizFDr/OBbGNODsQQ1u9bzRTnzQW7b9FXLy+rCS+qwtsfOomI15yY/9OkWhCaW8sD84/YHLa5vJJkiMqSXkXTxHslkHe7oVtMho7An66GFG5kp8hWYrY8cnuTVQcrVASkSNeTHogB3oxbWYzvJ2GrdkoSS84/XGZ0TIPi0o+IdIRpzcYdi+wXdZUFmS3/QU7IlQLCd+VFc9YvAak2Xzed92iOwx/Dez+CTJCGupOTPt8lJgPs7qp1hQWFQHdMhSpZSjf9RKZ2o/MO+cqQIabMaTcD/nNWOgw8ZwMf1cPgwkxfxDUM2Z6uL9HwvVAws6U8J8T2L8+hX1n01Xwir/EOKyCva5YR5vrFUDrYVcIK8u+/0y2eV7gUy2nRv+CJRUgD0FhRM6cbuH8LRe9a8hyMc11AcYVSrHtWHkR1hU1J+/FITbDF8q+PXMeucg6xLFaso1VWmzKhNFwxcidoFn2obzqCfPyjwbtxlRXosrWa9Y+26N9Omo6vb0GyzpxLqkSYQCyMLqp0aSG19HpVj0M9OX1EYrU4OzMm2j2KouOM2oG7bzQ9DHlW36l3GPAysFHYAihLT8F0xVn6n3UnptyGkXCS0mKlvywo0EswRosqwGoFfHET6CRb1MKhuQrC2omEPu7oLXAHLVpUOUO5WmgpgvloZyU6hM3B4q6ncWCf3LiiReRDkKqWA5t1WIQUZeiMCBlJCZGGihfq+5fbwpBl/LBdSMx3UK2zTfAM2uzM3SXN0uU8SMYvMQsvMbeWalsbcmzt5a8AvpCrCcejL+QJAOWAcxYMqrzBNSV9c7Cz4jcffcY32+jdkLwpAa5/W05Q2IgFGD3LXixQIKHm+RVdK5zXsqurDjx7s4ByNMEpXZpP/7IXlwD5KYdgV2w4pQ41b6/svtvXXx4BtKVtgw00937isbKkpHL8+7aWJMyUdZ1+ArfsBCfzCKZUQ1Evh6CBD5Xc9rHWidSkErKCb3ewxmzB8OzenYg5KF4+YCEepQV+4Ub9Ogi7wXfhcgpFMyWWI/NZfA8pPHFbtEe/OUs2ay4aqEs4DC2glLUowhb5dOE2kMBTEJXQnARo0VhIvrmU8ceFNZtnqHrD3rTyOn79VhQa9C+Dz4qoBc36ZgVkglR+7lGX4omPMR2mCUcJoLAdf3siD9AuUH72jAIM9rUxj/Wyx9tL6ZeXwfZ/mif1lRPKu7nzXya380j4znFDJiIEG/FulhVUgWbCpIrOK2wuNIDO/VfDuiWUTarIMjWFL2n9sbc/igY4ec5skgYvPbD6wtqb45RYUBz48YYTSPkJ+51ZjhcdiScMHRH78cAyHAQdXh5zWoW7vXMssAdCQXsIU334KPCKKH/KWhbJ0E5He3H7TE/R6AzM5vIMzybLAd0kTokNjbOVa/DQdWlfVA7yfg8aQC3pFikmbIzlmTgcrfHDnK7oJGkOCGpJL2MM49hc4RnCiR6HoLwUiPzadX2EdENlI0gPWKSAQND1fu7ey6TWVX23mU1kZDDhbMWcw8BnCe3mDq1NK+XWRoQLlfSxCvVc56WAdB/KDbQFKPmcRRnQIqklyISsQDwNOpZgqlUV0hns5XFG8pWtYEgcshQA+rahgelrb1pKWblsVcDZvtU5qTcezOOBMK7qkO/25/e79IJydeiQHxNNq/BUm0i/mJWLzjg6maAhlgAoRAFuK1S5phqrUFsYEebE2wK57kZ1jCM916dRF1UlSJKdeLo2KjEFFicnGGF/R3MO8zSBt+FnuoYEb5JDNV+lTYh9a6QtBfJF7tIMoCMn0FloximV0WYVlqHghRsB/MFOaohiroYvMB1qvrls9L+2HFotVW1GlOZyiNiPAMujTLal1N+eNz+pPHH5K7ApRYEm4Xx9chNfM1G+WOIUWbcpE5xOfZh8hLXH7taWX2fBP+zxjnh1+sNakR0Ej/CS9bbKcAg5WE6aMkCp081etgWi5zJfdeb1TtsLshvK1YsC1q1uFgjd6/WPyAyG0rga8c0relI6oV4M6vgzm/+KYZhaiHt8ntksqPqBFt0O0w/Q7t17uORGpoE7oSDa10NuBP7GzDyVq+8sCVF+AkjWq6qBpGJffEEEnCAVPrYZo2rxMDqAoRbeRqEXeFzN41OTBYciszasrY3jsBNs/qgwtpvTAMb3PCfVlHUfTcxxOQmpLAV175YR+ZpIrh9qIzhCq9VDu77/Jf6YqtwBfKIMoIyEXI3fp9hMkTEut3Q4hwzSNSKk5cRinV0kyZR0fBdubMHeA7yfV/4x/L2E97pEFWzfkIPlWd07K8WRU8jKZWvJ6UlxxgIe+sbE77WvzEh+wphpB3nm3t5FExSj1wg4t4t588qvw86oufBvm9Fd05t21kwRi37iB2/z8YIAApNZaonO7AFGF26pGCzO/egyq3WbEHXkjNMXm5qBeqyd3J5pMdUxZAEH72YV59LO9tjPbmlMHDZjLB8XNn42w0qsZd8NbjSTylJmUCim6yTaxjx1FO2+ZJWJkOghkHxUI0XRyifzdZL07VYO0bIKWZ6nI0vsUNZAUEcgbd9zIJ1fDKFbNXSNDrfViTfbMH6XdUH2QoZJgrNyC+HgA89W9unenWSjIS/MF0IS/le9CDwLx9+ac46TARIFlcW8phZ31OKhFCF07MwSRSc0jIqwPn7xIxutpqixN+mQ366YcFGV7Jmb/5unDdNzliSO0WDk2BqANgVrBdf5cjC/OxepimBrulhmshlxdlNdKc3DL3bInHnrciCFXZUfTiTWVCew7G8+k7HjM4h3eeR/GFd0EuOIe/bWZAQLFvIZYFOHsG7b3lMubUmtd1MsdAvuf4KtJbkZMO7WboKw5asdi3fsAAx+gGprWLgDqyS+GFfvZQDU8tljRonpc1uW71F6j1ZzgegPahCZpzGM4mVMSiHJao7zhAu2Qhpvmi+2ZMYDBF+i3ivTpCeVWr1N/QbNRfB7tX92cuo3VFL2W5yz+pahTuBjjg5PKdXtiJ/NgnG9UVf+oVjbk/nXxP+QZ3c8rRc3FQU70HQkznvHlrJnPzfZASiu7IvNwAeRIz7g7YswzQqW3B864cb6QA3IAcjn8Vhqz01IIpSZSb7C9o0bfMGk0M2fdiNOGg/kT2s1zlKTEuo9AZUcPGD790OnHyumbihl0NbjVoxGAYkdgfHLuBx5//nvaQEjBE/30lSyUrcpl5O4G6llygd/q4M+pSlo0Od8lHS+CFMxI2ioMV3LByYGeFczrikKmMM8XMlN3JIz+xdnCJ3mT4DYIkgBqvaaU5AvXlVYFGe2+mGXfs+2D6Q/k0KdPGgQHEAx2t6sd1ELhcgKP7BNIY4ABiHZnGtEACX2AuGUxvo03+l5YD0bdE+3iwCwUuj/V+ginqKA1WCq1NGltIsvZfsfGFbesSAMSIa8UJ2V8kIAzC4Mwl8GsfNTFr3brbC/rXgA3ic6raQ9MZOIc3Qe86qY8llfPSaZGtMAjdZs8QAwB9o2meFxsLLX6/2tiKsIWWc5WJ+7djPxIqtm07lUSgVp0YQC0oubterlLYsbYR7dMjkp7eH3843RHsD6XCVw5BCHW0+fO5Dx3snvBl5bHHsQ/xuCw+iPFaXgGGawn6FwhQZBG9y3uLxlzLo6GeMCLQ0BgQXdLZVl9UTT2gbyt+uyRtFOPD3Xl9P3aeR8kKw723wv4CLrC6erTz1Rh15D2DttQBBbqwQSEOT7giHl4sUnJo4VnbdedfcZ5f4CXLdAxwIO1AhhcyxZdqr1uztzwdWorBb6jedCv1UJCLOFH2oCA0DL0Fm+USWo+gN8v1SLz0ulG/6a/1MON3YKHF7GLgP/ZF5nk9vH0/b70WWUp4zhgYc307AKCocQUsj8TTEYxw1NIQsZpzR+XlE8dMdMggYOi4lTFMUhaCtVr8L7qibW31uOo3sUyiBGm4Ba11FXvCHpnmPOPpQZR62HSzaa30kxZNDmwe1RLEZj9lG43zR6PuDIa5szlOEOEP9A7poxicZbozU3+kj4seCnR3fuCjDnbyk3FWO15DldT8/t74Hma5HTnmzD3G8jJUmYpyD3wJxzDn+CChWKQAPZuSASSjP/rOlRQHl43rOfpHvqMk81skeQk8WBdwcYkFKJjpVxeo51VhhNBHBLEuughXiPWB8PhTf4ZskB1OT3wKPZHQSzhKe3wNpQvmYJd6mr4gQUUWsw0NHpIV9tME1JxJEPnQb+HKDVqfr+zWD1jUH0bwGi9lvcOP7x6k3RM5jGq+pFf3WeRGuX9L+aNEEP98S+7ChJi8c4qPsj+px8jzseBoKhgDiOzsir/dOv08/v+MX3QUa4I1I2Bq2ODnDm9JO7g30AIcLGsHyQ7RNBRQ/u2qHzzlTXXVaQa39ncPRxYK3dii3kZO/tuD8VZ2dAPlfGa8rRo2OtfLYMD1GlHOtGbJrIjBrzx8YVQW5CVN2CdYhzKvq5NJiWH5NxoDsQzACFerhgx0/KuyLnGvpkhbFAD0qFHHfKVgRAetDLQGd+hq7nv75qAYx4CFpuXhbzk9Zqq0ScvVZdt2pQC5YAzYQRQW33n0FYzrVF+8fD3bDvzSF9DQqEvU2wfbsD04fWI7v8At3ybR9jQwppjD8IFFBABFfRN2derV1I+8w33uDS0QDI0n3mOc1mGvvWGKROanw9zVAHVsynkIqVMXc90AIFLQjJIiZuQ5NQ1Xv1N0g3fpox7obzkiY69OMJ8skdT7wxLgV2wAOpn/0Vz2sW0Urt81Td1HTikQPfdGQVV28V4nn2enQBuXJzjEO9W6duGTrnNDFPOZ09dF3pOas5Kjjk69HGEdTPCI29kNRSjsG9o9ZGivLdCm/WiajZL9rNxIboUmjuEqSy6Q24oZywdJjIlq8eWY05wtZKtT+b2qdQwg1/+A+JixAQVLPWQ5r4amdDDc/r8BXrP9fOPIkeQGQtTSqMLJtUKSjS+RgI/SvIRc6rgLaI8hbVirPELdJxEsFw0HFw/dtVQsIRxRd+h0BR4X5JiTuOhVP4KyN9++n2/9GmxWhk5MiNDbQmcv3JC0J4RHJ83dbe+ZF9xo2w07c42lGbiu6efF0qX5TBzxc+UE0P+3mr+XOwVD+uE2VvCKnGEVjKFd+ek1PtrMz0Oo7QP/r7ss7Iuq5V15peZABFbZKfTk79ht238J0deK61t3JfufIxole53qBs5P8wa0pWc8Zs4hrQUc/u1YlBlnnr7RyqUG/+icdW+1zDPfnSTFkRYKd8FVun3aDqifWU0ZDFphf2nENoURk7wMy8q53OFqcGizX87qOKbP1WpwT05Lgx+H+10AwhE2nXZjTIu53tdzEVuR9AZnWqukvAi5VwwCwam6Nn0zUVKlMavjpWE8SbEDa+Wu7C1dgJ4OjRCNun8LX4B5SZTBPSX5ThMHy2e4kGpHhZp7YbPc27wG+pa4tsYTi6lrw7maMjvd5pXMzTYgeOi5MmY34GSKDy5EQXbmClAsAxfAZwFK3LApy+xahzvSFkC+fI/vlIfRTy/DkjcxaC55Acrv+4i9Itbcgy4+IWNhR0ZamnAJ8cucwvznjk4UARw79b+10/rEAFCuXmBueLMB7HuV0xUsVM+xQX+/ROs/K9hIpt73bUqssztrseeEiV5rFahWUnaRnqECC+YnflhHv2cXDZ4TzKDGD2mgxwscBhpwJWekTlBwRKWeAO8ToNjCMAxkgOuOLYf7UvEBrY+mNtPUbIw6LdwAxx7LFY1iOubNACSZ5bi8lAvwEo9rassPTtbrRwqCH7fNe06Y42FgNubn2wE1AXzgpat8oFLRZLDJLXcXThr1wk2WOX2/89gFQpJjuWyIw5YRGR9THa+ljdZPUOjad87rHx2dxnPejWsmtoWmAdkFpfg5/hshMOaUKjlgOmr24ASwKvP21NArfkUdwYY+gwAP+Mj1Vlq9FAnfJXu/KKvRTH8QIhqUsPPBhtEl9rXKG84PnXxRtI9yOevbmAygdK+J4iyPuguvJsEDlJAzqnACALTsgDdKzYu2Cf02c17gq4PmGkI8wYFizKNamWlOGbL06ebtkCsuLcO9Gws8daFLV+NJweRx1oV7JgbNIMJb046y1nwTH8R6Uwut8tOlZ6Bunx9XtgiUCqLpdGY5zqiHcsjKPUdP6xLs0UoDsYyxdo24dpBSc2Lb/eHeaXix+LWSrtUl0FqQ388thrAlsa32hG9yn7w1nFS8RYPIossq8cHyCj1WAZUBG5388UxP9PkH1kq6RPZRzfJLRGhPl6Y4dcH/9gAyQF9l/3ZhUAA5dcMhDVFbiuyRRom4c406sIQQlNYoPlWgrhnG7nu6BYZB4yo/uVvGN06KOPt5Zcf1hLp8izDSoLbDOMxfKozqPqwPqOH1GhEZSYJxeSdcPmx4rfywun8N03VGesbOdslOFo1QPzFjRVqhJRRfYbeFmXZrL6FJ1SnfeCZLQe/mndcVYl1YH/2cclwrEoUccxhty5OAOFKR9ei97R5FRAAXlsJ0rIR3Uq4mWFXwRHK+ytOz2n7cnhi7dy5Dqf/OGZ+TVNECyLY4tBvz5WtT45exmwfyrerMHuAda/mThjyLjtcQryrtvRoKgdQf0tUNFzVIJLeTIgxm6jG2CybUIXGgcv5Vq7sawyI8WtZSIbGNHi+/ZX+SFVIXe+ASq8XurbjN77Bsyn5AZtaGmwORoamKO9Q+OH3wlZB1cU5CkE+CrJN1WOYMtFa4q1HrnLDO39PQvVc2ICl/mY7SzCB/X290JWswRXF/R5eZvf80s5UsSan4toLE5yWvdhGlAnKhGIA3ia8KMPdZQLD9htQ633s4xac/WqyMwHQqfnmNe0cqgU7I3hwjYWNLy0iB5D2jLg/XMwJAdsXSS4wWDgZReo9BlaZh74tBEYZeti0WKMfNH/ZGFUjU3wlSKRNOnpYbPY+L1dnKcmT+biOZDnPZgCJvlgAKXOY9p2aeTSIjHZ5TOoXo6JHwSuADP2pm/v6T8qM62DzAuZEW3vYmVb8Z/5flFHnKMSqwYZv/NR5rhlNyLLA8/kVaB/oYWU/cD0lb0Kr7Hj407SMI8EKKYzZ5ArDtIMdZHOk5oIIOVMWricUXpVgK79juRCOwzZi8l7mrEbU9cjcvJdm7mEVzGF/9AbSWM1zzKhRoM3h+lotwD/PkrExU4mHJ3zBoJWknebL0h8ZE29CVdOhgp74zhW8VHFmxWqOh0l6At6frfjn0aER6tdZuehPyEPEaMLZvo3WTWgFoRt3GJqTHcQeea+M/zT8SP4Vqd+d01OAshA5QHHVg0+qbFGJi4sGi8VqmeVIPlyP4aWHoglq4m+wrQHLPNdT5J/Ln8mSC9dAfe9i6PXd/9Q/c14ZgGRqvk5EJLEPh0um9I0ww5syQpalONkko3HiOMWBDiUGKor1su1KCvI/zTatREc+/re5eF6wuC3yJ4FXAt4SHhXfuZJzgcYIZbxgQqS+9FKBwlqhrmmVDdry+7n1PYlePUBiLWPiProlrcQm/kZFtxWfBM9s/pmBvCbV0EHkPL4pPBv/W83Tn3KFZH8cQTLfH+4zl1yHPuRFt/KAsxUqwxQoRwL9KHd1c8O0qbWZXq8Axf+XFj6omPscPHejFW9l92hjRgTMqG3jYJKHQ3Kk9BAxY3lbIMffp4n745CRagVghv9m3u1RXRylY1r7Rpl/o0Sv5jzkmPWsItBnGzwpLf0OmB7CU0NpmBaAPk5H45QqIiIsYffnmiGxXMQIN7oBFrHokSQwZVLrIRQP9rJV0HJKfHhVh/CAZu46ltYHeZNSb6HWGmjJsKeWCWtyKP7d6IBntgOKzjDjT+cXt6PSJMRp6h6N5QjP/ZpAe6vFDO9Nt7fTtEzuFb6v/CdymsOJrpYqlE/8XjY/0TGONsZyVQq1pcOtFUi83pxKUW0xUscY3vK6ODRvk5LII4Nl1LK+o4I+wcAyORpTTtmSQLe5uniHMv6tq92Q+arc1NOslirxglC4uKXIawCe/fUxAijKEq927qTVevvaGAzun9vqMlGn0226iHgwWuXXXbHnLyW0tl+m7q3B25/t8HUmMDGvi5MFs/z9VysI/qEggFGtsYpla2grw7QJoZS5ZxY4AaXm5whgAEDEzDXsG50MXqVu71t/GRYfvXNkcr7kddanCx2O1p2tzEwpZ8exitxc1rmLQbUcn84TAnUXC0gSDoI0bI57OjbmiapqjukGNPtUTOVoe97pb8c87heqwB+/LzvHNhSrMEmKIFt4mXzYS1n3c8lkjrj0Ybq0XTzp+X+mLKQaWgzQ9ryRL0vBftvYfEg4mBVc1180xS5n+cVsxQLcDa4mmVRlHVKsCJdrcey7GE0hBzzj52d2uUq9VLpJswGZWirOsDEbfLRgLZkuK6ztVJiyD/4gQlRx3ZIiXC/oqA2hk1Dw+0VDKoEB3iOXhsq+fKNCjLzoWWJ/VCc1tdUSbG9l+6MQl5Hy1I6USNbYMVtCwzfFxGqUmHyolI4DoApLXhDf+qJRNGpnsfKnM5juqyTSl87qSjlTOGYyraOO6d/qirs+bq6n3fjoDSofBUb2iFdOXj8pP3icSC5R1eqUyrRpKQaFDM7AghgkbrwtVsr89yU+sDMp0h22OtPhZJXY9x8TwB5kHTrxouEtr5U7699ycoaRWBYlHI1cb6HTbd+MszHhMoGUYD1VjdiwmT45KIKOzKonlV/6RjMuk86ia2pr37aajpdw7s5lawC3ZB0ieBofm7oCjczEa8yccMpujsGSIEkkVDl4Twj8zKSJAjifsseLA/BN3rx68D08/XzmFlMuKwVVycA1p3rBIEf36dynyeA7mGbwxDuTx8G6bryw97ToQn1o8919XdVM0ZBDJZEEDwhvqOA9qEYf5mahEhPBkiIoxJVh/VzvuOT22pjmGYlH5bH6RbHISDx5DPeWnG+/BGuPqxLGRg7M0HhspyHz82cz1OMLIH0/lD++ZuC4CAp4tsWgtw7C0dzErGyfkTBgTIaL0q7kBIhFazdMkFAzAbRcvPi4uaPLrKQYtWaEeAMIiIaw0So3Xi3XY1OzizzcMEmQpJtceUQognyejSmTxBTAmUwzBh485S2/UEIWYBeeIMsmGMMGB15i8dAJVnff7icfDRkQQ5c/lLeb8Is02539UI7/+lDnCNRxKqCXYXdzqOSBzF/HzONcGWKrvyEFwlfL/BG+6/hqAUDHQ9vEVRT1DcGc/807swax9/dEP1+cIGjOmHIUWWw8W4ZqejOKw93uudfmCHnuPNtTcjNf1TXuQtAHnSBZ6OpqMdAW2NTRtaR34OonfQgz2qFG3iMQpha9ou3vg1Bqd7ZzYgsvGmyRUI7kKwXDBYf4oWms+jM6cvSbALYqMiXXXPK2/84bjZHmGgL8pzKNVLB6Pd9ky/W+imIi9GMaPo1sNyDpOSST1zTHap/T3qL8RkjRs9kk2MCf+KpscfhLjn3myZWDM4xqc/SW5R3H4mXFnri4MlrnWjbljL1w6Rg4q6lm1r6S4dudmcxrYnx7/B5v/b/MYds+bvRmmVXdF/s4l3T3CXqCK9cMjNMfOpMFQMwBMoPDJeT7Q8PhKqzLolRGpOIUfmoxCT277BhS6/pV1Lqpi6W5tfjcMYs0leiQnDDSw4zW2AVdtWYKimIw5i0Q7RdmPqFsh6jUpQQEg287ONyvmWNyf867RCvFdknHYDE/k867efzV23ID9yDaOdrmSegM/Jc4X+hJ1dJY5Yw8N4bkTEIHqqmnEr26hjv+vzehOP/JoxNAo5PA2hSGV1ciNek8hYswYHBTWnmAvCVSTw5RcJaZ78fp99TnIL5sx12N5jyywYfaHJLvwNp9Ejdc/N1Uqg/uPO7V2oaz9RdlejmQUzoyVMthe7+x8tbSiiuvcAOAyg8H25aKqJ9BgbqU5gXAY7zWNFeM9RJviLPy2FZ8ygpcvr3P3D0A5s1khkmys+9fg3OijSEXWcMmzA+zjMTFS6yzmoAxEkYAwYZlXcQzfNYaIKN0GWUDVjpxWXXjg3Woh+9yb0Llfxv9Ho3IXSulePzKJdyQAHAEYA9mmNmPw0tFXV2pKBEoIlFrKoJ3B7pBOZ82s236Z6szVgDrQUEpB41Q0eXMBWPFbdlwR1IcrHUrXKm7KzVSXw9i2udAEM6/xoipdEB0QYn0NcywfkAyekmLeYK2odjRRkyi+Lh/T2Oh4K60tHBp9GZZ1pWeygf2rZL+qubntdVye4t3AD6l6fbVbSwOPOme/JuCHL6nC3073o0CIW3M4xVw7pvc2c8vvha65uy2PDgiUNAmecIaayCkZ2mvF3E4acbjNgYw9i5/amlky8gpF0D8HY+dRKXQkPzxvPEffdWwtRDPZ2UlqTNOlbqTaTO3g2jvNI4GVFt5gQBYARrTPQm0TWntiHbaoq+BtVN9JBl2nCge3sO5vAv53iFuzk4vL39xfTyHiI+8pc2H0n8PijgeQO47KOqgd5LvKxLQlNDpPYGOelmgzO8LAa1xYMqUEjpVo6vUzzVUcpdmROhJrOzZ4TD88bWDDx5Xpt+o7doQTK4xQ2iFZA9BGmn11KSRDozXpgvnO42V2za7skvkwjngmoATM0uX4kyNcdBrdRYQWPmL/jJfj/I0SQ2Q6qa6Qe97v5QJBPRrwLeWIt1KCeYl8llAF3SjUsbiZjJFDz9vmDP8HxPwVldYlQfXs6FoNOBqB9WoRthTv/1nNK2teRigJY63ERjklG3Fgi6tODXpzlBIcZavbkgLi/0IbijKpKGMs397zUp12FIa4YbRwnA5zyBwXrhwYSXE/ZjdsXP4zqvcplSLaf0oWh8gmZIl9ZWZyVO9/UNcjlQIIAQ2s7GkP8IiFByl4hJ+Pw12t3aa8Gc+1FmmOgxocsvtq5xaG/EkbLdKWpsN/VUbhtxBQmL7/jtZ6rR1dfNMTH1wdoAipU4krQLFwWij8fR56bepajj5HWa/5VTBtNil4WPfk+OtdDx48whuRy2ZEAPo1uH99JGNNWNBpfGpcysVlKp9VRLGzH7HtA8swFMVqffFvKG9eYORAe7f6Y2UMa0ZkarbBXKTJxYAsPNDJ1ogSGP39HzXwqNnpjbgDftUxRK4l8gyVK8Uk6M1QXDjQbvN5quBL2/KspMFDnKTcC5lyg71m/tWg9L1CP/hKs+uyzCqA9EhKq5GdU00qyJptea4zpX49sbGGL0JnL58odZVykpqLhEe6grAAHT8Ky6j89MrX8i5yjAPwjHQSwT1mzIEXtmqTauoKwb5g3uVdy7LfJOw8o6ctM5e7Hh0P3aFCnw047h3KJPmgYSin18St5UvY56uinlPeVGyOs7KZ60GIGotkD+dDdTOOBkcumpoHi53tunjiUTkyTDQ7kAEd/m752iCKYqo/tuPeadYqLVNASfWg4A4N2kTvhqRm3DRCRNK4C6HDMVnBXAn4pZnvRSLtTRhZ9tXWU58XT3ivwFyNqwWFWbCEtHA6e7YDwuOYuy1sdSp/fnBAMTo5OoE7bo7MSbGO8uQ5eJUjJzK94it54MrLRF5U+lDI+jPNSRftBgZ/iFTSYuLOCQOOms1xZJKTa2t+7Yp2y4hr5uEHAaf25vZCLVKMjGAQVVIv7Fq1zjzhFTwyB/ZkmGKIzHiu2XBi31KKQqouZyjjFgfMaaKm43ytl/GWVuunT4kKk1RRgFQrlGlZnnP+/i0mvHpZJyRyWM8QUs1Grs+RR052hm6tubdPKM59JjxZsYetB5kpXSxeuEreeVYfxea5CylDWAH+Yj5CnqQgps2EEB/Ok5vGZwXDJh4z7l6jvshqXyt7mWL6RnAoo3GlYGU7mx+wzYUrAHF52txxS4qvJRgGrVyUfJesANveC/yUFdxk8+SIrxvQ27K8uSINr7cPH3ZZ6l2aqUNXsGjisb8jUBLNbCTs5tSf6cjpevT1qFhWhDZqjq5mJK7S64XNjl9y/bNkbAbGfrC3oXvSM5VWm0vmjspINiCE7TsGsPQgbs5pInZD/Q88c1NpKLq94sAJP70N8kJEbYp1ky+AkXF46XRU7wJlL+ODapL2rYdEGc3Fb1R8vjHV0ZC+WfJ2cC1BIVIUPhqVkt6b0MmalfsrhLcCxNPXKVOXDTmGqkIYoXKWg3aJtIPiw3sO6X5ExiJVYqndgmnVSJ8sYbU0Xyga6p5f7FO3ZPxajGjNEOHaJBDQD2X2VHrAY7S2y6k/1HrGvivLQN+YO7DYDToPoo2DpevuORAP/TmSBgGHH2GbSy8nGkoKJZoDuI1jrI7gaQdpzMtmr9xjPgM29ysZdWBO9xGhRi566DxzTzllvN61eBrSgGPF5noqYlAcjSW/YqnygF5IM0X3fVcRR1oqRVZH2zAZNoWu4EqW9sXJlnMXbGRPHHCh2FrYn5ZloPB8b06KNb7pPLtWFl8hvSFWMqejreC4JB6JgQ0t9yj2F3KgKlg7mcviCUN90XTrvitBqy26Gr2+ijd9GBY48Qh6BaFmugrANXYjIXyW5k2fbnZwZN+YQOA/iQkmVOePeqtZgerZjyk7ppSgC9PtnU0ejTH7J0mCpSVs6z0ZvtCAcRSM2vtzL0qaMIxTn0EZW+Su1ooyhWsGbPs8IkdhbabuwHPniVtUF9Gr43gMFPLYPPRGyr+BFz/nP+kaOTZSVNIB0+ZqVF+jUtcxpg9aRlCkNh8rmu1LQ+IQuwuNl3uPryvJ7we79XVtcRLBCLBL2B4mEIBBDKDbjzuSQLX+adjNMF/l7oFnUraJxSHiIEXFVM6fYV17GhCpMLvVHh7zdLNHT9Zy1z3exAIbZBsLtSa3H6Mw5BTaEgXE6E/Il8PPIujOn4E23TGa1MceZVe6CRr7OJbib/cwEsCioVai6Un+ZaBo7vWK0avL/z+oMqvKt73KnZP6cI5mPQ4RlgkpO54dn31u6amqNn6SZXswOCmE+PdfTl6OYSQ4nM/7cWWMVVwVFqKOsmYqIBKXLLK9Cr+ZMBBj77jGTegKg1CtsadVfi4BEpx0sHP4Nncqkjl0oY7yxvyVvfI8cc1lSrYd/UgjzMQMHukD8PuEiD6T/0EYKWGHHdlgmU+4kGqTwSBmDQYBstSmgmvd8DuoEOxjUrKSsDtKiEIV4yCyWIlEhRKo/NnHK2/SPCBcUAfvXemJZhZwsunG51E2xbUGUc4D7FSmpbSuMqPqRFxkvWLQ6007RTCHPJPvn1QYw74A9VvbAo97+OF4sklaYAXLCKHAg2mNBZ3+ofSC7qobh/3NZi7mrSUItdwN5mEVP4BWPMPQZE3kZrGGABbQ6apt4pxCw9RAqrSw9R1yJdG/4Ubm/GGgarUFmtXXajyZAXjdFWFXcPmpi4padj8kPIQNKsv6F77jDl5qi0xNihzWB8/AN57LiV1WveIz2h3ch7F9JSMCEuYIyciWC67NU/pYdzMwghZPLivy3TqcQBNL10dR/wX8vjrAIf+8I4FDFMgB4woUty3J+PI3I0PBdLUpQOLWJdgGzSgpq6ESvXzythjSeRqt+Sg0Bf5JIvwLV7rr389o3GqdE0tDOXR7KFXJdDn2ubJnETS6zBhLBGy8HMjnk/uIWbqFDK8HifPSuPdrbWapzzJgdxYERE1sd14GRj1rFkh1JWfSYPJ96c7BUXAqr10QmweHAcLacqJ10AjwDNNxl4eXJ3YRsKlaeY1UN0F4o+WYtZtcjQWDp+xFZ3/+DarlEwF/rVPI1ApoAd42mM1++tca9ym4WjcMzTEZc4dYnAg0B6hxtuitW9Z6+pdVpirDCQcRWerTlMbSeQ/cMAg1uSWn1qXWA4gRALIUbBQnOL1i97pIA5cMVbYdwt+D0P6q/EOa5A4bI/vqJLZ8u8IjUQcdZ7kQwgbLKQ2wa32YNrbles1C0hKWbBuN6OYWKATm7ffGeUeEl357Dgv4uVNX2VKXu35rkOtTzp85rVhUGwZnj9U5XSYbnWA101w11L+DmBgxQ+G0WFE5O1hltGm1YIHvonq8hqSQ3H+idG2nZv3963IMfwhiYFC+bqXyP22a0/2+ny/rLL8zxUuRf4mz/508FacnNJow5attjZN+GHvO27F3CQf1KXpNhzj4mk6+6uR9T7ZwFD9wJBanCHNAiv0KKdYQmiSHOGCLW8/e1YL/E1qDpCnPPDvsBGZh3tTSkRkor4XTMjksWk3ML183mI3ZRvyRbKNrbrmCJH4ya6YXnsXgn4ID/uZYPeauNU34wdUoIzzwgMXrvkEqPjHsvV5d9RNNWYtfjkywQlvwX5qEDPnLvr0QvpkVHxI51X9NFEZgD69mmZw/zxIvOYZqfWPgvE5WTQ2ljZvIxvtWR5JhBKckjpSPCXm43YnR3ukCweA0tyDtghDtAOxrEe2GXqkepHKgHNlyAQZSHMEMTUVY2WGqKFw3/LusKPNTeeIU36eM8JYZzMLSUBfDOjtXjm9Re91dcrlFZxZ60Q7YytZR/bEzwfAi0bM9Y3VJ3JuJLUK6cARalvpbDItOrlX38vNxbgL1+NbhUZnUYZNo1Xyj6laNgDlnp24kUbM9EcWtEwQ0UysrTtzyHetpMvo/ylVckO4yUawHt/Xfnv+OferH8kQUduAtEELNaMoPW9zc9VPPn1SMKWhyFjB8OVo5GRAt/V+r1qrI3eu3fB3C+o3ahQa94Vsgtx8EqgPvtxtOdgokcvaG5WWIxEuwdHuYlM4eEdkf9TOY2XwwCrLE+jAgxtwkrSdIUjAs8yxuzgV/UobbS7c1sfkOItJEGgR+/TLQGApSohECymyv99Q5T1zAZ17vWgJOoalMsGGwwi7aGgrYdDWd6MJqSCtl817nxbPldrUhdn/ClEU8783qAhxdcOjflz2yh8si3ilw8NqvQW2dK8sr8NLo/qp5s9iHN/75gTikT93twa2+VWEZFHDu6LWTdk7+3E87WuIIAhjGNZ1RDzaG4j6wxzPgB1iJhHDCDA0ogCCKGBC7Xg45aWf8N/EzMMOXczYfwcMS2sdr/VbvyXKWRUBw/InA+9oVxTCmBBgvRAn/MsUpvJIDXo67Qe7HIEBcPelLEzTG7jaddGPhSPEJRv66U4wPW4hRKTcIDW57LbxyaKEZq3ALBu7EsMeY6bXh9M5FQv+oqxMga9C3OWifXHRBnzXuzxkBMQVNyR2Zg3aI5k4ikTcUDOw1VJ9VovvwO1puSaYNLXh8ay4KOoH1dxfNYsgeWeH/FD+zJDZjsOANjwY70IDpsKgDiZVDc1b7tVuwk0YDRZ4AfCtGqysNblDz+/CjST2u2j1sUFMHWVN8KIJ6AAG5goOfTGslG6O6NseSj5GV2iHQWhuqjIpC77sRIVr4TrylETY86kFnfKOqGhMTtIB/tQ9H7HQabrzeqeSR/qkPSa4RSi+eTvBAQ7jw3TtAmpfM/H5xlqj2FRcBTAsnAAhnTtGj8qzcjkFGnkHwd6kMjrN7b/OwVlyJEYoV8dhy6/R71Ih/WTg8dBSJxuf441qF3tKDDZSfnxNR9n0PbzaXGw4nVg5qrCB8nchwoD1asw2np2uCrATqKbNy/hw4b3tRvOB395onEiAHueU2A5ivPL3Yl2v7R0oNZ2YKAbQWuvesT/kB5Tn0NpLO+bGWCc9YdMkgb/lrHQhDuIwm6EQui781Ga4VcEGsEiVse1kCJjwQmCGqfEZIg5wW9hreryQp5inFZqzXcdwMsSk/7I/dYtT4dDfYQr6Uzf1OOSFBxEyg8Uk/54qKs1xkcCZo17ArXid1cQHxCNoypnxvStwqaD7l4Gj7qlCOUPNKnpVRxvMC6jNSNBy/ks+1tIpg3fJEBxAvM50ghYpstNHjoWjDMGJOh98E8N6pK8TqYdVtlDzleFVFDgV2hhL7hkhH+rCJi/PlvkSyNVp2pcmarmi6dbzqL6z9mXkcsN24htdKhk7b9Ke/Z1juPIj2d98d/TLQxS64CbLkHr89rNXVUVCKP2agLaz/b2couekRrBEmNe+etelXheBI3/ckBGu9b4viSdSgxZXiNpW3WTwI+ROoufTOxI1NVlHVK9//JdTQYVGu9IyQi37aTK9dOJefqGDFqhjn4UyfRsrFo9fKSeFJyw3nC0J56DteNjM0lktnbYklAJ9HmRlrUC+aRS7TXPwF3qL8uPH9Sc3idOktbTsK+YsLY8xiqDEiqlq2oLA3XLb5/rGKQKjNNkE4CXq89Kq3RAXJIT+G0kpvEoQyW7hAyrC11Lv/b1CMPuoEsBHVDq+duGhZ5qjj3UnGyaw2L6ZhRChm3wmquwtNqOS5xdAl3qbFMQgnRFoECADlUqETL2r9Tnp4uENIuoTgZ6FVwJyJfoM47fvF41LI58l7ubiSnicEO5RVeGg2yMo16Li/2Nhq0WXBe0HpK60cuNdg/SGNMLs5JnyGwf0S06ZTUepmGQnjCmCktinKQUdPado4AFRVsyRh/NCIg3ZLS+E1EQPqZ6qVxD58g5GLc0mCakqjIUaUNZjmMX528ygm5ZqThd1IOUXRGt/DE8/nlP1zS9dwNjVrxfxAd4h4nxKyJMqXmguFpASp6kAw/ECnNb/LqcFpHKio7aD6qc55URYOQBT4nwcJysZ56fP0AkRqjMsnU2B8jc8B4bXnZMm62Ke9iVtrSzPmoEXtAyOzBq5KpQ9h1EGAbKUo/Q816mdbyCtCf4TrwqUQf0d9cPBH0Kf2qUdXA08S+vQmNR8mFyVBAkJs6bouImrSkPiiUpvAbUmX2wtOdXE+iLJP8BrYKZn5btXQ/xe8ZM/hAySVgFRDkVtM8PXnWoMMpfazQHTptnikhgIf21TRGFO4MVMXD2ytQEmTJZmLYX+Hzw31L0fCju/p0wTbnfb1eAtllCxlor8yLzfyVoX00q4Qmo/AMIs+/vW8QBnPj4SU3qsPq6TdzbmUGkEn7m6tQI4uG5DTTvjR1IxiqBAkFaY4pInqJs4S1qHqZtFoXQCTJ53Kqtq7Md9JBC/eHL42cXIb+V/DLtDmuAa4x2r5bFKrbj2PGLkqfh+8oRxp/9HVAcfw/UYcMpvMkXlwKBNXLxGCPciMM0YCF5N11zIi2K65MuUY/wZErQn53n1JIo/K/UjwuRaQIR3Dl0LaK1zYKjhxqw9aBu0o9qScUDmyYBSEHIdMfXrdGjpWXTQ+CnLAlBKlPER5HoZMMhbJFSgDTQh0/wZi0GLrtW84Q/FU9P3ZPptZ/gPkFrKaWmTF38JEyJHYHnzqJzUayyrOR6b7rx+DEC5PFqf/3FrnsrRZKlxc0t0vxRnjPzmcUPECCAPv8+FSfpGFXcc/jFevEkA/utUwuSbyMZFQZEkgh247/QuBIS41iTd6A3f0JUooIFinSpT8MEZ+fkv1FJIk/DF6gyOJMRcxJuAC7YzpDotZ7YDf+5j3CtvHIgSKFrOfyNiCHyBR+psCpynZtaKgQYzFOpRSbRxCmB/w1/RXhm3JF4v9DqXIimTb3W1aQZNt+hU/almuW5RHaKkHG/xKBM+W7EiyiIS3IXHFyrcfVsULFyQ6VkEABo7n+SbxsiEf6i18hc6Ou7s8uTpdwYFLdkfwBm4l6MTzLLiP6ej3NloZKvSQJHaVPOk7XQvA5V3cVLBwMXiKdd8pLZFgEmRHMTa/p4GpnvQicD1oanCIhqleHxtW8MpdqYRzooWlU10TneaO08z7mS/Dr5va5mf6EnVPDiKTL9oeFLJrwcHug5GlOBrcC8pm5rCs3UiogDZ5QbKTvON2BKm+3YSbgDWilk7gkqQ1i3apjNYlnxgznJuQ7XzEIo3vD+VeZ3h8z+Hc7u0b4C671ibkrqcWkYl/yQ3hte/rmSiWJ6gYdI5M+GgwcgI8xyh4/sC2mQxGnMnHAvgtQjAasaks0K8yYmGJR6nFHBz3nJpZ/WT7+kCMfUJ2VapfOc6bEHZ6VvpAkNDgW4R0BbycLLbJs3RmqJkAB3Q3+2O4t+8VxKas0O/CHaSUzs9Qtb9f6PZxvyEUnLYiP/MX14xkYGUE+kXwddrKiC6R2rx/ZiUZEIsXffYn6aaBEKYcjoYGaGOPSmlLJ6Of9zqe0Ris5Mqo1q0vjfC7RkMftZuzX6H4VPeZ98JXC63jOybvFF6B0UA4mx392Kd1LZzM3ZRx/sr2uNnfj1iTxSTzwKe++yB9tA7FwjmIY/JM99PZS+B06UAzXnrqYG1Z9QToEMfYnTwoiTd8e+oIucvoKPVszN5sfGRcE2L6139jlTBJtEZsN+mkOHhZpuRVhKFAsCyMgNPtl9NaoPuhN/MSlHYUeByop/rOeI4MWXY+P2+JmL+MIQ7fpF+xLVzjM4L5zHsJPQZpmnYvDCxCoqaOc940XCe6yeg9bWpWRu/tFql9bMlxZRIF+ed5oLoigwVwKKv/+TzgAUwTg/xA73+nzDolP+ozYJZLO51AVMeCgwmDhvzwoGOwzlmpxZXDDr0gx8kk4ZNtYt6DV4xFRbRBMR9wKKUsd3JgNiCrgzu8yO/JrWMNT3xEZ69DYdHYOYEFSX7EFHzYwNf0IUxZt6A8OUTGgOsVxRTh2lTKHUCHx4vSc32J1pLwwoEKkZxbTumS3S1ZKl377B4FII/r7AJ7iuLuEoD5FwE8DiNMwsNDajwMhL56YQGtOi31vEehZONKkfOpbvFPqvkUS7RPRYOvV3Ti2PtrNEoyS9zFA2QTUdvdcwbJsX/TENUarmWjuhsQYSkBU1O4S23UU+yxhPYONUiD4tTamx2+WN9J81tOlwd/bPa/Ew1BBmNC1ucdjuSlE09VtNa0RSm/cJEQI8JwyDeqcWQ1K1eexEfi91xTaukqd0e0v/W7HJwQI0jQWfix+ppBxuVDuurHDfJ3ML0NOAodz0QLeBmrC8k6c0E0+WUk99VtKjTnN+q1Y3+uXGkojmn8D3D3c4Nloz32/ClJswXYRkCBbcFglMJpGoPG4b8cuoYMBZRn2pFZR5XLGAoX10XwrbRZIrnMuWxoWr8zEbsIwGwgt4ZZF4+U8xV1sUZLP0YG12vZztE0lKlHAMWWJ9kV1HTi92zp8co4ZpE87UfNFvUg3PKykpWNgJyzC83SD42AW8Vju0RiqZvhPvZdgX3u01JEZkHB0dRzzoEUpWT69LLpur7KzbVhRb/fP05KeBNptQoRpFEPiIoPpEVUK4P+vJoPwcY2E+rmeLgsdgmw2Dp0Vrsbv+T4WQ6YLchgcbr8djQ9Bwy67iGwz3bbyMvT7vpoME7igqL3g+lqoTjeIE21MHZPd1ZOyRasfir2+5UEFGMkDDNoS3oaTzfj7Wpck1vZ7dXSx3dJNWXJylmY/at/nZQISwC4mvvc0Di9IrO4oy7Cjj1p1f6yKc/M43zQRQGfpLMCJk8mtmqTmZCksFjI82SPauCxh5CGT5OSXpjOQACMGWDN/Gq4JKt38r85pO5J3kaie77fu/1fg9eMZiSk3gPDz9LJw2dB65ZhLCbIytp2Gk9+tn39iSKMXrdZ5EK77IPf7f9TXXMQKw1RuJngBDhtr459jrKDJWoc1nJEXIZWbf4yktVVjfiLAW54sgaUMSI8IGphdcAwK/f8JRvJ0AkCKDAnr/EkGwAJ8eI3fiERJuoYB7XM0fOJySVl9W6Tzse2nXjoQAbIYpP5k4OXKu26vDGRnn5l0BkY2nKdr1nzyzGoYUIPxT2dGmE2rceJqGoEPbaT5Q2Jxe4yP/XmZovnYWHOXlIXrWHgvKsotCu8b9ijbcCgJC+MVWyJ+ytR3oQD+InY1ICcKmJNb7oIoy3+HXh4S3F7z/WoFGo/YFxcZvO4e3OGv0LYH0IA73wpRrgHnv3tQS0vxAciVoTwcwonaC8ii9w6iF/7jq2cGtjQHWV4ItIWSe6Zr26xLh+tSmbBD8HW8DgQ5bCAZ181PHI2RdqwpOWpi9SM4xTUJavEAXIluXAqOM2/0GB0dpmjjmrRly0tzHnn6l+KZgwBOeZJfdMJTtGnTU6z3gDOu1DJ1HlCQBwNxCTKuihCrX8YjMd9WA+AK9eaP++mWlLmEIC+GdbsIeAjXldwggu9RQ3ci38UFHEeezxvL8FdKunO05o+B94FsJB319Ja894/GVUItZCaqcSEX11Np1UBUq8qrd5PH3GAMiQl1P8lUqicm8qoKF7iCDkkQfz8fQ2RX0EhKkcA5wbH1CwV8OMIWs5lHeajuqH5xKCooHxa7v4eZfjn1A9kREcQsz8fZsjY5xBd0hQYTsJbVmHOEo1Hgl1i6aHLfNj5GWJNp/pdBW6ElnSEIeJhxdOupFGpqhbB1UWmEdj9Bo6mh9d5XAeUb7O5qSgpQFg+Gw77bplt3YvAWXU2HoXIk7Z6PRedYUhxppmWKGL0F9ZQrvX5tP5Lp/jxVCq4cKpGDz4OoCaJsgi2iVdQePl1p92QjnLFERXTsnIAzHBVP72zJ6qL7h4MRxtGS08b90gsHSs/Di2MMWffYGQ3uW3n8vFnXErUKuVYzExDdgxf7TffrlPaO1J3g29PBbSrGPUxMgy5d4+At1UlB/5TDD4uyIwIhPrD0Dg0DDJ+lAGW6o4pI5njEesGvXE3y89nfhoqp2/sJWBwskvz0HRwMEoS8ft7QSC0rmYQSNNO89I7cNLmTz+9q3rcBZW2f8mMWKkGK/jtLboxSzJom8+gq14OAByhX1xWon985Ah3wyPNnmlKdHEEOmXJmfNFGNygYLyyGdOQxDhWYwFlF2wzyw+Hk9aOJtnf2tOz+WTl4nsg3+JGL6FqeNTsPw6dPs+TlC2ZRh4kJnFYD/EktkNshWgXmbq/R5mVS/q+8Tnzoks/Y3zJ1eOtNAPjTAT5yOFuUK569V04Yr5ZZZM+SFe+vHKC0TWd8bnkuLFUpPynE+FqzxkFbHVmaRYAxpsU7c9xzYn7omFL56IFmAjeWO2mKqh32y8yrqBsnBRJbToIbX+5lSQNE+I3Mbt7/IeoBOU7XHQetJxH3w8DoHkgCUuWQ+g6T6+DHCdjV34fVI6wSgS8a/6P2aROzFqRXB1ciYxM0+8sFp8eCM+qOBYljMxmxscuFhTxs+J6g7am63Lwi3lIx8CJKqiqruJVU+8tyOhKOZAIn1LNgwyUuvtcNY3Am6e+sdd1pM+Sgj1PbdIupUZPva/W6yxV9y0M+X4f7DRti0hqIyzozQ8YpBc5jkYXFj1PUxThRMWp7s8tBiA7dPCq0x6in2aNNDrRkhf9j88bH2VB8/XtMxP4QStXLYyJkhb7mjzcu9tiAkowxK8LqbC0vNw/9VoNHTXJgT42tFouoGvYInnoAgUPUgxIRofKPO4MpOztgAJLfK6CkBNtZwD5Nlu6O9m4OSfRH1a6/6tFUq0xCZoyIL0Bk3t0o8roBHL+Mt3htve9aonTcYsdodmRUTa+fg71gBqY8emxMgqlPMeHETAlf++g96AfUiacSJLu3IjpWvDh+32QjuleHa+oAJzefqs8e2PORfG6qI5mC9FIz2orug1kleEh/FFb7dyGHDkMFQerX6wvx/9T3Y85RowQV/0uwxAxIww5yMglo1APkpmbNhY8L8Ss5HRNrsLOHlPYqGnv7uZmjjeZjInN9g0nr30n+p/qfmTL2iTM/GABJ10/LdfKiejEWKXhL+tXSr/yw/qHwWGe0pWL9/3/sdG4KsgZw3VQPQ16BCXNpgslHJ4lrVjAnNZCL3h5wt/kZ0aqQu3wXExD1qNzvpUMgHlmeyYVXb/2+eshyuKTMavwc65LhzjjhdGkhE9GycpDU91kUJRoFxyHhvhALEMReTIl1hXj8zO63DU7I3Fg/5pT/ioriUI1qGUa4qsWygqjIUMGc8ExJAO3eXPUCHjg8vjvlH8Bl7OZSVnvZhTwNTzj5mFsUhwRR/Kpd0p+s8uIUfTl+3Hq6rSIvyYq2uZQPTYR/TMDOt0SBqfpPVdqKCD6ePYQ92EANzvnbrmnZ9kdjQdAL50MKtrh8lOGojRTlQF9XGrxvnSMHS1w3j62UDgXo9xCjuBhjrr33DZjIShcigBEMYBOLedF+hgYhOhl6l3GoSQDAyRvx3QeYiyK4LqrARY35Onb/Wp55hOXk7ryi3VMTllJcZK/pm4LY/ubuBjJydsvN0sb2m70884+pMq6ZR+hl0HoJzIaHdljJT3LpndgAwKx2/FkSUXqsvCaTSqAh9Kpz/grGB6ADGcLyIrGTIPfP3H6GYlgm+0A8tu3AqABvJLteK592TPxKTzT+ovYNk/XjSQq9+soKrrsr7ItVV+10PMSuZjyO0hAIdm3SiBZBy2tgCLa3bodeDn1xWqgE9AgpNY1PNiu+pUTmx+JcDYYn86oY5Upa1ake7UhNndEPSzK663seywYQEJYNapJBVb2IKksY55DcqCAlka5w+7oQaR5noQ6yqefJmQWcuYLkpiYI0lYTsI5pzTS9+MVtx5F/xpUUKuFwfqA3bk4K0Gme4KjmFtSpQDyI21Q9MSr0uqlpDnN63pjBYK8ZM/AjsxJlfWrcaUW46vbCnWXEDpcL2mrkjl9SgDdlAG+al3oPihOSFXUWufmDnGoEpdjKFXisztSNgYqzg80JdZQtTgu7fe3nj1t0jKJbaw1ii7NA6KxsTdFBM6yDeUCvooaOvUaIiug6lyTv3gf31Oq9U+02NPpKzayYtKr9n0q7ezTqjwMkJ8KlsmarstqDsg171piFERfwfYL/oUsCITzJ2u1niae+raUeH56AkgfMHlsOjOm6l+/tlz9mppMuXfn/FHngVJUDeN1qh/6jIEPqvPbtwYHQOuLMKPDSBElE01cAZMLRUHFJa5uWkwCAO3DnXeFMKRt7ODyCqBHN1W4EVhJNlSGW8d5ZLYCck61qsXlOHTeOiBMDiYGRl3pMBbRetoyyvksm9Oase0gtCf+CjzDn+8MWrpAdHQIHqaMjGsK7nICo1/JAYuNln+YJL9O8uocPYl4PzcME3V50oObLoVHnngPwxy+HqL7t+ZslvAysKJQRmWOMP4KUu00e217JjiVhR9VmrHeFLdJYYr/Ju6Pek3Yeamd75hemrnuFxzjwDDSXmc5sKoKcUavuVAgBTinYQ5t9le2WPeZGp7UN4l/1SVJKxz2Lb+qZv4OyVleIhAkf3T72ViXq7Pugxw9ao6g4Aa3E3GmWaR/fcvUWsVCPcB4ko+OrP2TYbl9OWQle3ubV42A7gxZJwiSh3D986Kr2Lz1WRW98SgzJq2sxbuB3rTHyM2oYbI07Cx23dwHUgYjlpdz9Noocj5Q1jouZO3uVvNLmC55jWYQM7j8oHBxTwlthenznaeiznWqQZj5N8gM4ImV6zL4d1GlS1X1G+aChdc5/ku0WQClRPQhSnd/BZ3hX9tAQ6SYYpz8HOQo5i+bld1oqS/BqTH/KjRtRB3pcCTOFPHthdXAN9Gf4oA6iY1YkohYabir0dPhNJlVH2qAgGrGvTExQmvf8t2hh1YImcooZZKVeQK6Gul6kZNeZJzLth73DlvC97bgU8PDN9/WICwwrnnrag33cRxIglVqq/yK3cR/3xeRKNuT9dn8O42KW+NPKYTaAZgGTBVMHTrl1D0lIpxMa2Z2v1zydvC88PHAAcudC4P+W2t0D4n348kSuoK7Tb38twLJkFAebhIPKlnW8JmSsYpR4NOSiBZf3xjQN3ZJ3RFqv5xBAqv3m9qvj60DQEXrq1+bd/oNXySgOq1c4l3DCiRSHf0kGo6DswUQTXJ+f6s4FZ8TCVS6m54on+yuw6QiVLJEYZRi6jcHV6M7FSkbiuPkNdXDtOcUaESi7aE5NhSBp1fQtCsI8+f0och+vpgn+EjcaEn4I4d2qkjQQq3n0Dq9UJYLJF1LndUCXyp8jKQNYllj6dMYMkHnqeon3iZXk92c3wwkomXDv02PrKGKTNDVpAn++V4CUFX3rBPEInblWTp1/XoBexgCRrSkAt/4TDH0+VjgD2OhJFRnfG9skyC9FxP5nXZ4IjWQ7Y+WXEpZ2yBgZtiw7z41mKe8n7TRAWTP8xLHIW9OOyUcqIczRTnuH2l4bwD22G37qeKVRZWzF5bw0jIszS/ftDSGM19nDtteZ0u6JE+hK9TvCA+d/BOxD64nfTV0DIUZ4t9MHf6Sxg3Lf/13WuiEBXBWjcEnpJiAuIdcRJ80JKd7/LxfEqANDKZL9QI5SCc/29afXqc6SfoMnTC6z1NYorJTt/HknYYiEqfYUARQ3bw42F6Dm9NrKGn/A9lN0PAV7pLJb6FaeBbQlQza3kAo+8NjVzbzo3VZZdc/XSmE+H/N6U1MK6u6dEa/7Td659IKFfArzVinL2FM26SsJ1ikw6DsqPEoiMF07bknb91+yr1XtQ5wUtsY2tSUgj4wcZMwsB9H06lRpCGCDO2mdwGk9sHJmy+p6+N9vUut0pL4qURx8Ju5z0fkSkg8eiTUxPTDcE1jVHycQYheGJMFhZU3WmEVjRBPyHJYlyHGvXg47aRBMnAs8esMgyb03bDD32G/0iUhZsxFjbV4/PSGdx3UZwecO0NEkcRpHX9SFfSpWn8vMuV4ZElAHNG6RPgPeSVumLoPO99goTWbynOBl3Wni1yvFLx/Dq3k75XxQURVCddq2DmZ8rNnXNEcw2jA9/bsU1+w7IwDgEW+B5f9WYztV9OTYh1r+hZJglfRAXlZfi4rgZ/2V8nDebXS7VLF/NN0X1ib8MsVLTR1xT+UZpnvpvRpDlF2DflUT+pANXk4xZR+dwU5qyrQHnXdTZlWAzKBNSBp3nL/86bYZs4SoYi35RTXo7BjjqMMkIrJKaVp9FfjAzqwLIysQGu2FTr1fMjkE6UaGenfYF3DVYzXhEXfSM1WGTCL8usnq+zvUTwujERjS6zO+8IoSgCnNl85Rh6oH6DCMO9v7dTFvwCN7oYXNs0ZkeBYmg34UN8rjoNxMPi2bYQ1CEnSwqTagW3Ph5Q6qU8fRP0d9ejA1FcngvwkHYbm/UmT0S/LCei2h3AZzHj8hC2416uLdx7T5iPSUzxRlxM7pn9gq+h8FVnrIaAZQqAgeqDLDTWnCMuZx7knf7rDklSjfgNWxeuqPU1nLilWo7QEOV7VIkw0qI0MAL5dH/Wcg46K2bww9uOGHhwMvIKOa7v4X6FNiw10kBf07EGuO2LBfp59NYAekPbf7YKU0372KOGS7hNqQ1TicHAfdmfH44kwQX5VOpPVSDQ3x64wEdbbhtBnid4gyB5jCvbw3D0bXCzS/uvbTL4SNUtUROUd9YL1bpAhcFvgBvudupKixM6/uUajH4ooP9Y55TDBCFDCMpYRdV/zPBDpdlkDFEky6diim47YEJk/CdABkEPNTU4yAIEJs9B9xQaESHuJIoM7Cfd+oIqde+S+SQpbJ1VLP550t0D6h25KpRCqTJJUWYyWvtGhPhuFgLBGDvwckG+9WjnDdgotYP2qCW1Ov+qIq6BobVB4QuEDHMMBRtB9kQQW/9T6YWvKBR9lgalub5RkvydteuJ9OJoqk3KCxKggjSN3VRrsvtc3h3e4hw8dE871O5qPrKUW6rrMNTgQzf27V3y61B6rcCi5ufQxe7nV3FmYm0fqgLPgkmDFNLRoII7Qun9ZGb78FupLCDS80RsqedZcJ25U2jcl1LBonAGY7zAbIElUTUF7RLqa0I9NrQI8HjAseVg4Pwg7xOQoWxiXjDgx7ee3RbSIUGRPugPTTJUhoG1mUaC+wqq6f155hcXTk69wqSJpA8yehwuPk2Oh4/QbMQBIMyzL5QltnMYJ3MAXxUSXRm/xevZ0lekMOBSIliJnKC1Z4ZnaVMLhLVePLEJoAD0jpFF5qxcGmt2P0ZBVq4mQKHRS6Tet4MRUNefQq1lhSTI5Ru8E/UGFOh5ij00arTfidVQjE/zScDP9rSQZ+6pwlQUoOPk9W4BkpJNLtw1R5n9xyL4xSXYX3LQrtM/h2quhHNrhkm/GmsNawQ1jQVpduRdeXfgUAcCkr0McrXrGVM1wby9LV/97QB/79vTLdR+Ht9qcmWc5mlJhCVmvpVQe2sgUY96w0KlK/XrkfKHpHtV3cYC/eBDPASJui46nIwRveEcuBCjaOMhoAeKj3eKaptwZsYtPn1Lmir9GcgH/M1hWyOBpagK9BPLyJq6ieUVWAHp2uuQJjOuFMFCQxP5ejumeVFlz3y16p95/HdAH1efkky8lNwRSMFnqtuW6KxdiJlBWKi2pBmia9ol0jxlKRdLvo9kzxsUHYLp0/8vwILsKRfjOPZVpULp77T08C4W4fDn2JfwN7Lwr/vdzfkS3wyleCnRpyjzt2PafMu3DAv/wtK4GCgQuT0/EenlLURYnMQkEu++b0pY9rmRYwn+V+ZJdDm9pta9YWrUs7sRmtWNvNIWqN4Fw/xafZs+p2rnUbanwfTBMmyuV29hMTeTaQMTHMULn0bjHb/98S3wBvxvCrpbVHGUhF61zKEj1N9l7SU3Sjg3KeQoIL8VSdUZeIQJiUMStcfBJCZMvA+5K8mv0AED+y3sLanSWgDFtt6H+YiMQZThG8f/xT02deBwNMoeXUiJk2kC+FjhIoIhk8HJkBBwWf4EtOVpuVoHOBZBz7z/mYHVNnE8ksJFK3n0lFRqFtOlNutby42bq2nGx81QfrmXH2FlXDwgCGPn3U2doTMgqwrbuSA80TPZQMF/tbkVB6GuhywdP4N2OJADCaxpw1be/f/CwFwN3gP7X2IW2Ynsp6B4J9ksahy6fEnqGJe+oJAubsPIRuZYrXbwHhyHzhehL66o5Atl2uzNBo/l32hQ9EfGzjUWp8G7lgqLIcoWCUf/8D3f9qUywz6wGgXUFViGZVtsUpTI+j031FINnoOzEv1+q2KH+QVcpVlywVaTH4W+vhC4ZVQdtMHaiNlOJ2vkdqN4UZ/ka4LMAel2sxNZnlGmVOhOWS61mrEw4rOZ3Z4upvDTPq3UEBKHzU2O3e4d4dwVRvkj0YxnBwK7xWxhcJneKOl6EH/XXCLHqRGLbNVdavrgmrgwYlQ6MsbZEirO+PNV05sR520tumYj69JqqIWUFxBTaOS4PfI0Ikx3gWgD70qUsQgWwC4zgzfPgmSKmvHp2rtUMVJDQwjJWWNOpTwd8l6GRFPW/zTINUHPx9HQoRbYyvWz1j+DAdPnvcdKpQEvhIqa43LK5tvdV9LhfRxLhMG3O4Jaz09nteh0MZXlSnC/JH4YZFHpEX3OHQipzWCq3PE8U8FD+5/4JhMp94DZkYHTTirdxkffvMFf1SW2AWIy91kgH8Mash8hB2mMs3Iy6QaLQrDXLOAR+OkBdXcCzym1+vnVkHD2/G2MP5Hw6Rhguiu1fQZFpnDW/j5ZsdewdUpbYg1Z8MZit/FeOwFOXk2Oy1PzBWQL27vtXzIfVRzx8IvTVymLM/fcE2l8hw2EnbH6+bbxT7+Xrp3EnmEfu9PZa7GsbA/udQE+ORxiWXPunr0LGMcgP/tVb0n89qD7i2lm655RGPZAaoAAoOzkAhOa4BaDKYTqvpAXYNkMIRN4+hpNeQH2XfVkQWJ1kIz+f4WIN4lmuM6VfOb95fLdgKKKhfO41gOUbVR6s/CGkLXkY+mLKUQzxK4Hr+QkSCHlPiUDDPFAt8JCm19UhQLpHyHf+jNkJmWwzApgyux6SykerA5wCMBb2vC/peRbXLSSAHCstqlplpGk1mvbUZk16NM7yM2iq6PuQEyXeO8V/5kOHVJsT628H+S+54DdY+ElfpqRAeW4LpC5UGeD3LRF9i05UrG0UQOhNDrf0pnGMvcICyBFaZ4QjWp/jETcUX6EafvKkiXnzcx7yuIAil3LDLCUkotNHyiLMdvEWxaM2mSaJbODE09BF/2wupEknkR7/BPBF4iguuUoahjcHzvB9LYoGg3oVMnfp+V77So7ipAL1g8vcUYn8a1CaSbF/LRhmsDOrXyzD0oi1UhethuynaFZvvWjfA6yj01fjaaeMRb3uvJXD+Vx5X5fulxVd5W1XqEI2xTl8BxJHwwim+tz1Kg9t0rqdpJ5WhUPzQyv4SI5QGO0Bh2XomKmlngsvAlr2ra6hKdgrTjCHdc/9nE0agP7dmzZrpaQyG/3d8e544op+WVVj96q9eo92BewJRx7HZQsUueVZusHJtNZQNgsYA3mNY6fbseTjzaLPQc6Md1R+o3w5dhDT6FMXkPVuk0lwC5tPnD27Ak+gesRYjz2RANrYXSoztP4CL3jzPN9El84wZLa0mOJWbwKcR4Rxm2HhVFTlx02Mab7l7SpVTqDdfedwDYU6wjflZSVXynRg3l5UJOABs4ImoCeQU7tpn4HdLlBDqPDHSefvofwJxI5cy+qlQYCToX0/t2JYAaNrDSJkNUG5sPouQR1EWvxvFRjAZEqRHlKDLsREVtOWhRWFD4/JDsqhXPHn8XaxHTTjlHiYObbC/suBd8xDDynLBO013WLRmxrV+LFeuuSAi5fbGshagemRv5L3miMsJefbyqBjtSzsoTbtAoi5h8gICkfFIRM+zBW6bRAC7C00HeWdO1gam3uwsIKLqvOkc0+9Iq6SsCjR9H9GwSJQUqf8eRkHp/kxDwaIb12lTQmofKyGBeg1RwJuW7jeSdjEUJIEeiggUwf1DLhZHYVYV+l0IGVBVue5Bez0slUaF0qE2BrjC3lfLMrylboULuXgnDMV4gznPjDztUzmSQC9ZhD8Ac+1tl6U2u9YhEv3ebqyK9v0o3v1Ral51jKsfXdxlJlDnBIiz5IT6IcuP9r/jmHA9XHKKF2xVKxMAQlhaD4/n78XrRdGsVteh1K0E+a0DtngEb9aEFOON6m85tcVtkcUbwgBive2q9BYTiuZLE8SHD+CMpeU3qOtlq+8G8tcXgVW5J+MRDlOaZJya5rVAA16j6JpWPVrvdufG/nTmnE4OFhQqWdbS0L2r13Q3F6g5Jy6keBh5fCdCqs9RPWsarmxu8MpdgYozycBvPiIUPo4ixyUQPPPijA7mzwFb0/4riEtMmDOw6lB6fpboMqtCIUhEjEYrbVBWqtt1ALIxLXsedaLQsVPe+1F3QB3XZ5iJqr3mu+T2uf2WUem6wA8xPMrlprbz9PUHlZAcpC+zLvRy54olUq5pwmNwPH9KoBMLDgT3F7iRs0S6Vw3pWQmEQWJa3GARDwnMbjNAjGCnY4BD5XmrETEawQUEIsjHZ7hhi07hX8C4x0N3m7B/c+vaVpGKWxeY+bBYISGYUnjbLYCgrBULKttMgzrhn2qJZ714SBZP3DAvCTNzgCZ+PKwg2qtXPD9PrHnravOs4Ip5vQkm0xsS3T9BhBU4ozG+G+tOpqMKI8VQzietGFUqxaadbU5oDimKYt8V9F36IpCHJVb5xIFmkPu/kJ/erkAjAsBbDKvuXgWXcqq8NQRDZ1UOw51Wrw/sKdgwBHknBfnEXo8wkePPVrXFpVrJ6CCqQOp5Hz3YQ31xidUgYb2W95AWqabbFxtTpJ3n77WIj63S5EhGjPr0ATBFLjahegxC4CrzwgpQ1rT3yU2CpQwOtTh4Xx7U55/b0UTf9L0HIThoNX9ANQWjRhnNc7/s1fohPoJ+J3JCCbuaCaoTQS9i7CIrdBXS9pZF/jGLGRd4Ebm042IABu1FxdSpcadcLtqgDe1k7duca5tp0YaWWOidfGAVQABZHhAFez0/h4sKzrkgUo8SIZQscs22tNj9OAq7WJTle1Q2BlDoTukrSnva25JUQs8E2d1QebM8ykfetRq/HNwb04/1JPmvSB6m0a7klDamtPY+c5XGMq++fHZetJV5zRjjkoAspWbg8lXeOsXQ8WaGgEGSsbtA7Qi3vytffFQzeGebQbOBXsk1wOoAOKytCUeEUbFvLHtb/fY/UChIuwn+nyCBfzRHcUsxHPyWTD+8Eavw5zI9RMpzva9KWpDZRNAUryxmeYSX4RDPRXQzpnlXnsl2dxgTMAkbm7nvOFFc8rQtvXbmxhICU667WDH3isfwFiU+/QL6ER+IhBJTGJsu88sWgDJr8qQ+h7fYEmwBvZVVsX/LwhLm3O1fYt6wnck56y4LzWb/ynom6pV1g3BdUnC+zAfOGMAp4xZlVvJalaRLY86vStDEyAjv7CZ49RS9BcUo6ELjdsekqXD0qhbWDZHXfuMuDDhWW+Qz6DJ+livdaE4y0VDpzWqFn/bdIFF0RpMIF4Fkk06ZeBXHF247UZTZfL/hyebYn3bEwFzaNEbshALFgndUr4EMdTA42xCBhs93NahvQtN4z0WvbdtsM2hzdpI3MY0b0k3ehok61u5sTOSW23ymcMKi9CZHzTlAK15+1PaUPUlasiuVwZOrxLs+HAZ8EPY9MKatWGFKcVGbtjuWwKP8g6fU1LCFZi6+HkPwlPmhWNG+OPdNCW7C2Yl5eN2odamYqS9GH+QaxTbjgMP9nU3Sq+RykTXhRlHtn4H1pm/M36L2kYQvhhr0aWDoOE1j4tdp0+26HGcHw4cyrph4MmqEJ+I4ZIjGIIwI6iQ+DKBk+AV53AZv2T4RX/UbQ8mrFeeonCAUYa0NVwpFwqT7FR6oCV/qHI1PVplKSLqu6II2OHsCbJrpT2hSVjWaPVF8FHrPYZgheovOLSva1L/VMImdi9uULBOwjCejWJ1ZPy5sfBtPCVaoYE6nbVDqpA5+GsPjhotfTioZ61stxH3aM+y0dSLp/E+Z6QfTxFFVzXwht7h7OVoYqPHuNuQAcgYDI3LsfdzYRdrdtCGCDnXGuwdwqwjF0deNDuIcOS/Gftr6Db+/ohzzsQ9XaDlqFFRdqfq9yHUi/GJDyG0vfuO9JRAW78MHvhG5Xlsts0Lg6NeofQ3XccygG4dxxJmK9IpA2llGxhi2mXHNZAeRTnla8AL31SLXKV4JUETLx2FFc4hywrRLdFn3t75QNCGtMpmkXot25Psjf7vmdlu1cnwQlIvo/7LID3s0V7eZwwIBRUfbmXK9gK09cSusYDC9Fn8o5Yg7Q5hVc8fJpuMdHwaK/VS6+Pnrwiv3OAxMCt/jRK87FjrK/+QveZdNMAu5X33sz8XH+bNHIGFpoqdizVEp94k9ksPiwuMLzab40NyhCwVrsRXHDXjG0ixSah3Ghas3A5TTpbqSOYgjA/UEpa7lo4Rl3iUF3KzD5vKoYDBKjQ+T2mfxKN3E2pRNURT0eTR+KG0td628g12SKF23rnPvPgOp/+rPCAygYXhuLFRiEMD/2qPygpkrks9Xnq27O381onaEFeLKuX26JpH904a/IiNSk5EybfMGng7/PFJRVv6G8A+3ecjgF+ZtAMHD49SqZxX0OintylxvIQn+XZXY829A2faN+olD9L2nkXrrNKgrM7JDw7AYB2xbOEkfLiG4zV9nAgv71qg6FCJovew7ZtzU4hzebHyDu7y8ZhP2bPBw5tW9HR2yQEwl0UCfjGVmy5Ss2YXqdnPhHRbozessBt7JgFV7Uc7PI6z1Yr+LJ8wwQZpJhWO3QVsWFgPRIQS1eMPAvSzsJbDJBgD/uoQ8xgYVMkCN9tkz9CDHHuRfZ5t/qvGm8f3CXha+1KEziDeU0c5UR2EEVBJWFRsykqUEhIkf4PoxCmOX472nDW74H+fPGbGRVmSFwst4eC6BoADmWUiQluAvja5x6CZB11zAr7zp3z+1mNFUPgjGzGj30bQP0lhx+LaOIyY/g1OuM3DSBXChlwlehxFnYbt1j7t7yTajpoPcL62r4vqFJuWj+P9KbRypsfpPSgG3M47KGeU3RRSBIT5fEQstzl4Yfgzrr+XpOt3VsoZMuH6zl+tMfCvmZ6ucT82iSodP4hubrTA6+WaAM3D18MU2fIJHN2mQRuzG6AgLYnd+1tjUaLzwSeqptWtMLzshLnEtMqCRmzN9llqw0v0ECcwCQwsbyv1gar2z3GuZbZB6S1WVkHg259OssPBztormMufWuk+E/6WrU7VPR3x2W5cPX00u/21jtEdSLBR2BItnEu7uoBzIHxRu4Ke+WR6aIhFHDB+B+OSJVR0XS2NoQfafvSuKEU0gUg7BLB0XlZwYm8PR1LHUQFuJw1Qpia3IngB5Zkr27eTt/vAqczpi5KYYN/X3SHVN2h24zNXDaMHbG0sPhXVpY2X7NOhdfdU3u7CKKjguPngaDjYALtlYVULf5G4a+bdfQ+G6CZFAK4nkw0D/9xFHIs7VjQn1bYFML/1XrW34QTM0jmArrTAVOonveT+AsmG25x6Ibycbt0TJ1naa5ovsbFO+XDmq47k202dM/wzQ42C8O+5/RlS02SRiRv+inSCRVSfQve0VlJyj1onEIaotbBx4uMEYiiPv5BIlNqI9/uR3MUH5LHARwKrINtnodE/F3CWCYj0aoffK4VmOH3lVVYT8tZFO0Hxr0D2ieCiNri4CXc1fzBZ+lzcQdTJxMzs8dSLjqgOZFf19DopMcFsDDhT/PRAf/YdPiurpzaxME8Eu4OIsTljzZDccZmWjGvEO87jBUW/4I+oi31KUwuXQVVCuNlf8TRJw362i2CtOmYZZkDsJQF6QGvQNVJFTEtbicoUMydvHr/TSEqotpEYk55l7Dy+C5tfeYVtgimxBRm0ZyTZMMkpTDCozlVrhYt+4TeuWCY/uoMUR0+i7goNSIsdU90zb0quboCloB4GouNKRymbwDGeGuc/3zSk+r2k6BBhQFhM9IRhqPsUVk/Vw3KxOGHTfGpH4ZXzq/CZD1Zwc/o+s2FoiwEBu2qxDU1r+RJT3oH2Pn2PUPxwqvMNccG/1jVq74h/5TxZnArmpx5IfcIulBypjcTdasl8Ll7ay5HquWExk0wHjLgvGt3l8srwYoDdT1iq+imZDY+OKjrm0+7ldpxycZ44DFCHcYxKWfvX7t35PntW+QoeL/Ognua7D+xhSOfCmxHBC9SkWVjpZtKWJCXl8kLp2MZRyvATOCmoI5gArV56kiBvgBC465WpkWZrPo5JQrWIOXsTaBzt4exrhsKBgJbfY0BKvPZAfMcoNmb2W87bAr2GMPqm4itFwRP/QyfnYNjdVCa3tsOrQkKdbX0MUfqq0KTeax9Q0RJ6w/ZwQC6Sk9ySaFS0mnvT2jUGssDi7xlNIYwaM44N9uPCw7cgow3BiFj3vICQkvydc9gRydTO+PviW6VKRAGdHfh12cRmx37sRA6OIP0hUrw7aXlL24zER7BLI0aKW/6Mc8QZtQk/pRuXrvCnBCvbeZSKO15KndQOyLb0lBD7OKSqlK8ALg1dDY4gpYDsEu8ZJNRZAHTtcbxQ5F+fmU9IPKGua6TS7eYx6HmUYU27ZtKPHrMNRjydBU1OpfBwl1b6OzHGfQDeLIXy0voO3ooYnqGGSeYeVXoAAsLgbmpR+6gukMxcM7VIJ6eeOHvnLqbywqBunIWbPvt4S8l+jaAZXakPjZr1J0j51tRHc8KJfQVx20hGm7Vc5/OTT65zSdydbB43g0+cIE8u3i6jMcAH9pile6Yj2P7vXAjCVWGXQYK6KWfvNRPrhSpay49xD/vmw78Ce20452z3EXVkKOZJLZsRYbAj50ncCZ5klh/wPe9caElHi2EB9kCzTXbxxDzVxdwlb1sro+qX3yzbh4rhGtEPnPmdICMdAHHJopg6YTr2V02lpiujg93bVFsrsMlhMWKViisyGpoQry/0GKki8RvSHhfc1RUq8RHL29B0BqX17FMke6HglLLN5Pjp8YMJ2vQOCb3hgiWOaJIdFc9A1vIno+Hv2JvRf4Vop1Cqkmd3z+NClRwa/O2StRwTLpOeUpjZWzHYesvwh56wq8fX2IXoVkJCtGVTjiibpLtnsApgGsXzaQmpVhpuU0uG5LcbLYvJdkGoWJWN2f5LNLn3htkpK/bCljIuB2fq22+x8qrGHI1FAxoDUBVFTJ7k3Lfs6dH8rlkRXyoBPKcz8M51wRbqHkOMj7oXsxBAmLqKSjdwDode4mIzVoaDe8J59jCSwihma5EWU6LOJQI1wooOPg4Sf69ECRo/yoca48x5dK3D4BAT9ZgpvHaW35iYTAjC32ffcSW0EXdSOLyn168+G3xQaGhKc9DE0VenF8AGQTPIZ2O1KIIgKuEEBI/FGwGC+x6zvpoxZ1s+pPI1xdHBtfVsbtT+vj2q8J6Jj7kVM42UoIsIUyLBe9IZWg8kLROPXj1tu35iv9GoIKroPreXWkopon78laByYbb6s1SlHixgQRkAPSSKQYyn4gEZg0mNOvUctMXGX1H/o4nNVGtwT82VE7JIL2YXDlaAbOaneMMFg9zaKtebe1Mxowmaj5kI2zAwEZgR4RpEYJNqqLhJYpgqVij47K4uh00GNbsO+uAbDuGDlawSs0f2dysWtoP6zLKB/qXwe4xuRSvJgXsorw7ecL6hb3KgqJr3e/vtYFKfAOALlW3N3tjnPYZ1EiXRWEH2YUiguM1ltBPcub/DfDlo9fnF2Ob/4GFHfujlFVG6i785vzu1Gd46I/o1RuvNwXI+shhoilbp1v5WW/6i/0Y1GOlsNrQmJ3b0IZt9UsUjY+lxG1ZAvJbHEm/8MrDFYzzdc3zDB+jM1GMjf1fKlXMfzvxkPIHcA27CqGmCgfap9r4DxQjDYZ96mcrmWYs/Hz78blhrYqFlyV+ebVaeMaOVtDxrgksUv5pfQ74+bKNJZMaN7iilwcUvKPM6ZZXlKudQtKR3TzRoKv1gz3FXGFonT577ju6LweqNfCW2Kuf19nfGT2dPGrmwgf0SYYEdszMkTMdG1DObbkyOilDS3RRIUOqYjy/Sg0nfpmgyVOuRtnFzVEx4rBv1RrMF+cdAlJcc9xu9zwCV6TRcmXVxaXwgSKU66ayzz2QlOFMHiPIw6R4WM87KPZ9i9kn8UUTteTPnwGIko4OVxWynP/+JNmRVD7jwXOWDkdZ9pxq39V5uXWrUrzPyk5YQv3+U+OGWhZ0KE/wz6oHSDbJs5IZk4ACh9ImSTjch4ajxalBZk1XS0fM+okcL5wVSR7zkvqnqgSNpg6waw1nq81zCJYsMcSpwu1scMA2K0XcahfdVnQNaFrER+DXUQx4miJ+FYgZ065q1E6OAGBeLXTONLCPm38ZSXSHixTKrXClybO1p1RXzxFOjeONWFo3H2BS6TwhnBV4FfKwa/r4BAbp/kaNIQMgnZkRJLbiZlkKOlkKIEYqusRCHIjMkwGcMxcNa0UPfFc9+3hyhFe3BphL3ptFzwnVvFWnLM5C6nDZ5t9vLqpMaSKiRoBw2DyDaWLvZOdP5yBfFvrgYUXZSerLiC1Iee8oZ+bTHrBiIeu5bKrPMCkc2J+ejEp4J+1Cf6ugkBtKlRp3IqD3TiPRzeItRoti4r8ifuAOpgL3bd83ljtM9c5AjS9FrsjkQ+DQIozn0/iWrdeBedePGf1aHAHLGSKkhHzogTtLQsoXpAQvjCXb/phXkZkfDTajFglkyPgux+ti4UHPs2DLhy0iJfaM/92+uIWxDiSaGVzzqc1N+3/fIDB0IHDpK4simc6cx2obBzEdFz4FWqxBnzEiopPOcwp/zsJU2+pgYQgjeQbK85C/VTDWS3Mg53I55wvpMmdONYNLE/TpWTpgPjTTB8TjwReVeZM5WeKz5tKbvGRGqOPd5YwOqf4e+yES7G7pXNYL7ttR74R0J8/sqy/V3tO2Rzz43J16BtFyPZBm7dB2YOEk2dmyRea8F5My73/mIdFL8TDnX2V0tf7cx7f82siDol/W/JxtS//Viifm4BEOqAHRkXHM74KgqmDWibPZQVkywiRLE7dhJN2uL9S9ZzVwzqDIOsGeCmmZB6uRQIDwTBO+sFhy019b6BVNuhA/W2Np6TErkZ1LReQ6Ok/C1Vpp1KsQ8oUoMVQfh5eoPH+s0DqvhCw7VR57IMK1hXVKU7E0lPyuZtvhl8ZqWReyGpPEUa/5pTPtWTo0LGHgQS16eIllUsDYxwcUwbfzN1951eZ66CQohntFGEJ0j73WBmiXKE8TVMExseoqDgzMm84I5OzFMQpWrqs6oj7iSgMUU24NNFm8pYoESMxleytHmaGyRQ87mANNFuXdaJuN1hZOUwpHX1VWlsRmKnum8wY7P0yR0IWlwio3J3YPucDw+h+LBfrhCf35dr1G+ar+L7pLIwOhtB94J6UtFqDrcj11twyfBD/HgCFFK5Wf+K+HadljpCv9V6Vslf38TT8G2nwa9uRRvuVyksopy7sG+wK9tzgSkluHODOVHRah03y3OFEYQ4L6Iub0WC+Lmv0emz7clPHqigZfJOc+NvSlZOeyBVY+Vo2EELUoEppq1b2iKzuAWNCYR/0DoXvOHjcgVAFA7UXauUQSM5DF6NcZVF05QTmRCKi7kgvfYvK2jcDq+X+tqYPRVtu6k/yFi9lZACZASVVzAKVVGYF/AavXGvBeF/fBRUEabIlVf8wWT2TcEpfKDK7Zn/FTyPOGo7SdwDwwBZ+KprmpMGcPaf0Ioq+oYr2M3/qvgN4kQjHmRBvMAsqNOgY8JtLzCVruLy8bFB8ZG2h7IfzBPP0v8b8Xzns57Dm+K6v0j0HEJrm0oFmDecv9SAm6icDsQeUEdTrzfQGRLhIvfKmXmsC3ACijLbG586vuvpZX6Z2IEJAeZqZ4ZhH9xl3YF7u3PxyR6/PtL5COr02IxY89mArp31X/DuUYE5Z19RXeE9MxKhPzjsLKQjxZq+/Vh/gUUHV+QqLO/wyzJ1V3bmcn/+q7tQsZFMmDZhAZowOLFIn4swSVlkHbq0nzZOLNwkAdyXUcQ/rqgjI6SZVvDpj1/A6hCHKwEluQ3n9Nsc0Qc0Yy6R+YQKfqMvhjfsGa7hDU/YydnoAUoVHgqHykNsCt7GOQDOck1h9f4MmaCUZ3sv6ZrKnJ7D0AtpjT95tocup5WdiTRo9hxrAM/jIRxrS/hyh+zdeI80AHKCHGw50BIQ38eeiQ0scE4p+lkohs6ktrS6zokBXianyLLTB5UhbIqHjnRqZqzC8ZHALoEvifr6oLc7g7hrP37wR/HwQDPHbMJiOCGj9fgHecr9EOjrkFrWePR6J8TBTiQmyT8axgqfB8vl7ugMAdBAQRvhw8/ksq3yvqdGHMJ3YrHehhqibySLfSGYjsTGKtKnzpJt6kli+CtyoA6hi7XAuBfDkYdIP7Nj3qIaO1+hpfbK9DfJ7Pgd6fVZX4tvNk9DQ9GEA6r+o5rn9OR4lXCG8K7ujlZ0S75teswnsBrXq9v2HNWFrwRPx2f3rfYwho8SC76rjCIWJIzuVfsbbe+kW1ozyzou+rCbYC9oEMtwb5CDLOCaTDbtN1PE3HwYM6l3u1yX1v2L7T5bKnUM2xp+/a9SzBkZsAuF56V6U6fF0knJVZLxt5EU9XLXBjQu1tvDayJXT7ch+lYq1TPPSsd2FPg5UQ1Zqz0bEx8xChkS7ZMa7Jby5oJycmKTW3dwWlFBjYXsOojvCtkk2XPLXR0ilNo3OP83n/HcoS3FVAW7KaecnqnPUoKRNEGPaQf25QDnMHL4UwOq41G7IsO7SLcrnVgWKYypw8i/64MPX+u0AJqWcqZwJ/JjaSzoDWt85wlejRjFyx1DaCf8SXrcFnzBXl7d7Hoa6c+aVERLslbiyEW8t/KBkqCA4AhcQKEmUClL1DZXUEYEmvORR5HUajSY4tJ+HKgsQ3MhiPjMnGaeYz44g/LnDKleku6QIWEKbc499VaLqOc2fIZPfgsP7sPjrNUcC6qkaxlX15EyIIgpP90SKogwv/clpK3HTe4obsSwy4apbEto5rs72veshsrxQWUH33mK7qqWwQgbaJihjpIt/mRW1CK3Tno9uZ+Jdd/3JniXPeWNOdbGRh/MWjpWp8WcjkWeZiLMK0IWha3lAYHu+m76qpyyrwEeEkbkyCrp1O8LXsLyOn0yIDEPr2jQ94YYViOxJOlLr0l3X9eUXPx3jaOeFEc3hmpyOFOzKsao91Lwzjzrz7dE/LCL/0UZZNuoipcfE+51uRo+CYhJVnfokmoF12G5gqgcsckCgUrNFc+0caUOYfR1TtzO0bAS2nvhE7r3O7uyv4dQV6FfKK+cpYtJ60ZQwF+4zDwExrpxhtl3gXusDb2vYuaCD6gbcu0v412W+Lk5rF6vy83F2mRvS1BiSix4WE5SF+WErhc3Dvj/8hfz5DrFq0zs8aS8eb2GgWwDYtjFf0cMquQHdeWGtWUJMWhq60yb2kz87Pvug7GMmkj8wSOPLz2wSYQ/wQDow4offszC0Dqj1OpGPLQmrLnTB/OFqIIoU0Mqw4+AMWjETfudMTUvMmQV/ebL6QPSjQR5XuTUdc4n5mSbfgNxT8JH64qmgA1qbtL5tHOGeRp6kQyQDZHA2/xd12Ho+VCb6bojLoc8zY0hgLRCtRlEZ4H0UPz+aKM3LP4FuF+4r+hYj2COJLN0e0i4MuAZu/umcjPbWJwustXzq3XOZytWPUkU5fbqqZHoAkJJlPIBC8Z/SNO39b6mmG/vAnQgdVRbmoThFcyt82o/mCdFaaiAdXLN4i8brMNjFzqqymgLz8kWPH+Aehh5hXxWG1FCHsmIuuhYwYmeQDNJSh/2nUWz6hI8LO6GlP7u6zfFgDgAOspxaQDxlx1Pp+ZCq+IHwt2QrE/7o26xCbmqGr18AI2Odk8Vv2RDGaNVggdAeMI9+pjLODUNxxzI3Nrwf4aF7sYpyPikkmfIVtxr1pTgd0bj0dWEDD05O8zZt2T/C7HdJgRhnpUZd5tiI9bEU97etRSoR8Wqzx2tZbIYSZplFSRs0ghN5gsBH8sYuj1c5kgTGfYxBDdbkR/u0DYjrVQH9wQhnBlS7ZVs9TuOEW9AjqOoFzlGinpOudD0BCs+QDKmjQT7WLiGVoBCSG5A6DRxK8LA1GOcJqX2mEktYFYLBeZYbw9av3Ao0dN2H8Ok7hWAb+gnYssAj7fmYdrqSklszZKZtCl3lkt+WMyO3T51xNSMuKfzMb5Z9p57ymHha50Tp6cJTyWGIhJACOwmMdsRbLVast5SQPEzIiE1ceLUvySzD+/7NwreN7UvBgV1rH5eqIpyILNC6Zjng+PU87C+BRcHlRgJfZpI80KH8EtQWDSXGjrRsDfncbNywD19boOyr4B0zk/7f/8My3NCC65H/pLVt8TcxW+T/DFkHyhNVJkGUEfPBIG1SUrkwNo/cI+AS8V+IfwnEVVQnC1OGxW+ZF1kZknlLyWDo2TQEFtu48sDqFCcHvhYg5sftky738Mb4vp1Ni0KzYF5edI7LS1EQd+r7smgEl7e5YaxF4MLMbr+gYt1FlJvmHKBfx7bQArsXJyZ0a17XmGC2bmgnlkQeh8tsQrwA+TXK1RalBTYkJ1rP4e0hpctja2+1veKSC6ZHyd/ugIvHWH7+rq4XccKmfFe6xdtldFdNzyeOIetxI1S49SLnYfC3OdJ7vOdR2sgYQ6+R3xTZbxIZ5p/JZ3sOTToUP6HwfW/0R0Kxqvy7vPpyZVqjXbCgvWeR5gacjie2p6esh329MLkMCrrtzd4dd2dxGrEOdP8UvAp+wzdupkHGI9WwfJlqGN2YBeh5zaB+2HtCOC05U8/khKZdg0KmEIdZ6Bk5NTWVKN7LviTSAWBV6gbkJhzUK8a/AMQByLIil6qmB8FebgD6RctTjw2/fWrE3eArh56IjndIqCs52UZtBiM57G4KpflJMNR6MNxPwLzsl12BBaBr7+kAOeJ52B6kcvr6SXrimOQISkmqm3sPBqw9R694GruzdUC9aXTraYdaFjXHDzEaMTpEVvXj1HqH2IsPDdhSqcu64kqEQR4Fyf7t41uo/rsZbitzjbA1o1v8Oav04GvKwLvGvvxGAlEyVltE0ihn5eM7Q1JFb0fVUgu4dyPbitn7V7flWgr5zdoa8i139cwvxQrsd8E/Xi497qXRDtPEVWFI5D3UItLWQwfqPg8+TtA3Kowo4CeDlS3ID1CHHRjk3CUhdp5SC9/9gm5viE0SY+8BZ9sJ6wFGHYgq/JotZB2D7FtW8KKz+tE0ZpfKXpSKAFgyUDUlpwZRR2hu4jop92Mn98TUNqlcu3fE5ohNiihdgY5Iueh+KYLjx/g92vAc8toP4dvfJxwGMIOzQaMw9ybZNVuAU44fKND5rD44x/9363yN/HQcInPAvvCNYMqGjI/YhcsdThAhQjKSBZ2uPi8A8qTuV8YwHzG9zCgtWmXDE/UdD3aOmH9MD9zjdMnAZ+mVxBuoY6Yv7O/TIq69ux84o3AcJ5AU0COgyu5BttqltASx09l6d63VC8yuC6HShOksnpOPlute8XYU1yllX+QJR2tVLeU8aUtsatEEYqXwb+DvkKbLQliyI8vRG5SL/Ac/8Vv4dQi8rKf47Qv+19+WyZ3g41cnxAecVAbxLyW8hIOBhfWlpKmRZ7GLWIqBFBOObUAmhdzNIyodk5/5DVVt9h3A3/5f5icfThIte5YWVYlxUqGDWE7tfiX2kQxn7kyYrzvmwzkJxaPwz8diNGjFDxk9tid8VrydJmcLV0KIobHQtppQKpupGcipafJDW4EhXBpI/IHIY/OdABuTN5CJtvJ20x/PHkGGxIbG2EOOH5zHdKghvlRvlQaJsvPMhKkXMkV7x21hohO4aowjsMgzfOdq7WQzX4H41EAOfMDcuyv05hMmxeu2sb61Treu+URmPGaPh+jiswuRnHej+MUHUc4kpgDZCW1LNgHMWcz7Ik28j+ZyHg56uZlS7APRmwOCbU4BR0xyG8WSLb8JCxR/eQqu035fbWK00BFaZjYDJ1v8d3x0mMMWq1YwaKWvQfneALqL0jXWBd+Cfj+GUKzIVq1KwHTp50MXCUmNBBEmUA6BwTbnOJKhMPsKZ4Js2ZYXyZKrWZoLesEDF6NNeqGKtIsUaSir771u+QQ2nmNBGgplt8ODbiq0DSpCoHS0CRu/hE8q2I0DdwfkEn7wSGYpmBDSyiPbgPrXD72SqmmdTyLK0wQxXtZUCfWIypzvb0UNQtXjzq2wcS7Lhl3c4ZWezLjT2ge6zb4GDQovbwND/AZfE+qvzGeZAPL2AVjRM5kIsP6x7LZKEbDpaCihil+LJQyWJFWTATYW9DvJwj5A0+xglJ5C1qNHjelB8CU/nwYqOhTN+e9vE1vMqcmLjS/T/IcRLzvBKJYhRyAO4p2w2ByIsMz0IBczUH34LhMK+HKH0c5XVDJ33IR8BTmreqNdaMj+cTdR4zQn9MMImrJU3mTFdc+Bgru0aefs29D8Laqt6CVCmLEYYoGqlyx5f8eW9QKvBcmyJLKSHCPmGJWmgyz9PamnXr7WbVA/0HygiOj2B4P6k27GJtN1ufFcrSoUp8/shfVe43qD1h0O5fTUCG+yvX2xQO58XBWyIth8vEeytqf5JGKQ6fFY2kzMafGoLHr1zLMWnc3+DSw+MmkKAzyFxvMTSTjyLQCFvNXg5PMxNrrLvSuJmoFJIQe2mUqgM5KrOyGpkErjG9qOvVCRhzd2sFAwoMrqBfQWj9ehXBzHuqPQKKN1xaB/9U37XzIqrpW2K9dyGv7S0rKtNjPIA40+DEk+4g/P0aFMHI+zG5j9wCiRL/8k40bqZnAFEtw3RrMTKbqqp166JtiD5p8vLhPIbwkdAq3mNdrtahK/KohSIznUEaG+Dzql7i7D+F2PQF359JZDTRj+EcYX4pA0Iu8gKMs23bVxV1a8gpZGoNak10tybxcr7RFj89wAym3+mCkCeJd2UhOmbQeWRt4Pjk2rMIKqrt5tsENjgv2Ip0POEeWiBIeF46LOsbGJyd7RfeZ8ra5m4C2+Qh0d9+4u+Q+zf4PcslF/jSZOBiSl5rxjUiYlGk88hOenn2ClMrrM8vBRIysEOAkyy2yBogySVbKbqpJXLy4B5jsvJA/qhE1DKiHJO62yPI5687wPvT7xl1IW1HkvVEB80Zx5z2ndKe+Q7WgxG8rC+N3s+goaCrQhsNrcKi1FeCQPTsnT/cWyQD/gF8UVxyLQXQCKrlPenCKJPWS4x7pPiJ6d7ne1UxPzA9NXyuD75e7qx6ZoT660eWdUfy8l8IM+b1Mw1EUqyu1rzMgntigsuZYh8E4+msiT84o7PvaCexowKY1SFeqYPXP4u4UnT90olXPqOuJahQjU2uuH6tJEAtteVgHHfracX0RT7e26OMi3DXE2RWGKOVfOaH5z9FtEI/XQBUd2QSd8exn5ce9XXvYIn5Y3KsGPq3gyn21iMJU+ke3wNxPnwwsvYA+Oii8WU+OuwWH9NQS0Vg5CMtbpxyGCoNZX8MMadsF+3B9zc5Y/swbVPGQzFeJ4UyjzowpIDRRG5Q1o/tjNC5XAa7ycjUi3ibKIihi04Emg/1iQB1+faWSovKR2Uzwwrygvj4hwAvUxJf8iEJTl4V3bbRZ/5PSgIqX8hB838M5MjsK+SBpdwrRnmdJ1PbVoRLYECYh1cpr/33J+DFNkTMrYXg/FqhrDiEyqU1M2lJj6lhcxdhaKRMLGp2qJfSN/1Wgw+DcRyAVA4ys7qEfwf5Kt4zSPsnphEgrY/kHROIKZvOXXpq880TXs/CIM508+vs2KvMzFXjy4PiGCdP80W6Q9+6ukgujn4tH0UiN16UM6hjuY/qXv+FGbsnakukZuxNPz3vbigB8cLRou7IqKWiqYMRVJH9owx33vVp9nsSPB2zSNjpf2tSNJgQoB7eTOAzDVmOBuvUleo0yjD1JlyHnoE4VaW2Mym/KR6OWLTmjFk7IVVTTL6D+dIiQkka4DUEG3BNmDg1FnvlzT5lF29nmAJiPBCPRd3bIcHkVbqXtH4YtnOL2ZlL/yzg6Yjh/xVfCDm4yvZGcI65spc2DyOyYSvmeT3gqyzUBv3QTCP4XYeqpvOD9zhGzLKv3/KWGMsbH9TErhmFB8yHR+dwmBxI1COiiEyMC7CFItCHRYqK/CNacQSwJ6vuDrlmi0w3c2UYo614gMbAWHEN1pPmfFrKAxMT16v9OSUoeXM5aCR2mCyjhCiojjLuhOly+ZSY9IiexWKFj9htmW3C5ri7tvzwb+vQCDi2x5SOIKoCGaPpfpZUcUVFR0LN7Ksb/FfBDhE52DMEKLdVDCtSYYoTW/bC484SBgjg6rt5GG+lEZ9FBlnITabAJ7a+pmaKfMSe5y6D1s/QRnWg3HrgPqn2MIR5gNl7qXSLCvr4LEcNGMBwtAAmeAmUfqGx3WrvZvJkz0TDp5M5QvVrFd/gYVGfoG/JfP6CwrIwFlTATUQzp8734xiIwDRMcH175h0jXAAa8WHpHWATqdOLP4QsEDHehL3cM7DjDCu6YB1DHlP21QZWvVct/eRc9I/jophVu+7ZEz34aUlhZWzAy8Yd2xXD8p7f78vaKMQCw2s9BuWH6d5BQTNyxMDxVAn63SRxBo7VxOa1Y7xh44932t+jdaNSkXVTrilfLsAse/zH1aYo/50l7YKBNCU6HsX6BH4/0VxsoLUGMpEsNAfGCiyBE+6DFAjKbaTjw0+TZ233xG8/Eu2PQ+Im7xX0YV2LjWTHgfA1P9GC7BNjZe2gkg1RDw5EkozltdtlDdX0O9hFBFQUolBhkFgw7KZpweVKM7/XtoTr8H33Hajd6c33cVJTuXsrGv3l9Q7ufaAvXkXZlArZQkUtDhL8opNEdB1HL4FSrN9kCbVuiF5Zu57kN1RfMaiuiveo36rX4kjw15zUSWYJeOmuohP8wxCgqHMfQ3eCRpvowWXt3CNGZe78Z1Yi1oEQSQPNaRzbpNsrMpvV5jTO4q6vh9gseRhxGbsTXmaM+/952U4Pv+xwAboA+VEvnbhtiFR18S9sHOMJBCAF9F4ATx5PfhTuw8V6/iG9kFoknT2YFINk0Rr6+JyehHsAPoFtQtG8Xqre1BvvP8NIH1SwDAsRz4b5L88FiCnRyRNhKj4BBmHY0YDtX3il+qOYfizZEoouuZ6mhf72EDGVZuqqXopuKW9JOWmhtWIx18P3ZuvPyu+ld5W5Pn4BBkcevQsIgz3xrlMEKW/JSlGCfNIIkVJodQCp4/0gzuU9NgFcwhxj8/aztysPGDi/9/du4N/sbmEWuqBcur1u9CkSZaKqyVNYjHrZVFBOK2jbCIUHNO2JmgYp1a5b+Ay8mCVEGZ19J8ys/Jf5WGgKsf7J2VNHtoe1UM2GzMstw2Kdwxb//8SzRPVnJl1/h1fn8Fr+SsUeiUHZ/ovaOS65S6kuNn4W5QN+qHdxo7YtLEGE+Avat5RZEYB+47HZUxB/I6ByGBgK1a6soNfNM0Sp9lil69YgFiHQVkpkkPZ5a5bgz2EwVJ4sn3lr6/uVLzz3Pn8miv3ZFNTBqZGUkgjgY9IKwurO6+Le4p4721pKzaxZjAdc8gw9/E0b+xaxAzFKTuFjvGbpfFoTaYegMScaW18J1LxL5dqEz1FAefsXItQHRMbZDcoqJMCoHUZma/J7dgtW2i73qEByzpqUhsDSHQ7ByL4buu1JFg6VlwqTERU6QbossaCg87pInYND39itiwfqq05pa00efTr4aWIFVOJspWN3YU1FbDStHplhAqhjzJSl3CLtmmopNDWf2znDi0uMfY28kz1aLKkwmUTWp4lEhEm2gn5rQ4yd/clCpXYGAwVoGNnOwXj3fxz/tomB0nnymDn1LbariXqFadVYdkOhXnvyzpYFvEDN4POMIcCZ58WeV9FUA7+X9OkDtfdOqP4qsT1DIna8wtTKNOUP85f4OfJu3FbZa7/M+e34HpmFvbuv6qvLAPZpzYS5o9qn2VwwefWC2CmXvBlRwDICu8oWuqP18St8/wiIfQRanGCTYlkRNwfxhfgpx2K0t6uuzRIezgP9R30lFh2p4jwL30ZSU8rIdbbfpWnnwzlsYSp0grvJiAjak/9/GlOHfLjeyX2ccA7WONp8FS0I+NMHroDCRqiPr1pTYCrNO00r34Ondoyne6M4MAUlGXnQEGLmvwjCvh1wBhVmSB2czTLGXNvfBt9TEpBDh7V5MvCNtYEjnaVkijqHcarhEZtElF+VNSpJ+FP9hBtMxBHljytgWvrMN9V5gqqb2pdGx289FtyLbMTLdiTcNR5nQyhhrNvWHGRP0jd+XrhN2u/2B1NS9Lq7T3ABuhcS41HRqpSgJGG/SvfE0xrOVpFdJTTDbc+3d0pvjMlq6iE/ybb7FYPTUgmcrOX1qnju338z0+hCtN/06VFXJZjyRrE2CYmLAKz+R/kqCQjQXsxkszJ5YWOlAsSc0O6vfJ5h7lTla7eBXyrhh1M6bvDZvM5Rfm2lqLKKqjzpoOg7cjsVaab2dXpJ8kXlkf1HHPbWud2nSL5eFkro6NwYkx18Bq4/6dC/criQItenUydEOICzeEBzjDdhSo6brfgK6zKjero1CU4Gw83SH4muSEUON7ea4q8dIPUSJ2a2vgQSINkD4XgP3aB2d6V1ucp544V7kBw7E2CE/HUn6zk0ZQ0cXG/OtCfcPOyiMG+ZWMqRUwsvQ1GOGJ1TszBv3GS0jRww+Lgwk2y7evHR4+rUj9o6FfV3aGA6NbrCdkjg8jBMK+rowVJ9D5mlV19or7PiR5iNeOCCR00QklWfp53iyy0BomDbldJSgxzFNOLpZPmO3/fYdL+nx4yDmgJisAW2NHrRNDmglrU5plepO6XsnPFubTPG1tiJs+7XgysvKyh9HVzBZie405ggv2d+X1j8qERHPuLcjwGLBNsCcp6vRsk6uSf3Wghyc+Ge1g2hMO5yMBUMZVDJA6Tm2zxV5iAgnBDAehHpA14EyFcE4rU7K9rw+z1DXX/AeMVkOgUbt8vJlnpJk2y3Tbcr1SwqDkM/93bgUBSh4Jk2YlksWXBZtiR/tvI92XkfEa0Pf8u+Cdbm9JRAn6DLIlw0IOUXNjBXa/Ank9Nljf39/HsV83q8TI3ePbeSKaK8r6dxFSPtKO84Myr1GP1pP9LGUmBv17MuCp6z+wPk0PvQdGnJpU31RUCXFNM8Wk6Xrl/WGcC6ZLC852bX7A+D95C8pUp7JWXhv/y4YdUPC8O0K9xUNkGwFUbWnrfIC27DU4YdPRyKvtHJZY0YoD+Wd5WNJY24ZlOff3FOXDmA5fDFDtPv0tY1dgfsMN2Y8qXXGyCnUADj+nnQzaEkUCFIxqcRVnS10eZc3McTtO/4fVmFIZvnk5E/w6UlWnGyAWNO4dxQKqbNLTxUpIAK8iuFgUrfeZy1BxpZK886N6xH7FqEKPgjbnX4fHpCCj4uOhIGv9G+5FtwA4C9VN0X30+uxjp0lvJh7oSxY3MePWLPk2L+u6Y9VrknH21L7rcYrTRMVBCydC78MdRQNNx74AH4NBfJgsTpKxB0cdmYyxNso3xOqSaumPloFnjNx1eXG0faTXWp7kU79IMsoiHPHnJRJE612YagZcOiG0tKMGFpQAQRucY8HDhkGRjL4crt89hsOp6ZeaV/6D4F+sepOw3rf/icu4I+251EgCAZWVdq0s8HFF6EfDnBQaSTLVRVXZOgTMdLls6StDmbOygjoizvhFVrlE0c6OEuHjiIEAu0a91jxRZkIjhy3sLZzKMQ2oEpoMzeRn0cZFTyGhodMPuGo8TTBfEh1A6L6SqkRhQ3UOI5z0AFzFTxUXJETaXxzycFOOFZwmFwaGq1LxPyaDAhre9e0/pgEQTycBqoKqTPshX0bsFqmSRNRiqix1Xz9WLoLxYZaJayNIq3qJD+HVQaISVGeFJqMI1oa6UCa1QBAVAI1OawKLtEpP0lFreENf4agOX3XPNNyZMi6nSYqSZZyK1oq3Q39ghl+55Y/0p5E3SSMWyr34yrqxLoWQIRyQV/FeBINju4vadWthxbZGH56GuQDGC+DALWZFbVJMPZtrg6X5dmELkAMvQ43HSlObY9dSk6MoSy/Tg5wbmNxgGbOfg6qKFr6bknIOem53awpWuxQuE9tEvg8Nvke83d9Uwg6v6fkailHaHjriUSzamSX1hhMenw23O7PXx86dixKGerVk5rMTaLEhh8iLto0Jd6hepCHjepTr6GtOiC6qHi0iDvOAAFwJX51xm3DqPP64WOAzKiy2GtLYrzJpxajuAiKsGP/RyA/BU6lfQ3tgiqLNnytXREG/7IBjCvSjzT0oFoexb8lk3eTFWVnnAvINAXugbyetf/Dk3hgqKgnqamvxr7nVXEdXumV9Jon6oNlw6kpUv0+JAgaLzQfd1jNlY116Tsw6cpdfKH0taO5O9asKOCOTy/xoi3d0ZW7XPGqDqJalyS0hJ6lCsk9o1R8kK+JJFxxowbza9/9EOMv0eipYKKONXAWCwwiOkrYy+k1i3TcDaDJKlxjBt9i1lvM0HSsEvhkafd1cJEFEkIG6bmzA02VxoCu7ep6kzvQ9cDxV1Ub/4/YhfSy5V53sScIP/bkwXwp59ZEQW4pCwwoLGWUNWdhlf1UpVpAjlXFic0aXe3wYehi/472Ldv9VM4M9YYFjLhSkE18okkrgvQaB26Tapmn56BrCRL00tt0K5aSPJJSs+45PJvcdfCsKbS8XBL8KATxvFNrqpv4Q6nhNmQlQh/rVZbcmJycYnY41YwtteEwopgowOQSICZe7a3aQMkcz1HSRIUpn6i7pNwVrFXlE7AyYBUzhnjgr/xE8dNylUehrtpytFJ9hMa8N8QkE/CcqCq2wvGePvKtSmR3feU08/JKWoZYVgJK+j7r/sLmAUEAwpyW2flBjKkjvlzZEtqAPKagDr9iq/HMrTPiwuePIZfogRaUcRADrsq6DazHvNwmVMiSyIa5TgBU9ngWFEwRkBN3S0DVmAJjnJGw5YnZl/+XdVxFeeInDn64tALhrpshpH8Q2glCZpaCj/69TQFxoDkyWXgbIJ78xAKwfw7ip4qzV15XijEr25YZMhe98a5Q2ILSX2n3CgZQA2oY3dkqIydEfZ0DFKxJU3NM86h1vzunHJWEvV8WReMbKPy6z+WknZKpekC7dvZG+s12TcOiXOm09Ho+bzfmnBRFBIrclXlKJBUJOF6vceZqjfN9e1zrvm62Uw5om0owubIM5R/o8M8td18x5RsgWNJyIs9dGl1m+wgTDNPIkud4BvJnhNbQnrGJCMtwra9hAyQCEHhGyCNzHkm3CrJKa4fRvtUDYpwGNNwbIVqtP0eDUjqjLp3Q2mdWz7bWB0dKOJx+VTuwpbRTR/+OBPzIETaMflAJZoIJIUJ0Cz2y958Ih/G3MC++ct1DvFpxsCVw5H5V8ZxeYqRUwomVCZnjeIM/RFkhJMDS8McbvrbOm8c3SRrABYexKC5fXE0ckJjFu/8hU9u2OBZ69kMMksD4m5xfvexbSfEthjFOnXNjfr42ujNkZf7UntWblut20jIc4iRp2HOobbrwHdn+eE1PJe+qcCkM7VKIwUPTJru288panylMb9bPtzWykcunVcJ5or5Muo7ZuM6HWgzB0dXHXsQeIEXLXeTUVrGTBmx7+AxUrXnaXtNY+XQ3yvLwBdFy0xBTID5bKHtZhfeYTXDBf/l55RovlX54+hG46nYqvscBfWLKs4zERy0wMsFgBzbKH41NopsWY0Km8IOxSb35lBPsNlK8lfxVdHoAKk5z4jIVaA6hhTQz8yxRmP/NFS3fsdIk3kFTjMbP6JGLKPHn1Hsb7QfYR+H6lMKHfgDOZEhNeSnqZHbsflKrc/lIs7S4oQRaigE4Jy6BCHbzRXNbS+fpYuCkIrzKgLn9la7u1UJRUwWavWAKJ5pgCNYsfQi2ZQJGXSgPgxSlXK1b/NwXfq64pDrO1SV5VgjQ6quMcM01cR8SHuEHB6Ab7lk2gaIKARhAlXgjgR+L0BucBAV2OEsJo0Q1ECrzYNoh/C0hSxk+YelEdI6K+qwyHLRBrvY2ijcFVGvvZ6Mz89JU4K4776cw3JvTofGkxhM9rpdEWmZfbo6wmgqWKeTgYC7eCHksLetgLvgCooZTd14ZoGLW1GwJfCueuZCfgXuOTO6OLSxtV+hDbA+7ak6aICyMX3BnZ3uWUJTHAKgRlxL69Bh57FsuTGVdap451wiD2ihPCiGsvwbXtlLPIssNuzGjCYu/MhLQ60ZOra6coyw1kwKkMKM7KVLHSqE/blkX8EK85kyxcOg7JMkEQG9QHnE6ROWRy3oUTKUJYLpDT5+zH7avRrRC5IMb/OIP7uvT+jDUbaPUwHtK9ItINeK2wahe6bl282JzqtAKHgfhwg8d+heyi2vRwr2Z1cHSMGJopPahEL1G7jP4sv/En6Hjwssnnv6S/HSoO5VjjbTsd46ynh0BMBFiKnVxcpMDmtQ/3c10kjAToBqXuGv2QJaow2srQoCG9skmXUaIL87wQQNj6F96gG501d7UL7jpaCHAlgAUVFeBAK4Rj95mfYJB/OMxwk6IFW+RezUlZNacLyo+vee8fYLKBUbhGAOrQhKy1bzOLjfZ7HCnddf2gTZ5UdPiCRTl6+IPq/FbiXnIgcvHNEzkSyFDgr5M4rcpKeWcgM5bBS7roLojPC69DV1YADoFzOJ/PffHeZFUKqEqZKaKbgqPQjFRXKJ8nK/i0gzCcdupf75Yq14GmE1EQfsH5Cf9K57n41xRlhrjGHT6aCxE/+PgBKFmZIr+jXF2pCqM2v0m0lW5Er7bMrPqj822nEURC3dCV5Cn1AuzgvGoB1nFOViQB3J3hEsg5gYAPVNPuLZv3ZDxfDKxJLrI7nr2uYJ5lsfPk5CD9JdD1CSG95A8DvHt6+RrHGI7+9nBJ0aN+pideb2WE/yD1gdj8VQNIaeIfFs71kOEkHWVnHLbEGYqluW6ePeLHLuLZYSCaCqUwOPPnyen9mFzI8nDvlPrSUQ3r1tYnD8e1i2wSo8SdZPoYzKvbBOzjQXNhXLDFIdPxyDWri/LogPMT2O2L8mVZpOZ61grO7tTRmmcG6Y76suRB35qJx7GmauzrPe86iqiTAd+37YYXUQMTkhf5unsfwlD+ad5qg/0mNp0qhUBtyZC3v4xt+AkC7dJP7xVakl7MVlhIU1Sgc7fRwVEEGndbsuI4dv8dIz7MNFmHS72XBLvFX/xx1qPy8LsZOBXtl5A3RuvdGXlSTk3kdaIZDhrSV+Rw5ZkWlBeHlgRPcRaQf3Vh/X0+Zx2m8vJ/w033g0wjM1d4gsKTR3eAP+Z3kTIfTWdl3a5EW9ZSoNp9yG/ifrT7c3wSQ2Nj2w6reTkpe2C5z7bRTBfJ5OcuXAwtr+FJKxGh7U05kJv26vtvOv1l5aK7/FcbAKaSrBmU5j+oOuNxZHKr/KrBWqatZgTv9jWF3c9o8iedaDe4k7rQTiDnwhu65eUCnhs+6SLufm/vTePEF7dWkqPhJUFzxXOHKhRl7/CCe7JfLKeL+W6TPRw8KHSUFAO+mssoLyDqq1qnmJ+RU/WZ2SdZJs/bKGbJ2C7HijvVQ+PoMZjKqvCbmrJ0XCAco2kxtqjqiCsD5ciQSw8H/zPGXAoUviJ1i9gZXf4din066JwGXbS2LPAj7+inyehVnx0YQ3Opub0xHXd1wdMNmURrCa6BCOmR9pnWOWWTMSxR2XUGyNfTTPF4NNqpsFPT678gnakjsBAP1gJBC1NryyxHAJyPHFPMr8TJv1cdoTevi7fh7ybzrtj3dPCndMp1bJ5O6lkZyK+ZFVYlVr7WP0E7C9ckms/LF7k8eTa5wVXQqkbg/6rjfvfpz8cbYK90TKGA0DjuOuqAY5E8bCf9/CLYx5Da/ybwEVgi8tR0M085vy7+E5+wR7exCilbSA1lmI8g2slj4ICEBc+7RzduDaGhT/Q1BO8yiLMSO6I8dQX4ropqnlLzv6YLcPwvfuHEywoFESEmZfP345I6YgLqiHF+fr9CzPjCchL6oOzILQP+u/BeAIOa083tfqTeaYWXmVoTQOMyvUqCeC2MJR3c4F9DNLe1tVG5cDZwlxz8QsXeOR03cPe9rFEuXklqtWOrmInbjgrgTGLoejO/koT8UbSGPC+6if2n7s5BMy94cxPNG7KR5ihuZyXMTYb0RbmcX+Ej7gkXw+OtMK3tp6n6g6be85RszcIKzFK/J3FA/olUm++DsbaCf342qvYut4XKdA2BSVmLBXD3FQPvuGS4ofV8j71AbaQZF03x2tH2EhE9AWOLcjdhgU689WorAC4Km0P79OU1ygog7DyIhb8XwO4DEoycMIcrkbz1qVTvjUTewwkb0fMLFxr46vSIT6f3a8QTNLVsi86J6L0pHt4gIlysyV9giyOSXJznixmnW9RUkughaz0vy31sZx8WkwcAyvTbiOVdtueWhbsdAPoUMyLYVNc9jGTwvhl0FNgUyKZvi66+OrX26nkQlDblrJQI/cEyqrSQ+6Bo+dS/QPABR3Xyj2yB7qElGW7hwR30m6Ql5pTak3h1XXlZfEOkCSCYsYyNYh4YfP7r3o/Xx58YELVFK4WbEMDHk1sfKk4ugqJZ61DRe0Ca+Nu5sYl9U6Z4JVqvfl2RQ1ndC/m7/qXiWn6SWH5tITB/BO1KYLDqwhAkArXodJuKB3JEcvNPm5wZm/0IFNVlHZ1tTEFBMzAtZBjp7UEscGYJdx7Go4R04jbffUHbsv5mpbHl3JPs1N+MJBgTGaGJ8JkPui9GOi9RYtbP+czL/rasDsBeWuCY1Uq19G9soR7dAFMyoOQ5MbwBXr289PFim8qZFEX3APa+BU8FXgWhty7uDgAbD1csoAoyg6QTnO/vX9II3m0ImIVNzIGS7kQEnwFbQjVQNW5QWXAHPuZykYoBK1A6ah4o/62AEjWDWAQ+IS5q6ogiWKg8ooIqe37AMQu0MytJUK6QepFOGhzVwgFi1vyaUy5qvwct/R6AogV9xaqOQ/WALAG9rygkeOCSt42Txtn/mIY4ULypWxvxazOBfVamTcF1perMIutcJc5t9A4HuG4dVaYQxOhxzEmiu0ARNge7hqod9AQYHlKOLEICE9/UbgD9UEAsB95jGdCujFELJ5Kw4jWVuX57d4qynoBfy1lICB7qEkGIM2XUl0dMkcAnumP1DXBwITdoQniUcdo1z7z+n44Vnk/NBJ8JWlVHTop8mjz/BExuLAv4VoHxjuXZcimVL/V1iZyK5k5rOYOhviEYgepFggrOcFxA8pOaLdEpizQx6HjaE1iNjf8Tqr1aZEyugGTRMW7bWd57TcFZHYz1EhWYEoBgxp1YudmY6+1ImjDn8qQITJF4yHiW8z1YgE4TENlf/hNVEJkVsdBqLpibI9tB4bGJ5jdQRjasPruhzOy7BZ4cuSZq0nVH93l7vavk4AUb2OobqqI5zrvrg8gFHrw5xGL3NJYaBC+M82zWMCJ2p30TEqp6nTwKAI9SJhd/jo/uxD2eumpzgzAaTkrxOn26BJE1TjHCTBQ0I+HUSlFmVGk7vNWvIaVxkKpr/KWCsuEHozPsDJ9Kdjkoxz9iL3gQO/uV5f+TLPFsJ5M2M2LXMQyJMNm6kPPww7hW2POXYuQp9agDPXz7eWYmAJNjx1iwsgqi2rwbfRzCGRHG1r6bL6lsgmivB2ivMELfOnfokX2PghpU4YCbDIwbto8U+t81IGbtAic6e0yeJ0Fnrw/biuRwUmqeUhCTzUeXI10cPdd8IRHmqZMw1p6SUWZ7NFcVfVtuaB8ZgP42RLaAyJlDl6amPxYBntxgf2f3SYbArjAVfBcXzbHp+0GTFFP191J58VwsqequfdpYXaPUcM+BPUrJeNOqCSLLEWsSlt5udAC8OvxMpVrFRR0LilFpul2Se74FvBdc/bOWDiHE0pFto6oeEpMMhQgLPpmnivSLOk8wtR4FCb4vdrzNf7RuVTRRRKsqnwomNJaN1dOk2zjavx4854apmAG2yi44EhtnXBkNBLLPxSu46TCJl9HNq8KhFlKQFWXUbOGsHYoFk8iOwxzcDDZSJQ+D+v4BvxY2SsmOEn4cQuOyc2OYG4whgDllI8oBpTwiUsk9b2A62BklS6QsG0oUqnEoMTmE8dI905VMNIPdEiTz3+kghYVfByWr8P4xgxS96CK/pfYgCW/AsHkTSnkwU37CAsY/JubQuvOImdF7yJ4ttnVRnwslVeTD8TGKHg94K1YgNYvcbJWrGsBGKXzJvBXMARWaqjjOGCieI+kJ2HRekSrAaayt+ic34ClkRaizjGvQgp9+zQwy6rJ7v8gO5p7hmooUbTzJ33EawB7zYvQpaE6k83AQuRWOYjW9rkAehqoY2MYPr5XDUSrCkjHMXiE8JhVDPVzVlrqMPj/6aq0BBEyw6XQdCRXW0v1w3bKJlz5S4Q4RvRoOC1hluO6OVKGhZPsH/Xas4Fh9CePhDFuOKiNHsmfx0RLqS6cbSpl5QDiqE1cjZ+alc6YsrzO0mRhWj/fdSfbl3Fj1r1eYofIZqw04omc3+lhqYAc9wPxhg1yslWx+X9sKIoHEX1Hx8IE7m7nRU1kvHDpJWXjIg8WRZDN4KAHagLyV5QoLcI9x0dxNCqqdWsicOCC4F06BvVEuSqVAWEiA3Yc2OGeclSoZWWv2jcIylAJeuqmuWN+i5wreqficfCfXlNQvHGVvRh5Sv1ntGvHzk/GxqoyVB18dRME+z7tlQEwOvV5xJ+A7INsYXV3y/2t8u21hLktmZzdOILzbNGelcCSpf6X9M1zx4erE/tzOvWnjl++zRgL2Lw8OHv8r45Eg6V+pROW9d1d4a2UQpag4uPNxcyP73m9UakOoClNgAX16tsgZovIijz036gGhLp5BIPUswUhio8Y9+IJciXOIRbKIJiB3fN2/kFKvNrOg8tGfhcMiQka1t/Bc2H/LiAgiN2H9E+30HL9snk4fS5aBLBf4j5ZnFak2RDBEe4DXMs3x1qdAVJ1chjT/CJN0yWhQSdUjeYrJ6KbB9Qtqw6Uw9OwbOeHoM+n4OGPd8sI9iDNk61++DxSDPESDFMw0VmaToN/RHr0XLV7OEAaA4XGLhD2IVsxU/VeTPPh4YaLnqVI1WU9Vq8k+mLPFSv7p4DtmxG8hq8JflMoEwkKmv/vxMjBM84ZdvxDZ2YKxzPFmX9MtDaBJMRzQqcCdo5CMzU8ZkA/UYn3FEd5N3RTvcSGcwnxdeg3UnHYf62GUxRpPyaEcEpXJ6Uvc653sJ4z/68HsGwOSc9Lb1UdSwnEOuLhJIfKjvCzsgLbALe2N7giVDJm2aQp1fmtzseO4vHL/3QqIG93Ep/NDHOPDZCiqgWGx7xoY4OKYquJH/RbqF4HNdg4HyDs45spKyWHWltxO4DQeRqy05XgV9OQuLuv1z7Ao43Cu1AIBGGRZoV54tSprLuM+OEYmxMAx/rXOotV+gb9VQ4hCusoovNDVNCtgIpxBydjQKJge2il9aMBL4VawNk6c6tmKJW+eiVQoj6+3dW7SMr9N6PzG0bm9ayiyawnaZATJUIOkvzMH9660ZIEpSIMm9cRMgCcYOMpPvmhK0q3f+P69V2CmPZTnmW7smC7PWQGi32n78WiVMwXAopCcAO8nDA3zsakdLuIpyO7ZSOa1+QcCcO+U8XSBceGY3UwAJA+AiNO4qg+brA55cgFrZaQq8zB1TBIW5aYVJDShuk72Ipf3QoymFAL6KRQCQvHNb20R3NHZykHIo1m49x2MoUsioBosg82eZaY/x3hwbPWQSsHKmGy3RfY3dIFeNFAo7v2yGor84rmOlZ+BzFIR8m8Ex+oZQou3wVCnfoj2xiq8IOiJT6k7LTRZBlZQG8/+4I6f94e+7vUsC4keXEK5t960U7EmTE/UcLS6d76Wod6LfWj34606WDsyM9tOaCguGd7PUd7cBniS2e8oX9VdRynEbiscWEdytuPpME0TGGjo7nGLUlAuYcu6oKAJSvz9jy0r1C3Zb5xEKq3GotiKwF/3bdxRs/BC5ktot45oWxg7bPk+P3mpfFp4K/NHowq79jdpQelWD79bBtNJ6bS9qaLcpqJpiEP8g57II8JeuKpJFHI/4J7tvCWz1PdyWy3ZjFUgjbHYkAI8Eoxwzszo+zDoTW3J5PM9zhTelJVmLFL5c2vk4QUYGgwpr5XEJSarluxiSrNn1b11IS/2MejEm++O5iGTJQEK7jo/dp6ubb3kYncL8IAtRBXnwWofs4Ne90310VMLLd8vlPlXmhtQOyAmU+cJsuwyp2lt/Ocs4ttk/BiHYaAsUMK6AF6+z0HXMCaC8vrInJbJgvz7pKIXO99VO5lImHHcuzJEK9EONBIaV8EHTV5o7cRKi2J6Qd4H8m2iW5FBKlx1fZvTHM33lMeW/NCWNYGdRuki1MBQAg2fslKDdECDNXtnQCg7PwcWvMqTCQ++K9wNQsnDVGahTdCMmSYvfKZ8N66OHt6fbCyZsvv2wTDryoy8+0Hgg6PU8rzlz19cko8Tbq1X1a6xz+HvSKhQhd1ZLFGO2HXK0b9HnHBAs8wV8DE/1D0JXmqGhqWgt7sefVsD2aJcxz9oir/17qj2ij/w4ffZuUVgFw/oDSrD6v7rdr7W9hfSL0WmafQXKOv26ocg5zbsqiyG3xHt4MO8dUsuMsO92bnEtUcEuMUz6MKkBb6rjyLmysD9kpMDeD/7PveuAgpudP0bu+UABbE0kojWq0xv3b+gP3Tom88CS0ojJSf86hg9Tf4x5CxbFIQ+QcOz8xVwJMeanaaVoKBG/O9boRhEB/ElCtxSGPn7I0XtpcZvPxWmhoBEFK30Ar9WhPtj21+qzkl493TpoP45C+ubn7riuNlgPaHiAVD+EWODNc9KJYDFWsJluq9/DvWKCD6w0JLCmCvImZS0LgsVdXI9PDnCun8fVROEfdH5Bes6/Fry5b6v+u6OeA4PpddWyxp+4wFIWBhOOcmTpv44b+6chegIVSRFYEUUJEyLV7MJmHU7pEzwp8sdzn/rhoLXkOAthGzNapQfwRQb6sc3fDnxnt0gFyx4id0eReGQV9LgI3IZfr5jitG6HG5VNjELpIYblsuIItwPlzDvVnrIW6iJ+tMJ3Tb7d3NxisGO5pF7SX0Pg2IP64fcdwgr+/mjJRnVw+lQSPc1GJqz81UkOhpr5AOx0/2AzGhx/RuraoB1WLZ2JdGXsIgIjzE01jB4U2B1JqXehnvd8IhnRamr/sLnTnXQwi63BFoNd7S8sZRNY20pNcemld6h7lpuo0ZfiM8HIS2D5PbWYuDJF3pvd4pa8HtMkm/JZ/nEdTvkX2Ysqc22lERT9SjzYR4ZdfdUUKvfa1Xi514VOrB08hitsj8+70AhSDW5r9Nw7spHQf8pkKLwH2scN/X7xIcRBcVpKO+qrrNiPsRStVtv4n0xZoJhhkH9ngX0FU2dZ950P8EjtbueadWTpJZaeq47MDXS5JEOoFnPhiVhk0h8mi8UaF5ronLE4PR0kXshwMLjG4+xEaoVCy9BkVSqFnHL14umVWhphmM3tSxzjuvQx691+flJ1rvEXCTiBaa0cYJzhWcgK+DJDDhAvkCbBlR2SzGibPPeSn5/nmHkEyiqzntu+LlYoENslydHhxrMGtnQN8sD/j69gZ5JfTa+AXMLIqeT6gt0T7S1qqtZs9f53AC9aC7AkVHNVFtDgUYJE03J7RVpSmiIEFJXXwzzJBy6DOdx+k8aYTzgBvA5W059nQVJRCetOHXnlNHXW1xLzViXJWo0esGLSyZE94T9caQp50JRl+hZ4hTGaQiRL9ISp1++VSfdOqn9o/MtXnA9/eJ1LJXwSvY9wsMUWJhSQTfhpsgdM3ez5eRhxD7hVmgU7FFno2lNE8gHsRseidLwXeZpVMC9XgGdFxgEM6pA1rIEaRZ+eL7IZyJjdotg/NRdBCH7AQUutvnkg4dzp4EA8ucF2Wja+zKBhsFt94kYtIUnsf9HYkc4sxUDG+UzIciMm5sjkJiND/p1u9upCrCOYCfim4usyibKjSKjT5SHzBoYUPGt6yp1b/TLEg9uRr3zg1z5wRj4M7NYaD+XbI1Cx60VJbr7tK7tb9r2zXiOn9DQ/xU2eQq+hXgE1Y5Wd9f4+40Ya8Rck30l2aEaY8oJ/7EyJBuW5C5hQY2ZQ51jtkhEOE3gSloEHiodC1tM4j7PePlGtdztauCHPl3JUPG9JACFYPQSOtGhCx9539fgR6+1cLC3whQtYtX+ZWy0xOhWo41q8ApeQaNAAsB5NHHaO8QxL6vU9ylbjUPey5dm48ESQr/kVgxoOC79WKM4WzIlQGGXqhpvHnP+SHtwskFyq3xh0FH9ceIp5bbFb+9tasVSbe7UiLYYr3JahQBCKphfOliN1gIH4KpFQ+bgwE4KyBL+h2WnBCgEbYRnvjvHg6o3QfdnQcqebu6RFx2+oxllUTKcrYfN950UBhsg5ZXD4TBKRsqWucN1YLkyvCSePmSlpNsdgYanRmQfoKuUbwkcIgc/S4g3rGQMeL0aCbiAelVyVCZgcTFHQq0SCbS+0so+BVfddltSRRwYJvgY3C//ddj2Kcq4jythP7204RXbBak9W83QuAcEPb2r7OujFnklOX4SR180nQY5BcFV0YJKVCrXKYVTUuF61TXWzRupVlc1aRaCGUQ9GNWwFTnxmBJJ8PiEMJ96vwYlT4XBQxGCCSPLdJ0r2fGUh4RXv0uDsOlaSZhqCezHySxo5PeXLJAMn40UIeVgWluuGKdaFLvf4ruAp6ukjEi4wXagU8v7G8e92MPyF73MYuWIXeHFzQzBsZZQm0b9Rmv/AZY7l01+vnOinKpa4Bgm4hpbeIVyu+4D/X0bvuDkFa+nATSGTyVZ4iqzeg8mPaFTjfMN4kVPHs0pE4ou8i5T64/ps7ofUG9L0EMHkGRLWqg2UdxDaCiJg70/XCk3vT/grNAJhc5hpVdzEqJ3VDwQvToD6CBxuxiwOCCk7/rQm/mS4B5YoQFbsFOPcBXYlws5tP3HGGku/QJgDNVaqdWlB9R54+vjk1msZWQ8chgp7RpO+Vztk8jdLNybj+hvZnY3MUJv8dR2XWSVsUNJz9k6IJMtUqNkE4urQCzSWIKnVcR0GO4FZf76elkkqr0pgawGb4K3akDjGrGUO9o4yyKHyDYf6nGfPIaBxtTvgfeNayP2QT8F+/6dh8RmCbTXn6pPuM1XEftsbHVraNZ6bdc9D0nCDKdTK2gQWuZ39f3g+/bWsA14Hn+zom3nKLTpWRckkzlPQi7ecrGHGT14uO/qh7Px9/tDRKZj6KO0VOtcQwNsqAh4qBlS//6+7Fxy2Xeri9rdcbBtR1nVQer1/Yw3tRPnMostiZOhRbG8/wC/Rz0VeWJCoIsgdCrPnN6XRbVJOYqTod+Q+KAgVeJMmUioMN3P3yaloUkK+HXPP7fkTnE0PyAtLKG4fLyqO/gnio5vDMmoooJXwcHLluQIvKxlxAX0bfDUYfnHlBTmfS99gkvq3koJ1SfGKz6JIRjAZc9ONJgQOmsgA4LmcFJ2tA/42cUgRM7NFG9fPfD3uk5POZK20XmqJK6CDUBBzJdnuC2wBx2c0MaW8pYGUIDiHQBu2NZnunWjuu6zZuQMAE+sc2g5A34Pn/q3Ywh2TRdVcdS6M3DWqO953WCJtZVjPfCKVjsMhqN8+nw79u+uX28IP5d7btw2Fe2kfCV9MNHRlUDYx98xb02WjaLGJlptDkGAn7TrfFPIrinxg/E+5n9CyI9hO0KjgjDW9NuwXaq4u3LErU57PASNBXYPIzjdz+jtoWmpdVT5Gr4vfD3ycKEXB8zxeJpgr/h2qYa1OJ+vFf1M2s8nQcg8HNXzRqrAMw/+H/0dhW/vBp5DOpFqBLXjzqlGXheAcpTcvvBpRKbdkCf2ezlCZYZ9+8kYQ9OrHBm+9RFOD7PFsyU4tGCYi9ybz4zFEXUCRf+IBEN1VZ6ryPRt0zaOAfqpF6EvMv5HN7n4F5R6weDQvch+eiDy23QeIAueTUqZTTS5Nhj64d2AtqvxEBcUonrzfJ4Zo6Qsc95OTV/aMvve1VGf82BUvjg11CZOH06iy4L/vWrOv8rPvfYt2ppcVdZzhHB2PUXOcX/HtaqEO16ggktRHji8Nx8m8B2JAsKnhRrel0BHBZGAkmOyw3kJokAxS8BuMqEQhnJSkqr/t/0Npe0cPuY/jyNO4h8IUXNkbaA12EdI1ITrnkmjhQNa0w13Xh7FFKgc8/HNt1txX3qMH4Grkn2oYXqsrWlQDcUlJw+tf3pV1H+5L72D2CPVYmOpTv0fR0998BNBHI08G5BeReM0b1vdQ8J4yHG7sTB5KoOoBa+Q1Cg0uXRhqgCV7mYF77GIm6QZ4W0sqVrtAzeY8KlEkGHXJmRCupV5fd8fKci62+U2iy+KGqpOqG2wX5Yq/E9MZJ/5BdHa8Q16qHBVaUTprqqQdNLYwMFrosyHB6P3UT4H1ghK8hTMEx9L8hECIBiV5uOR1R1mUDxcXnfQhItUQa8rhCyh8Pcy3np9bLy2wsRngWiFu/C9SaYnjNLNd0e1M/pr/lj9Vpi+hSzyXLEl+6VmlXGVlBWZlb0aLFEGR0wps5CGGnSVH9hDlW/Yqp9K8JSHtF60kxAq9WJ3ucQbyKfcGq7N6Cf/crR3A1YBN7e5ep/mSMuXdKCboObictSpANG5F8rGAGKWz6PO3xNDKzZ4prToAwLtOiWcfXo3LNUX2AnKZ5NJZaJUIiWrfaz99FkXnSa9DAEJganJoEDJgVPTzDawUplJCTLAVvZypi16sasTgADxqcIDDUSkA4VCUO6oP0KzUXcCzHk375cdvuzYqQJ73eC4fcWw3WYLR0JsIl/vFLI81CfUqo9z5bSnUuBB1VLYXV9uNpcJWOUJQNshtAeI+wUcnofWuzJjf5k8v6OF5e87n1BN8Q6qGH26lUzGHDbDgr5ee7UQ8Ot3+tbm+s3z2xo8ouPVFHyVEhDw4uLaHat6LPu+XdG0Kn6d6yyQJpX+vJihe+yxizFQMjjgep1kMjDOC6jinIlRUZD02jZuJZni5TB7H3IsRubWkjNwJIerPJFzwjX1S5TpBBqjL/ug8CBXobFD5eMxnh88R+NYE6NnYbJETs0T6GG7iMVdYZ6Tl19WRQi+JF1SJkKg4L5/mL/ZKVfGZjTwMnbShn0uy+3Vwtd434Wqirza9PBJ0yG3ZcWXNyzZLoMicAiXTl16XdHjuYMZhG068g4obDlIthQBgptCwUuyWkh2Cy/vclWgeC3lQuEJNhoVCaLwH5vO6uDmmPWqRoU/GDyfv0raHQfDAnq4zvc+o7V6zo1aOf9zUnGneTyqxHQHl8DKLPsgEEZOqCgTIrfu39J/xjctezhJK8iN8l38pDvAgBXjCd6dGO8aGVydp5xNIrg5jwPNrON6fXs3RC8fGLm92q+eC6V59N/c+H1El2anf3C7u9bI6vlq84nfpLbJH+rK/pt9cZfp/fmKEi9j9RbEuqniPBgRd2zbFnAQZUqnYdfGtr+92Wq7Jlz/w2x5yPJPm77JchX1UhtOyehPWZYcc9WcG9awd0cemK5FJ+NZTdxLSRWNJGZUmaIN9x6iwX6MbMfmZ9Y97tjIN8xCJupZFenrEyKHyw3atLjFmpXwgDGH90FISuZqX7ggtPzjhIcjf2VQYLsULg2GtcaCvUUJrJjSunEgaVVLreT5U68YcIFYUJAxlKYTmlHeqvAuaOi4Cn6N2UOH4I9Rir/dbI8vmZI7q009sSK3HtJ67rQX45xPxYRn3evxi2v3doRmmZrmjkfH2u5sDx5gG9WeAt6zxnupmN6+0WGKhgtWBXMWxjt2SshLBh0EEde93TX8Ifn0YFd7IGCF46Tqr5I1iemTeLJQ/XuzoMCpkEaYxT6mFxhpu+rG2wBCj76msXR3lytnGAyXAkTvDIZ1zQ8necwnBff/8OIMrS6FBimdTx5oW6YcZcvrQbD1LKz3BR7h2XXNO3EFtmRloGkoHD5eHL5YPmWKqUSRCDM8CDBbHqVgy4o8bjCzOHaIvO9L3DsVGynfl1/7xU1/sWLZAHsETk3Nzt+KXOTq6y4V7n6OtAMhufIZNPMKyeF55iA1/8VnJcz0MQ/9YdmOm3BilBYdVBNdgNLHINfP3pwnWyf8nNlo6+qRUz1NYlDBSjf+UbP6gv1gE4htzwNDGV2cGq81PZdjjrEtVuLRUpqM5GnGJm5rL66WttbCzYiTr5JC0Jmh4noIoZ5pUdBVv143Pjj8Az1cGjZS7i0jnkbVjGgYnVdtsdYRBjidXWxE6vL55T/kbXZAlI+xA+Pvzf06IyZbtRJOKEuJT4gLQwp24eUuf658hIWCdOL9lTcKBXYhvnI4SeZCZClwXnneSDUpRStA43bVq1zepik/ch3cZWZqwoxWafsZRMV1z8OrfddIZI2jFfwD4Wri9H9wHlL3/4mK0xyGytJqmSGq+k4K2RVXVjA6uxEP+vLCkmkauSsLK6N+Qzy5cezUWgLw4eCs2rRcCITi0NN+rHA/f5jve0yfVct5Zhcg6kyYAxlgKw5TDwOiW8LG2RswtsG5Ni2vKMy1J1j5H+dmgtlHR/Whi7NqEeFXvr0sE8ACpGDSQWZLHGUIaFGDSVWbDGYyk70KWhXX2isWU20B2VYg7kOLQM2IpxQnsUuJWpB2B4iJW/mnmtKiKC+l5xF5ylOslcrt8v+y+FJj3JIDXIsuxKMNeGOL4Az8VfD1ddzPqPToV+amFDIw/xablfl8Gf5/Za02Q3lLCOIbMeisc5g/D3vO2sdCr0HJURi2byeCKthfDhLVm3bXDfZ/5qB5rjM9kyz9lEthOfYMDKMtUoFELr6JiQTOTG7xWztctXt+XguYn2crZs1nwV111lTIoPqSMxwfT3vYq4Aouzw7YOk+tfDU8vQO5g29i3b0eGKIsDTqMDbvHRy3OBJDFAUNmk9g6+I+l4sIPjwZA2zGVmED+dB9gA/XI9BboX/vpCKi7k+lSWP+olsP1UrlGSqy2unWl3k7m46zMC6KIjpIDb58JK8F4Yaw/9Nqpy7zXaAybD9x4n1HK02THlfNEErJXb6OmaCzCDTlix4oAQukX8gFXH92n6DhpSS6Sxy/ryoYoLIEsajcBKwV/zF8UQ7uwWBCxa0BKK3/OPNg5SNSr/60Y7OKRXIMadLOaIrbSAnC/bvQ2ASNZIZWG/v3AnGhQhiUqEoS3CqRBga613ot7jGUOIylwBKWxZbxpKowD5IjwMXohlfD/Fmn/Xyoz+gJlr0H/Cooq8WXByXfro4PB2EH2QEq+Ih4WN942Qf1l0D5cme+dL5aH56Digvon1PwnYeJivCy/jP/BgOpg6nVrICZpzGj3l+S/PLdLdM7wciA9ubjSzO20fCS1GsTYHFxY/2jNewJLQ3Z6c4WLk5hWl3V7Mxi5YhZ1qgdHXOmE0u9NP55TIqeLI2qJVEmvnfscXmSvDiBfPIrR+QC8lhgHNDyGssnj4La8sIL1KLXSxfTPOZlJbuFX0y7rT4HtamgnAw1xmzIgtMPdAuD3rAkFnK860//p8EXlvgJfbtgjiO9fcqAOGJHPyZ9Qyd42qruEBOI1TCuqeK/CGdhqLgfHzZFgEwfdiCmAiz2HGTgNJGEfJjuhSVAtylDaxFryGI2xZf99RdBPeWq9KzOAVD6m5k2P9dQs8d4c8OzUImjxvu7Yqp7BnidRxDu44rzeSHuLG5V2ynzQ3I6j8HmXyr+CXM7PRr6qHUJV5nCaBDfvfpdrtOyQdOGul3v44D6LRG1GwbIPjn8fjhZ+w6R7FODlKDZgPKgF/VDsjVrjWX0f7PVbJhV//bB8N/lLF/QFq5r9Rar/vVY11vf62TVbZZRCnPOFk9+0SHCBbC9dHBKs1pfUd0vELyqlwaVE47y+BPlx5ku1RAnuE0fDErDsPJC9vHdnV/mhDRDrwPoBbB63hwEQQEk7YpQhg7sG0PKjTmDt3Fv1pcFVk3qiWprqsCbBCegRfYaQtaK4Zw06gbBSHGGIYHRe9hir8wSU8PtwkmW1YoVeYJB/zzQPU1sg8x+99gzVJ2fqmfn8xu8RS3nCtIuH6TO6ANR4GcizURtpWwz75fXgxbUHhM9FrGJ26/JfO3TuerhbZjnt0ynJ/SY9m6rrFUaP4KhWVVuaRPDj6Ib7IK6NPhkf6NFMBin0lFJJDpk+OS91O+Y66NBUWIQk+Zn7mOnLRvXfKiS30phi6rFsMNNMZiMp8AeKq+55ccKk66Yb22G/1pPRCkXPT+9v5rboiEo7FVCA7hYI5L00urSIELUIhDD9CSx2plx/RARZKRuAtJSSrPXlf7nt0eN0qUU/sca1DjGjbUjG+za74QWADRyCnjCwJXm/KGkgCC4cINPH+R8jf2uqoaVtP3B/jyBCm6m/QEEOBXXsya8VXkFoacdU2hFTLbPAQU+B9herlbnoqsALIRagoEVP5kthZ4uwjm4siSDBMQMnrYbw9yInRIlhpbZW9G2vzC8m8gZGUaZFZdwsHIoCsLbvoOk9OjTHwLSHViahbzCCTay9YZd5oITcvEhFQXRu4egMSb9Guo/uWCCw/WbItexIIZpNzq+u8sB39RPSyXxOTk26ff9ximZxrzPy1bmgw7gWsBLjjau7eiOEGgJHgI0P/bAG0W74/jZyHwkCVqO7JHiufKul23jlPSkwwXnkYo4P76P7WItWtVRmGWCjv5R33sizryjaL2q8mjVJte4XF/SJkcjp4TjkBtpmSQdrF/uMRJkR7fQZsIgF96WuADB0gcxiA0M7XNYNzhPs0lLOg0vsqNUgHccIle0SRYN9hv9OCIkg3E/JKuLnzE7HnLUo1r7WzoLVYaqHQhoSl9DH8hlz9QHG3xNK55rNmJxCBq0CpPvayetOebTV/mLd6XHBBTd4Rpmm9ZivyNjuEH5V4szxO9GPpqzHORqnH8JSaoFhWnTaNy2SioIjD72oHYBxPNeYQ6mdYqJh/6bx85ltMlK5fvpPDE8X4ueugQspH1Af03D5DkCnS20vmLiXBpujSONBverHzKVzqnbhM5eWmzmOeH5cZGJe9IsEarGdnEsIDoG/Y+0BRSz4UFVvXYZndCXO02LRxYuofQHiWZskX0XqMMv4wf6pyQd7tTdTMaxEj3w5uvrvYsEBISmjCBOSr6GxTg/noflaBsmZ+Qg9XuGZJtN5vqOkv2knG5lSOOTOVApojb4VA+xelAknxgfDIKL1WPVEA29aL2PBbSSf7rTcpauKkd1zcs4LveOzE1+U/FoZyl3nTyEDvWIIM4o1szl6+UWQsLZXQ7G3gnUMVtydYiMcjIrXhNSshn8KVF7o5Stf7JBFsadQZJ/MOa/942p7x3AxrIk3++xm8yk96HEBUP9WY+yjmWwR/WjDEQ0NoMLJap22KjXHOQL3EHGmIjfh1jnevuGG+aVpuRHUzJ/DJgJGNaVOJWhoheNsMTmPCpzZPgXK5bWI9Msx1MGTAxrXiehmM3jNs8gSFTact9YY9CvWFrC6jxckE3coNXgcCmZQwvYPI5un+kdYyN8As2UVuvgpn82Oyel7Tf7b//MelxVSR1bH7EsthW0Jxswsdubuz/HTFRQFWKljYON2BP580HXgE1NQu9mi4nu+D19Tc7+wbr0r8I7Pa71jA0QODNhpzLKOFLPAQEIaEdsEoajwzIlmj4tqBasXJRk0RtsrzOhSjN1kqYthOTTL3BKu7GN/Vny+tdwBYjWlJPGltdHlyJMhMN6PDLnaEH9qaHG0K/QD9OF3yQLqRoV6oZhjWrv2vo7OcCAOSPfUAOlzTZenTC+08N/qsZ5egccaOMrQaiUnRdW+gn3e8jT5kDDMiFS7Pk1syyittErY35qJpMST8AJsJzveTcUQ0oBeWvmWCh1DHmynChUpK4q4Z3r+yeyXzatkjfczY9hvyOjLuP3AtdmAP00loHxge+DHy6ZpWy/bqct86GH0LIUmu8136jUrULufRjTHmlSMdM+4qlDGApSP6i6icsW9cCyP5oGdFWoEfumhg4SKBwtQUj42mruTq09A7fFNkfgXIKo5YGpg34TtiZm8+0Y5cvwYot5t61jh/dO98S1FLSRqWOHuhSq3DWSjeo7UwzAeqwanHXC+2LVgjo5s5luLQoSyWR83fR1YFv9hiUZOY6s9pwSkEqKBpPnxL62GF6iqMIkNsUtvCOTr0FbwXGnVM8E5td2LHurZROvp3UJeJDsQO/T4GsyP/aShMHWm7jZUxV5+Bzhdlva/YA+D3bcUfbL+6NwdEiQw3Q62uQvQxbA7Zyp/+syCJ1LJMP7QjQUBvM+zLmamb+aftJGoVo4NrQBa79xw5yZNnipHVUNqfOzgFUwUGBxXCLYH8nc7AVVLQ+tQZqHf7KofnD97H5ENY3wI+H/lZ+OOaqApGRIvrMwpgf7WdOvFTwbW55D3BnZkqKGD17Z1yeIQJIL92FTGhQV9/dTa9DtXg14araRPqvKFNv/SLKtJQ66rdE3/Xm607ouG5ldJR3Kwb3TpEnGvikaun9Gza6XkuJ0mokdTNTOk19zEku1oC1+mfNBthUAKps6jbv1AkhmQ9JJsp7ePwB/20ZStqWbFI9GOqgRkBRG8sqKer0AfyrQltRZ1Bn+h2unjRKWpqp+t4BjqYC6QZEjIrILtSFyo7iB3+/rn+Ru0VpcWfFgkl1l+gXT2OWKNMdny2YVkIhyRe4BEMAu0ewRt+gQ7pFErf41iiQMgkDucQuH7CAQP1SxojlYKhpn8z3zLi3k/tHBe2kGkuvwQ9p0dR+B93vuHty34UC9hFwCWzTJs/kHSA/pjP4wbZVG0GsOA+dgkecqoaz00RbAuyjU95BGwaYejiV7aQWLG4xxhlJmM4sEFcP/LP7pe30bfqqhshWrIO6dJhLS9oMYNzyDzDv0H5eeow/5rZesAqC67hSolYoLkbcapLpWaoEJzPJ4CU8HC/ryMd/TDx/wModuRUoVeKbTtcSTPQQxwIZ3x0B4ZbS/BT5FtphDX0w5w5VzYr9nAxRalSMWuhK0zJTTQSpX04Yja+23V/f6x5TNHdJUudWsLrBH0uGTERqcOtGz+qDmLI1JbLSUnDca8A9uBnSPvrnVQFH2YzdN1X8nyNbt1yb7Het/QvRkd0He4tKyO9w4bTeqQ8szcUmri7/fRqeB26EL9ywcgzW24uxSQmV11dzlWY8Ma0CgVNZOVU/Q7K++t9YO8nA/bRO4rRqCMEPx6R+TY1VRkyNsyYJNvoJmn8O9+6A/6XdXyQ2/iFYb5VxxjP9HeZQse6J3c1TUWMCg+gPi98W4Gp+P+/ZsO5zLymTohJqs/0deom4sngXwwExVqeC+jQPDAXddOP5hV98OrI8zMehfh/vvUmg61afslPrlMYlYT0yDIME0JxKguEc4I1Pv4Jt8rSAZJHuKIHojbmF9KUNozAXhz09A8DLihWDOPNwDHxrQ36DD7xJnuc9vGMltJt+3oaJiOQpCmS/8XCfx6JptNS3cFsg7uUAWVNC5ZvA+Q23cVk/M9enzr4yCU4rUxwsR9yack2sWyFvvEewPogLxfRWnpnI8IA2kOE/V7anWZZhVwJWGp800A3DcYzieVv/TnPhhVQi6VH2EstF+tIMQ6F6cHA/OuX5CciqZBKFBsnWiT/3E6sMEw2LxLPbGFWa+oBn737MplxLrRRDNh5F6jnqlzIkI6wTgEY9RDpqcQEi5bhpvkfB1jR3Oigx46yjzZ8l6RHhrYAw5tBNgBRC062/RoV6q53wk2atjpEeRuSGLt+pS8iHpboK8zmMTMxQ4mZvOWSFheRhs9VGvkpN91RykcSqh+WUHwq2wYA8Y4aWrFAFhWF1rE31e10RNfXyHIhpuvy+mYRqwQyLbCAIgBfejPT9n9TlwwFZNs7m+AxHMFNcGbflCKwAk6uK37F4vAFgGJbiZsNtE6GdGhEDqzXRAoVqPHtQtCgtMvwp8Qx80wCHtLesVt2/EHBY9d/F9yyhnlqoTZJg+q+ML911Gxp1/V8+r5XTmE9YP9QUDyW2RJ/3jx55JoQBeHTq+SiD56pNOqXHcSWguqpqE1LqF720raYfmonoxEtSdikiBYqFXXb/wdIL4IP/jKoMi0/DJN62lPHXYN3Py1PG6VYEmz5SULFXhyrKEskCKUL6JA8wdEvg2UL13u72wEOdxd8igVWSEvkmV7bl16jNF7nsUQuuMs2hTXnu4z0npcVbTsw10H49/TQ3kbU5LCiUFAG4YJ+a1y5gy10R4Z5CauTWLQdjzoFY9JESeQqi6Ik8qsNeGFkphv5LZqc6D6ucWbtx7Ui/STzPK2xLvYxTbGzYIXV2SPnk8oo/PNMwNPEchZEM1xlI9UsLqLVtOTenyG6rswmikEpW7xfbQfIG8Mc4aYJDDGaROq5rhbgPpV4fTH46lSD7R0c2770w27IxQnJypDDKC2aE+EZJh3Dma6OwhI5sqeUSMxllcbzDkfS9Mg4xzbIlw5mLZh7SuSjpet/NDnaGvKIDnyVbD3CzD/bqQfYmeTmDWtA5SUFf6CdcPQj9nN1WSStUQYZ7EyGQSlVjNj5GYGAoJ8u2gwgf43ZlLtMoA+7/HYqe1blJVAS55/piVtquKOQ6jwty8zTaKP8uyiC2KCWK/Utpvx8dIuncqhyY+BBOkzZlmpXmegkeG7xg4I/oGy6+S9+C39A4VIr5MbhPzXmIrFwDx3T/oHavfW2RZ9lMyD+cwjSaOKbq6obTViak1zCnGBrxMkpYBJ4Lvpk+GQk3wgW98qK7a9GLuomgUjBSc/vxtfPhfc9qcIrCqM7tO6yhi0ppumqmZqowD2cUA9XgzC/65SXbRaX/7VOLPJ+5U+VhbI8BMDHbA6Myt9nsFZPwkOUg182mviDarUtsR0Fh5z3XePV+j9tPCbrco2h3mmpYnhHHjI8edeB4byjD1WNDhj5ENYuKBWgs4uyhxRqF+8RqQ4PdIfxPbxGf5lnv0vXMn58oWoGZ0u1OLMaLZrv3IBFh15yfHt3dAVcqqrTS1UHd3eTA8wzIuxW3WSR4e2P+W4UP14KrmMgxgt71SyHGekiRE9A/pkUJhoe4eRM68HuMuLlhEVZLwFZ5ONo0oz8ar0kphXLOZdQTrVoiBLBZtGzAHef4COV35aHCfaxImfLZBisHeOrhajBQ3fzT5XTEctkBEl0BtLDJODcjqysSwNjHbB61UfJNwg5uwKmQNaUhq+wLC4tjOUbKrCXNTstiyWJ4nIxb9A1HYnY7+OR0DUxe7K/Kz/8Xi/UKgeU15xXjtFeahZmue5HI/pYNNSn4UQIbApYZznwG+8Z0LXYugLDurmXsJ3DVPODID/5Wyzc91BnIh2jRQDxp1D84KBPdEVrtGtHPLCwE8gB+tPwEL0kTM7DLe76Y2h/IdbUgssRNbQoZeuMc8FscQHtCvFHVaHiWoK05tYAzDEq5Yz8i/yfpDEobUdBSCxRRvujVbiSjKxdrykWo4HvsUrVze3/eo1P4cB5x/p4+am54agJrzQbW3eScp3RN1+LHUHY268YJuj+5ozuTEFDqh1VyCCVUp4zNLQOxBKpEFvrUfVVuLVl5P9BFg4t+dbRhRn2KPDhM/RtCXhKU232MuXNtWlGJ3dCM3igZ1z9dN7L373srsBEll+uBBBSq9JzjDTgY79ViWpJAAbA+bbHKXJUksIUTV4tuJlnQjTjCXbFoQ2NJtNsqjTu0nwy0/yFYVBvF4bd4cE5IwdfKv4MDyvaIZtEPV11cyYdbb2eRAwGkeFZVxnFMElahb9lLePY5DS+k0+LzRptSzNk1Bikv7psu+j2BG7RYn6DUZivjygihtuEx9keLYprxUVZxFONyaPtxUv0CBPouEpkqrIpxf/BJeYQbsYHmhOeTcfpjY8k+SWF6iMJlZl3UPIym8SC8A9gqyNW2yfulUVT9g7B6zYIhM/i1f09PHG52s2XFYZGPQfw1tpxKUJK6TV9g7oZosnGn8fUum+62KAUW/znmr7bwYlBZsVxklATDzZeUMofAhftMYWPOg+huS+98wnyfDrAs4FRiFVe4OcmdIPodtaPbYC/f4fwO8Z0SYsWh4xt4GJL+3/tkehN3dNANCns5SNs2Yo8LsMNFmIWQVc7fyNrpnGAs4UmLedwr7H7mxH7LCvr4M2ptdNciPWJBAy9MQfcb4XyXIwe+0ab9+MqVxUSzjUBM+6dzsoxIHzYnWpuhpKA7xIKIqaJryOhZDDuL3c4MhFo177eQasjX/K0Fm7iarEJ5reSXG0SW8l5TZyRrMhxVoXq1mRQUP5dd3jcUjnMpCBBDSeJtRWMwg8Jap7wiCWR2OPE5GXAhDwsmS88ALE7OzhLRiDypBiXUR1RixiqHBctR0urkDe+GyAUm1HqC9yabylsBbabEhEuNRH8Qi4FN3JoE2LW+UK/Qj4uaM/ixAGA9J542csvVy3tRZ8qdZro4ziXNoNqOpTxCyozCFwtMZ8abzbPGH6mPnv2MHuwQg5iEpG68MNUxO540CQ+qnhU0CDZqa7wYDu8kMIqg2yqNMtQ+8uBFdtw/ITVPop8QiY0W1nu05F+VhpyOmqvPsb/DD2DvTbUwuTQQ9SH6ThAd+5ZzG8H97jQq+5Z4e4tVaYhmT/X3MzfHe9M92WBU374yrnXHwvdU2mgE301cdd356L2dX+t6zu6xyWT6auZ5hUTeevQMn2kWYsg8YnjBraiLutsmki/q+w8+F4esM9IYImGhGinZcWvwkl12ZRfZaAndTvY8xKkFoWcX5d6Lw/aVOLsjkAxGM5DD3cRFSOPCHuP4li1W+hPrTgZcY+1XJUA1jfXU8zoH1g3XXYPQUuv6CFJ77If+heF7bmI6KdYCsb7epFqfMCo5HiPULGro4BWaQUk9ZnWg0mni1O+xL356jlnE7zgwAuyIsKui/fUmQ7ChQrRSmrqlFlK+RWxFo3nUC5BnlXYj5fMz2Io5FYZhe3iwlXikzD576ibi0mzcH3DA7WKoJjBJ83XwJ2MxZnifDF7Qml1vgX5q1rdvf+tT5SsZiHO72pE7LsLDjlflfWm5k76YvIziPimpJ3Y+qUmFLHOZ0KBG3IBk3fNPA+VSVcPt0eZQ4oAEAWsqKxiRvA1uhyJ0mEdhbC00pk6aYTcnldqlTekzU1mN8ccl9BJhVz34JTrBiX97pChTQxwPnd9+fSEzbJK4zeOZ+OPQf7T8ncv8/E+MpjV2wUSpyYrWu+ftEliZZV9Iu/VoG6/A4A85w5WX5a0bfHgf6ApI9HeON9TyoE7F0+6jVjVIBAQqA1HbJjlED1w/He563RgxQzW/yvWRiDCo63T8yqfNlrbOP/PzS+7R+EO7qhFPEQatIzwL/MbSCVXeHm9uqww7JKYJsGFzIMOKoP/KHoZtcsECjxroum5HSAg5ctB7Gt/ndzKCtOG97H/mx7c7oTpbCNVTZ/xib6j35HRAJNEe5QVkc3SeUOyJh6AdniL3snZOieSEDcnWUItil/Pzh43JN0rAP/8x9CATxmBQPAFpulBNdjrjnnZdmkK4kAPPS3xcc1/uNrRKiZTtEaZiX31fDTOUmeHrOVPye8av0WfC9WxCkfJNq4Xo+GpF0LcX41lMVDjHrY3sxQaQaxuTuthZPsqSzgT8GymMPqPvbvQOiYqdzrb2+C3/DhTR/rtDwU6f4huLu6pKprBgTw+EWyoT4Q37tTm5ZI5I1Uo/jxVA5U3/Wc5Xf9pM9SHEVHtsIi3kBF837YPVj/EG/GU2dDzXnfI9ZSremzl4UyZW6cC4rYKzq8KfQZ2m7X+HLEeOoVTcvtrZcQQaJX+auGwcoIIezKm8ct7qZ6SEH6fh6dAPcyZHDGVFBa4w2JRBJj5toWsbvi5O+FVA68RfYTghqFTeOY0YT7hk+qVsY9/whF4hH9MX0rkiDei8o7wa9ctpozAYMxsxMA87PwT/jFVk8eaj+eZvWUPU1RYGM3ldDFNYOFtAKrOIQNcsIKvl/Ee/Mox/0G7AA/Zy9FB2hg3SvDZy9eUePyFZ/PH+muGftkmDwgfz9Tk/7vnko6794gHmZTZnzX9YrLy6CZiB2err/LEXJVbYHhUyncnZzCR6taLoSaIwgYMZkw0qSbj93foByzFQpNcKDMr1ILKgTXmfYmxFXS1ZIdp/i9WVCJEWHAN+9Xk/Beooa7qePt4SXJjLReeYMTZ9vEe774ij7LYE2TOqB5i63tQY+tqXqYUg6dtsIVOKTxvS6H2PtInaFx29wU+DJKMVUHJX0h5j0nAMgIz+mF+TOBnUusdU+3yT46xlKuZyr/OX6aV0DW9yNh1FeWofb4IBS+JgL15SKZ013fPCb6FrSWvAyzBhTiGxOOJRpY6K736PsV1ORU2/kSJhL+Hlz5hj275Q28pfx3W1dHUNEmKSutHEJXOz6oz6zijbnVYVIrjmholHjUhoZppeD/gjrrjj9AeiZq6d0+kSf0ptNd2Cj7+KKNE6VlRsRj6Y/8mMx7UkvzAUoBmSbj44C3OhP7tOvr6xM5L4L6JrBW+R6boyjrchJve3GCLXW8gadvpB3/0Kxh1tpYqwK/L9LcKNQdP7CqHVEiYpp3ZzEqo3p6idHqVxTQFi/frVovpP5w5QHFug71hfepXsX9D7vvk6tGfuklmihAaluLJq5qmKNuLGohCkndkf2zd5+QNFZscOAMmIj9GdyAazaclKWpOG7BhUdufmyRMYS/wyZzV5z1cRVNzvZVG/9QfAADQVjfRuRQ8MNOjH4zweuKpsZHlJ9sgAOPVcjLWXl32y84P9MBWc+yZuCgy+0eiELFimnyLN+0agk9fptcYDTNqdt7Wqg3Np/LTt0wgfyfgEHS9enmWOO1WSrnU7TPFi19pdY2yTRaqvsXI+7ov26UFI81uBS9VK3Ia6pDmav9pBBowdy64i1NdUtk77oWXI5xH/+8wydrXt2IIqjUeF+A9Rod3vHt5wNFTdNpX3IYAf/aFPMPG3dhvRzY2VDA9r9n6UEqDOB5ydp7bBzpfMvHIWAN9tpOeXAMC0ZyoDCLtkU0ZtwXd8sby7KtE/ycKBixaVFHZ2diftp+WiicbtMR9ILdax/3sqzMPTr2funZwb5hE6FQf3OH/c0Ywu4pjrnGgGEEm3kFeeMI7kJKelnpDOp9H9pgG1Kx9XMEFi5Y2B5Zt7+KVZyfXhEMLny08a1cJKW/iJYhHNrKvjwbEr4zvmmn+AXC14GfKs/03L+MMJRyQd4WXNZ08amIBCP8sb1EvRl0IVdDrewDDLaYFs5N0RSgtz/kYOgM75BN5x2Ei8OZa5pzwZP64qN9O4wBXaGiOXQWpYtN5Z2iFIx2Xwvz6b5z5zoqfRQ791d+q0oooQq52IWiKpJMoJncLpFrA4ye8qHI8N8pJDbP+ateT8EdxsCB5gg2G7Reh14k59GmF0Nk7WvZhM/421vftVlp8iemDqlR5AOT/yBqHzXDPtQd5fweaO5rEQ170rRVwTZ00Zl/pvlUWZLvNL8Hk645anCDdIWf+nTcDfCYSGaVvzW83QiDFzj/1bWkvDT/cO+qU9G1BILMJ2g1P0aLjxGBQn1tsHmaZzuiOH44nEiLWjrCJNyH48KkC8tWMcU3Fqr4C36pfGvJKZH7ta8hz/26MyCXG0nv1ofRZl8GUFm0XAjSlMQpz6uxGj/M6pP9gawV+qBNv7UwbrmHiTignSvOBe9nX+gAuyTyA8Vb5M3zHOeRDW8NZ2QyVQc2P5iBItUh8g5f1j7BhHq5bi1s8EWo16+LvO5wnoaoPe+rl4cS5D/dS+AlQhD5HzbPvz3RpDDCeyluvlayhFwIQT6kfNXaKyaLA+SX94OeERsGPqmGwmegLgyiLGRQAjDFdw9SdgVUIqWYVBr70mRsrp5k+1PJkS/f/DVF+RdMjuinb5hxZ+GHvawK2Y6A1A4zigmnjRkYl4vlPbY8X/cY5DM7nV/q/nzmfqGiD5CvX4hCNNSYTIuGDlLqYvp0SU+fd3VWi9MV5ed/K7g755eBQKwo+m6KWxFLYiKIR66aDB8pQttf0Hv4fHQnto0L/XXxeZssz4tbHZWGNa0jM3wO4OLKUuqj98oNPSa93lmhkRyWCYsKszqwEtzi7yNSKDwUWDm/SYV7+83xmgwvZQw3YvIfV3O99+h3yB1R5V1Kw+pWKQ1bmL7oNqf84zr9vGzVhGt5JYBb2+U7goPcNl71Bek2KqhGY+eBEXD10235XMRTL+5wuSFnUfzAPWpq66twjDrkuyOFD24TwaJfuClG0Riq/nNYHUYw6R3jTAOOpeirKrzHaEo28ifH6uEqTKs7TeWtc5bfaYYmmSCxZcrWWMk4oINAdCTE6uxzJZqhFHAB+gn2/N2nq4Ps/l6j5MD+0oXWUFV1R8cpvD/ljTo3IzDs2XPgSuYwwMJwcY4fUPU9EeAWnXf3toP1sHFpPM9LayS/amuOmBxUkfYT/9xLfc/rZaRNJiESW51w3LajT/b0/g2vNpN2a7amRYiv7c9OPTmu5tWUZ3OmpfAarEsRHMfivBDqHH7pik1Lkey1O59DwJIo1Ps5mUbbvswrwMrlQPxlVnD6Z1NJ8qVA+3TM97UxEYhaMVsjq2KH2yEowl4/nm1Rd9I1YVGZaN787vxv/hEi0ra6OCl2UMmteFny9mQzC/19WUEQ48rbo1NwV6X6AeRQ1C22bd/Tu/Ya1DqlmB+XeJhdagO5kyFvWL0Bs9CMhn7bi2qewGbeXQF799xvkDN5J3kR6jqPOlZV5hlb6LCaqAPKcyoumijf7K047NDrtVfcVO+ZQ97MvBuFi86+514i3i7t/rGGFbuw5axU0KXQbrydJSDA6i9QQJdkkPiLzZoTR+P4aC+6Ry8XdEIUMpEHOQI1XgBk+1OrnRx/lYHm0Z49CADd6xFbNe6I1wTN+mZzWtDj0FOpqCEEkbBkMBwPyq5vsw769zMXg36KZV2u/hLhhOfl6X2hkvDqDQ4KQlIajQoAy2WYxLcKLg5nfFTOj34TgApZWHwUa3aYfVnsxMjBviPSqjmB6DpnWXNZnGgdrq9jxRsNzDB69HAl0H2TIKTrE8Y4Q0CbercDf3FtZp3hbxCtAnLe60dNspYQdS4fU0Le7gOsdwg+LGuvXQSx/E1lMPFtxvR6EmfkPkQtpQaOjHRBiUuM2k+gL+7zMYeAIydiLUpQZqtad1xzzZVzKrGtxnfRWJIELa+x9i1YttZDYlzrmR2eCHgHAWy9lJtvYab9EVF6JcPf0y0Ijv+zLiMwVw5QsJeHGD/aTo5OuD89xwM52vKd+DCbkfuStfLhvPXQjmBv0i40+4PdEw8b8OZo+Uu5CUeKFHmlYFHX87uLbiGhTEF1UkNETNWDmRkRudC17y5Agk7C3L4iWNnFKUIcwl7oy7fxiBbVAR2IxHkaslv2AyCS8j+8sETRQLbuFa2YkDwtPdClDyc1KSonqtysw6MXll7j511uZAKWuAsxhA5fgawmmd69R3Cb5NSqOeUG41UCLsOXd3x0FbIHHPLn0pXy1qXx2pp41r6Wj8bAbQBWl7IBuNBBH+JreKLGFT+6gpTIxEar3jP4bKasL51yvtkdphzO33FRQgTIuhwIZkC45MMUBilz5itSy/cwCrkInBB1Do+kPNpemKmwETjW1QtrLZR6QiZvOKpZOelcn0fu45T8Eom/anwBkxpsDQufFyhtFoJ86rTx1n7nKPjC7kP6zsfSNnmQ7IGS51+YLN83ptlla+S6bTMk5YZwHOCM8nc2m/JLckKAzxSuE6n3veHYDGye6scbXclAx4grjxxJgdK6HuqoPf54M+xuVhDMwT6l1rI9hN6pPnr4nwmw7gDE+9SPrcciizW9NwfxeVmNzyvXLW1rTovS8fNU9xh4m7TmlaXVH3VWwjBHTPrbfr0EyWGlqWiGaRseG6db1T6949Hj+ZTXuE7WzFRsTzLWPsftor81/WVDGU6lQTJIclTUfBuZcaxl/A9YU1qkrRxuVRHgE5oIfYIJxhROB/eqnb10MfjzhQbSi6oCn+Dgduw/+qytxzlhlxUb17SG+6m51iqk5diZDVCPVLjaW7tsKMDcK+hih1K2MsLPYHoRikLUAuKOTbWbwgq/82o1EaLG4Z8ObOJ3NlpvsrGuWVzPLixCzniafkOAn4HGjtCUPIhv9M2oVRnVlG+Wm+/UCpjMD0nOXYtSIZy/0lEtKlpB90v4j1qcmlfv2YeR6nLTqt2Ji5eGoypaozZzz0NBJlRKrrHUERRmaF4DXq5OnNklFSKJ+v7fqFHyL58447oWgNACRkpxXlhafgrfccN2s96/UwarVAXdAQbqHouYDPFd09iF9qhkiFAOwkj/kkZ8IvmYLwWgaZdVacuGgBUkeUN9zL0LawJDuQ+9XSVf9hGEDjF2IBXuPjoeTvUMiAOGUv+LA0ehvg6w0HIgScqW+PJYQkqbC55F/pp55+znm9s2XwXg6AO1PTGASBUexIOo/MttzMVAne+HN+Vf6ihPR6+qtelsK9X3FScWfL63JdqkWgu8MbDRU5bav8gMON7b6FoL3u7Pd0AdIsdZJww2g9usdrF72pm3ikN9HqI//OxQDCV3I7wspp4qJMpToZ1hXiIfZQsNzBSoiGXPGC5JR1Pfgezw/WPgNRu5y4cOKH/ix3aoOt6/0ZygA2d37EKTNmsv3UOglSnkp9QQqs7CtEcUiBKTKfL6ykNrb9AIdTKG2aGol0ANI442UiTpWp6OgX06sjs5z30kcE33z1qJJIeG51m1+DTK88+lDX/cSy2SgBqQ3uU69cLdaYuZSLV2oLzPbuqEuw6cBL5zZBr+ZU/m8eaqZDubC4uYvdtQhKUeGY9qZW/095Bh5TtRYrVO4qfL/pZgw/50B3QRdlsRleD1o448GE2Egb+W/U+ld9gvhgaNJV1t68a2z8N5mbCq3trNUjyJf16H5Ir/l8p0QATdd7mH0z+2qgrxrYjOnGZcrNDZf5F0VjtwGxTNvXn44jW4wFmu9qTQFGSv6czyb/ghiuncfx79kaaJ53eO9gaYbZtzZmJZBz7eCu5rA6vsU/JulHM2jK++XJJmFnIoZukiEwfpJxaksE4zW08k3CoxiTN7FVObMEwsMXK/7OxBjXg464YHPQxDdAs0WKMBsBmUk5EV0nB8Wn1NYCep+ZLee32BjhyKy4HzwYOs64Sy0NnYixU2xAbF2QmKAT9/v/FEL4q15IXSeA4asCqPC43v0d382M5jbR/qPwle//o4KFnB881EMUxAIwU0/CUdw1rcIqws5zuzVDHnftyjBrmBhrbw8IDL5hJ/dVmS70+4J2+JFaIKk3MBkLYZkZFmap3VrFNTCfJc4McOSCQAoW0Lhl69VjgspgWcal/5zhcmMtRfes8T/EOjQp/fhG5i+Kat0ZoFqD2BJiAwIfEcA8JLlriDIkgeHJ4lbCwBK/oYgdx4IZFkyRTLqVTxJx/ZEoHcaaQspBrUE6Fg4wOLAa9SZhf5B68YWTtOsJrCN8MswPM5KGN6ZTNw4NEEKX95NsXoDl9eA2f/Ms5TRkDLaiUYXa+Sr5keGr/USRYfREJ92ONzuNvFMqnjoQ767Oy/Nh7BJ9rbO8nqFIE5xfYeTLti9VbVc6WC7Nr6sXp2C2zvg8NeiK22LOR+NKzxFwqAKCt+RXDcKfEyfgWdNGaEM+TdSAogPqGX+3ad9sdvH++O7XKyOYIUMoYxK8v6yNNs984o29SZ8fkggfq6dbi4U+ZHZaGlFTn9iUeaG7cgLJtHXc4wyZAWtW9Z9AnIU35P5OveKmuEMWYitlX0J4T51n3+T1zG7EGxeRV1DdVYJFiQP5MgpyoXNgtxiOP8hpgLBgAybP7rHc2pLHF4faAhShBUkbIGLTMUXnrnsfX8HcX6TP3eBO602FCyeTC9iv6SbaQ9Je7G1EuLzBRbFhr2pVD0ZE2n5akBrkY1DyIDiln00phNk3iESt90g8e+zmlvMNOu1T6PWE9x3Velcx6VcqIeSIXT5r6oX7tOwA+6pgd/xjk7IgT20xd12kMzpL9Hujcml2w6ZMuKXhnEmtlK7Fz0jFjtgbZJ3tB1NBcjZBxa0wMLtXktP7jo4d1+X0h6p1wxyRWoOeEVNSOtVfvgwlbsZJh2Jw/g3tzYPO7VKVt175yct6g/eX49BhwGz1yrOidIs65Xwr9Hm7O+7Aoevxg7epKz5AC+RPncdNvChbTHzM1sNtdVnMnGWzPJi2hbnZhjmIb66rdmbJiP32hjvU8vHLdt1mntuSev4mg8FqXqB3Mgb310+/XhlXwuiCDmoGICLyLd0teSx9HXq0HFwyCuMjaKZG9zFj/3Vkj/YYZKfxxTjFSbq71G/aQNE3JC35IJzcafdCdc6pcV3UBk49EmADCi0xsyqAw6ejR+HLlXLtdew2Y4FE809U/JJDUtWDqsK6+DxvIlQNLPpMdJWWe0u5hz6vqeY4PXCZ/wuj8eRyWKJFznaYBPQRPnwpg6fRavMpL3rm6evE/6q/hKXRt/Q8ROycCAyphyW4Kd7a730owbIz44nAXyvKozmypPsJPrUTz4nABylETO292BKGjP5K1QO2KWIsXIs7BfAS89iY1EuqeAvxyC48N/Lx4Zb22mt8LoBQjQd79lAuG/nGF2OrPUKxqvuuShH6+zQw2DSNQP3BqrriC/38bfEx0Ssib+0iMwPQKlfwjX9Two7lIxvqDltqiPzVC7aERFFkObp8rQd6wMKtTTsl+r2jCWfIUq3IH6+DxmmfIZWH0OnWQqclU7tLNcd4S988wQDk0fK8PxQlY7k42lWRmj/8NKliQkQDgW36etP1tbuqLNf0ZkSXXUDNaM85bEsWOr/IU/EIV+EJIHkoIBz4u2A1h++p+TBgGmZFbw0h6eaKYKb5bdMBiSuGTqFpgpdb2/UZ4gaOnE66P9HWGuK/1otfv2hEXiMBDu7nrjVDCJf/4J9uSNEnFf4Y+cdKuJcXejtusJrGzk+iIlfMITu6piGtPHVWKs+EtW4U8HyfmpBkbyvxuWRscPY+eP7G7oK0fBfuQQFW+cvBltqw4w+07ZMUeltIrFU8R3kSxDCqThGmIUbVV6RLTkgnh9x/VKgfPNoYj9WKBc/OKXeatO+Gi5h3xhFtQ5bRWQkHlkmxPQCSyJuO+LwlxsBgfbiayMZ0V15trjYcjTL1yGoISZQ5hFqQfcTkiX5venuXJgJGCpfAKOkRDxJ5gSYp1oTay74txZFDSWyuu9cEFwJK7f9JC+eDIXPWrDGute9iJCu4t6j52Eh7KSxS28LwqTSuyN2JnDJV64u6WoQiJnvnio42sEhumFdsJw2RTbAA6GDP9JfHaQ2ImbB5jJSr97/DhBBb4XdDOMjqhPLelij5Kq04YE7dNASZ8wsFGh/3ls6nMmgcyOz2ff3wJHzdZmnUjtOlK1n9PROjj3qlGZ63oSpVOtNBfyptvNwOKmRp8XTeyRQNFvGgfXOLTWUTZXenWHcsTMvtH0IqAlXNCVGeqavxvuaspVUP2LSGeA37PHWHwWBKJ9h+BXt9ta/sKb75bbqiuUI1nic8XVV07njpwJlKscO3fslJ7N/JxuV7U30yX4Wkk07czbpYhN/F0hobTIW42/NrFN6P9O22RCxaB21NSPlsHZypiMlts/2b7BlYcYch3Kml2BWOMQNYrImJo5EurlCyiU3X7eeyvonmkaBi8COieh2PgBiMovIxfLpdx4D9JP/7tR71PFaoJ7hC4sshrUGWE9O+xmgKPeh8iwwCByIe65sb5APdf6SZYf4KngjzQzSKNPYLV1fhaSf6e8SUXIb7+LG4WT4sj157v/yA1FPQeKJdJc7Lgo1zlLV/dfMirymAC70I8kNteQR932hxmGtY6WMCX5Vzv3FwreuXMBxRamNcpM0lXq6hvCDQ2Fnb+nIV9P2XnP9R40Kac2VU10v2ttyiBOay73zkKfj1MxzhL4SUF+HeWhCJbmV/WQRkQm3RH5Hy2vECIwy6ISSkMFf8U5XJtVeWOA4Swd2+5Izadb3bWjMHaDropHRV5nGNjB7wL9HzFiep5YRfgd4w9puyByIX7iMnxEsw88XHUNtj6s3bInIdFxsDkgghnn+rso4tU193RUjrDjsIVfNn3qvx+OppGpKwwsrDNRJUSl3/ATUrXN9xpoPFFlEnmODdGA2CKIzZE8HqMfw8i/X8vNEKxd4zA0RixjPXn1azFPp9ebHJM8SZ+Oo0bDpgot0wRJfZA/w4PRBNZrWaTnr/c235zKMs/pb/27X6UkDaNAp0qA8P+x4wu0c48wHZr9hSb/TLguriotWqKhKA5tQt3l/ZJtuCXWFmJLrCj4lNaNQDCjOx6LqwiT8zrgEGSHl7KRm021aNTLNWuUX87ldzH250jJpwE+9Vc1Bl5dL3cZCyzhJASU7bWscRizY9w8QXsgXZZV+gsTFFcJ2BkiZIHmVgXyvPlqGpOTqRvKxVtF3mdBenjFFH/qaATmqYx8hbFNU6gtWWTlWWu/yi1LPW81a4N7Nax9Ew4T3LQXusJOfKdjG46I1PXAUrzMsHy4yNbyBx8UNeJGZ3z+d33Zj0n9befiJLSN6PrRCixLZw7Hj4a89RKClzP2Hk8Z2smd0pvbPEb36ioRGN2pWEQx9XiO0alcA3PhtekVg91Eubsuz20SiMlXpUlOV9F/Rq6ZBeRdpWpcceuBERfnAy7x9ImMScsY65bJMydBXlV29nWzfnuVXx8yaYMX7g5pxKW4VYiSDdA/0fZjOFfx6mETcdqfkmAt34FueXWG/LGWx5N2hVTlKnogUv+WSkV8vJ77cH5MFY6SXZbc0mKhCGzlX62UKH2Z/x11GbPeXKsOymGbvnrODw1ZJJw6+4iiIfRmStKtsIMCnVrMtuCYs67e2dMmDx/MPqdFWoiOp9H7us1qPB7WPfpQJypWZPIAdGHzhACGw4pDHViIC4kyEuLRfX6OTurAR4wvDPGp5m7oWCq6G2EeYinq5uBBBUWz9f/euzR1ucYiI5bgOo8VHdW721P6Uvq3YqU5hm/d1+9H1qjKjroNNbEXzn+ebj8DYy08Fv+eybPonSRjQcfHNxNxLUukuzwztFXSFizx14/WBKgs/7AJ7jCpzTUV9AXVfMZxxbT+4/NKwnXI7hwU8ZJ7Mq75gkQrHfPyK0QBefZVly8ij0Lx/11LhDyHDaLC0mxEDcvdY7lpCA4GQDDv8B1AfH9kJcngJ7wJ6KxL197srzcA21SdUfwWcIf9wadtKwB4iRWBae20Lncu303iJHu0pjH32qkR9yp7uZQAR521YY8ZI9rCY2CZeleKa39VF+6770r+oM8BKM33u94bha4h7weXTb2UQY/oOxoV6b8pvycWR7zbNkmnR4mLoLoXQaKLnUddFjLciKyConfmROZosAydgPCIbjU478CTcZiX6VIdZQw36pd/OFCkLYyYm+lnxe1gs4mpEHKeGKU+b7rHXoHffWvWm9uTFtPsOeH/k9z+bvzaUHcVm2lDusXQwN71Z7tP9xyT5kqSrkcF6O4D+EFiQ3i9HKZHi7u8PGoo+R+u2rXqb3PIeHeaMZ3mKhfk1C4gDLvoqVxBt1AtLRU1sdVzcODlhQ/ZSWB91C4wDzGfu/DrHxdjLPPXYyOzTj4vnBn/0m2CEXESvLRECrXKdxarLIrVvWEGuMHu0aDlpL7ZNgm0OPbWJiJteEBa0u8CPZUw1QjgXqM4JNzvWuraeDkCc4QWvHgMs8WKbQMv4MU1nZSTqpb2GmvvyGvAacWv3WS6ldKRJsSvBGxyLdnXndsR10NCf3t63o9BXPvYPvMheAMJyie0B6SuRA0meFX2nh5ifRB3HmWHZ7i8ICe8mdKwqRbuPvUKWdGZuFM0jIksKxkWIo6ZmAo8g74Ie57VUUqipckOBp7vTz4PHscU4lrl9LH7otKrkCINI8VZUy0DpOsU0inKRiY1BSxPqEtdeiQ9wb4k4gflI7ETbLkDGqimqvERU8+3nbcDOV87INIPQ2DPBGIyEdSGuS6xk6Uoc/zNszV3iQOMeIVtxCOetlTfQuguLqXNQJqn2xdoFFhIQ4CFarGmWmydpPGjAh1lIEuVMA7HwbChSz8eHkWlrvSohJn962XCW4mQkVqWeLkGtpg/sXLvIOVYf5iRFJNjucDo93HRT++4dLJ9gS6zFxsVlxYmJiAm7/0jcws9JMCZVdMtIs9K4n9lBzpIj/xCU1Rgp8Oov8BJPUaV+6niQ3W+VHNfEnqUH+XyEVCKTJx/3Da2VLooemb7QTPp/NVnRlzhvPvOfrmC49p6Uv244lkf7gDF55xbUIH/B+S7Q+U8uTwuhHqV2GJks33UgAIBu3PxKym3Kn5xwVKLEzro4K+6gVfbOXZflgPuES4sbyEQImko1OL2ByRVobAHD+5Qana8GM4GGbNHTWtWK+/fZSP2jlm82qsZ99bpVgFNb6FiUX8ikOg/zlBpyscNg4hRVizrgx105U5YMmtsz9eMUpgbbXM8cQyiTzVY7UnjPD89QWnfuSOTv+iJ0oKOuzD6O3gJhs7WT46JAr+lxYq4+Y18mDy68FImUrPSbACX0XYDI0qxWVeV/GTZLr1IO7cfsVZ9qb0eEzkWo2ejPAgVjwuqeAz60omqeX43nzA3wwwXOQy/PeH6FYuItQMk2m19SBvYxLDh8gZVFyqQTbFTDdLYnKbHyIWIqHWVJh2H5CxN1LOKKEhg6e0nw4Zc1cmvpaZo8cvsUkOfOPtuqtYrDIvF2ZgBaYK7DT697tm3VCADBXj8fSEOYxool7ufQNoTFNYI1LjkCdYcmIOUnQJdqQnJRLksH8Y8WeKnlSy0cpZAp0BhGk3CXf26i0Hc3PyuSVR86W0a0SxrFrtvAbFnm5XOj3z/xBlAaw0sAABGbBDXSvIouRCJU48xI0WKZcIbY1YLu/gWAJCGaZuzc1aWXrRauA0zsNx5bx8ozld0LIoaB69ehSUCw7MhdHqeAbNfVTVoAv88i/8e+TRHwryA7URcwAEIoL9eRt1mooY/ccSyGxhFX+JBovGiA624dr9h31f4bxvTqU6fT7ZeO9cEsnKQUTXqtn3OMKpF557cN5x5m6dCpt81g56ZGvpgHtTKr33LnFJiByZ+3g/97pS2BfeOOVgoampA0u8VPrGfS8qpM+AGOTpND0g9gea4to3HqyglDgtGnq5/hWzll9BbPev4zX7vO9FHTIgnIndzIgeUWb2RDTHiEwg6ER5CcukaeYL4xTgYQzdhs11Ick6onidtA7IiknnIpy7zTE4XANyimJw7B8HGcSDSeaKT52qeut+dPfe1e/KSYjVa4NieZVf93md1Jha/SRvBPdkpUN1Co8Yfis8Pg08a/Fd6h17uydw1WT5n1T320SdGn/dCFSL1cNtQWYCr76kJSCCqi4orMo4sK6rdf1jfq1bhLTni3Fi2AYmEUNcFNCS4sUpOp5Y4kz3oFYf/2OfcPIvF/si45vSuzbrxEH0NNvoAP6WVjQBvSIvO8VR90XZmbTnvQKVkqnZzU5EliqYj2oFLzLqW+l0XHRMHDkiiZag8QghHdIluCxWybVKSsKxn3o0eq6BROEm9a2i5TKj9yXNbnbgkKvCTqOVNXW5tIyNSg2dlR2W4UFADf1lIZF0fS8oLV2FmT6DO3Z6qw++n96mXLEFoZIzUzYGrFDPihr0GD+8bGgRQw4NaS6CU4nCIUENmpWv0bksiwBmdWiHB59SNSB+Lc/W+aB17FbALPiT/iXLWQb0OaGOtZ96oyv7vtZhA0OOvZVOHbbPKimYmcDcpUpN+rPhh0Rsk6kENCwvl/B81ex65rug7pVpJxaFvH8xYQXuvvFaBCTwfKfq6ZcIw0Sbt+aScl+V51HIz98/eNaOKIXmpK9AVhBN9RnKlIE+9PhGewe0OCFQzdd1DNAExaCTS3yVAG1arYwSj+R99UMmpzKHtGlmHc3cb0Ae/yxY663c6B0N+ACZnP5PUM/7THHzfYOVJOVvt4/BMox5k81KsufLzomcDMxQWBctG9uqt5hxDdRiVi02DuF+/86Nea60Ufcghad3otZ6Uy/pBHKxaleuYS0KR/RJxpBL3tL5qJ1DINMMXP6lvxysCccq55PcjH8K2YD0re6rnpP2/bzEat6qQxw6TwbuvxoD87NfgpJ70B2iDCdEdTrYBgHHE9MU2ay/bJFysPEgRYaw6H69f0syOmicIzLPAmEGda3fsZmzszYqYhMB3skth4arKC0sqz5t7XQn4XXity04MgPUkDOf0jY71aNy98iz5uXQPqx8dMlnbkLKZiH6c1yTWNQf1Bh2DpDmSTj8KLxNf9M97dg1yWsoYcHZqUOxZyrfH9ja/L+A3z/KR3An6jRd/6nWR3MnsvWztuaFASOwNN8f2HGVXC7WSSm3pFj5Ur58tFtCkHBRxLD9fbqd7WgrA2x6PGcHNRzzFl5i3semBHKb4PCJ+vhbvAjLh6sRZZr8T2XnB72m1kHnyNKdgPqp5SsiJnYD+QlJJkAUb2Y0DeOEEAO1bO3amdDQr+1vxRTSuRZwuNKr0ToOzGoWfUWWgSBW2z2Zt9hY7nSSj2aPOzUrWgTLYkIA3RcqncZ1Y4ObGfqi5nCgNKsQl6KvlOYvIIdDhjkgW4FBrO31+UIb3iNdgOx7WXsQbeMwPgbNaw0DWZBd1yWHUKNguVEELwLJPv0emBRIxLQcI0IU3F2HrehYKdmF9/EbZyd6g0QxKLJIaVpCFPR/X7cV99jytJ47CFP8F6jYHfLxfPCL33qZDNu8wgXYgSBoh9Qo7ZLC0IfZ8bNTRyy+12uN/QbEZwqU+jVJHxhU2ggpKGO5FzSxOM892fqWpmTgtIZXbCqilJFFzMRQ+nKpf6FweRqiPfnwOcswytSdfl5K1AcTc+pjIiZ7amqzm6xUFOvVuNdgxtmbaQ09Bt1Yw3c7F+swDSPHHrlzz51OeKvki8Owmf8dzICQankPpv4mbRH2h6LI1M3rZ8Gvj/FelsG8kAmXVsWF7fruM+koyDX5TGPJKIW038WzqJjnXDcu6kG61NtgHAOJCnASI1i7YIxbW4SjNbzhvBjOltlLIJq+KuBeRhFYbYjAZq7OtWrOjsnty/5WDrXqS4oD/4TyaanJcXoS4lDHnAIcwfk8ECM264UVOQ13+cxi1TOJUhg7NsYPmZ5Tg0lBLrTlYW/g7o8zznXlXB/7IzSjPzWX5IGqvAP0qiZd8qtNi+zaRoX+UY0hlGtDJPW+Esk2n6TULDO92HeKVCZvpVa8ZMliIv9XX+KK5JC8b6Zvqw7K+kfFVpVZmBOX+5VWUlJ18+EkXdxB7sa3tMxQzFf6UN8wD9noHPLwenFkfJCH5o0kKqp7v9kPiJ+vsSnYN/FIVKrQ5r7UkOeMFQlRpaqEPTYTk/Res0o3653B8yolH0nbSJQwhBkmj8gwdaduDgCCrlbInt5hEw7gPU9LKPoxo5FEccvIy9yBA//bbQ59yqeJXJ+z6+oFOlkfNNE36yyAxIVKymKnuLtj+V7N90+mMWdfr2PAKSCiAOhVTDPS55z9qe0CnRaKlXQ+stBgrhzNoUHDmFg6uBQ80amQO9WAArwVlDLh4vCH8ioKK3yFVVNMnJ5lI914Y6OVsmt9qYbG/PYfRHze05Y11amY09WrCFVoEVeKj7mLeGfrUxRi90QN5QFVmXOwyO2aD+xUaGQIIUcLPq4AnprxKmWhEhqiQD3P8VqrCSlrcvM6ykHSwUsSjKUoiSGt++cf1x3pe4ZbqN5wNYvFewNInA8bXtarBRyj4mw2fTF7guQiD4XIiEUVR/6H32NmMqUevjRgr0jTatSrvkxA/qY03crNlWEVdBqsihUguouL4VKhWFaZu2WtjL5xtFEKLwBVW1L56oCiUVq8SZoEdZ/gqrbJzlZSrflWxFTTsquJxF+1L0X7oC9vwKsFaQpbvbuJ84ceI1aRhdq+6Hh9KjRbcmmAMYrpDiuGzp/DKfuJoKQkjRHINKv+p/b584MBow/+R8jPZEgoqlPtS3jqeLsleDiBtOHGDcMVMHwmGtLOkt7vxnCegGlxz2diqCJQ7qEQINUP8idZjCQPBl5lYXEwJPTmoe5Bb56zEfAejEidh0BGdkBLo2mDAuUoZbMKJV8yq2Z79Vp2433odME137R8dS7+wdZTWt75kWUafxkI3s2CmzFJHeLu1EtNH5KFodzNeCz5cchya8a33qndL53R04gT0INHQoWLnqwFcuBeB7Ii10hwFMiqAB1EMvhsjCZjc4z7FfyCrhEyFfE0oHM6Ufhu4okQHMQxHWRgFxQW42aFtwDk3OQPzmC9rzxR8tUWE1H4KIgSVC5GHZTJ/dYDm/QEpxOqyRATdYCNSmrTm5rFaXHbe0oPeLsKeKuLh1x0jdzk1KPrksv0SuEUiVXEZSXWEGPj1dzHQCBNHus/zTMJkjsL7/daUfNWlxT/jwvofuDE34xsYvf/qkIR7bCo8iTvLMIha+xo6h/4yNfEZfXlQZhq07mAR9ID7q24QUZoQw0H6Yv1Q1bTIUoM7LAMKldtMuw9T2gHse03u/RTaUO4WL9SUzRfXpCEAbp9AxN0OsKXwUSrqI7a8NvWNS8rV7DSD8x/sR77aqELG+KYC85/qkDPYdNaSEUVGWiHVLYZvvInACXirE1WS1Nw71xYyfbpdCMaoczs7a07E8BbplTnP8GtR4Qb1HBI32dvhbj4ZjBtaNrD6wY72LuTA4RpFVXTOBsZEDZIb+IMDyNxMUkQiE9AZUZ6xAJNjTWCuXP/ohBDqIF4GRrp5dgU3IMYXpPody24+La2vipsoUR6P280B3mj7WBr8hWPSTkTREcwpHkTh/78J8O3WpJOEeQkwJPnCfWbRjsDnVQ8DEVhov/gKPPE7Bp+NMJ7so4YYzcGE8LTedGaRvvmLvdgf8bf80fpNAhkdJaJTCw5q4mQbuubsVn9zWP/TaMJlFeJbKgCm5dbdEQfrtkLWSwyVy2hv3s3seqbwYMuwClfjYx63munPxORFbXwRqT2vdHBcwT3V31oeAKCTOqEe8l2JpaKLHuyxGCPuRfv/g4FlonOMy9QYEJF/WMAq9wgaW0n0N0YWtLxzyNDDTScVe/KF8oqInWohML7IaAihD4ushR5iW6jKcyKtQCSWEerwvBr0NN6qagDd+hyJD1wcUFssgeuwSz+OGOFCZFLI7p0LhlPOBphLQ4rDWF7uQt5eqM48zovFw6lr5m9QUkHmuc7UIEUyCwiclHvDx50uet6sQQSQGF+j5hf+9HPxFdC4JTJ9REa89jvOTN57DRe0Lv+6PV+j640yQvQm3G+OEuj4ExmZvIDlAoywfoMmzWs0CalDFW0VAO4mqAhSizwuxSeYIzKWw9St+Kat0aWfQ57HZfq5TfSv+hjub3v4EqYfn4oZmK6E+6yaY0TP/AsuIClVRboq4hsZHUhG4GKh1QmkqgCldf6dGyTc3jP1e8yLJef+nzLfAcW5LYOmh1cjCcf+2Sgd7fIMDFCFCc7Zct0vSuKAr5LczN9SwDM4eX2xfBuQsNAlNijdFJ2Gp0O2zQ3dvfdSpEapwI9E0AaCr43Zemi+oEUGj+fmy/bzACUtKmvph/MgFgrpdpNHrcZOeXoPCZsj4pbIvgybbpxJQxwhJI3RIp1r77ed6u2yl388kqi8xmH84U1AOjIQciDpaJVPvbyAORVD6wsvf8ZSzt4ZtWg71m5ak/5Jm9XCICJto2ACW9pAp2+w/UfUTuAUA0EUAZ1TzM06HaqvNkyyUToiAGRphTVCYdglfPXAaURpHENTY+xdSnrTXr3P91qrGc72yiGuZQm+EaE1boGSciwGGm962KiRzX7/PadwgrBK3YrxqQNNrvXagsEpHh+LpTlnX/AA4XJLZ66e6QZyJ851wWdvRPv+Z+4CRsbOWyjHC+0u/poA2bW/y2/cFc0E/6S/Oznl4LSgVDdo5penR0ZTMBOff3HJaY7iChT27Q+hFUM0OR/psMFIadjAjDRgcBtGHdTwwHVZckSfzgvANYiSv6dB7jGcfgtgkdcR+BIxbdFbfJwgWSb3LugCD80RRXbB9Ml3WCN3m8/CDIIjYUr0A8dAXX9eIMOW7tzoET0LF/fll3BCqmW5o6DURwL5X37wzFcFrfV4cedHtVgBMZ+2zBKAUvZ8mT1HmWl8sIAMIWBOowGZDW6pU6hRZ+Jp+s5RL1dQL9kqnGr3XIWRNqSS78f+h2GDCm9CnyhXhxdigHGhmLxmNINwPLfS1gCFambU/yCowUfSJn4jx6D0pdUit4ESsTyGxUektQrpjeG1YNYuh9BG3n1+brNDX/orpoYKU3pTMkEjG4M+Ac0SuRH1ykhZ/OZwVmwhn6wZNdtc9giD4L2Kn6UjQajZFL/LxtroPWf2wp3emSHQ8HAVyd7be80yLFqRTYDksO+hsJXQ3qQ3HIPykK01EuA8pmSgSpf01TLZ2XG+voLCDcMCfR4pLbcltBdmEQ+eU9gWeF6EVuTxcTZw3/RSoNd4kAsJGS0qpJ6o1w9gG7iIp5C3QheyFrUSggPladezpiX5K+uOHN9lDOyxyqQst3RR0CSseN1DWKoVOtq3JtrmDKy1j+8jf9IgplZAByM79XPrq4kZ1C6bILGO/7V83H/GLtlFoYnvwlgyr1+IjdoPzARUyo7QJJ+k6acZb4UReRJof8JByt0NoXg0su+8qtfdSo9I7Lu7SWbRptnUa9R/Tu5VYCOOgtM5wwy2uG82MLAJmrw9rhu4Ym9TxXhBBLl82RjlwaIh3GYky7kcyFLbtBhbVYvdkUXdNJpKCZjVIlUEu21AunkYI4lvgAHmYPKt5c9iZs4Jkrj2BOnwIuCeMErrKdms8e7pTxydot6iONuxw1YBalO8i/y2Ch6MgfAB+rWoF/AchDiAMHp8io4/FID1unArxXxBckgec9OKsGiucGLuaorIPwjoEHucaf3L2s/CxU6ZN90RENmzpc6Gv3YMGWNtQWBuUJYC0pOncdElVN3CpZGgzMODzQfNQ1sRN2EVRp28mIvM2BDMWtGqCoIpeJNzqxhrWsqmwXBvU8X48sNXRkJztDPBiKVrbTFoBNvCHA5Yq3Z+gSGw0wSgliOtUXMX5LK8bF/iHIx0brjscRvooeXilBbiy/ubf/BRQV9d5097orDpy69V0POPEp4TbORHxkNcOtr2So4cmBA81iAqrb9G66zGy+KlnL04BHzOC4onm0uflrPTJR+yRmVpntowGcBN9hOvOrXlat0ndrQ2qDvpjHc/hLg48Hx440fpamPvTvnEOqYI+FY9oOLL5bQUt2j26KmxIFQzHXdFiwxGJubcWT5kTbADm/puOAuYrMew8AWWmp20hqsF7cckpyXz/ihpPgiUimSN0GLiWKSDZweDhabyJNuU/Lr/btCeldHyfMts2IUkUGWVQShig7pqXQpAYCKIsWblyuF/ipByiaqZiA77ra1I7DiHN+8EhrAWWBmLER1T1j7sCJH/YAcE1xm5V3f/chXjuKAqkpm7Qkl7hF3O9HLt+vaQ9qUdf71q8Z9ZZq8HCR51G/TN5BU/BTjoGQE/+jEoWLImpbW1Sj/f+OPVElUN8j7W6DbmGV94yudDGdluvaNOOT52KHGffG2nWUxUUJO2FXWiBEplfP80RwBmSTWWrKepll5R9nugW158+YlHyVJKMl92wMoG/K/Ec9WZlj1Osqj1tmeSUVu+Fsy7BXBdfIpGyohyapZ6OU1GKg+7y69QwVzXO0rM0RrxKEscAkM5RRpc0NwSJ2i4Bql5eN4JdnbizzBQpa4vsoXqNlwz4sifqojQmw8EYwL8Uaw/yapS5FXtpmyZR3zXATaeFBXIUc0GhweFrgfGddLPktei+lyohwqoWtZxoWENjZpX4nZF28QCfKMoiuw8fN498KeV0s9Ty3gffQBXr+3JTyYgcQE1GK3F5aN1JKe5pdgP3AgCULNFufG97+zSgK67TNYzAWjT3M8t/4u0KmIoFtplAjUIrc5YdUgHq77ksggdqsHARbScevz7en26TfrH+epLZrlzcC8VvZShMq71RZBskPNxGg44tMrmFG1JpOITK+lCYmOy0qVxratdZ0vQzsWSol10L3tXHmU33g41D/bmKIQsIiydpf41nwJ2HcPWoT25UlqSt1UcTy3DTTHyBqK2dNQhhEIY37JOekDFTR96ZcVRji6kiFbZ5Ts+uEip1CB4RUWtxuAJB/QSDW5sl7E+unQChnOdByWJAOFTFLgU/jeG9kcOcM9wWAV30mpItarifHqCzWzRuqLtSlSknzjXhIEipqjMQIHdgEWdiba0KsjuY9ekYptCAGy5lwRYDyVSJ5hv4Jm+n2TwX3MOHhim8W/8er69dsHjyEPGPjtt74+fiSJCkqBFIYiJR/FjdUQt36tPjNLXDg4KpuUc4ZTCgsBwg7MyZmtCthoxHQnapUqOjrxO8iROm+QR2wfpozJLPcuHbqRxPn3ti9SZSGdp7zdTcWtfVa3DBIVnNXVa3/QDD2d36NIB5nQDub2C7iQvlY77ybospPWBJU8jR3VC3Ab9d+kwxOMBDH1ZQjKYNsVsKFKx9fEPW+W6smdrwl0VVZVmqO1pQJCZ1BE/gESZai9J73ZIHUsjj2VQdL47oh2bBXBrSR3454Ba+OURpzxITviIgv9yleT5A+beLQFn/QlYCFx3/IIeF8DId90j7eFQ82sdW3aQL+fsxVgqGyWCiwqVPDoGTYsPmmgBudELP791hNL5DkoEABBKKQIzLASyZ1Yr1IzxNAEx+A84RWPi5TWIv2T5t2zGbRKdO7KVx0Cyre0FPkEm/ZjX54SxNOx+3A3ag1cZmlWGAJZNcu1Ca05j0Pq8yFapjkfBvLAANL/vy0Flazxhvia4dJdqNRnxNa6ZpwDaR4mb/hOj2PjY+0E4k9y0dWC4g+XD73AFffbNIWSUVWayoHwAWb0IUVcekLcmTLoDkG/KYAND8o85wF7o2lFhO8ThN5aQoRH9QB/Nmj8455sqE0uU83PV5p8YHWUynvAot1ruDNPQ0RKG+YROQW4T2i283yMx9akjre5KYci/1n4XfSc4iLtYmk52beZP2zHusAN1fP+kO1U22UtcbtfoqzIoH4B5UvFo4/h4r3biWVHFg7tEvbZxAUQEKtO9PevB7E1iiTnN2A+rZe1P9zhu+J4oYzvAgRnwvshKtoU9xEeraeqvWuRAJUw87ZO1tGXU/JB07vwPTCTPW+uDwxh3HipiGcGY5ruJuXAssvg9ILT4FXjoMVTN4mKy+z54HQuax860xSIDn0tcCdok0N9S9Fb51MTfsadWloclYuLhNVQE4uqGWFFwuUeGKyeevZTzFI6nRjUTo0RrzVYIIxAOJNHM+u06DG9V4HXol/xM9XItgSfGvywEsSYbpn1bUrulMOdrJKRIwd/yCa0r0PQWUNE9lyZhpETOiojgWNSn7tDEiZJ8XYCG+bLbuuia+u4njdryROeHhceq/5SBKhdLJJQxHn2T4iom5H2oA5YTjrnVKVlVwQ/IM17r1XlEtFjizWHoiIiG8WIUJoTlSc9guDgcVaC6ge2jSC/cQAtPMJ5EuR+bmk5VhhMmjf4np6cZ+cFha8xopngZK6lFXgOwy1amqgKUhO4iwtHfnhvCjID58AQ/LXQyagRuEyHqGnR0R2wlyxNJVUoEDkHKFCgReKBeZLw6ee4MscL73yuPlSDc4sRkOfJyFJsHGQ223+A0qcWXbzZV6KnIU93r4hg2IjicRVSf1dTP0rNVeb4fdqTbjUrFSUW8UZ1Vn0LU2RpdeRSNvlUjcoz6ZR1tyIEAHfd245W+c1SYTVYHgMhwGZbrMAt0j6y2iUhCpxYqR2YZL+1srYGDEYEErKzbVPlggFQOuW309iUMSU6F+DE3KmGMXESOUo7S220FTVLw9De8f4vy63dzFILi15FQD6wgeFN4hMfKQExoQ2udYIa0d1pY0PH9C5OcfnNxndgdgwfu1BkCpyImpoPeE2Ul42cDuP1qMQsa452xeNrDHw+tGZNvhurOuF/kK4Fgl4NcIUwJzprcsReixXoKhqZGp1b1VLARFv1E7vKLMSxqC9zekK7ZD4OQWjWDWDM32duGCFZ3t2HBIpETT8vNY+/WdfhmUKCqFk3ArdHzaTdRpRBCHpXRCg3JbltcenNOJuIWPFYmpoYMeduzu8Y/5CXVQwZu/gEhQgEA0KX7fqgo2nsRYaObGqGZTV5JJQATfh4zy9Jp+qENhrqneCxA9ykBklWfqIZ37gE6jp9OSWcSeGWqVm6/TiWoZEuqNad4GHbAIVqUDLnZqLIPgN2SWE+uNtRTcfTX3kGtdDbHRMu2G0eFFhJyhDHSVj2OptlwkVj3mem3AJPXhMuCdVYo395BCFE5mFk0SvM4RxwybVkmOzto0k3/XgRzC+8aACDyDSnndS3fqgE91CIpMJKqPRj+Mi37gwt65SQYUiLJrKuHRwrdXC2akbgtJUmdIfucwH6zYiiI8cQBrhfqg83z+vZxCAmyCwpJGRJ8XbEGd+KOZE7uB4/TjTTthJ//0TpzKIkbz7E1koLYbGzSCfcz/o1pdLeEbB+ymXkpUtXzE3dktFKz3x+ojZ7SOM0JMOQvQUmTUMTSF6+joCVy2ng596icYfMVFxca/9R4J56O1MbJgAxtRaNycjvwvlcMB++qtozPkez43ojAqqbI8KTKxYo/7CzaWD7zJXj7ZahvFwe6waecNfLrCaU/V0sCbNzVZNaU0gbcjrzo+vS+C4u438qnxD0SVy+kOD0PDHdqUIq67AJ9KT9d0WY9/DvKWpJnqZINyT/ol1eXAs18KmJLXeq8NDobWPBghmq1fDpHkq9sstZY4vTagaXLdFQdgl1ChEHbGGJvCcYehMAGBoPeLVWTT/PKur+Ae53cCw3iJlIdyk68d/EIq1cApT9OKaBaxWVw3xHhMgJq1pvJys45as4cN4hRAlTXt32rjL6F7lZrpDObTsQqBHaK8pWwA1HPsY305h7+j6vb80smZ1zK2CJtFQmqW4DWxqB7GFAF6fh27HbZBba8cDZNSYTmyoRjmC+GJ7xQzbGZ8d9qp+Z6TUcPbdrqU+UkPGDt6okw7qLO8IvLJ9JixTvPhHWYFM6B29neFJg2p3jqd3p0TcP0Mz3bSNtpRR4W4XEwBiRxKVhF8WMnh/FS08ZbHNB+I9ehyF07mWywcsmDFTZP0dW/iOGk1dvrHwoSj4eSTBKTjNLwxhOyNRkmdOOlMjqwm8u7aPyVs5AgDjra/eHB6ldpjr1RNreEIRi+sy5EIb/G0ljjoNj/Q/2OsZxclD0OOh3LZ+s40BDrZAPrEvF21u5PbZ+RMVrzllrJJ5cWUBYHT342hNA36HfvT7Brue+d5ImVo4UW0wk6U2+9mItIlPA2CbSL0f3ykseR4DXOAj1IC9Jvgt2CUNKRyPqfr8yd+VPBW2rOGNcyKyaArfP54A+NujDw2PcI73iZFHGIKjhsJa6XeVWtIZZDgJc/bXoXYcBOdOOWZM3oXhwZIUdrrIP2gvCluShOS2D+bl0mf6IZ4SVu9NfvZmLifOLlgyX66l+kj4+w5qoHYuqujRkEOyYHDkB4Uv+Se8Go1P235M7l3/aaPlqxo1F4uYpB630G0GgOsAWXT/bAv/xcFdqqcyQx1nnRUIVXubfFi5E9qJJv5TX6yiqXxZ1jB1b4LgqJ4TuW/baxu1SWg/3IAovyvAVgE01Iuc9uy1RrfhTUd55ivXgrUwzWMCtRbgc3VH15lNkuYdCB8u9ckB2flJK46UMsvb7ozQgurOFdH2Z3ByOi2/OIAY30njdomlVMgmAaW2J4xBInxW7msjJQ6BMJhbbItGtEc2PhCLHV14il+v9EHoAdVZ0Q9DF16FCHzdcER2V4umiG+m3LNTkd+8upiRGlhP51EihK8Y0Siq4dVonR9KObdKGzwdpy+Eo1qYW7pW7l6y3nOMZBKIX3+ycmlI6Tb1cWS8cXdqeRs8S7vQfPME8x4v9dW8SdMUGPws4tJskWAa1qHE3Z5LIBntZDonyOEYyZRR6oGNffZwMmp6ZAQ7MlOr5Y9WSy0d1ql0ypz/hHwYZOiDWDYmmK1CpPm3yXZv0cUT+C8+WqDvN8MZQ965H6eDTEtB4ExZuR7R3uFrwhgRoDCVbtZBMIVACMj++oLMYhf9Rr/J+S7GUEcdD1Gqfg6QxolmkND7mPA2bCzRyDcTcMSeYetUBqDJ+fFIEVF7x2YRAbkao1MUijrLs16ybhwi3HIBOBw7aX48XL4bqMRvXqEAY3li9cU0zS4y7mLAG8rXFmnEGXbTOWXSB0J2QRbwbedeK4FfdTk/2DIyKZy5rXLKZjew8VcEzHo2VodvV9u5gD5qfbqCad8fA1MctE49unlMxgaxMtdzr7WA7V6hmeI//ORkqqTn6AnVSDtag6zObgGitF/7EAaKxA0uS81lgT/+vdv347ZotlWr8F/wf08MSGBQzTW81juhwNf2wU2s5kk1HvrXGQrAoaWG38S1G0auIOGKzNhTQo1T2mET/ZyO0J+INZOQiGywAzBjr3J1z7ZyU/aULoUarDwRjEloLtOcNKSJdQu+xNC1wl6XysX7JtUlxcnKQBv7c8EWqJhBVTn9HsdMitZL+z6uCff/7zOa+Ka9hoWpucuZElmOJ+ZLUoaEFAP3Qp5dBObhMAProUgW6FGd5HZ6i3D7adKHplFL+S46Ct6E/QbKTFBfIqg5HeyHdb9MAd9M7fzsPWx7pp4MRzUQ7LixNmHaetJziioBVRYmUYhgklqKvbbwVNkiW4scfzXlJiUPUkrDOo+IwTPPE3CASG6JLB3l+wROfaU/yW+8cgVrZwK8Nq7U6pR1NK2pN5tZsVT6aeIyqtZWqpQGr989GYRc3SWbya/scVH7E/f0KytSC4xqxP32c/mnnxYLgCU/VxNd/A0fCltJJf5JL4QuadWUOmaH6M24ulZV1ggpldHMrLfDr2RXKX4HxIYQAu9tx/VnxGXls0AJkRveWCW3SnfXYk5ce/zvuU19AY5WncjEtvtm62bfdHmLCggB3pLQ9p5FvNifG28g24q7b9YbhccueXfUQd5xCMj9qa46Ii8YUG+yAl6xG4koqEcLPxdSWUF1wW+ZAWjFjlneCmfKDaeLyc5XjAxvyJm9l2KXXA99TQpaaSLDph/Lq9qlAnnhiLslKCWulM0uwpWutypU1u6+x4eTssVn+2l2C9PK1QLEccOrq/KuWAZyBeABAavIyTMo/2lXfDHDyJgv1KzgV2ToEtgYUf+2KfKeekYy9B6/I0YxY7WD6m7aAQ6KtLKdvRf9RGzlfVst+NSwaB3XEeSjMkgjG0FHAq65BxwySEezrPIaVZSG/doQPd4xKRIoSpoyzT91hjZ5qqSeM7AGdzvHHqXh0smSvt443wEkDi+UAl9CyI5fkhQ59CE4DL2yP6ClJ3P3NYKwZavOAvvXirBWriOssYYuHd+yv4H2VMLuBkw64p2TAPcO3IMXc/VGiSAtBKpeJ/a0zsCexhJRiQkOaqugWnrfnbb2IqHsKZevMqyqh4uQL7oXOmds9ivDat64ky5ilBofOy3nXH4AOT+MfJq0qDsMm2DngwLvtC8oToV/705nrKgEmMT5+ISVwZPm4TQlPrdC6vjk5/IFuoalKQe0tvvDZohv7+JOXwOi2okOJbgym5svAX0nCxu5aanShhti2fuhxY13wgszeMb1qCIs5gwM5Th0msV2KhwVEoOTOLR2n3Y8V0e+OMcYiIzqJx0OkRhMtU7YkG7HEqV4+Iu/NDb4IXEYUeqy6oOdJffvtU2vhznlxtU5Mur+CnR2ie1YopdgzGGrdpO1K5AA9VoPswt20JPPsWNRRnOuaeeSx+G2wXrb9O4q3CETfQN7lx+EUeFPRmDN0X/Kc+xAVinRbnbVyTMac5cT6jBuzqhC9Xe3dnpeo5V5C/SqiEbpi7QiR4RItgdE1mhb6QRKrYGXr+pQHw3KvYS3iVaWsvCpKLKWpyoQYqC5Nm5we/lzYLbfy4y2FdMPgJLICQf5Q2KS8Y3G1tLaAlJjiqVLyZnFmE9shORGkaLqr21feeFlg+11iSkc/GPpzzd+25OyuUF6oVF9Ffv414XvGRcbP4RajepcBhmksvixeeI9/1FWIo5jknsUjVrKbbmz/sdVq3LtK/YRLVSgTl1RUubngu2axVDR8TR1009obT3LN7Sb7ywyhLjn4asuriqyABLd6qGCCNWF/QULI+Ydzr+Ta0nTkCgr/2w5GUj+CK3aa4rJ50oMqFYcunY3MJv53HkrndI50MLevIebBgAz2FhhG3Al1y9ULJPPODiIilOm5k/g7PnPW7tyNKQD4pbJJVmYhB6ZSf3hxdQpeyKDHrX3NFajfr8kzeNAjrobcraDMpmZm+6DcnondhZvWSXaHLBdzX2xyiPP7EhWZtW3rhH+T4cH7I7p22egvcsjCY5T+ghKBpchRixLDkOr+aB/u0dbnB4hyOspUo8ki+SsWiRKMT+JFoLJpCC52IzhO8v22prM3ypChCKTxUBkFH/Fx9uUJ7yBSX9syPM1UdncfuvYfeWHnSlndpJYSyLSLES3daLORki59M4GyYH/VKATtehC7ArLSgjcAPs4cWs4/pKeWgFYqRVyrmiydFFqa8lLj25YFGQ/EuZUbFZjzkTQE8fijkxjaD5A+04iv0gCUE6wHL/IIWZJoh6iX9zrPpO1RnH3R7LpT/dGlirC/3ckVMZrxGs8vCldPCBGtGKNYsNX3oNgOSdF7l/QVetB9D9wgv4Vfmy1OOUzXZCtUfscU8e3SiiLQroHkKSvpC0xoj+PKhN5XCuS5/28bZ1P3twpPZnzjgbx/kskcAD+AF5rDI94pc01WeWG7Uvc01BiYPTE0o0mYB3plxqu8McYV492ZnfDGHv4iLIc817Eo1rbRmmntHtIQse09FOktEF7HUl8Pbyyc6aA+LGGEEDEVRAmmdWEBOkDVx+4vq9I4nqrX1JVI0o68xTM8XAQtS/xE6uGrOOvwitxVpCzv/rUagHeSDYeWMoIVhEQ/vl4BaZ1WdAjNTPBTDoygjTpQ72YOwbQVYqnBi4X7CYc7+GXqWgKU2P8eYpVt7ZfRK9PiFSLgukEERX+QZZgTKbonglNZe4HPko5+lH80teZv9/oD0f0lXfVfaqNUtLtGiZCT+Guo0/e0AN9uMebZIoGJiqt0yYuKRlLFpLdcKnqlS2WlN7DYGvMssvVKTjhXrv5CWLzMzKcN8SBtfQASBmovRVLHbGsolxi7NuZ2/JS++AOeRbUW98h8oRnF7JsxrVa1qZnm/gAGc1Bs5pNOQpGsxcupa1Gb42n16ruXC9sMy4wVPMM44cLkonIfonxQhDB8zlixI5w471+JMt/X370gvoU4h6ZS060IllpYcRr/rjkRSwpPZM+8nSW+93inucON0g+BqDiANVqcpO3J7INeoCr8Y9NveyH8zLeLXJHiIn4CCiqObmMsycpda6+0efClDa/fimhH6M2l05WYNRvC4cOsiO9fcLAKwnGbrK5NNGgaeba2NejGBOFbvCvEos04mzgHzK9ICQtaX/JMjNzBUiO+GwxskaDzl4tt/aKBvmJVrD/lF8i5f0guOfZ49WCaFcKh3FADuNrA9Kdql4HV6v3FaNWU0HJRJK62YI9vJ80uMJz2VlTj5cEhe/L9lITcYIbrJBiXvjYpPSK3Blojaokl5pA87npGg++fSEbzV0JkbF5pq7IQH9a9FYDCo4bzWwoTKB1dJee3UKhCMUhnwlqadzPCi0cZh93sJOMV9YoSLGiKS1FPSC1+HmodEDOIITYM8qtmkb94QTmzv/v5ShED5VeYYrQshtk6bgN5T1vHWtEsio1CsU0T0i8gsdD1kxlWvyxkIAGUm/ZXP2yasoJaKBH/FClKWa1bS8K+E1JyMx4oO4ziIXWFWMj1sojNpeOoz1sn0Tnnp+G5bOXXIprYCf2eaIhkXMysseFZxJ9w2Ih9vPvShRtnrUm1HcqyG8bb00XQq6Omy9SoKdqinNo7AyDyMZp2QHlhifGE3ZhVqi8ojabjiB74u7GmxmbaqXBeAo/lwcbhMi7iUohpfqlWZQh5rOL/Qm37KFIopkB85cAkmrZNLH/ywyur4O1djiskMgbRP9FBEwdWRta2hDRsDPBjXpTDHorbmDNroZo4IxdUvbv1rigKXFg6k4OghNCiVLoq3lEb512L1gkGy4jFfmpi6Jlyffy40EkA4FYTZHpGgNNhN8jHhVdmYNxQvQF+gf7iY4kv/7CE4qP0nsN1ohILE/8ejlzSKXMrctdgvO2soqJ5OR+/IOaAIP8MJMI4vIFDboGrQE9oApd3j5pRORds4yl5f4hqwqk4EsdWd3c0raTq03HBCW13b213O5WQnmfGx1LguQ2mNL0GJzqO2hmoRQR8F9oLQnh16V4lyGT+zi75m6GbwTXXRSemKjDn6vHCNMLO/E3ulmFrY3RIKq8mZ9xVfiRD7P6mg6a5gTct04jRiMYGZ3bqHKh7vWHw4qSamZsO18cJ1cXk6bTCpPzqtZu7VaUTEGK+2GphTKJbTok06tzwzUBksNCX91FccApUZGebwX8vEvREfBfVdmHJy6Phj0H1rQiuXhrr209eeEHSAlvKtODZGdqmqg1KvDO7M1joiulo3bpE2Pphqqwu7H73eUENP+CJKMgMgZIsNF7yn3sFrtWHYdoRPbTKBCsXHqIRxLnR9UdR7rrrX+QOJ8wfof0gGkOiyTcaZ+tunUFya3kxN+A3uGjOvb6kP+OXoYvo32PHOnwA2/k6X+eqECgr0oQXFR44OBS+7wSGJQYBmz/vB1APt/2QO4w43CFotdltuHGfRGHklk3cZVdZ6lxtVDMhJsetFBMW5MKoO1FAOC2zNM079ZVsBJk/eWeNU6iRmvXRoHRcjcbDPnSm+gQlpxJZ65XqPIMr4XuL6WWbk3NXDIuQB4CfcFt2wielQKZOZpAQ9WuXzHctlm0SP28XlKSNp5rM7kUEeJlq2v+pgrwo3U1z1zI+qD/CnU2ojpK88VHGPzoUCNYb/VkddpKz6p8CxqyRz+5BbMsb5BXDBsvUV9cRRLBZgzCI1jAqDLqpn3yGiyyH4kjQ53IwngC98vSeiArG0R4mAIRDGyE6PxtUwUoN5dO21XvkSzBO8l4GKhTPOd1lrRd5DG4E97kuxQlTP1U33Frt8ZjuqtkxDLE4QMrESAfjOqVuTJncw+3rb0d2eV+ZddrHsVemUwx3ZdxdB9IOby4+qfaCUlYtfto/QfGZnD4/5HyyLJ5HiBdpc7RBVqk1TkQatuCu7D2TtQpFXuVaN5glIzpANflTwkHf6Bvks/2zbP+JrpbreoMvaXaCTbTzGnTp3F4abiF+xsJW3c0FKeOXu1tboCpInYXF7Bb3iy0IUh/VWXtAdATkt95MmOckbLlAfrfZSJORKMzOAIdNL3Ttk84RzpaG+k30F13SIvVPwEW7JM7bbQgtxpCekO+mQ+SfW0grXogzcqUuG0FR+fZ/b8dvznOxhM7b2D7Si5v2VAv4Q8pdywpmNpYkkDAbu6LAwafS8MrQM/9rh+H0FBJ2lRtUSTDJF+sYHRVKmJPjRYwbk+zbcLFwvNurFDw4WJbQ4HxPS9l+I2nUxUajyCsTPZlyOGkwM3O/to1tAQQ/qCoet4dTWSq/0bzxe38qUnpRP6NRXbIf5E7f4d7epNO9eWVvmMXVYTfetWa5wGIL43gxrI5MPiUVnGaTBEodIBaXblIPDj3Ane0URmnG65TUoRj4EqOAbv/iwVA9AgVD7fwgiPdxHITOdpudo5qBxZ5SEtKzpn1qhUANkEq4vscE3102V/2RcDl3mmZeW4SYXHcMIUOfVyNtpTWu3ZNjSpUcdXqQXdchuQ5Fb4ZuzxxQXTvXRLGUzGTR5Xd+YcIw0tIGhlAxka6Rp18ygtFwgZfggSFpuhPKzx72NZbw4I1CxjCsJPQYhNv6DZM87QzFqKeUqJwnneCInUusdDmcqCEw/wtWCcPZOlSQIczjqPd7CD0pj4Kh49mXbm2Q5rmJ9mIOC0OiEz3Ag5165NIy9BeRakZiZL3v8snTQN7VdlWQEdXCg3KqhoSZ8GobjxUcQp8H6mCYZ0JHcIJkBeWwHY+G/AgAZtriqGuRGlq94uIjSP4KYw+Gnz1HQPzfeYl/+v7aM1zfrnxMpqv7Oov3gm5RYc8n99N6rWsEwq++5SHphkUoBSMK2zynfsK8FknOVQDAgywhT9qROqmkoRVH7XcA1UgAL3H6ZlTVhAVa9ezV/ZepiWaIm9aBIMuuRutlBCcuOO5z4myho2x+DoHJdVOIJxxcgQO3QHilpFl2bGCWU1UDh9fGj5ZKjTWN9LK3Z1LJfesZBvVDQLAfeebXSK7vymiVsbtoi+ov40cZitXk/+kyqTALD/nfcRCyMIJYpSrEK50r/ScclHf9ZhJBAffzhscz0gODz+LfJh3eyxDyn8LuY5kWPfMAWPlbQ9kDqL62X6TAzymedg0UNuKDQCzePdB8tKczojmSl9JMBX+NQ67wbQrktdS2uqnVgy28RhQym+t0BNZrCliBqL8F3BhYqMQ0KVXs1GwMrH2fRxzhd8FI9G88H3Vtiyt02bq+Z0DAJWbWL62+ZstVDECf3GhGGignqEPmYpwxTXRQ2b2av5tKF+q7ydhJ4+p0lk6NGf6gto6AHQrhCvFfW7FFggb23GAPyjNkwbY11oVU0IV1ZCuPxOzddlUegZb8Mzht+wJrgPhDKNK+O1vhY41R7MmnexhQFx3UcHOhqE46beTsgjvzfH6Q8fCH3s8exMWieyHyGBEIgdvFx1I3ADg+1w9ba2KeafpUcZt/GmkyCEsza+ijqxZvOAHXnFGMHSygfxFIRVQKkkmQzWXrrnqMzIN7TDQJvuNyocBMVY0yDHJNR1aFnZkupcISqzS/Y0UBDUtNTw8twlnQcBan2ct7vKGpdfZDrbtKBzi5eAKyNFAgxQLHGeMON2lvJL2RX/SLPdcPS2Wa7qLyfc0w+hFsXd7oNPhDhsfSEE4qlWpfIVLg0SJo8GzXVkp4bLqQWFXKzT5KF77nUL58taicAxGB8arPjRE9G/c+ntpn57h5Qq51qSGK9/4auX+U8IjXeJC+ELaE6Wgf5ffjte3v2DFg0Dx0iWfz+DFBo5u0OdckfSK1z4QqWXETgEjTOs0g3k+hqX2TQo4b/IddPvtwRdT4kxhYZOej3R9M/AYtF8PCFb8vBbuNRUwCKDlOqrXPjK/qyhXaJMnufhYCMxUh9vPDlRLrpOWVzb9FyEh/mCnhX6PFe2D0J0v5X4/kXGl9KLy36dRJr42tCCOo5O76m0lXqONaiO7lgfIeKoTlfCy1lQQ/tkvYCBfar6Khqq++bI4BxvOTv/UyXeid+LmUsBpq7hHGVVLgjM2h8qBvzxAVjJlsiuZPqBYSG8j0r5hRQD+CFpbxUzvKXsqvHY56CMIv4pfC5PtqKK+N5qejcjvqn1QPcEK55S0E7T2iQ1WjMr+JXF+hHHcK41X3M3ho4EmFQZNF3hzD5rpTDkCA4fcz2D3H0NtNDC1RlMTBjqSwEioBsQUGMhUzee0mXELgeymKDMdXFo0fL2YKE+5Tm7DeoH+bYP06KEruaALMD+lkYLU9DUCZuS/HgujsVynk9gF3l/sjWH78E9ixLrsm4OrSmMqm0GG9jGCS9+1KX1yVUeGB0WyiRFj54/niC+lRBr9ApoUk81C+DL3Pjaux2av3L7NQlrmJyQacCrOjEdEpKfpngWU4D8JU9vFK6QPlimkSbxneb4ZQQFZAHyMnwkgVXQhIGwdRpWUDh7jp2NkltFNfVk1o//HEPt2HZkjjDc60BPFvPg04GF+jPP5iIKITcCiYgTM1EsG5kx97vz3YfRUgHn8GpzPr1/I1iEln/Fw400qE+Khl2Yyb4qRwNZp2/lI2CwxdOrVgZwekkL1Mviqb7j0AWlb7nc8AgICXc4XVP3gnIw31bVtiiBZtJaCVW+ntok18HJ7PuNnFWeWK/BD0k77sgi9a8fHdZ+4BK/8T/9P8lvkgXxs2RKdtDHCR+avj/A1LqcPk5l8KJG9YaZ4FN9Q9NuaTdPkgbKK5M8DB5JqijF2EZNNiY/5aEwM1u3EY7gb+NHhbopHMu3wOl60C+u/3ZF4S52VeUjEPvukzazImcRTI/k1Kjfa1r+MNhSuCYitInyW3BxGLnz+VIfKIyj95aL5eZ7SJ78TZv5DpfFDFnjl6G9NXa564vgYqy8V0oyo8sqkzvDAJ9dMVc+b/jzHrYs+CzYPcA+B6qQjw2/aQXDI6h9yJicyooUcDp6LmBgwGzu37nbq2qcFe9ONW3xM9Jpz11ewyxgT3y8vGw7Nyse+hHSVhg0SpBn4hUObd2Hb8E6Eal1nFdpL0T56GK+bzrDjKHYKnAP46brl81yjY1GO33+pc4w7sWA8rkX9MPhA2G/+0FqLz0fw0UOt2IZusPbqoLwRc+zDZZShs4b4OV3P2G+z7mSS2H/waDx9Mo4LSjwIu4kQ3qmjkFR9Q7aywjp+8bCBxYkNXzTTWl7T4OelLJbHqdRI26HWG87PEafBCAcMz+/p5Q8nSwmWjYOoVY+0yBVKjZsyEaWbbh6VUnpfJ2Or3Bepuo7CB8313hWykaNtudIbbbnbc7WYdKjSeyyVOLvr+szQYRx3/qcoQ7F7sWXDX36O0HFN3jhInMBHZofcCNizS+Btv34ZquMs51C4SDT5KfHtJTt/3NgvutQxV3b6vck3JAoXOZrR3M4LgUQ5e1tUjae1lzXe0+5V6RkCwi1XQJyLEFN8ostKYFdD+oJqJCInhCIl4LICl2qrf34sKxr1ZD9A2dPgxOLoHQmIEz3iKQX492bli0NY5S3ggrwzYE/j1L5faDecio7uwmO7ltS2WJ9VUxnlrHOp4lJk4EAe40s/WXg4bUbW6CkT0iCnkRDflfSHf7untfo7HnF+wVfR3D6rWg2gwb3b9el97GrrCJAgqkuKT9RH/Nqju9WQvNTBhUUmml/oDSWVE/rgwj+TELrKCnKn+s4eM56s5dncxuDvdSo1bHn4ShxubjawNCjl7EarEVcjTfrhXAoPdjBAMg5/b0vyMIcUREQlZakpWx/GYi+ejVl9P7yYp3oVBxpauRIqoxs5Ppd1d8NWxzxl9xLg3SpYzQcdbzFY9W/a6w0sRG3aj4f4Be39lqfDmtBpbLPtFFlZEnJ6BlsaE+bPnMUfGekBL9/AnnMWO9gB80NSmOr11E6GaNPXA0cW5rf9FCtkmjOc3h5Bv5NDU1nroIIfEwL15n9/+5INXdnqfE9I8UF9PmCsQch5wfH2owdIWHv8cbbrinPKQ28eZULdK6/TACcVFCVmeE3Iii5nUfPcIb2ymbAFfS2aBH4OstDLDoQsrBk21JCK01KtamvM8oiMUSHZlP7DX/YK+FPxTmg4ZEG9LQDO/w63DHXznyAOD2vgxtZadWoqk7TPyKFtOZn6dfczo/ulnV3Wt2xQg7U8uHME/v2BkrK3PIZ14GUWYNoBWlOz6jJ6Evrd7a6V29Jkj8VEM+5LxYcv83ABOlz3yWC/X+mVSiLt4tQL6q7TuV30F6rAivdnzWJIgYaLf8kMEny6lJaiTVEGTDZV0sxAdfRTfR7/j72oaMsWmJiQuzNcNvB+BbWqQOs8dBscvtRsA0jrQkHNa+dCEce4lUf0BIi1hl1VcYt4rL1vUv55x2zxY8O5OqqLWnABgGReqb56p7tgvSJS9x52apbeTzc1x9wR0dEuLmfA5xMImhXdTSKPEHxzLiYo4gZns/SfYngqSNjlo0cpv2EUumRvH+VYnRxkuuTqXqDovALlrklNY4MiKQTmtCUp7IUmV1ybFSlkV+ioWXZEFA/YusBpKemHvphXOeJPN4oS5MCmGaL6MXY+jOrJZ6YrY4CpUGlZVXbOTL7GITeWLZU2rIuPajoK6JyAKiCb6EFudp09MJWHwHBYQ7sfGSHD7oGE4MY9+bNgL04vRGMeaVQ8gQF+uX1VdlxnA6JnhrZ0tivU/LsYfy+aWdAFqTmNCw5YovvBckg5CJLW9LorBvBWscg3Yab2DSOOCilSwgFLF009gYuD+yxcg+LSr/Q+F5RM2q68gyH5DpAac3LCJGuktTwg/+yuHapVuCkgSrZ0WMjZfk+EgYaw1Tr2sW6zMi5CcGq8ah1Gql/rRLhN75nDgmy0aTEQ3cvWJSgSEL/WN3PN9XcQogz1EEMBt/8mkoA5/huSq+5+5xuDPO1ftkOpAacsqZCkEvWbpPxaMzPzkfKKHb3d+GPdoPm1y2Rr74V3JYazZVQfN3q7XOVQ07SqeI5l1N+Lr25sm6kSpJzprcg+eMRmx60EZWtnCIB2eSxh3GQYEzOxilRLHyne9Kkg81H7BAB60crD5TeVkc4oDaSF+CYGNtAs9QTFwVwTnmb95fOlXEyIgkiCtPOI8UDIikgTxuhb8ONSmK1brT/swFJU7gmKhYWDvMOFOITjAfRf84CWxwEEO2ObIjq/keTaUhWi0toIhsyhQrh1oITBajpLhz1kFpSkla2VOyWpoSpDbp6/htlIAQAomxJ7bWXbLCcW3g+1cvBWEaMu7p6sjtffeAsG3Gq0DA1xdU5DLY2QwveO1kJlcPdY1ws2hJfN+4YSi6NV7msMhS/+MMZLmCWyjpRjjGBIhz0jDaI4pvidFYFiMpD3D/OZbvmeVjavIBtxqvIb3S9FfAUgOnBGWSbMHJaMCMFluHpBhekn8SoTGX74ZbTxA09uRkNFAfcX3aKyo7ldf/Me97GwE4QCEplr1XZOaGvAp0Zq0Sym41/iwC573HckQ+t51vdH64UyKzAwm0PxnSYbYAVutQGfTwW5yXEeTvSBkKSSPjRoKj8NnHnbXxvmsvQEqBNEtgq5ghyRFk3MTf0Wf//Pa+/PZ4YGrK30qD2Q4z/d6bMdv3JIdiSi9Vitmc4xFRCvbsup3wlIIWmxMBRQcHtnaKsTgg8iRbDjhqlIlGtLhCmx64+dXSE07B4URlHufHlWUaOMvQ0aBUVYUwZDT6zqA7IEWHtuswgYEK7x72W8zgyWUUUlVoOkmoTn7l7h5RzCQp37uPmRzkasK/alY/2hlw/qmhnShU/kn40DBHzYpUSdEgDwJnoQh7g3DMmeH+3RxdhTXmhZbyhz4KkRD5XhFM4NSpZsKKmeoKf9XiU4EQ1eLpzWgUgFBWK5+hqZAec8BAW9y50UqXbMjxhfWqcmWw56Vyyun1WONwZ0MGBGRD8/Qlav8KMk+yir9XhSkhZxLPLQy3jfuxU3hK77m+8a2Jz6jBGQ2BbUJjtaX89Lswy1IlRTMXKmd0sVtOLu/B6CMHPTDK4WqG1NssbjyWDNp+144sY9WIbG483HNFdo1legCP371x/GYiJINoesvno6Rjvzm9Fn279kDskSTHfg9Jb+7nrY0flkAs2jrSw3p6TmfQEpkwzLnFI/Hem+5xKt5M5MPr9U2tQrNWiZrBsy8Zb1XH1MKiUTKzHTkHGfglLybccGPZQIh0MDt0Bvn6hjBk1ZLiu5y4iLhP/BWCHCzVsPGgFBSMEozC/b6mggek2DRPgmzfKuIxG3a8c0hD/7c8ZBNBPmVvQMpCt1u9yxJbu0sRPg9LE50zqrWp1Fl7LSdiQHaT60iJnwb6nkzoaxUTVkZWqd8Sboz5KSSlg9amToqFKRh389qoe5Y4NgvY9H2EXdD3b6hpa4jkRrm1EHeQAyvhGfhIY++6K5ZwvZLlweVzhQQJd/rDuHsQIutPIT9+rMwvm8LU2M72cotGA/LA2XshV8cMJPSz4Gv7Ra18LcCuZL2PvfgQp7v1gL/Sdie/ySY5mHNl7mjZhGdDL3p/G9og7DxeJDikjiPIfHLX15dtg8g/zS88NFsqU45O9okRfXC1+qxL1vsUrumYsLqikXQ0rCCw/vamppSJBumNO+vgRND9eUCwZHiC4iinmaxgbKqqhuAaRj3xIw9p6LI+A2A+0PHVJrXKvIiPqY6xGf1CD6YTP+NI6oJroSNVxJygmeey83osdbcXmCwkK5lKDmxXWk8CXBsQJOCdW6R6R/8JB+T03Lan++CVjVNNF4CeMj5K0KjyNIYHiRN3abJgRonXQdwXnoaJAkCBLVby9bJstac2GsYIjCJbnFckmes80vbb+EBYxlOiGJ71G5jALbFCvROHXiJK1hqeVJ6LRlLKBGO7DqyhQzHzk1gtT1p71ippUrZzHKMKqvCCyHIy2YIA6ajzq21hIXO7ATO5dIRIY9RuqYJN6A34a4hAwu6rT/NLewBDUPGDbyTVpkWRbDkIoqrjKqiWvDMLuWDzgAt8CLmesPA2mlCVdlGMi4PDAX4sdFr/Mw1G3obIMQiayNjrg0pqOg9VdX0nSBatSpPfqkCqyXc6oLJoffMyhS9v0MDQAlCKRKi+kmjcSKyK60r2YlJL09dAT0piMyUYNZMySTQ6CuEipLU3wBSTH4ERgRGwnhEKWtkorUc3QNLh5PjmpgV8OywcadZfjG7aq5xEoOJ4o30vsryd+y7FWTtDeEzkIcaDpGj7dx2/lnRgOY+Nlo0BY/rc+8j3zbqUBy9Da1m6eNNrU6m4RFkvXdTTtyF2RgQrp2Hotb3bHc/w57PAJyxgMhVv6fe4W7KVi2tLdXgtq4WIIx46D8qUm0yixdBY249PCo7OufSEfyARsPh81DpsfYR0ympKhL4j5DLpvPDbTLKTKgpBzEf7RzjBVpvYzIvk/Goy7fBnIwmM3Iz+jo4F/f/MEaHE3E699M/YVcW8KyIYIqN4WcTkGbO7FvR3gMIMslaWJPEiI0j7yMWGJ+T1HbdGtKMPJt2YlQpXc2D/YoY/di7JXf6ywyvBic2NemmmRdGE4KB8bB6MGe1ZwT4fYdOGQXwxq0KjXo1hAQ0FWInZlX/DUx3tVqbUIrEBMKzhGF8f7yRhltJPFW0EdfF/KUwgjsnaM1jVC5Ev7fzs1v3SGn0b3cGh+abB++o46GKMXORqbech3VeeoNrX8qkhl1lA63CFD9Tu7EW6pU77XLo0Tcr+F6DifGpm2Bes7RScyDvVZBTgIHIBn4lzezOdzSwSNSwu1uqIk/hlupolYCExrwe+2JJG/BQOWtO9Mk55z+VJHUB7c4srktCxubwdBEnaAUuh25UiHrk+wrEoRhABSfHWEMX4y2QNKHqCqTqqvvOUs2hI9/wrbZ7vWmr+5570Wf9IIpKgREcaXslLg+EGqEv1ROvEZ+SfQ/QxVRRdFJYbsEsOZrPLK3Z0geNuT8zeTcAIsP7ltC2KVYw0Tl3nxkt5RaE7ISXryxlP/awBc5AKUsUTLd01uz1pOwTTzGLfpi1g9WhRnIdBOxg/OdEUgW+u81qjW1U/1aF5i+XwRAD0zoWxfsG9nrVGj93VVUdmNlHAT1KgSHumpJNr2ljKtDCqCnErPHAdzZF4dFFhAkIPvg3nTnr4hebDzxbTwQwnMXZc52XGO9Tp2vtkLBYYzj4uXPMaU2/YdxXCrTpAXIsFFOI8e5nJ7r1nMs2r1jbpdgIpUZYAA46QGoVDjs+AuAnQFndjqlwpKycOVPChjP/VO19SB3hqD4qlc7bAi88ircSBfixDImYpnYK0d5u27H+hLURlNjjK4dGRNLT1e+DeXaEp+U9wperIwHbAaek98rtO6TvagTl4uJ/tniMX5wUGkSWu3pwh2hmcmSwogLA1VnGrwzRJHEcDkDkJEr6GKoD2k8RCs0lxRsjjXN2OlmP70YZc/dJ3/FecIXPA16G/nqgJaJFNojHwsQsWcGfUTUrllkkk4O3rgYkpVAlt59VvTs2raXltQ3tpH7BsU6uI/6HjxUtCNEIs88Yx5bClQ7hC6/hxKQJTgdupwdZft+1hG+lLuLIZvBaYei2yqsIAwhQ8GynJbJ4BC9Vzu8hRMAUWUGglvTEy2tMpXwJJOm0xAI6zym6KyjPEzSqpf6t+fWQyLOdfYhWeXdx+kSDYEKvRQeqMi8PWX4hLLWLK6MRE7iJxShO8svLs6u8v3HOTA+L4qrPTQwWPb2lmHeIA9BBQKeYzQxtmdKiEThUQ/Y2B+zRaD9mJkq4WhYougcEdIHG3liFRe5GyF74f7tVNey4DWOa8BUI6+3NqIkPRORQjWfWa/8cV/+lwT3/yj1HpeRlWyUI7gy9/8EqMaiE/zw5wfeI6odiTKtrLgajQ2UNkBOQ3IDJTxM0zFYmW3cVrOcsNdMa922BdnNKrPzPd1oJj4Hk08Rj3twrp9mtkvuvcVOG7ZefkNsc6R/rBQgJdH182ZLi9YpByo9B5e5Pf3FBdgII6TMO9pJOmlQqfC/YE/yG1d6VU1xYYkVMvC7+Qi5zSw0HjgM/Gl298hFo6+bV92+vWcqkQYrbJGzG5wxISo0ZPWLaQGiCHLJLKmN6J4zpIL+K6LTYQh7S3yQHFxtiQKj8CsKi+Ta1gCJKyRb9fKUq10qE/bEgtA5mg0IrvHEOBhwS/O5NWbsdffsXMyve3Qdwdyui3CDzmqJPpEXdUVdbeHJoneKuW/G2OMjoQadu1kvPXucs+HAzzeIl8Lfv4w9Kz/oHm3Yh3jrvsSMGxjYaaSiOdR5LYgcJA/5MuK/Z8vxauU/K4dZmdqSMN+VgL63JUJ5cmC4PKNcW8EqC9smFxWAD9elTB0Q2irxTXUums5h2Qb5eRVU3l3eQCUB0OghXKD7/XIA6kpquA31kTReW90xPN6+wGiq/UWc8JD4l8M/aritsGmWgxfMCuQ6OCh0YHh8f6xhYJ+3uFR+/SHf8NITmMthtNts1qreP1YkmdFb4jQLJeDXhELDRBjgaTr8NnQMxUOucyNLZxcLiafPOPjyB5Z5M9h2Xl7phrngOWOYjEQDbMoKnIqKs9iDYG95PCxzPs9zyjP8MVUPE2/flgPprknXaJ30pqVDgk+FpuuSBI6LkogHco8LyAf9ajIT9WZZv0Ju/8UVeuERYEq/kuWDLARso70BT1bqJHLPRwbf74NfbqdoTX34tEcq1dIDYiI00CZJrAlachLd+u42bN+OijjaKSMexOKu7IMRBwJW6k99hw79OEsnurpNwjoluL8n7kYOGQEQUWNGZM9fJCcFdwVCvZoiTESgD3sNGxEj4Ham9MwLe/pzQJVtwRNgFv8EwDOcl+g63I09L5F/qQLrjTv8K5wfouQdmqXT4NogAipp8KLgDTyk3a/T19bR41TEZMMSVNj8bY5sOr1qMeNDyGcMl0PbrDAwJASCzistsh3ujC90/l5s4LeDx9fAVw6+ZpkP5U4X7PGhMivrh98wqzQ3rWCIIgA/RG2GJVm7JoBcx15nMjrXo5gAWO9AZstNFAl9C87TwSEp6PjJxW0Nd0M4cRaFcwl9BKKBjagp2i6XSNZ3nH7vZJFp2Tp4ZkigiN1rOs4bE3gaVCMXHIdY27wJT2JioHCfY/MpXmd9cBsspeoyzu6p9zFOOchu8WcTxdOycQjlrGMJTWjvjVdF3Fo9RWhUfNuH33I8eIbgLH3xYaTnksRWje0E13Ybp/YmezkukEbJJ7kBXdeOpeFcT4D9cnOGGfGFbHPqDaQPynihJ+WPh6wTIazHjAozIUIbrtyEuke15j5JQEeLkPf3RDbCU4b4mbH53kOitNxWMtw02/F74W4pylWN7C4e/TOJjxexzKqw1uixTJuBxZ8GI4ReAMcd12p7bp971G/cpvn+B3fBJRbrdnJaJajl8bqR7Yn/xCls2E537mDWGpLSmIDdSkJNeJcewwOkFr2FbE3no9LPJi/pQn1qZzNJL6u6sbTKvKfijgE0kySzjGhf25nYGp3TEXk+KNgRtFHHNaqRVuyTi8TktH5Aj+hJSYyiuWb3QMgr/JZVnkrZqAgDmkbPrlLHWcncmnaaGn4ZugG1pCghRJ8T4ex4owpmabe40ilo8oSL7gWrMjbLDDyPmxSdWA2VtIB6VDfn5P86rLOFay100XoNfP3hFtYeRfwc9iCL+pjaeM7cc6687Pm9UqftFqcBaGio01FuYfBeVdQxW3rCSxtFqh5k5A2uwaaJr4T+2s8jCDz2cKPGLM2I6nfzmvD711tF442nKWdMZtUk7kWqpL3v6IravMI6CV1d8n2fotC+GyBPnDw9wiLNxrm3aQASG/B0+NM25bxQbod+ysF7ePlTGMxYWEZUFPWWzusynI57YeULVDg26KlYtbz9bif16Pp0vrI9MVLYz0cuLMIstuT46IK2UpTZLkOSRynG6OWBG0IxiA3InvwRAPaArMsNvLXRC7byx2O78Z7tJwDcCVykaVR7JJXOcN8IzUZMNRM8+s8aUc+BlBb2gJ2rfSjQO02jTO0GQV1TC1cPJUnpNJUlRzC061r/htUuSu/IHOb4P30Ro2wgStNxAewI5Tk+zNDSqLOYUXbXYN7o4mHs9hRaOsQnNjOPRxbmhmUPRBfBwvXDJZHQiZYsWPbLxjLiNluY1pxcCL8XbFLFPd4fLtFWIu33z9qrM14Rd/pjB6I8/dYrPiLLkuWnS/Y3ytZdiV3vHkny0juP+hCZhx2Wz7w6JArrU3ksZOx+I10CDKtsqmoBbrR+H0t+bfxBqiFXUMN11ngoYJX2kpOH9FHdUri6/3rfXdJ0DmIuT5xcB57HCHVkmlwhYq4BwFMNtkAbvepfALRnkD42UFFChPcB+XLEoC2e31s3F15KU5AphBy1Bxa43Ufs4fOE15lHh/Mn8WklqDJRgG0WQ3hGWBMxOjtSvMvsjtwZnGVxpdb8ThWGsfBRawEy0ePsA2qAHlVxq+CKZDlDin5uP5DoyXR+YTIhN01iEsPcIZyA9dmatQuXuGXUK7e2ZCT6S6cmU3tBtylMR4fBaZTBkoIZTToa1zdCxeLo4jsfmiseZka13tExtz0oHSbujKICc6vrVFhVrWfe5dstOE4ugj7uvaR/o34r5H+V873glhe/0fF22BLznt1pI5NbFAj66qGXxPeHurMjM2FXDTrox5FlUbFU2LOXkCn5CSBiFRiWYqffGaeBOqN8WrjfNkf2FrmAxk4wkU6M0CWmRDPacVEE6i/3UTZZdJxwyzfj7Q4Afnt97pjt9I7rMGKk6tL7MRfHcbkAHyx8qdUJ2XubojTnYudzvFqjYKbKS/Ll6ljUFHrOXO6X9iByEinh2rhiYmlk9OxsJjIBrauxeK/weRGUGTpOwohrQDdN8Z7ftWP5xkdk8DmiJ+KGriFUWAwokKL70AQJ5lf4U/DUW+TjpUd528HyeHZy9vQMR9mNyWgtC2lJj3NLQGQ6YvYXTycnIBKVz5MoTBfds0Dznetfn18so9asR9GCcOINMYGN6BXmuMrRmOL8bNZKBFzEWSwrQE4iCPIuYziR0QuXRdav4aURITS+P1BX3NziX9H0RDDOYuHV/4KvedJrFFvLmoEn8zhoOSuLkyPzotg2CZUHVfOUafSiK4mLDm1BCDCVlHYn4HpKca4rHVdYozKUd7UrREoYq/UgrBMY7hVkxOeEiWem/fYMKI2fKwCx+BTctlqyHMa78ooseUG1igxWqStAGu9o/nQ62QZiDxG6eUYbOoBxeM1uldJp7bvkwJCXsYGT4DsksN3G+ZFU8GHdsGpiiIFlxEFfm8ryvaYbvphZBRVfPNjD9iJuxD/DawEBdAabHE9Wjp0tHfhgDDyHVq4AO4QXZDc2jGr1RN84rAs3T8lk23al1kFn8ejUgo8/h9BUQ7Wms5+V/UnPQiyOK1Fv2jD57rNiFmo4NJshCDzgf80j4X7WfQxmih8kNmogrJsYxlLpuTQNbqFRnNvPzdZ7NXgI71e7WcXVucFV47Hrb+LqFzq8Vkyy2YNpI7tXsxGe5yloY+qjweFjUoesDwRfDSvyPklZf591QpM7ZkQTO3Soo1OVU0pRMN1TereVhNWE2Q0Ee9y5dT3QplnUml80gorKum8n8dJJbpSMkNp6JEwpYIAb3SdDEfWtWzXEddaQsEAnXQEmLIWmzMg5vPGSUDerossJqqd8/GWEKNHHDjku//hqY9mOLW7EwyBXk+00A0ynFrHYuazxGyPAHWl7J9Ox6+fqSZ2TvCWcWNkc9UJ/X4NPJ5sjqVr4N7vH6oowMSdaYXaLBPIObuR+D01Y12WKbdb6qLQsJMGa7OIAuSGD9nIMMaGu9FjzMxf/Ta57NXCIisSZYF8fqD6O/UxDaAZXTUBIqxWwBaT1kI19v9ZlKPa0IIQUudsb92DQO3kP8Ez+b+aQ7xDI+bnqFjf381GhyrIyFIjRNRQ5up7jCnJvUjvfxtwEFk2LLORTZZIt15iTOay+/dJK8MU8Vp1m93QUeD3P4jOM93KIf81/jay3ZAadJzJGGyCPSsmcV4QsiSjYoqxOBwRymEZ2mN+Tlsc++AbY729cwPnEIdNACof1B+4gHuszP4KTOxdnS2o0W0qSr5jIO+QaZkMF/wGWZDp3n/9QotB9IkRMqA46LdTafSKyDTfgo8OxGdrEGJk+tDKc3PSNeWvHI7reTKo29X6GbHL4FvGwvlyp/mphTDjfdJXIKrjUtaa+1BUx9F0r9l08u4ZU78qseBspTNsItVghaFBgjeTTPZ1o3tFVO9Sz3TxftPU+PyLZhBW+gzofPoxWGuL4Z7uUNweg6uCiX1KcP9Cp2YbpX6gdxa6wnLtnyp808NcLDdwko2jt3YQxVRUoTBlHqblHPUBrN0DIMfIlUBo2xUA2ilIPtp/mGVxgg3H15q69WslB8ofOgcNcByEtbKlRwx3W1v9fm8w2wlRRbMp6l66u5s+qZsq3OPubpKdvrXk0NkOX5qgqInzsN3WqxYyJfNte/LOKJmPRfNLXhwFH+xRzt5CZk0E1mPIkMBu2Siq26aoUYMDMxzX89OpTIE1T3TEgWMNA69WjK7nTSlMRW533T++0edgBpx0Q5WrNRMvCOUZdAxURFcpq6i/zsUG/KL2BW1lMm3+nE3Nk/tG/9eVJ5UTb0aC+cFo4kOt62DM2DVSkDz1v8fg+7s7JyT1+ayJpGYK31VXq6zFi4RZsKQiUYJwCIw6Sc2risZjxhFA/BDTEjisN2B/AFc6R+B2aNBzCb0JEZtZfl2quVJyoYbBNidSqjCFHtuyH32odA6+PXud6B3eaPuTb1V7vfohGnsv6NIU34K9fPJ4GzgyOsS5+uVsCwuDDszUHVg4ysm8KfrZlnElYqarD7Ib8gvvafpepoIwcni2k0MhKtS+L8h2hFUhl8rTujsLO4Urhx7HvipuNwshDQBkIqQo9dklT31Fgfbo4JtN2/rSEjhHvq0SZizbiNtihXVOR97CjpgIb2aIu2kipGddZg5C+GuLud8EIyRf9I3Eip5v06ekuUUiWvADD3/T1VIQYUlh/bZSmHMPTbRW0NMYdHkC9pvvYPQqXRMJ2KUwaNjfnUqEXS+7zQEsrphwGeWzwVc95lC2C9gBdQ8I4dPhQ0vt6NAzrDZLCw4SnL/xiEyIlfFdKxiI6a5/TlaKnPgaJOYQH8wUAb3Nf4ea0VWMi2v2SS2eBtmUzvaaWKeK7lH9YtOVHeiSBL2+UVHzvMlT1QgwTJYUalJvQIgr2L4DoO+5qxjP2Cni63hQ1md4nH8d+v4CBy91rdzvUSZApJT5vL4pLfbU3YvYA3/eeOIfvrg1FCO9hPuhoAWyssYn+3XELikmHNtNtI2V/r94hBUklWtUQ1XG07u402if9ptpOCcM/DK3uQp+0QmjjZPmu5p3yv7YRO8EK0peT7KAumWu8XCLyytNMz9zZkiNunoQwQZ4kzP5XZlFuw0eyBV76qhKB4Ubi4gm/Jr3ZxknZu0YZT5qdAKGpcRFIbnXWmxQTcceD/RD1dGe+V8KL7Hye6V2z0EYxtIyoEde+qU3hYql5kGZfYRzbp7BGRqQg0LxM+Ot+r7I/XO6v8T+tii26m0Cm0z2GDi9KDTI8f6pKY5ewo1mWq1FcjpqIOyQdQqWibjFeLzniGp/f5vgYwTPTz0tKI4hEdAYz5SuxNf5oSMmk7/xQTv+mDkSFL6fIK6Q6SI+otACaJhRlaEYmCl1x5cpfpnBH6vyQD91Xb7en52g56iURDwq70dCPvXPe+cZiJzxEdejzZPJYWkoU2oGKoaHPcrrH176+6Pb/WWuaQ8euu5bh1/UdzovyiJ7BJnnACBbmdp+iJq7cXUvO5Id0WJTGqXD3+wFXFnQnbzrEKkgBy/XA/dGJPkQOfTr7baopSal7dvI9IgDMYi32C2AGGC9YTa1X3RpCekFl5a6pApDQwLMtXzRBJTHAjMthFE35reyFeTHEheddS/XMX8V4AhIfwNIt8WPgReXFGCU7UACOE9ifPsLUAcG1BeuI39991ZUu1ti5BBthrdtFzB2tb5vLpeJa8psCCwHZ0VDnQwZ1Bt8oAlAsoDwgshZelTWrQnssql0SJVp2ef+fHRZPpPRSXqQEIoDDjuvLYPBoZT9o1DYIcXPsKIleTX6JPUVRFG0HgWPqHsCIFjfOG8Gx9UbqsPW+XBTA6WduIkY7IfpHNCq2MJ2u3yWDE8JS/eBysGWjSyf3WBmrcLR7d9uN6hD3PoSt+G9TE8t0ZeL2dgVHs35oHq64VCVPk1iTjFLD7vn76YKaR5li8/xgMhiyC+pr+1NgAgx5niZOvVvA/nElea8BXw46R5RLrRTKs+KYDgGuUpawW7CA5Mdl/JNQjgGSEjHA3olFzM3n0rvboQXQZP8Rc/NQ+PQGGEZkWlvlXlPBwDxYNTUXjH1PqidZTFWhzaKTVNBpNUaDSxvQ+A7lY+rXt0xAV+QO99L3WlGCDaHhQD2Gxkw6gn2CYTfJ9PWWm5Sj2QOf8/WyR5QtlhyuAD3w/ocEwgyq+KEP/Pw6rZlV+dRsbIptg+lue+9sup95MthNTUrazZZ3eYTTIkKntJGMYd4d4t06wKAhAJVn1XxCOJq0Wcf4/dJMQC33NcfakmbdFB1W0tTnhEOHRSgdYtG+GZiwOR4p8r4fBZyaOF21VGB9d4mJLYKX2amSFhoRLeflQn1CoMjpMFtZvySPCx3Q2bcXShZOVUiG6BDXFiVNkzRzCRZrYu+ULo3PnWcSleEt93Y2DlREZ2sLL/uJKR7oG8kjB7VK+b9sJyScMdW6cBvRw8pm1gbEPrJQA7xhvwVamz6ImEWiLue0anVgWWFiIw4VEg0icnvx6I0z9OGIWUnBUZGabSd+r+UqpIMU9i4BdOvt61rtqj3RLDaQpLbxmmx0LOOREJmJNqHtIbYYUPvUzARftuT7ZTsex6ykcTkptUpEDTmtUvhIpRVl8C0SKgAuNnDBxNWWMTtdFLG+zKRh/BTJlcpO7bX91/usrmoq2mDEpmlULzJ4X87bC7W3Eg5FGhyb+e+dDuTREg+tWbkZKXxV+Lqu39oSNSUEHrpRnIbvyjzPBFSGd3a5XWfOlhSAOW2b6bg/1xkP9rtT2UVqGBwxBApsb7eKy2Gt7m4Qb7TNnijcUI3/uIx74Bglo+9r3llY4lmwIlsgM9Kigu/NofeekrnKJAUy9yq77uBN21aPERICkD3WhoVXEcXr/5+NWzoissGWNUH83+XJuW7/P4Zl8HmxcpC+qIQt8GsO3gjEHohD0AmEY2+HETFnvKiFFk7IjpbdwEBVIH8Y5KDtEnYF6qsEaHBqmcC87C9tosUJiFZ4+cO/Hcv4Z6U/VSBy/fW72JCQ76HkurQ9P4Z0qY6CGzVIuuhzx8JAUjyVk8HpeqswnCt6ljoTHKpFlnk3ct/epMR8BynOWEvULoj8+3OtTLqxcImUhDOw+dvrr8pRsDVd37SEinpNntavV4LsnRPPE7EEp9OuK5BABJLLbRPwtkoEvA6L78Q//7QKfsRd8+9gNhVUtOWegRzjL4IsOPNQ0DK4lslLYmkLUtn77aakcHMgMEjfzdvMkTXYFdPBPRCQOe15gOlxBppsKAEUpjFtdjjwGf42M4UP08VU/f8ZhCTXXV/BWa42CYo5ffqtwKDMkAbg4paeWS6iDGbfhpabJ9LmNZIvCu5GhqpLS3g3r8+e/qzhgImxiekwI320Haccb657Z8oMrZ5nNFWgqihX1Godc08A3zNlarmaSRFqqzN78tXIwjzzKfh09ezqXC3fZLH/VdhGHTJFaRZryZbQ7s2tJjIHOAibYgNwWwT8CWeMy+Q8GDoz9rqTvLy2F9Rd4qfKvwizWm5M3SKQOWDJdJchqRSsHTzzKrrpmG43SjBUW3DsHBgTct5D3G7QNWqqRs0X7+EqOUezcyv1igqE4k9b7wMHj6Tt4hNoW1CQ3SGd5+ztJ1+9fGX9bl7HAKSgGvVNMh54URw3PCbqUY9ielNLoZN0z0ScnNp0X3i/vknOho1FQRnoIFWhT5csk4skEEb+QLHgEKoUu+6xFtCa5T23fOrPyOeDuddF+v50mhb9GTNHa/R7CXFuhCoWGZQ/Li9fhEpjnz2utPmnWXuCDMlknolLAxVghHMiPOqJsSdA9OKIgGsaU19q7QC0jFCMLQkiLWGFBqcL6pMnbbM9Fw0Gn+eSCdnP/cveKvFJ1HGIyQgdspvD050D6m9MDDH5SlHGYJyiyL+EJPOEweYDrIuTjjx9xLVmW85zJfbWAhXHKvi/X9snrTgynGtIyM8doxcF8ouBX3vAvwUFTlaU6szQSibkUPB2e7JP33mXvxBvnK4CpdYf6t4mIJbU/b96NN7TQJY67ZWP5NLgoS6wzt5fkESrJpPQ7UiulVie8VexRyeu/xzsVfZEke0K6HADufpyNG5VsHNpB19u9YZ1YyUYvket273sRJyEDoQuJlDhJb/cBnWI1WESzsmagxs1W3Mr3C35j2BwkwCdtVeYirkA+zGz2F8nwswUpfIFTqjoF5kNOojYFhiuHjYHJo7rcV9Cvq33yJjw/V0tVQ6mmWnAz9NCMSZMEufK4wQzLpSKvaXH5mbVZ5Kj6XQ608L7uvKkJY2tC6DPRnKQmPSme7Uny2IGKyaewnv+X+hM/6oHSfGgBCwKi+vda9OayL+s2+KUr/XvDJHlrSKwZ3gVfGRz1tzAWa0MRlcZh3qcNO6OxtG4MefY0t+LFj6A+bKR6u39l7VJan6CqqOzhTMLmfcyY4owIKXZyWi1P3+f/ik7/O/RZSnd5CMJiWTnhd7uGG30R4GwSBpfOvAKB/Jyj+HuEI81PwUiprLJGtP4XPHPnFNTJhWoELNMDcTokxspyts0+MrNwt6I0sctDUpSYUAzjz3k0BVAKLbGh1alfcBxglB7tVUmx9A+mZiUzji/ECuZLbeewWE/hgZMKz11Y1+f+kFIfRs49TPZCmYdxAFnV6CQre/aQjo5xqbgGlYaw5EeMorxZHpGu9hfcLoJ0lSDKPSAkH6hH43z7ZyXaMJGCjGb/Pca7cZvoLsIvCLUECJROr4RV0QcTCjP8x8Yp1pAabDRek/7Z2XZCOcJS9yRtFPBdNUOWK7BhjwwnJkzP3LyApYcP0noPDzXSZphqMgyqJUTfsPJBLy40L8855L7JSviQYiMcNVcjoOkplJFraIShGCeF1w8x/MQY+AOPVKCxje1gFohtr+QndN956o+x8VCqCYgBZnssIo4nC3AiHRy66wmstAwkQ/v37+KD4b+ro+kpH9EM6Ds4w39fgUMBPQ3AQHC7BaU9PzYaF7Kr90k/JA1Vq/ZuXh/QCPJ/86DCJTk68TvaeDPo7Vbb7icHd2P6vd6MOgLDCIrDpfJEYwQJI1EyTqa3GnrJyuqbxeH9FnBwVHSwToxZ491wwG0Jkl+97T3oWNi7y7DEioMPa/uKLDw6UJIFEV1Kt9leFVIcu/LpjLvTnn5pUnN9Lqmh4/82nYKH+qX/Phb3+nl+zrrPCC9j7uqbXPphpEjBK1z9LIGsYQP+7tTQ1WYnnB8a6Prgg4cD5nX3vi6THNK9nRg2mnOD0Et4vqs0sC0HuF7dC1UTXSx0uxI9qaIGyDpCqKNofhVZxjZZGleXZAo8Lb9j5k8tzDL2d6fF+At08etux5n1eFuS1BvRCsAzD6DNkeozFCOPb65du2oPEZFeb7nbnb1QcKMyoCr/Q73cAKTwwvrx9CKQYRa8lsqZaBCGRD0ma9mc9P5P5oNTHgrjZWkw9NvoHlXO6Ao3u1UxfxIEq+uIEk8pmjWKGD7+DZrMWF0y+lU0SxvhDlTcUs4UBVACwNwL1LI2KLVJvihubCGt+SdL+DD94Kft6T6C64dLpcEo+ENLRROO3IwBbtlXuKr9X/ROf5AJZflK7ua53Vpf7uBu2faJhDlLcbk21OD2AC7pOQngrPBY8RI9+2QiXODNLRQK5V39MFiw0DkKFi2RPpkE+12nfOdyPGtZdaBvlliy4qHVo1zQgJZnHl8oPGAJnKTg9jA+EvztWfDsDydBo1Fs+JkGlh/qVzO1E9W7RgVx2bzaNqsPHrlKM5QqK7ula8I6SW+xfsZEWHY+zMc0N5uyji8yRauZNVrgmLcfSxHzLIQ1BZkQJRwogD1yqqji4zkF1HdtCbsO4mVg9X7zguPRZo01QfSOjYQRPFBmlBu6Ih9a1ly56cRfhkfnqZLvJc1kOK9MSlI6o1IU52pO8TsbmrfFZFx2XHzwY9r6jgiZ9FqmkN8fdYqm+HTIXdpUcRJ8Y/R/WP+lObU3QYjeROOHOrL8mLQbi+z68iLH8ITlOo7NVc1L9ovFdRfcvrtuLuceG6XxSD7oLC84f0+BWkfJhnE8uszPnAJ24XxwmNOwg7q6Cr13UQPFmk3ic0q2uHb8f0c0+CaHjQjDsM0G0g87EqLj/Wm1RiogoX1xGb3117ssMD3Y8a6TgaMLvTTLyrCPgU/ZYNhpBt8oZoJTfkRApadOicuf7tnqtKHCoTTGj/Sbjvr0gD6Y+KkuAu/chsiB4ofZNRI61hNqjqltBbEb6b6gNadjUl2MNH91mKlBzxwUrB5FkdURGUC47yoHDZxD4kgDEYrD9Y5+eJ7fdlVXGhlQjM/N5h2XPhsO3jUIKsSlG9xFF+639usNqNspsrp5LcmH132sVC3AHx2yurRst6q1jLxoHg6b5ECY+6+8ZxY4IArLNUEOYRh4hVdfx8jTLR2SrcSOvfZjacGwAS3+BJLr6B5PDx27i33QF6o1Uck6HH5++MIKV17xF9GO5a6EBMZaUbGoWec/t3qva3ZpmoLcAOtJ2O0P+8l4rUkpXGWqsarxiudkqBDfjU9wvfzj1yPldTmqaScNkEWX8CjYynKNtSKgDaJlHAQxSvWGUdaVfL9f28xdWeDtCd22Kz6fNdavGg0wRw0uYtXgCr1vFch3z+dhTDigyB4bCakbFO0DQewW8GNY1wcdjYJBB89/ib0tVJF1X4UDYgb0HJNFKY3OJwJCaOYLsgArxrD05OIFhhQ8STZOOn/r4lS0T5toRUf9ZPxljezyhnbNY+JG53zcvghaLSnfwiFn/vTONkpwPaP5CZQuHcZ94a4M4msMLstBc6CeCWX/AHJA5VxTK2As9jp5Sh0/pzxshOkYsfG36IE5FdIBM9/ad0g4qSc8q0asClfkGX6dUxNdrccBcNZJPIkk4OOytbraUGeL9yrDLplXdh0egcmAp+5/iRSbkF2pVIWpX394mPYo4kHRUbMjPrrCSVQkWdU7qaKtZnZh0xFbMxuZbvXY3G+xzW9oozoB4JTTycz/wVT6Am5D/u7bTDJMXGltUgbS3iI5m/mYBQ8cQ2JrO0ZoIOFi9pjmqNLzCuI+ETWmQ3ayYombkH1DbeEV7wcUtcLjLCDwOEL9WTEnTyNI1J0Ul/KRDCePXNAJzgVtE7mwKgmrf2MEsXRG/VLTt16yMMjwVFIicXiFduFULA6103Eqh9tRt0p/BR3NoTJxIpJKgV80rspJbmfs/zJcLjz5Ft2I+6g2otlHE6TE0MtbVRrtkHhzJvzvpQYXeJt3YjM3X2GZ9PggMI9QKtowdowHlT/3UhrSIKT6X+ZBOBde3bwXPkn/3KRZ7wNay9TWchT9z32UxPgdsTcWazl8rLEtU2E4qLsekcVXbxRgI5cGfBcp0w60oDYUlz3RxbXHYVZB+104ENtK6BTdoghkwc8lEgEsNRtdYK6hJv3ios1SrQczwYA48tVskIZRpFqUaiu4qDPuxBnX0C4IiDbk3uhBv2kOmsT2UczgfWrro+dWPY2Bh9AQv+XJ0mvxSMerOed5/SlfXTz98OpD6pEmdLtMBIFV2eShqIiY+CtroryjJLlI4ZFrJTnq1gxdHuzaRT3/Ok+pTu3Rnqfd2hlqlLxuORKcnfRlX2+SvS9WLWq6ZgDVz0eNr7jeiC1qVjFM2OKL5jBcXnyqfc3M8o960x3hgDF9CpzaP6i7TIRxwAIGJCChQD+SYP7+u1YrC5ruyprsgs6vCsnnW/wKFDB5aAw7iht0iADYif6XD+KjOS11qRi0Qp6rNz7pNcW/Nv3VUmEb/eb9Pmsej8ZXfMjA5GnLUOd39nBHq3AuEnzE0uuwkrsS+6hd6rwBKTvc9B/U+8A+i5T2Mk4ES8VDcAgo5gKKl9yvAEe7st0jbMgCKeHYqjqrxcjvPuUslLMnr4BiwUA7hwaABe9NfQFH5NMk0gjNzw2+RguwIZlQSfrteKlKT+4RTysT2cfRTnfv0Y+ZS5unO8LygGuYCPei9QAoGtxqIT4c0YRjtX5rwXLQvWixlSallKSanuEIrIm1q9n5pOCM3nK8oxHYyNjWrBHgGEhIKhm2ZXtOnwdJiQU6tKMda0PF1kBalVfUZGwE5yszQvpyyVdhYc0lhQBT2PISaNAQVD4Yo5VSiFWm+4pTp0Y6RFq9e2IYBCJ16tTaINVWa6lScQB12tzYvIs1I0bnlCAJxkwQ8qPVyjO/97sCHGfaxJM+lXkNHBxG7tBX9wtvHbRbZPFn3pnvxdkMvbItRXbvJanIFvB79BRPUlFrhUDpZZTyu1aWyD+X4cTvO+sRdF70wfm6ExRG+WbJ2vZ/RLYgMv40v5VOwli2i2/ho0xCLvQMgWfIIjQdko967nlHWFA6E6xHcsEYv2KOGo1gUuOm7qHDAbHEqa2PSS7Y9PIkDC3ASZvEsMxm4ljqQjYurSmoaeTxBbJ/YkZtp6qgSqyHO4i7EWxy0HEOsFh9C92x9jxK9iS6X3tC6i/xVvQLMzmKBLIGKXQq6BZe5/zYxRvLApDDayp00Dt1ko9ks/UOezoJmRQmyUtfiYxwxk37wkbDE8ipnCHVeIIJvBhJgivyGcPuTfb7IC0mSTzwpaIGvgMNxTjr84xpR5ruDnULgtP/RJcqrHouums5OD8D5eZUGjuVLFW217jfd2Y2vgcBm9K2WHdLJRwejhTQCkILLaZU0WuaWs/tdgHxSPh0iCrj6WeZTTnJLA/VKQSOFPRZw8VbSw6k7CsIIkHtj8NwnZLTnPAFadDkwVBfJ706gjYd0ShJMX7Hpcskk12sbiusQaNK3eLZJ1MUTbRG6A2kPwm4L5ItCx/KJTO68WGSfmze6hI0YnKDr0Fc1osSx/SOCn9fzmPv9e+s2CgEvgMo1zto95xl5+Ome/kjkHsa8gTwlOpjQfRxDuW9GM0fVhKMQok69rxzydgcqilHe6mAcPULrx3CrovipBdDUOqipMCW76jLDp47SmuTVp38gjvDbdlcNfQQ9MYLuirOX37Jll82U0USvhkaMzpdcaciPJImNok0VtmagSh9lCur2mWCYf/JiNcBVs+OdfIs8ezXy8nVOwYxUY2NnD6J8i4DbHNohHMndn3RuvxHVa4UWgfT7npo5CEH0+R296irvSXd6bEO/bpb6LjfX7kXrXJ7UfV3oQeKxjzlYHC7d6A9OWf9ljCBvgBZMCGlfICuH3wAKmo6f6Y26WlGJcm5wlmp1dx0zurw3Rx04smFCN1DnCPS0Hz0ACTk/F5x/zyui39CCExLUzM2dGW1ah+VUmpdHx7XZz92xnmA0f3rK+5FRu/gvqO3JEjVRo29Y76pFX05t9cQGAy50bD8Urt2YIcv7TWYtvXhzqzZUWZLPy2dH3N2vQhZhMGLtTWgTL9kKXCvO5okPpDpFfrcjLStEHagNU7wtGZkqVqXD+6lasvPqGEAouDxVt+ZF2BgqlpMlWdsmTewZuv3qSSqXhITC7WV9iV/C9XFTujWZ75K+E+WAm6QD/Hfz9lgBuZDOrwfrnl1HWfRjkGNh2wX67P06hG/IyFkiBStYzjtjOaPCLkEv6a7kkMru84KIQhw9+TakfK3vSNhlxBbSiqKVu1citVJd57floFKjlnvZen1mAT74Au0jGLYR1Lg9u4fvEhM2BDBhABKGHofkm4DubGa4fO+Nf6FVBJkLJrPMFIsS+mSjzA4M8umZWfgS3EF4DjloocpDgyM6UUYKPX1rYLHs2DOQjix8wxvzj7CnfCHUxoPfmbuCP51WlR/15onNFne1APmM6EsL5McdbXUF9QUx1PZdhy3cChRdgtzRvYrAtnaSEYUsGRJPYP7q6gl5PADj+p3PWsuNh1tdnhD78o9TTkGUPAvvS00uSijlJA9uBabwcbwurSCdv+bRKrETXJn5nctqnQgKqGILAl/BJnCSTXXwWhVnU4bB3K8Okd5uAxcPa+MI3YI3CRz9Z5GiI1FfP7rpu2taphVJH2Y5+D8EUFQYMZSTyMDKVIq1HQ3XaBVmzlq3bcmBknJ5JXsd7lPXGTHrwHgKtggwzwxZ1SAglIUhJ4XmB0bthCe4g80kUP5rgFzWRfp5XEc2PZTEGawnuDzjsNVwKEKmzTqT8mDCMo3ibMtk/W6vRMA+CQXfmRSEFJbX7r2eSgCRK7cOj5Ck/lDvrmivyVfY9p3bmv+dNSjVASGMcfC6e6ktwNk5RrQgZo+ZF2otZlrNs0LfCqiWHMn+lizfZIVIHxJiBj1QxSyGWanq5AtxOyqFg+j/+6Na/CHvG5HuaK+Uc9rS5RdSFAoq/bmdPUjD4atxsPQ2Zb3OJXuVyof92pQ0+ZR0p4TeUrf78J5Ah1ZHGB14SGyzfqM7377+zAnA9neKpFzrGTeHJPKFSIHOB9vZJ4zzdVA0HTZiwq/LTUUI9ygeCIG6IpUbrIlV3PTBKDzhyuO8Ue6dtBAiq59snBT8Fk8HtdpVfnakH1M7F4DurRvooPPIutcRpIp2kiJCKZBlb6k7Zo7QHwqFEGsK9GyA9MziXdf85W13d46c0A+W3jfI/81pxX+subrxpLnd/t9eufHv7B2HpiB9huXzf7PHcyqi43yU8eZ5BLYzmu4fMdXmtkv+zMqL6SfnIv+jOwQLoSmxqHdhrh0WwnPMs9mON8XFsYdc+00CFnG327iMXmLIqzyaLShiy1JF+tPKjEOvPlFjMSd5kPQe+RpOoFqESHXbmv6p7x1FcQBshm1fshbN57p0X78o/csB/TowQR2gK1teFDrzxvgJYrl1676dQLyQyuLvqC8lFBPxPZTsuPrFNIU7cU9Axy92aaTd/ZBq6mNvKIBjbSRLg8RsRKpHmXCb6zIGCuyBq63O7/L9U6HczLDkEvV7vQJQw8AXll4vpXW+DOaO7aMyb1jZBS5hed2155h8rF7cgs2U2xzTkKedIWstzax7QfFBKV67bLfxgPhR67tI/jzGhe5x1gvLkelm7nE+2+oMqLwpRGpWWRMRqCUALfz6+alS6IB12cv5jgxBt5Th7EuN5ftCSlw+RfBPvNxCwF4e4fr/d2QQmBcUP/JyrkW6yHP+M6K5Zmw3gRU1hGrP3X7JxD5k1BOQbpClZ3f3YkkHUvM0R9TH9bq7x/xIIZuxJRiIAsMB5caqsFy74X7+YvtOVUWoFCyNeoBfc7+LTKNeyYXPNOxh0ojNle3mA2IF2HhbnFC3ovlQTByMj/6yLAdqAvTa6AjUZMfSlGchbTOuqY0GrG92giFS8NwYTV9riTgYE2qma4zXZezfaFtVYvfwis//cAORdgW9Kwn9AFTFFo1JwHMpuGeAGFV+wnriyBccgkVwqvJyMEM2OlYNbwKSx8c7ZB6YrBzItKFSAk+sXLM/kU7wQdtSJEw3z/oLA9uTJTSv9SM5yaaJjuUR1G6VLCF+nWj2ul0e59rclCX/ZiP34T2oaJMkr27w1RnvLFruuD6T0q/LLZ0jC3FpBUKnYyLgWlc4+q6J5DUUE3ErCv8rh1ZMHgCoet1HRGil/uektJ9pkAYNKVBbJDTXxB/Qttc0I7O9FyCK4Twkn5A9Ozi4X4/LBzontMaKnuxeZbw8wcIVfi5McOWj4JNHqAayCO0GzcVrWXQrRvSlUYgcb40aaQMQEHdP/iVO2f3KP+LHdbd2sclxgq9inebJqiGv6J8P7vaKqgkUOiQtcrdJxWO0/Ah/+8mCTObnGgCZN4NdU89MfO13RRvfteUpqRh3oHFil59xiHA0XDp33uqylhczRWEPKKZgloRxbwVUcT4IkfX7b0eVZrQvfT0N61G+mm3GdfxkF6RrRgGUWmg4kNI/wFF19o18kRFqGib9m4PMG7QMGmkLRH9LWepI3lyWO48Hrx1MP/WoIeZv1wUbghlWPIPgV9tu3PGWqdX/Tq9dWV3XL+3YeeSH8ZREQ+lR9DQX1pHZHxxLcRHaLyVFL7OUM5xTW9xbRC5iT86K7E+PPOsEBkrzc4ZcI2S7tvKGHopBYR+O16JuCMO6HV+bqSXwkx/OyS9b0425a/6kF++P2nwVhM2965suaRVBTiehjDALHBWfAiMJ04GNv6Go/c1VVozTtFVUMWdaIqZIoFlZuzMnGMo+0OCRpyCpYjMdSPmLFeeGDTtIQd8BLQTSPsevRGATf9o/jjS2yxCNKBMgewbzYJigtae4UJRFeygkzcKAUasO2yDzFExW1jZjWqxEc04zowPXuXu+bav0xTi7hnzuc4fSb5yiL+d1Hy7ts7agQJccyrHXM1thQNqmPFiOZ5QFOPHClZSlgrHyzUXz6Sur1bTbofW/nnultiwMVMJ0cf5SShCqu2iTiYZtj2EReUA8rANbeKDYxE2IxZFUxXbFiNCZx8/6LzMo6JZj06cm+UCy4bYCN2iSIxXJNUNHdUzENy9pEjYX0T3iHtpXw/njEt56AP0qhNwRYtyVsPjjQ+PY2psIh4Rr8h23E7weDuWEVh4YHeclSt9q9w8cWWaS8DTxAZXxSX5BuJ2BLxb6gZTZKxolavZVveirPREMvMzcicWed2rusyME+Td0noQMvv5TlqQmLpq2f5hJNtIIKjqxXym8zb6SZxTpOaBPU7sjzJvZBJKfTeEw0js7l0ujmcatH4Hd1sGv0qawqXgi2AKUOYMCVp8El+1XsLsZrSyvDm0agjeOMd8HaMiVcFKCfsW1eTZ79LgbFOp/UknhG9VA9pmBTMGSgli9m1NiGKmpt+NuIuzpEm6jCT8xPOYGeboarZtSVbhtfw8DywOf05iARNd/ERTorUWipokOS+HyBVaNFJfgobovboEK2r/MqGY1YilMvfgrx7kzehHjewDL41aR3rZKanyiQ5UNFx5GhKakVT7tC0uR89TrHgAmBAHaT7KtWtlCdV9bIx7zU9hc0t13eS3Ql6Y6x/Mr/F5NUPdafQLmQBSHjzzymD9QbURTWhCQ0wVf9HTODqzEYtTcOfbeAa3/kxmTn23mq0Py0nUtRLeCZXsV/nCKBl7DUJhvVTvWzMcuemIf/CumKRqlbLyNHfSIDNaAVC64BtSiHnyAepfdUPM9mddgLrapSqLY0yUhztRKnkRTCvIsVGXfJKFeHxETAE/9fMAtNS8NUsoSqD7qo5bpSAT75nP/diAZCzqQ9+S4aJstXCCRe4bil3YZgNCWrhxFYUH0HWRpOtkV33ruos31288wRDSD70lONsQZJefdwyckO06avHrKy4tObfemhqQ/AwM0MTvQmId409oAkiCsxD/dVP/JY7l0zKH84ofa25LUuuRZ1tGOvY0YH9DYXrOU3lNVQ/5sEhJkjWni7mxFhw3KbZYWpf0BrOrctmc7zYpICJBKEjrHx/1mK5EBEzBFnHHNQoWE0vZMkotZMeDqSXHnKmlSJRFIff5SysL36mslzH5XXYA4jrcVdbK/FoqL5G8/BP1PlVYaCxsRHTV+DCDBlGT3oQVKS/mMZB33enKMy7vMzjHsnfZ86ybNTHS8+IEgIeIQmCSmeCm+1GzYODgfflo2jUV3xL1aktdriFfPNLSpZMOqTour5tyqeBcNfydIsx27wptMypXY3cFIVQE8RUP7ISYwG2i5RRrzI800YrE0rQ9Q92Lfu9fE++2K1iBztdBLOk8rjrxLK8vO3WL6M/YvQ5vT16KS57fewv9t6YFXrnXOSb959drV+ugs7TA+/u3XEyeVjypCQ0xCBkt14UqmjNuOvdxK80++Q+eHTQyIPEbHgE8K/rVFroR/svwjNU8kD+NB1kYeYtrKT2m8ZUJEAmcnyvfVz2NEFWWTXo/jnom9kY24mfq/epEIxWOHrDFEjJV+3pu/tIVgdUnvYcYoZDmNBE/z61QbLH0+wHj7h3gtaS4g5mYoQhuEsh+U1DVLhxElbqWKVzh5sjk3XFc4MtoT03o38VrxecIMpZbIFrqNjOUKi58wC2zFSj5TYCa4erwogdZsLpy66gMDoZZXO3nIFMCk2dElildO5xCAq2p6l/6cu+wtLjZrTnCTzdL8I4ijWMIOFMWpkrqeo6c9tHqhVopKjo4+9RmDFPKJR40i6qDppwMMCbBjI/nSPRrEtQSH8DV+P7fYzp2D0JB7OnUsBgdEZMw9FcdIhfKHXLb4qHV5BXL7NLgieZRowiE1ilVQ3FUIE+7a6zP3C/8rpBMNSj5Nek1qA4M881MaRlWiYreO3bKUt2CK65x/JhgMQwdxrzSR2xz45uX3XLKogoxXnBqlsLBWGtF7epPpu94qtWpQejKBtYG/I1ApFfuR9BnreEQ1vae1Jom03lv078twQxj/NtSpX2H+QUhzhEyjjrr5508vZmm6YGEEx5M2YnqgcYkOXKIHfMxB3zGH9IHIreI4vt0gitRzcwPYPuK00t1D6fUn33e1zN5pv+EX55o05xQzhPH7DuKVkr1UFXO50JiMRdd6we+UzeoQCtKET1zpVJv4JdLrDJd5IyF5Fgouvm882vhPPaFizBXMohojsUK4g8TOORNK1TNWful8xGZxbwSbA7x1JgHoxvJ/0aZUF5B5mvF4E4VZPTz4DI2WtUr1WCQfxeQNRzlX4PxVAC2e4aaZG4BIkoeFG5mdg0wprOcfAvghuNEZDAK+G8874lOo4Zk/kgwMEtVByGh7nZu3zTlMuZx7vWdd0N8hWvYNbwbAPrao7K5mwQYQcxuBWo6NoAXCb9WptVIejfWBV5WTut9P8J76ZFpFvzJAxjQ7kpGfjBwyYgZQiVxHYiJ16BD6NIODqFtu2yzwg+QhoTSToq3NtstVdiS8B3BX7WDGyv5GNpFrhCrkjVOGqTerRn/n9iSaRHqEeAnZGvN1OHcETZvnUz2GhP05aNqJUSCeI4rTO6Wd4XdLpvM85P4YHhBX2rOQ+sKycbdEEYcdfSOefGls5IdpohjSwhehAHFRh7a7j/pEE8w6qv1MOOT2DO9x2MUNJmhJ8iMnajc/9oNF+QW9vnys9ZbmN6N3Pq7uBgfdK5sh/HgUPOe68w8M2z25jGKkeU5cjeejAJgXBUQ0PDsDGmiPv4Kc38k9F/qRmNKir6d2Mx9E3qnzOOB/ZoDZe6IlnY4pBMM1+mhpjIGz4y0GRt05DP5lnSVXNl55BkXJZ3Set3sthPseafYUA8yLeFaOiFyQEMbyasvpOvxYQ1dBQRpn2Y3PC85k5Esx2d+b8uqE+4D1qfeNxx/BD1RsQBoIRGsmZm5ZOcYBNJxv3x8cEEPQAHT2VuATSVIWTvQKxAy0lIf5mNkzjqqtyAzx3gwxr2xP5Zyvc5RBn4rgG55HvHTDDlWHVl0rE/ug2jRdeMC/0ffM2lgVDaYufHfu5xGHQc8tSSUpvM902dfPz9r90NgPfs2qE3KXtLE7O3WeBidsjORyuO/cHsTzxkkB5zOnwE3JdovRg7zcHuoX8EGdjsPtMV5S8ONY8cUa9C5qywg6Y5nkneT0gVCx/g6tIb0rH6tsjiMlLkWGt6nvuIrD0dqQHNPO+cHvnB//JxEuqdtzJlglfgMpywo83mz/oT9LPpBGckjTossoggIImE6GBHVL5WjuUBTmDuEkvoyN8Ku0rev7L88oUsudUueendUCVsxMprkpxTIAfgLXKTiSowyE1OJuHq6bSrTXkE1tXg/jjJqkGxKyhy8yVZNm4/2zs+MR9YHty0uJfThoUxWK7YLk9xJ9oRAuoMGMLMbbJU2k/zvzYZKErDhLf6suKpq+f0jW2nFXgaT2QTHWYWmhwmJF6Ri8tDxIiifNpc/F9h5Wgp50sISzcCgWHlVxdk2lc/7nxkhTkhNQld69CoWMbC+h4dtVPJBi+QFJHFRvFvYlH3Ie252HlQrgYoFLJc/tSDShzinyQ6Ac0FXq6oYn/P7Sl1sn1gCiWKpHvc0DJ4ReLRk5NQayyK4GW5B3dejoyvs7uXAhLKuRsM3GS/niUvv2h/izEA1H1Ja9wb9enVXOGqJs20e+ggaupheAUv7YSbwkF4A9R+/n4A4KOveUQ6CyvhBqBzfCsFfCkqFkJeb/z8OiVpLgrQudw/9sMPPE+rkCzQWHgRfG/zDCMtKU347wyy6tqy7bzxA93+jIPSJqIc4Rwxi47uKumXeu0+3BOk4tBx0SKjo80UzV/dX3WNoX3kIVKJFwawB22tahI0suoPDv7qMh30/VOC4SeuXmwsEp+454/t5iff0U7hyXuz4jR+9WxSGgJrxDNZXjPikodtzyRELslRxmuhUVFWyJ5q0gV27pKTL05Z3mUFcNPuDTGITqTNW3dVXgPsNXrJGKDEkg3o5YfYJVFDVqvG+L8pHr2DZfqXXKoWm8UwjkzKvCjq92NWhUlO2Zlhz+J2gqA8wgICspW9gapiYlWkIDkec5Of+WKORbeMig+/vSmSfQg4/FOVXyvvx6LFyQ8uQqkecR5Yw7rYEAX9awj6XeXcTkHk+cuUBGIWRZfXpscOIuij5E7d1+klBkF/qM+y/35VuYcSH6MMbJ/Y/EkrP+HHKQUGwZSCpHzeO0ujvB4A7cfw/lSsQQqIeRNISijLvrBurx36nR8dS55LZw5VuOeeYLmyIBOtjjHBU6y0i+rAh2e+p+qRmQzaLmUqVxO5aBm1zliQGx/27pj2VAtKNJeAg1FkEukkbN2/FIq/6+D41Kyr/lgEV1bi0m7uH3motl+f2Vysa7cptgTMBLBP+elkQ4HFZhBpuBamtJMx5z9abY1qd5f1C07gON6GV/vKgDRgFGKEcpiWjTPRciQcwXzc3N62z6Hn4ocsnTK0PvjX61MG5n2jdKKr9D6eMj0uJQGlmTlISutObHnQxlikN7KAiyCzcnmAT/cedCCnaOCF6Vctpo6RSqpop2TsGTDHvFs0+BSp9xdSqCtCqwkfN5XagByJd3IoSz0ZfHg/Vh3NtPAvL58e7vHi0x9rEQdQ5aq+eN/D3psdJm4KXGTpUaoX+xV+mJJHnvmppuZusBtBcQ4VmiRVjN3DBccorg8BSmwxkSUzGCibhkA1XcZWKRyUBLjx5r1sbWMI5KhxykSReOj/aZIZNQP6OvNHnC67OB/1QY6hNIpWedLK7PTc2raQoESfSlxK9qsMkULhr+S+BFDXonDutPKRa+n/FdiiDexOaUUjN4i/soG5BQw+8zyFKZQDJG7CMF2ZbAmgF+BFefE6FSTDVnl+FLG/bCwJJyDD07S2ccnkL9Z2wCVPmRps03AdENCAtzZdt3mP0g810G3SADW0IMcAGzyWGhFl+3KlqsJ6hdHIwgkl5O0nXAl9UULp8hqxr+k2ukpiZKDWJXSiXTsJa/wiOrrfB4L3Y6MmfRPr20Hhjr+0CAbRJTgbyqCpP/FE2Q603LQLLP8adtwMgBErunFGUZqgDj0HhPq1011xdd/z4j0oekA04+9QbQS+vyJYWY18RknAvK3gkLzL6r0TdyHElcff2RmU4WVzAmAwZZH4wLJI8EkobTzsVTVKz3JE6hkJ53gKgmQMtIBA8qGLyDes8ghCflwGtllu8HTH7KerzNc81L91vBzZJdxz5/BWBNpAceIJnnRTgOalc6489+T9YsRPPRcQVbVTw+PMWTgDQs6R4HYgP42VI/GTgX3gGTC28B2qW9cb3J1gXKTaD1CBh3TaEi8fjElVIfLwxkE1ylpA8UOX8EBTJaDyk85+o80XNDFohg8feuF/PjMHO2dK9WTfL76kgmwUs/pa8/CpkX/ZkH/flFM+Cvs3wSDdIx0ltRtHhyyRqdoTwnBytlSMxjn22HXAAo4K7ADn/Vtj0ddgKvILzJVH7p6AJXGyZ+YU+0UCG30bvCJIhOL/Zv1L4Jr0fxcPewfZjukek0CBLDDwVI/D0hR94OrqXBjWJqTygrMLZm2mnWZdx/Y/j/pWofKNj8wMmJ/vj0Dp+hO3KGjpMvNdrX3MXkBVG+H1irTCnm3i6Djq1wtagi4xf93EN17XYuh2LGN10xhOKqZJ24TT4sEXjQ0v/1tncWG1nhaftu734zMN6kvyEtqWRXZp9kbvEu8Vw+54QRA75AAlOL9zvyDeZReuZhqngOlNXD/OBRyDexVTYozqd9ytv1caEXow3o2S5a3s6ErQFi+2H+ipXAdBBiWcRXyGjNaojiFIGtczjXuwpV4HJqtFTnpwHlGcmwasxf1RLy7mokwgv/lTQK+RbCd8amGE1t4POD/3A/xC/lcVbJ3VhoWLI9sBv4HJLkt3G7Tzlgmn1hqITtWLd4UiBR3ONd93qG4tkYTjUTvYAfluaUl7btZnzeilu66mVrhBXQH2Feqaa8sm+vKZDSar5pER3EH8Hbi4+984VDeBfseebc4xTnBdKAuxpOFdjfsPe2Ex4M1N3XSL/Se1j6viCq4z7e0WYv5+BCa1ohCesp7e6pkiRfr2vdk2OGEAF+5QTiFUXKLEVp+nLydILETGjW32++R/SWRdC//qUYbRsYGmj70D1pxFOqS//LqCq+sk/jdEUxMaItYY1IjAr7IVLEi4oog4ZdHIjpK99FZc6A9vF/+x59PU5WQzPXFuwObK8gLDhvNdzMAEhElMiYW2GPYc9zZCxJ0hn2CUsPMYKSFP5YK6E0Fym64DTantehH8tEq25Y1d3Zq7T53oANPqlCAH08BzbNPcGHfi4VsGaGiWrlskaK6w8Vq0wXmcOaxtPtBlbwm7f2lCFS83SmAszL4Im1LHrpmU19GAyBrtLDf9F37Z221aYvIeEwYvFEVJmN6rh8f83TeopERZPbllf1QZ7LkalesUBQxySTdVB4PGRg4mCZI0+/oGByPwuajkZfrThSgE9QC9iOEC4bOG07ZpngRH+cuMEDoX1MzKnzzz3OFJMiZiDN2JhCP24k70HRHsinnGO0CS0pM5fxnWZR0nYy3keQnpOYzmIB6Rkr8TVOKgkqaF9Rr5i3OsCho59ihk87vveqjimA7G/XO8Nq7MT/BWV7uIObqBj8Hg6vRVcT6IN/uy2lis6c81qOWvAnMIFiWniY0bvNUmQV2g5zhFOtvp00RsfoscVgaQdjDXgvIjkJ8EMq/vKwBszDRJzcarWCCt/+uuRi2/JfvJ05J/N3zhJRn36TDV9DdUjWn2AxcPlKNotRylz363Gl6lDcMUzftgJbHI0iwjK0I4unvnIY6Rk2jmmDjb7hNcYAhobjmgzM1bdkzw3IHLMRYTgYlDej4tMf0Tp1AlMKNPQ1aR3xy6cno1C6KKKcbxngQrm4syyqJAeaCeylxd5shX1O5QNKEhwI6orcPV3Oa9rkrGEuXR9ml8bRd+9BK/F7opjI7UrlYPWmzK8xVn9Xqf2I7av03JKZHCPpCN4KpZd4beOUdHPWXyP8bJnOjfSxIMZMP5C1oEkXA3HROPh0tL0nNAP2wwVsAknUoheANYD2OZoSe1U142fQs20N+F5yArjTXc4jpWFS0+JDFm5ChDfubP39uEDgQe3aMWdPC3WTgD/QjvCq5e5EQ1xruzZs0pMZ1RVPRYOnL64HDbCjv2Vk+SBDdVpBxO4Sm2m9/xJuQ2eVvB6UYvF/n/NNZZTxof5184NHxuwxQOt5LJZp2KIn0k7Q77jO+nZPcyu9s4XaGj5B3PWQY72mpx3KM171ksuhYA/fVyOaqXMvVz/9752gbSb07zi/OIbXix4qfjN49ds4Myt5mpN4AUAq8HCDXiIXuuh2bGHohmePAPRAIBRiJoo1r1JbwsZm09WJM02qeJf3FNAZBnDoTgGxC5SBniLxvjsfZt3m+LvUuoXvjNMb2Q41iFT7EIYlf1nuohIcFegai0DH8sFPrRuSptSIGoWRKYvjUzIpT+3XAA5Gvd7JvBi5rC6CXjJ0UnA1Ue0Q8W5rPDWvuCDlORAQdSDdEYmzhKKndjMi01znbw36hakTyr98gbBsVGE8vOsdPIGuyf4XWxlKV+Ou7KXNEIJBG7lmp+Ei4WWZVduuZ2YWncWgzB54oEIMaiXhzkNJJer5Sd6Gkg1O7Jw2Kjz2tM00QKu7eWsH7owKHeZFUOy9IsXYWo88Qv6VkLW9M2YGkzo+j5mdRFMTM58rxIlpZo7DqOZknV9XEjdSD7ft3miOcPiSa1gvCiK9v5tON6nrC9cVLwxVj9vMHEnVVohKAKI1emrOR6/21nS/ZYaJyPi5Wicu8VW6jgSgH0SsGG4URfYGGhjcUw/KWlAx75vmmtOPQtwH8w55qb9qwysmjhM6S3QqCR9Oo6IqmjA//Tyrnp4G7GlZxoK4LYJZ/pGPih6aUbrDMO/iUu0whbABNY2/QDZ7IS3yDx1Cuw4PvpMNi4ewgnqceTw988P+BzO1pYzOxCjb/VOPL5g7C7PmBtysZ3ChnnjPIYhXm+lUsBkXwk244uF0gVDXUeL2MwtovwIJ5KgTGnitG2jzjXc7vZLUkWyUjMEXfJLu50gJEPfCdxLHMSzdMzWhhmCitY2GrqMNF+qRCiTFYY9QYwpSVHITvafMbVH8dRZYhCu6vMysaPrahvJMNNbQ4E+KJ6VPe4lSgknbmANFFubJD6khHuftTbsWZNWjM+PjiUGKH6Jk/169p5eLor1mRscVacCu71pNNqbRJYGVIqIrBex9/MHLVp4XERp7aoiuhTVGz2THG0Czgani0DRpEY1uDDUcJNwcqN2892shUd8zHB+Xb5ZlJgRPpjv3vMyYC/YrzuNZciFdEg7mbNyz3X2IzMNHu4lGwJGD6C3yORr9OkvNXBcU3ylJbA6QFodBq0KtHdkoAF6JnFK2WRUpKldw7Lh6sSBUnm9uWeWzGeOJG6htaCKAzlq5cMDhBqs8XQn0A9edus0rFGfvw11E81uMwwjSrHIxnxW0QPdi6fWwNghVyLRMtyvsW8JyQdCC+zm5/KNN/AXc3oy9MOL6C9qLG2Tjlke6r708ItNDhuJpHEDlOi4+WjZjnJJm57+pVVgI4xE9Qj5X5ijsuWPL7Ng44k/n7nACp48MUxChaXuYRNpX9oQpXYnCtvVCbh7SaGL4XbIHnpEHResJjndBeVmkb3WQX2WNIaIRnmdVCZG87yTfXfSyZrIQ4LbvXkETKVUebbkQQcWpZvuJxMjk4rIUplrMrbFQJ31Fs5dwHlMH+YWhZZFcGlLfKhwL4uDjBZ5fxm3ZdebPFfmOm7sRFqu3sY2BCr3N6CaFO6adnt4SIlY6E5aW3dNsjlArR/1RRYbPvVI3b1QITfQH/M5kL4PLPPI9MtKmi6xd9nMoKJ0eJAvSLcK/PR0dSUc0THiZ/b6DTaYwjZrhvpHaA/ItOQtAsQGsA5ANPEUybuSB+TAIRML/GuwkJb2zTSvvN1Tb76wHj/tUL+BXIoxIWdRwBCWHJXui2+PQAeOEo57m4tsl79FC3/GLTqqzUMOFkOGG2eT4UfsoYi4iqkLzrt4CAxN4O3uHK38WsFI20tEYZyaaHtfISPJgF8vgK9Tq1JwP1l3i02N+Pe6V6hDZ2QYDWKDzccAPo233ZrZU52Zf7WEkeoU/Kh8bARfAjxGOp/HXvHOv9Nroolv+aDoD1jxwBCORXuhFXUzSBl59S/ncKUuXG3xZNKA/n40Hdd69mR8D/qU2JCqetRshnZFPlymYHymqFeK1nxY6tVfFncsEvJ3bytlSqNX1BEEYZc3ScyF2CBOmxWW9jqj7k05mV1j4uJOlJf8OTQZ/3lvjruIOJklnTxfu5bvAuwXDhZ94sE6T5BXgOzQmoVESlz1pIc3/T+Q00MilymPse2hrOl/TrYzeXd/8WqrQ+nbNxmQN0gOjUBMlgmGtIfi8UdXAlG6rwSrfNz8mYt6g92mZQP899HSR5OTP+jCRFSEJk12s01jPIB83W2o2Nb8J3KRIsFb7FJfmAVXSpmlQ4YC9djsX/1fRTowPrTLGMe8iY1FaGijzUPAYRqDMWx4Ku7Mkp5hOUQE1UATL2NgofhI4SYftR/2QD3qNQ7IKVoFeONxFa5V3gFPnGc+bz+T+J7TOlpdkHaHmLAnuTyU6g+JRpF5658oK5oxBAqvUEwGhvoRhNQsV+8SEb6hEE7pKt53xTkju67Rox4j1RKHqXQEImhFAafTmNl0YEe9jc3UWI3l5SejMRHbF0F6QdJVqGWbzb1WiFqOlmYvKswvrKgeJ/0J8Z4OgadfkRujGbdGZdxrVuEDVHDoq5TxuTO0ySCmJG01MUIUutGoFdjPA5G1yd/FC2GsHUXCjgZwB56ROD46Cd+lryYHCnV1Vj02JqkNwOl/SVxNOYyqZXG4AbUkMB0Br7Vp398f79b7z+sC1ats+XSQ+dym6PU+J7NVQTjRC5rmJ37SoKbtZ94uuF8/TNxRGqIXX5zsvhfxUbRvNabaC8nAgI2uwx/H6XEHBFZKgYxfMX028pVm6Z70YzgHUA+JhJ45Vhdd+U4DkHU3/Kb2H8MyvGpa6W14x0ucrorZKh0yFZNnaNmoM6Ts+EO2+wiMClE8uIcKRvhdrlT1uOIBNwFoT0lCZ+dezmI3HPWmFHOnNP9Ulh4YD1G9AFqcqqGsd/5aYJbgFulYnr+8Q6z/lTwRJ88wZZbGH2+IYMDnc6ybNIR0AuBLuRV9C5Ck2caO663sisxk2KfxyGdAuQz5xOFQUeymIFJ/dY/h//U+roIuf75Zh1MQMZpLXOZ5QOib2wrnhZjumHt7Q4TVu9fsLae6ckj/2n60VjwpEiuIURaRGIMrFmFrfYstiCZPaforzb+SjqDv0wfhKT3jpANLnn/3weMtquvWZ4Go5aJeY0WVcgJOO13aaLixkecm0ZTcLMVqTStfWjraHdmW3crS0UzS8tgWKvdsEMw5rrN5MpLWCXDl85GhiGws58i3LdtyOlYX4OSKKVgimGMJj685ZbQat/MKg9d34r8pGu2AmmtV/ZVbab5o7QgFZ/3YnJgKXJJYj9e4e8EnxaSKJxpDVdwtRLWRM8EbyeTQqZsGmeVcOkRx9TKk2/NhfnDECPIQTPl03rbfsaIBv9582Zdqf/K2i37+BLMh9sW8YcF5C+eR7pJxcw0VFk3X0d6BPMn3VjLsCZRCqa18oNE81EuyBuZCCbQkhO/86qmrx5PhXh7KoA4CCUCNblKUQk8FotqEclE9WDYyCX6E7yN79BcZZBtrl32Fj2yj50ayBczPRDwdoecPQtx7/ly3yDb4iy+HbZTqAq802506hcP0kqB0/4AQQNai9KrXB0Yp5qFn9AWmdmiujrWsbyD1A+iBMn8c0hbBrYToCBNb6WVw7UrDb3i+sO8BSw8vTaxtost8Eqk+9UOF1rI3fjengS7++I5qoLuTPuCXCvsxK7U27+aTXZmSKnhz8mRQSo3qrKEat5YTBuxUOnZHN9jE41x68mZI58HrqCe0ZzvhxG0/RcueTHtjuf+8ik2ECzetzIGrwaN0jGkJpuvA8afgEUOhIYkCiZstVmzyJsopmH3g9CRTsbk8YjlS939GOHhlOIqxITfi+jx++EBFSCFax2AP5y8ju4fq5AKF5xe7YetEqLfP+q0GuXmQx1sPs4DF9ohNhK0QnjJ7Y7zLdSiEVmQUwVRdkL6qOFqRA/qp6+pTshIzdwtJNyaQ6uBESy5p2ZGSN2Bcy2+tpqCC42wiFup0D6eioKR0rCCC2C5iYfgMBosBP3Xzmr8TFX106griet+gQPbA2dqPIU4VlzzzOKNb/WnQcISZeSOo5JjgpvI/4NZmSGxCwiXzzyumaF4nxKQzYAhATIN2OPmi1CH25nM7psSnF7cj6cUYJsPSGihYskwsDAg+XcjAiQ0t7MBey/0nne6ahbhxKLd1gSRiic/YDjQR4m7bZm9fT9ckpfcVSH/J6NVFOg7jVjGXps44+MrFfKIFJcZ7CyiQgiuvVA9w6mVzEubAU6/DezQwUlfs79FEVcaY5R+JM3pU8nmzDe28cN+60xY2e00OG5+s0NHOI3YPdgya2Kb/L5HHL48uH7FPDafcGrP6Lv3jeJ9ZClLYoY04JSqx4dIPcGnzD4LaE9nIR6E/A6/nq85U8tmeGF+TxmC4YnxZK3YPbH/hoJPA2enpqobLZTR8LvCnlgnUcFexOo7bhjgGVn1rI0Zr9lHhD2tBoLqjcK2rRMpJK9jE7wpBemJBwVkRODSCSmzijx+ZDxYJ+76eVZ3XO0AZIRWhw89FNVVIYcdqDTUYiFnrLsFFGRKgYm3dlL7sltDmg5MwS/zz6QhLc910RuSXRgmoPhAPN+KjHGyyfXGG/gTcud9w4cMRBHyTBSoyeuBycN+P6qmMzn8IRrvlrsE9LULaJNy7547C+lkwqIT42gyhnxOZAKpxrUiN778Fb8niRv0C9AaLN8I5oxhQSyHySMWelekvzqWq/OQr1+nz8RRmzJc7psiO0AVyrL0fjFm0TW8kgSBtd+LvDw44yzGK9rBt+gAodglGnIH5RW/G7pR/SqCOekDQSOyWxn41/hzgCgq90fHOQN1Izyc/2Tv4u4xbbYxsFZcAWFszWh9jQucNoNkkF55Gg0vDoucRdiZTzebTzK7EsnS56LU4tVdpKbO0zJLNcDR5pfF5sb3lYW2bmHwG+Nhx0yBM2T8TR0dhM3A+3hj7x9dEBjrZbls2m6A8Ai1vnlztYy6OQ0hoC1oM6NTlLASZcfVvnsaJ8BlL8Obebv0QB8B/P5ts9mtnDqi5Vpo/D90IuUlfDaUF0URKCWTT/T9f/Az8zNzI9ZJ17V+fwpZHCul1V6+Wd4FT9Gwme+rBW2OGgs3gFSBF/04A709z9vhOoMISTCDqD7DcKNkM9WAyuUkLb89UmcGQMD+lj0W5CSj7O/pwAL/iFNawmDQbW1lCHckQueTCgrmz0k7gscl8sKNmi2w1hnV/o/cfMMtaGsupM4DbZELx9Puy7+tNDdr6bceNseV8WVsD3BvwdRzY+niqk+3HLn5xuo0Grob0MF3encPAOOqXH3P3TnahbHqURblo8Qa+tnEC4ocQMXEpqrcvEbplBP+caAU1uUVrIjLSs9wljb5iSrW4jUzcp7SmBGiJgGPmt+o1HLFD3IuLOS2M1+dERRp9eZXXAixL9L4Hvjx4XC+7MKIgnso9fdpc8V8O/8z95zBeuYxyjXNc9PWe5VeOBO9YtiH1zDKeCUBhSsCFmGD+BwOLjiiLPxZXrDC2HqVrClvZzhwBIQyKd5SDzEpcKHhWFy/voda5Sz6d+d6O2qcR5XbdJ67pxN2uqUIuxTD11eTdsYiMIrbeFRACq1RVZWT4Evb5V4fYN4qBRj1f9ZGVNgO+Ypi1oSLqFG2yn2Iv1cLnftl/A3EGmFwTHJoT5/SqnxPgyr3a8PeDXxf+chpi6fbp2Z8h1TVe++S35eaRT37ztCxLnaGKMDW4dp/oQTfA5v/saN8JIAXYj6hQV7vNiiyF5RiHO4tLRJOtjLyfdT+A6N9Q60hriIRFg9j2rpahXJG3OXCepPbLV275gR18oWgTHrQGkPGQhVuJLQPhhu0BMicLSK7RZCcKq3qac2N/YldxXa7Z45GeLGF0+3+LaEZLp9OIeJmCW5PHLfXF9wlSkMxEWXTLcP+BH5et/X8UasBH0OzOb2MLaAnknY/r49eg15NhDSma+lRaOpe+jJh/6u8GjnWz2NQ+QAUP8JvrdK16gQpB5ODtfdvjJlN8The9AoUFwbrgdpZHUZgOh8ipVff/0Z0D5u5nPesHkFrcOO0aoHT1R6iCXcEA6ie3fBNV++D47Zu/QO8wn5Ua2nwZ1SZmwfglvNInQHzqoUAPwEZOMZJVDanLLFpGbgrO7YzSitDrlr04Lw8f+9J1qVmuJ9CQVvwuBCgHNh+T6G2UgizKkW9zSnJ8AIFzxe9+L51dg1HCGSE9xnFI8pHoET65OJb3JIvdO12SCAWUAhDYFTuN6mX5XG5z05UoTm0ISnSKh0yx5RazYhsVcKMIA3i/J2nMA83S5nDAlRJT5RMwhs3Y9TxLHftHtWukz9eAeL28G9Gb2VUPX4Pqyy487e57+pfwOOqmW6MSANvdlU3OaRLxAd2QwmtXsznAzlqwtTffa/V+0kml0loFQ93gYWVyp5erfIPsiMGp/u+7p3o4Yq7zI83/n/raMwQ1MNcROS58cwcwe2OQoB7U6i0Qr2M1c/VptC8cNRsX3d4gi4nB7SwYxxzSWB3uPTphkM3vB4nLozk5vPLl5mQk/spLZK5dntG0xub4wKTwSF1os5kkQvBvZDjxtNqEuCbLYCzMsCXXzHPOxCsmKPXzBUOjFJ95CqKk8cYq6lV6MQHKLSQWVwORUqHumN+jpSvI80nXyBQ2dafv+2h8BhT4MDx6tcQFGPqMq4m4BLt1v6o5o8OPNrxhTOas/eQj0pLwkegcgXEaWQrL8uBlDGEXro/kc2EEAOAs9YQdfP8MUxTtsqj46mHkNgATqPBuIjZQFXT5NvUfd3wwHwp+QCSm8jul73Hz+NzrPP3tebs5yWFO5+3NEgQ/eluhT2zdIrNI8OxkMrpBxOMAphuGw4xuGr9cgrUTsX2H0glLnm8nFasRGl1C4eOwrUgSZppu5xzDBr0ZUSlG90sXm63eZXzg9H3SUqacrNNQeZLuRkeDn0LUxjNJQOFTHFpwGn52mU47745gREOgzXZ7glrW8GXJ+lWGLIa2GBg/tCwHJ7VZG14nS1tBe9xhHoz0bKPhFahaOmJx+0+f0RPFYqcvPEYHxfB4IYvhmBLV1LRNUVcrslrO08FtD61rlQZAwQFB5id0lcaOLzlC8tfxdGbtXdMGxR5FMrYigOrkEPcwFDUrCiVXH3evpC93uzLChiYdOoTunr738WTK8QuVZmEMli/70slOQQzLGc82RaexL1k1yjse6kpFKqCNgfU4Ubk2Yi749XalE3jz7fTBY6cj82I+N8RlBHhcjIj9hQDVCctgMPa+tYYZYYxqEeauVU0J0/0XcNP0FRMtDKrmDzHAnFtWRDM4HNU3Wo/iGQ8RJIIZ5knKh/gpYQZ/lDmlxo5Fz/EMaEksVsBk4MPefEsao55+oNd9I5MoQC/gbjR+EWPeqkaZLN5vsQPYeru1/MTTLX3epgDdCEsepQULxt12Npj0sWg41oP6Ke+bjQhTjetUeZf6Y8Az5FwE2jrbA1bxKP+iudtwhlCZdPc63Z76C1hK45wO7sx/eTSYfKW56LVIKlx/HCdjDmaEs3xCt1LuBZHcW7Z9COUMuaZiT3CaY8TlJmTYj2B7qhhe7otQk9OQFNYru8yjh7G73GG+EuEYsVKxeAsKbEu3wuqzqdl1q9nflHS2aDaZSfy8zsXOkNvoEJ/bsk8PqFEhbSk/BjtKJ202x6cj0UQoBPhH2kcxxIIkpPKl6v3p7NS+aN1B50QbNKJhMMP1PPUgNB6WSe+GduipH5gGPlqRddC3NjihCf+sCKFzTUXY8UB3JpeWJA1j6IFX3JKcHhh2ep2UeTTvN3OyQbEqW0gNLQQD28dLQRgHIV8lsUZyJaEekJ+Zxin99RL2vg5qOCv2aPGnZ5ir5d2Xj+aSHS8Ezu+m2BxvTsSZVbUeBGYOhqGXnjX/LmgAtXux64uLP27At5vrmZh8TBVZRqBtwE/pbTCzrVG3ZLEPmjfH29nYHXY1htmRLmt/ILupsjg8xFpRIGuYbEfJeEmVp8GYJSlqTc6ZbDoFZrfmxn9gJV7yKHGPI/Yt/C58umHf5jD1cU1HWK2vq01+dOf28HkFdSYfXsIA2C+PySS6vufmPxDORUCYYxqJefS0SwbGFEaRRi2CnGiwLpidqPWDUhERKUsg7Srw2bDs5eCtJvKmK8qhuUOTxkwVGETKCY8Z6FDW7PxB8c/rJU14DDxAy0IPbx5BDmSxJkMskBF16CPM03b95CNkAVyGLq5ka/hUJRXtr7wdP2uzy6s9dYsOnZU/Qf/z9RcCMJ2NKuyMdF2+0ptWEwea5JX3JFtY0/4EfNUS6XzG1ONvdKtUiV1bqvpGYzQDQ69vJ+CvlkD3+zbO2XpdsMp+qizIbF1A66wcvZf/Km10I1qSKqgwifnSUtJ14wJkA3bbEgDEwSaVygxXcMQ4Pe8IoFuxeYo8ZF70aV0evIJIVXnZzRilKAkWVrE4KIPNN0BdgV3azeoWm3oqDwHMqTugDoZj1IArXDAnE0YS79NV2XM+QHHfLKwpSpTxiYqcxj5241oM9BjYPHvQ9snjrI/5lPiGa6/xLQCuBv2zWQ1xaAypmSB1szX94B3fvEASNKZAVrYwJItHhumB3Pebyee3MjKT1KoG0pbQrwxXutCQvxm92dQ0xb9m+oOK3BiEChLpVLe5QvbNvAyCOOLACVMfrhq6WpXQAmCHC3I0PM7m8LemO4ySTUEs4Je6rZ4Pv+fHEhQQ+sMozlYMPzl2JYDMv7tr5vb65XyLAgCNQfdui1ZckPGmRpPzvrMWVHBdtVxnBnpxoq8uQORB4rUkDDGoBVquMv+7w01m3FXojB8JC1U7376rQWIv2jkriZKqZmcU14ky2/RhtTk7re82YhwU/mnlFxDx/aeavcwl6OoS4lfY4pAq1yHgt+6Jf7Qf+lFawvsVJSu3qYkIiwyrq+UqUsLjExF+DdpIdcgmMMMhnRDgAyZ6Gqq8LMz5G2bhWDz+BZA0Iy3Z0WcnjP1j8h4KpR+FJKOuQPRhhIzbqeLn2lm32x+KV3G/XUJWV+T7My/Eu0XBJOIv2mIpKVZ04crhVKl0oo8hm68hbMbq+AuIKRwyCPf6oOffCpEjmIvVIgXQ59vLPEZyQ9T9HT7p2zMJiYe6xnQisNXr99nyGiR7Vlgoi3kE9JQtc4yIE3DX13mw5ZZBZFELwbZisj/9c9PnmFWkJ61NznJet1FgpFtLlQxR8DMjNRApZM9e38110UhnQthf4XP4amXyHTo1AFtY8LjCiu1NBtY2i6rNFBusvYqgDzmTyAxkF1e617GGFm7zLf3Ub6GVq6LnYVq14f7Pi1dPWhigePzEjAdpuu7xggashclp3MGtNLPCMiyeggYsO3pUconjwDEMDMD/IZFwTZZg8F3Tmm06kIyOtXPuPCDpvTLD2pFa1pUhYFMYvGhMVw1sDFhdRxYnBpVGNtsVydD3Yusd3dcRp+m42NpPdfWyHaB4BGF49nF9m7wk0Ckw+JZBx+7ii+C41tHRoR9sPryuJ4VqkUiovbclmbx3EXZUxPBCif1z/21hRsmLBm5Xd7zXgxlGorK7fuDY9VePCJiM8v6b1+43cWjotJqzoolHSshxnyJNiUo8w1ljSFHYGCmZGpWUYlOU72oO27/ooQQtnxWS0OXQPItHbUU/9zhCXKGmrIULS1f8hsdRXWTRlcSzgPok9rgIOe5AGAM+hwT6/asXgo9yJ7l4kT+3s+UlW/AqyaL8SfFhOMa7Y4sffBZYrbrbs3cziKnxaFyzFya/a9CHBU3s2pqbIS9eQmJM1KYGuFVKGEOAuf11Ij21vll01vtHLLSBRBIZGHfgLDIoNMXMeUiigKA5dd4RBDZWWoHYMekvUrdQuopheNvIEHhfobLfwL4BUAHe3yeB3CLHUVv/nNmCc2515UOOp1QN7BvfS7lJd8LdRWwpAw3dh73BdMIO+xT/l6r3ZX/+ltD+gKMj15VeeYRD3G3IgUFbsDFYfw3K6a/0cDuI3fpAj74k1Mp7Eiox331ORnnmaXNk053QeF3gemvnW/sPCJ+iYJxlT0khO2WStcg+xO2yM8IYKNG/xwLRa9duxtZZ01kf2sqUlH9VmbG95ePhER6NkQ74gX2OoJ+C4vt+FV6vEs6+ivqrHvoZr08StwyXa4Sqy9eDf+0QI7gTn1ei92apv/VzT94kjfQfl/kdrORHTV2AG3bMVDSNltN8DR5EtNTFSTlwmdEeHR7IvwJjHWf5WLz5kd24j6xD0/kMtjuV/zhrdPBOeqRSFO7w2rsEigSPxpdfocN/j8341eVZxcTMCNTelC9htBgYL4bW15nsH8D4RJyObimB+zg4caFZMz66PLZ81O7bZvZNdzLuDLGWqJ+b5r7hLcHNcnT/or1lx8h0gCjT7wqZf8ILHh0oVbdGzpL3cl90HVO5WhbmS7fiKbLwJQJ6REstBXfSmKtEuQ1+sUzD+1rdsEKhDD/v0FPQShOOWyfR/dghIVc65PI/5KnFVY1QdFtJVrtwEGNkTWLVvEWHH/ygunQf1e7UFNPydI7JG9thV+iDjV09umn6yKHFhyLWrdunXgiGzTVimZexarhNn3lQDZaiO9mqlXSYvyMQ1Hz3QPXUbOjCbH9cshHPcJ9Ng8VekuK98Jxlk8DddTtuJpnBHgq0o4XZYSpptnKPTx+0DCTFxtm22KwWoWA2WVLxWHff+ezGOro+j44AZjha78mPjaolWEujUb2qMu9VrDPUMaEtaS/quGVE6mgpLxkwoJscS7yFZN2VAdoFTtDzRYFJD2rc28QVcWEOWQP9WbYU5l2GYoRc3zoVFhpiEEfcZfjWC0XLLrCkihClOb4EyZJEGshT9OrTNxGnBdLWXOToQMilu4N44OwJObV3ROYgZs7reJwOBJ7F9czHpVkXLiqKIMuFuJdowNbtIRpgOWs40NiEkzAyEmL1Aal5E0oXYbX0Miaxtxl2BHurR9lyTt6HRcgQ76Oro25gU9IsEKBzt5jYK9s57oDLjbPW/8wa4ickFW6rSQUfsAnjwUPPi2L/vHCzNF5L35eBSIouIrSsiXQ2NiQXl0wL2PLwcT0tSmPEt/dtHwB3HD7BWZBYM2ky6aMIno2YsDMQFfgEZ0lNw+5SVRefU3qldpw7G3wap2Gun5rIoPsU6tIYtiw+SIMLVnZEiBL97IQdJvloWK7ZKtqUjItxUC4rDMpV9osivgUxv6GcJoi5VUDYOFKDeYRhdPMss7gnYRk7lvlN06lH0Rt/Qq2BUeemCmfUajlyhvwyaaEHGideABYzPt1nAVbEK4M+ZtlA+K26o67s4q37QcId1+L34tbqwgrnAMTZ2ox3t1i7lhQWQ/saw8G3YE2v2FVtUGhbIi11LI4zAksHhf7LlkmTWDrsCrs6vrAlDBp0D3Ax6pt7NAyrMpeI0+/BnL7PpAtVDfdAuJW6ZejDlrZZSxaztzSe9s4cuI4qnalEE9KXD6Wzc0tLmvkk7BZbdAFG+I5cwKOZcTYEMRRcD0P3n5Mg4lkY0Nepuq8LVel0/Ltn4M0r2KlnTKDkE7RTm7yHE+Vm4BVzb8BXScPvsD2j014tCF8U1R0PF6E29QcviJiOWsL6R4jaHhX+gccAa6g9Kzz2AGoZl85JR/ddJwUUuxvZl4DfunaPgo8Fu8G9wgUtKhZ3aJRUW54677z9LhTVu0RYVkEKqmPC4jqPTVEwK+6giKe719yTlSgd/ZMYnoGIAt7S23UdzbPjtGV1NNR+0Gu+bZ71dKYAHxPuO+t4lYE+pScsflRU3TAt9AvZynQymRVDqHS++I4I/8B9G1x9PZG3nMd1SMCLd+BLjvKrEeNVjXdkL1PLXtcBSZs3EvQcGlLcODA9ZnbawatA0HgOQrDrcmj8EfS/OyTkM1dqGa3J4l8FZeXEun86lrEnuY0HLg4rtmXD5ZvDjYDIAcRCkTp0T0ZkIQaI6J88yg1vOrzoJGdM9BqwxWkR8gADmAdQIXzpwL70D9/eeVeyc4OnPoyjII+98HDSlp/j6fdNhbkei5sTuyrNBKV+Yu4KWuy7opbMJ0ZPHc0E7VFaJdpn+f2SkBKRbOSYFbVuI7Q+TbX1gj3hkhOP4oiUarIG912+LEEJOYYR+LKf0RqXqmurrG8U1TIRHtvB9UXyhjnE1GMz3THRhBNafF/kdYOSZt9xkK1zp+PRlV4KPd2NRJWCVRM79zpgNPhAxn+iA+K1tqaDm51NbpeVt4vT2UMVvvHeJDMR7sohmFjBXSmAk7/H9InfmxU76v1m71maG93XIXrv1L8VlORZn5Ne1rhf6Zgy91wece9GENT8XyhAA/liJH/IPqSFWM2p9VndtNHY3hoyCmU03KZE/z/AIBYMs8lA9iCUwUZ805coOhiHh4t6kHELXd4ZtgZRhUeyENqpatbxZI0QOvNE+1C/DjXueecR3xP0QQPKErwrneHlPV2rsKJ0V1L1RDxig5x1xwM+3YSXa6Yd+YIyoYxNp+dycYpQ5ZNW3c0dVAC6kDY4L/sf6fuHlDxKvvVIBxcQg0YK/tMYByoUqKUBqJi3ktkm/ENXTcoEyhZaRAYJsTCm+Yh0eGeaWyfV8Ybjjc3mdsZFonYIPfbzrlfJfNDOOqngPV4b8VHr+fvr/t0ejxQGu8Kif9Z1g+Gu9my8VA4bSweY8DRQW/VH7r28bpwlLKhAzfDcnlSwZXTX/JRPcPzWg//APAhnDLcBJ8t+90UsF0ziz2/9Vj36UA+Y4g9p4wZqgRHeF3Lpt0ALxrhJOs9fuSYyG4XpvHpqGPkRoGAuKwb+5pvHyzpr6ufkCt84DVAtdCsk/fLH0qIUOFj7AHZbhq4Htt6kD/UssIABeIC2gwW3X9lXPOKFI/W7hz2B1JsoB9xeQMRPPi02ISt3jxua1vyFnuz9pPhWXMczLhhxYuStFvOEYlwnXBhXlD0aDU+tn5tHuEjYtHkGH3X3ShT3Pu8Q3zw30GWStyvI8unjYzs4/RrB9F9nKjUqO7b3xpIqCToyin2KM8+KUIUFukRX9dHUjGd08IoJoRKIejElANh+7sCnIOnKy6KYiDIfYxAnN+B5Fi2woigbM25oEYTifNbFzYJgkG6OaHS2LjbVtJyHysO/BhZoC+LXuV2PnH2AEIfWmwxuvcDaFScJhLuIrzAY6AusOovEjmZUaff+L47GKOi8o4BY21zTz4ITa9th2kk41MY+BJKeIDN2ZICXdLPCXKkmLoupSqon/owwefTXFj79n8bSSYIZj2bERSIbopaK/vNejdmfjff0Bbs8Bq/OA5Kug/fL+apV9Rnr5zw6LDLC2lqwyTqgcasPpRKJZaamuw/VbCC8neh4eNau6wD0XOLTcspbRaLRMEVq8qjkwkE185B3J5PP2xE9Nqovd2vExPMyQ+2gjwejCaHY8RiuTrZQFDx4UMUgMZWt+/bL2HowLZH/V7V4h2tUDi0f/gm6oOzChgo2YCTwqVSMKqs+h9g6g/vRLFw5SR5gHb391gkmUZqx/jMEFGWLcafU7KgC5yv07k5Z2ifIpLHW6lk8A5heRiuoU75DVhDScrLxtSKtzwk7hsrbpskPxI4gY/UuhHvVD2slLjwxwOTBLyjsg2VhAZ9+8X/f+BkeyzS0YU+v5IvuryowsR7Z+4IlWCfRs04df+CohxlLnVzIfQsqxruAmXSmvC9N8ktMFcEQzDYz1EZHOrs72yFSuKIXqefa/ooQo+CJ6sbbhdRtFQv0VV0IDHMesj7XY2sUCupWahHqV9oPSryCVP71pPrYkiyYXkcGEgdHQAtWhq8qXDhhU4Q7mOELQTKtEj6YXZjtg68SwViHnLKRSJwi6laSToYFLjzBBhZcFPvSc6SY2hAXQrOOoaLbe+TLyZlOPsu43rir2xK1aPLKTI3TfDa1LL85MStPoZxLCQLOZBtehGD3e7OWrCv9fvT5SL7jgHyrJpFDFCIMEISZinr9WI37L7VNnv8zCaQ2cB0J8fXbJyb8GcxTgAQeb4VFcaQwv816xR/T9KLHAlhzw4+lrN86vsOQI5zY/ztopIlhHUFJ/I5HztFdLwEvSZPdWiqo7IcGdUP5XdHApDt/jG8RhNCp404wBuiVmwkAca80JgNJxbVhNfLTmCJo0z8yhD4zONR+Rr/MDnKBdTG92PP0ynp8+GSf7Uof+dKCwXSnBssJ+MyTPGp3TV10HIjwxdxvVgh5WK99nXa0sioWuKiqVad4nOjvdv1ULr1AbC3J1aDaMQC6Yeh6RgTcL7ozuAyo/hCxY2F/QY5tEHR7iF5rfI0jVGOgu9o4CnupNDAfJIi3g9OFxmZVm85u1PmVK8A2uT1QQhrZyR7iTIsOnmLTaivYnYfauJIgFBGml5HZtUvKIJA/li+T11UUFzbyR5Jpx7T0KTugbZtRDqYecX4fwwcEd271xVoe4F3xZIsTDu0r/nstti1GR8r1S9IYOtlzQk/ZLnDGBkmUeinz+ro0v51krOOJFxa26KUsEP9n4vjpGjHwati0eb9c+Q12xpWN+K/F/DqaeWOHAmPF5807JP8o7hKC9Nlo2+1M6cQDDJCZkmZkNTXb16K76XjWh+usqtetWDDnpxEQGe0BS+0re2VJqD5oTL5zW4XkwjHs4g7TKps7tkdFqnWf6ntoSarMxfOS43AMsriWLG0jcloyB9bEEqPUWce8sETU6ONhmjq8WyNBfL7o7CPap4hGUkbbBc9DeOqVKtg/Nf/btx59bsaIcfySx3AkiFGyT4XUDYTkRu3ZWxwCZQaQPm5VrvOTFRTb6jd5dzI/yK0BGn7XcmxSYZzLWS8A8hZvywvVEqLNPtR2l3oF7r+mTsBFWP9E1D2MReuKefRjyVmjW38/oP2miB1p9D5A3ccozKF2kokry6Ep7ZQWooAQtP4K7DKHDzj4DN0jI46iOiyCgFukWmKfDtm0vQWKbf1g1GN5QGEEIE+5YUjQOgZM9qpR57qFbKBed5hbzgLBirzB73mfJffKfGwycjyD5sgLQbwkzRrPmCWBY3YXOxTzMfzCXCUyvcXd6rG/7CzNrLILO1b1Db2HXtww/WVHnkOLosYtyyZEE7q2RCHwAcKLqwHo6aI9xxCqVU9vKb5BaAMw4Aw1fNCSAg/EhspXgiT0TKZzr7/Kzh0JeOK/x4Iu6Vl+zdy/xsnaBtCaONqMitiX5lBvfBS5oyEoyAhgrUU7TQkIj5Fy0q/FoN73lSDh1uJDgrW0NLI/Oyt5W9NA4C9CZV0BvVnjCVLDQutRv83pabsgB7064ykZSHk//TuVz8ruKJxKz/394wGlfDfnp41shdC2xuHJyMpLe8smyoZoTcMVg1DXmYV0Ge2Pnb/oHDE2jx5IHB/iizB/jY6ChY/gYPqSEkk/MSeD56+18lq2d+WqfGIq80gnrqRCYC5hpR4fgTbh1chN3ZDOxEvVgL7olMt+cJEMpnNribvHNo0RwWfZBz4MoWs9zFhBCaxZ7+Xy2B0zkTVkpczw1myG3oPfnRiOFR1vLWjs7g4AiKk3w13YRIdEu+OIaSOswD0I6RgBMAd0x8AW5aCl3rAwY5RMUDRyA036uVtlXRP8sLgwFFxdKLi8xBxyGr6tw6khjNjOfQVMTEs3vylljvaEkIs6f7MUotbnXOrwpiUk7ax6cew3tovYqI8D0melUY9w7kkhXTeVNz9M/KpCyB86UZ+ndY0JWbvlnDa5h5AklKbuyCyd+scZys/f9X6SIx8lPVlY0vN9sVfnmxwxPA51QxJ/EEJL0s8VH7Q0+SNfmwxBWN6yQBiOqQ0aQeA06tJDZsQdbsf5ySfmsPARgnaE3TyLXaI8VRAnnOPiuvzFV1lxrYg60/9dTeUvlWzkA/Itw2+BjNxMkDxZgSdF9kM7Q8hJRA0vByRQJ89+91uK/sGcGNEp/ndjhin/JXcUKrjCwQ3c2JDUhnLlfCyPULBRgw7EusADsAqGRra5b0u+l8FhxpY/nz6xeQDSIpj7j4H5FgkyBAR8UNKk9fEaOkvMIf/Fat6ud8rd3Ko+KjCV0MoR5p1t0FyhT8FQA5HWa6YRG+HQYYEQS5o45W+yXaQRP8wrcBOMoz01vCUwt6iPcQ5D7qSk2gS39Jy/6IZfyIPB/bwvXcfHQg1mczTqixYPlAQdlvmUpVPVeb+XV5YDmlyfVJy07sQ2BImliCO2TGonBEcHKem7tPKggwdeblKP2FmOoazlvvszLQFRUviG55GCwg+4hXO+CQn90j9s+LH3pEy24vVAmZ41ERAHGobqSUwdksn8r6NxpF1sVI1U8fEp+mDcU3uDJqSbanXwDHQW7gHQPqH8G5KY9EcKgd8BuyCwWSYZ/vpDBfXC8JZSYIEH9L2maK8egz7BbArit9hF794/2ljTEe7laB89EXma7u7s15Bi7aqaejEmMKAsdqoIjYuUkp8OjA6LmCLGJ05DfNqkiPl7FbqVaO2s5HDL0C6yEaW6cDEmUheG6gaC7gyINhxNBvP9m1wuHOQIF+0rva8EZI0EEJTo67CDUjdZ5csXnB7LN7nYNSJ863d4cVQ17v7m7aHL3O5PuR03eeriPKrliBxLcsykDOAdu65flqumjWicgsUtxTaKEm6l1Rf+qEITxzdXvnC4VOG4jQuIhXVfeCPmIz5decOH1YmhjEtdD6Ss2lsQaOAswOtdvkTQYAMipJOEqH7/Gfr5QrsfVtQNFRE3aLlAP0hkcNbcDnAlTDlCQC/4XtvmeoHkJKCKyQRzJwM9vLg0+5Pb6E7tcOUgWEte7G9OTJV3sWeCHYvS0k7en3ZUVOg/z2wnvrW0D1X0liOGLlTVE+Fxaxqd0a3rcy24SK2G1wAFI/tnQRlK5z1wFJ9FI2041h2v894+T2LeD567QYyh6nnscSBSk1/Kdkfz8pXYxpuDxeq6lZsMb+tJVZJLDsK1KaXfWwIwqRlnWFL6YIz+SNAzDs7natSUZY9X0YFAvpDeO1KsTmxhyVeamhKejpPVrrYk/xgUi/pmrhPqdKyqXSIwmF2RzCcuIF5VDlYkpMnMmXyPRrwGTuZROcelTAP/PvQXymlzjhOW4QFeGr/zM0B5H46fCB+p14XWqaf5BYJ7plmKZ2o4ZvnruBmIVaaNllfNFfUWefiBc20MquEPfZVkMrO9MeP88AwFGsUQzw9tDF2ymfqbVdoXWPIu3x+5FzX5IvHdqhoDcUaXjWkeR1uyHn6Nw1THxombtn+AVw+FqYffFvgJwe/73tVMGQBhjvL+0VFrYL7NQ83uTAa8Y+4irukmh01KwHtqxl3uaQDWK60vJxIkrmGD4z6dzbgcBqTDpYD8Flx7MTYl4b3yHLw8eYfMynCfCDjavSzb6LTbSp/XA1accW9sKkhZI/9unWzFwN227I2NZZILj9zmviSLWAsfdc5xU37RZp9RWzR3RzzEl/C9JCl+92/q7Qtsx06bDT9JSB+7wELl0wm84dO3Dq1a7ZMGZpRw6kbLkm3khjCKFm2l89Ubd3/PrFN5S+1iBtl1pGWR3kSh2vqm08biyRG029KSI7mLhLDpvzJWDI3po7UxUAd2Q6WPl/tt8yX8v48mfKdRZvyP7hxRhPPzHbpzH3QpmeSB36aUIaWRIjJJwGpxH3tMm63RVN2VWUnUGeJhJNuqrpPCY0YDZPPI4gYsOisPP8ckWUTTxX2egyjneimV1ApQjOySkpLs5zMdK62oGyHwu60aWYy0U/ZeBl5A3MRYQDKFYppDh75py9Ehh+vpe7jaz9CkPxLLMHxEAqUsaJhWqRGaAiNfpSZ/gnLXJ9wSPpHHzvtLOvqyV1nmI/ltSaRFdXzeSYOHkRe5HGQmSk8Bs91Gjge3OJ9EiWp9NkieEfB/MzRsGBdrztwKlRA0GFhR6Hg4CLS6+Z02p785wSfL3dy7gRREax5rMPWkoG4L2e8wqCogrUUVH3iVyXxCD07G9bFNoNl1VkqsWwu7Lh3q+EWOj4rE+WAib+VPJoqvqXtx2eWdYdY/xkH7UbKPhDjanjhaxpcFNY9AGvXRsvQQVhWuTSDtCBeTiFM+AUkvCQVfITSt3JKaiwkYPoMiiMyua/PImzcCplY89AJipv6TVmwFCZ24DBRhsXlONlUzAMuCRUN+nZ5iK5FHum/h1qJj2G59FBiqPflJwd95DqA7ijraVESIpDzQC51OFZhBSx62Xnf+oyUNQcy9vT6gyUapcjGmko6bz4za/UV7Cy+A/y3cbHvuM2kKhSv435W5c7gdH9YQ1Hrj5Zcu6YBirgl+K6i1e0UtRjoB7BGtZuHW4K+NS3XQ7UgrfxqoBmH6fjReckMuwnWQF/I1+xOK9YL113Y5LgxY7VYJDistO0/oy9pItoeNAF+wM76f5dxCay4L47YF8ety6J3jcPV4COW0bTx81YvAAf7GH+G0nPpdxOfhgcYTa7gcTnNm/UE0PkQA8FedP+K3s8/TlwLy/CmWxk/Ya/W9pC7G8Id/X++jGTj9bS3adL8pW3GcO0dJnJBJrZ2QB6c8Xkp4cJa9kxWH/OJPZ/sL3H7k0EYH4oAK5hA/1J2lA4R51W90Igr8LjhIIHY+LL4KADaJWRvg8NjvDdGeENSXiOT8qzdEdO1lVZ0lm0L64ekib3B/nQVYWpzCbpr9j5AyDZvIZwTj/0aukXfa84zSRlGmznPSyulWU0kUr2xg2l78g7FLFzUhAPh8f+Bi+nrRiv3wGtcE/s0JiYDWLPbYCRZz683JlNleE3I+Eulv0wSVXHhH6s44Xt1H7GS2tuN35l0Zjkezmuk/9Y0lESNf+q3CnUhMZraiDuODgkSlpgLejjcYrPlTaTRHt4Tnm8htrQqfLMe413G3fwXZ68kEGCKysxnzFTT5vRDkT5NA9qkdH42g7cMjY/5ZEC/W9e0ImwbPC3opkr+7J/PQDv4b/pxo1VEcT9HS5r4k4IRXL8KoeW/orbR3UyGJqg9yGqKwq2ngPJL577Bd06wNL8HdYR23zBEN3eRgU/x6Jozc6/z58/32GfrRGMROtVp3bKUbLhdgKYd/E2gY3KauTVoS+5E82Xv+lLNxkhCrVjC/7kCwx8QMLtyoANVub1N0Z2dU6c4E350qRsZTRZ8Kxr2WMD78u67JRnythcp/8Li+50JtxJ0AbFxodWeiVyDaF0eeam4aLUJUAhpmz21jbCtLKfcnYopx+LN+OH4epNLReb0UL+KnLkMJlGBUO7YYMZl0GUCPIj0fI75PQ3go0MVOeasf7N0j9hKMIsIzRYLtnqoLkMGGHs4ybOc6LaqOmgd3YI3Z0k7leKAzxNDz4JwLGRBwv80nZs5zo10oU85YeKY9eGAcMj6F0/bKz36sedZsvtzEnoggXrYeMIT7ddCk9Io82M/jwwee1n5FrauAKDGuPYJFDsPY+qgpERHbQFobGpPpJ/wo+gqqXlG2Ec3vAI3eipWWnMwpEgnLqTDqK4jftiU4sgbBmSm7CIjjvTLfJSO/CjcEOPRUkVGbCnAHIG80frd4bzXyO1Hb847k87nwG0lPEL2+Ro6awdgzlA2XnQL1/hDsAuviROALB9KsftbGKKex8PTptosFidl3kroZ+hWDSud9eNbjy3ZmG9qMpJQ/hJcwdlg1QAIZ33zmnuo7evR/jKQjWy7YjmszbnIbhJajKjzbzSgvSpikCnRy3061+JtRAs9cFO8ByYEc82U72Vuk2jIUmBEqnqbRZwBDmjJ1vQ8zR8/flmNSboH2mPW5M9WwlBpM+Q4WQLG/q0gB2kdrh58s8KfUkzyrMq3lj4XAE5aJAtw8SkIm4Pt3lZUuGg/Bh9zWxidA2QMjk6u9xtmTxj8sphYCQetCC3/MHpC+dDAMvyV3jXRb9d64Fs0daNrrCyvHtm+Ct128OD9oiDbWYbBOz7lNehlKaemZcyTurvjwe5k8ZUXPesbWS7Zn9oTN7Std+bf/PQEomaFaemy+ILAFRBDvJfmk0ib1TC/r84/dgTFCjUEyJa07GLluA69UxwiHGf9LWhFvDLQO3yOHAarK+a14DNYaKNGYg5wnot1+oVTtXPh+/5d8ZpxpLCgnE9uTLXWfgSvkNq2Wx0QfHX0SMcN0TcYf2UnGUcncfdPWmekEJPYIBhezJdLhovyusRGnQo9f0GgD+YfF9Z/cWOlj1WYoP/3H/JE1+Gth7u6uW3MEaVALZC20qlFJfkaFs6smukzO2AaIXNSUTFF8+qYaktODXVxRNui9fzbDdBlaamZCcgfTBiWo7obwIj43GLiCMQ0PygMf98Ndg58WoxsEA8KNfkYswGyU+rWI9srZhFZl7//HGeWaI0fVFj9rKFyR39E8PCiqyRs5ffdQLGMTK/BwiHSDOZ1mmlZsD++2415IR502G/lKTtZOy0/pKZz/ITgW+30OulnocU/Yanvieq4LtI1pDiTYWym1pRJPn8A7SxyKD5PSweFE609l0U8nGW0WTEF9gSeDgF2YURYRT6dDPiOh0nzRKSGuB5HW2HVE4TRlYx1Q9ucMQkJqALQg9KEgozqZRVLRKFbKXQo2tGYraRbbV/yIthGzdcMSBLEXLrhvlbtFewMweXYQ/SUUxLGlzhE0gSiCgXA/jcLy9wBq07q7AaD8sLjTnDNFHQsWkUOQQ1ngPyoZf5KKyw7HoPPsBEUe5EX3o3l4Y9v7kUSPQjFM79BVLzbeVY6vDGF43XdKMbyrVDeZ9gOuJhNqRlov2orPXJl8zyqRe1uPv/PssOUCbGd1gpphk9BGUXwluZdv+YPlX7WzvZwQrpDYxSck2E9igV0zhRXObYmGBfmUHnJCCWXsucvGb9XAHp2DTP33RRPykAv6Ez+8R3q7N9coiADZg+EGw+x4afgdmtHh0/1Ap9+evXjNPtKLort1Z5i0YdLMWpnG6Y5oacMCdAQgUFHLXw0Dv38iC/QU20F/uO7TvBuahxCnUX9dnzzd+5/v1LPCDx1HnUq0omdyGqgTb6eWD10fc47w00TXwNbDUVWmobtWJ/dDbZB0mawE+vnIDf3rkvFnh2FpQoUYmrHM3cj26W0otPfYR7oDC4Ef2RnV74ANGftWnrEyuy3/xrysJCfT51IG7uu/T66KV1/drvkMXvoPn7Dopg/WkjkTiqiPbWSm6m7f0rLAE8D18pfiBJOn/lwEDKywtvxNhkllIDcMYr3cqhSqNryMv+/he+pdmX3R+hWUP5HZQs40f/oN+45MH4MU0xXoMf3Hl/i+sISi5q1H23+6miAJgtyiNIum8HRV38zsUHRmIzFqJhK2qUUGEKQI7tmSIXe0hxV7IcjSY4z0nxCHQH1fdB+Vv5ZtNhdC/ptYTAUSCErpkUDh0L6WwzBTlQdOxr7m284WCuYg0ECvFK4SIjWuyjaJOZZ785G5gwnUfrv5mZ0JHWWrcGT1+B4MbKA8XhlNTtKHPlWVEZj2f4A10yAqBtWjNPZtVubu7QX4+IQP+DLZ2wZi21SLR6fKztm2BbZK/uALhJWujY5SRlCKyDJV9vmgq8KC+Icqz+OK4fJy8z0/M/MWY/7u9ImhXFBscA9OhvtCnYSl/9snxR0txoNrdPa1g1j+UFP5F6wHBy8tnePRP/uKAxsvmo0y/N/UxN0zOW6pAMXeLKI/F2+XS8R2NJG3RCvLl7FAX4+VX2iPUIZNuMUk96Dw3QBK/YhyY23MwFEZuvAh3nKWCKdra1a+BbIUuttO0u5oJcIrzNXDpE2w3oDPbLecqv8XxkZl8slRnuvtKzVGclB8niRsFD1XJFPWlm6MG5x48dxz84rI69L8WpbjW1swblJC8vxn4eqZHwd0OYc06Uwi6jbhsTNSL2U9SbEX82LXpkB81loCGFUJNJB0rRrpKbbOAHdZXTqs34QD8PB6sfxSm8cFD6ItUx9Y3s6aWkHEScOq3q18CwbC3AQAH7BwP0iFtnZ+58oCRgOBGWGHsFT9xIdHjKsimA1jL8YqnJuI2tqZdBDEVDYp0tBrOsQPY9hkNr6rdRZCJUqMhRE/bptRlVs/qdoCt5c6XRDBFJe7VvKVAHF0JFwJ6mapqa4zeUYoxUjexTcd8i6Z7/VvykwZjzj9pivMQeVz9rrHjb6wrQvLYcT/PIQob5RKmx8b4ALdSu82n6vP8SnMUg71FxGn9jIacnXGO74AUrS2U6j0GEd7wR421VQqSDaWSTOTgIApLgnTCfB1aynJYvuX8ZxBd6+O0Lb9QOY6ay3B6zL/GHPGz5mCKIVml86c41T3+psVB2u6ixKo01a127/Zf2mc5tdPGZvJmrfOQKDTTOP989CCxgbk12xjFQ4I3QXgM9BlXfrPPnrHhq7gk72JOvbzLo/CxsZlHHVC6V0JI332qWxZPXg571UqbdLQN+xF+ggFF66dMIW6J2KRxIt1zaUQXgE/fdx5RUbBpVQpHfmxkDK/q3XoTp9Mo06qPMRm+51b+9l9FAvkJjBwG7P9GxSL2Wjw8QSd4gjY9lvuhJQbCYfjUv05RycX/qiiMsIpF5YP5Cgb9dDHlm8Q2QFpfX2+M74AF7G7ZNv+rduuXAOdlR6uxhCQBKBlV2bUoPHocqmJB2aSgpHAzlL/EZusmVBVCl3dR99C3+FySEKBO6itOZTMdwecOVdJbb1qL8i8JYa5HJT+lwbFd/Qyiy9TN5YDjU11alK2RBRB6OptlLwY+opOVcbvBdHuRCS2R3UEfyoXhbeLRJguzvRS2a2k/ggQnU5N2+R0SuBD/ePhKG5iqX8/pNISl8ijpQTCTZwLCYJ++zDuZM49njhVoabS0AQ/hxhPr8d67y+6Pm5PaSBLjiuPSwvwgrRE3PHKETm9UVWgdSqlJ9gxEZAO8CPB+Fe42vEGVyLqU+EG9fXLQfoUW1PARBnCaRs4cfBmLQMRVb8QowMy/M1ciOLExBvJbE9YHj2yssayqgJf1iw2NI80aLC5WdeJRMD1NLZxvmzPqwcXo/+iLue7GGGrpEV/F60mS3pvvYxNVmsoxQxoS2Ox6WiZHdVPiMyiAxxxmxqehHOzWVLt9h2ncGMMQY6zFBRUC4p43CqZ48yZCKsPxU0C9DbyrgzsvN4DWWh+qxUrPgCxb+OKdrzJLdr8oT0GjkGs0Waf/Y6omkWd+49QGYAvRppXn5JT2D5eS1oP46x4u7ebz6w6WDeafvc7nnITVX9J2S6OIGSudquMvBt4Q8zm0ryUfPSSWzNYyIIlPqkZbdPg59QSpdKCeNzx/6wM1sE7vHcxCN5g370N9UFQogoWD6O3tQDhxxMX4OaZxn04Muwf/6GUPGNEHy+u3xGJriBPzacbMHue1FPEv/txAZXxgdc5nP096oEf0Sl/6fC7Hl8qWIQJLR04Z0AhPjrKghmAXpK/5rtzKTLnGJQJetumroCbtL3VlxaGiRtDqLb4olq14EDM9O2Ag0egAUF1vxvCdxGLJ3nvhIDPCXOTwxhN5iv1msWgDUCod6Vz2GbQWrHrwRB5b72QUV6t6Gb7/HywVUJZePgvM5hIk4+k5EJLlB9HlLsxOiU5XaPMvrmAoqLDp3tkOI0A0kuP6pIOvB0DcEoI3tprF8r/ChaeICmSRoMimnke6peV1fc7yg2LdW1bpimRuU7/D/zrpTDvB2ZnAcpB0nX4DVsvfonz9EXVKhjMQvu4zw7FkvWIFJN84AKYQE9HrBZfvqBJiEhQj2hUBLrcoiowdSjZXttk8Uy/JOzVc6Tm7+qxT6SZuTjNy2APGtBQX7xhTPiYIXYRAfB0PTm9DQkW89AYH5nw+Pz7Ff3Z7OkaRVFn6ub4vufmfT3ySKHYEJFVK3vC1mb2JUs0Oe2bv5vWyIS8XAyWH747HCQukhR2+CENJo7E92NOReQ/7dntjKmoOroBKRiLSyJIEFmVyvXZMbdRM+kX+tg/rU99QJfFyKZU2GkyATBmE26sIuJ6LRwNHXFY/EEjlmHcFEfD+P9SXucBFPnKdOUoCQk+PohLTcniaSmEBZ26ZqpXIeY92PoQL5fNyeOJlyqcs2O2xgiv3W4gq+ToBOFJ5HvddQVRlQD830AFxa5QYsiWqXN/OZz3wnErI87+kJVj9LSCi76A2aHkaeGL3VI/cm2AXZfyzCACsjraj2yX+bMuLwcIVxOw0ej47bX0H69d+GkECJMA5Id8BolJ/MihD0qMaXnH2pxzcHcIBaGHBIrtznVBpKE/WDZkwf1YrDMb4kHfjfhLW4cNNGCb5by8MIigQZIdL2ysgpm8Vj23yc9XZNOcZ1tDT9SD0jjH5D6XCRhEyNsLiHqfol0EuiM+Ax9x4RXV370FPN2TusAc71OpoZLGewSy4Ul7zwYXunG7qYxk+cPPZaha9ktDpjqBsSeTNQH74+RVSm/1Oqqn1NKRv8hjqHxruV1Ngj0p4hv816P20yLJ3UkW5ka9/gbrBz0YvhYf55mackdqA/lnlsQIW/SqXOjSUyibBefv1p9NmaXRoMwfKz9vzSkVDNvUDLdWD+7QAzCq9une+ygOanHutbc3oYkvX2i5w4UXY8VAOB3l8nk0TtEbp7Rnzi//E3N+JX4VY7nr18wvsgh0CRUK6nWnAwurvIHcBuNmysCMzqzuR+PPD1JJUIBinsx+vYpEpOGG+JgFrMsFwf4vkAoYTyt4RjD7B4KXTcQqS0woYhCpSwDKhAW5lxHKqvqeNcx5jpURJU8p/wLnOgeVlIsKqTx15nVb4EcAzxQWngfzEOvlZALIwvk6kfGYXSo2Zfp6yHtiMq5WQ/tUAs2THFTp+ZRQXhmUblcvisa49ZzU32pxr7qXnucqX0J7/Df94VeZ1tee4oShDXlkmA1tIFbZa70abxe+U/+aJ74dFmoyINdWaCy9Gj2Yi+3idm+xte5er7K3sy5A/L4VItvqlVOxhxUp8wfRmk9FFDVx9VzBpxtXmipEx7jCpWkd8cv4tiuEFrY0GFAdgwS79dSgdIjv4TV27OYU/Yukm9USPRXUjRjZleQlccW0Bv1owwJohhhrMbR/9+xSAQIXeUpEFVh5LU1gX7+jZkXMOyqha4pLQ9+RlOpFy8VqCq69ny9LeSWgozR8OdIRXG+OHbRj8WhYYmqQb9InuivkMQ+MyQvwE8f8WABoZXdNZlfaNE0S60tY4XYifnCkpsrtGBw1ErvKrUGlDTPTMAeFZsCJTmq20xUeaa+VJRuMp31xerIQAuQkQj5L9VBnuRRWxke3FwECK71shwcUBJGzpjuX1DEGB7DpkHdAp5eHOn5TuIhu5RCPkVfgF8/SCv7wJ7Acgnm8SvnPnHdf551/UV18wECDJtV4a/wQoIeBRo8P2UUYH9bVGksRe4Fqbml0BRhnEn76r1QpltGWURsS6C4dh3BAiLH0/Dn68tpCX1Vgbhf+3NkE0cQhnXIa/5FFSOaVF4MXpNLK2RassJzvozYLgMDYRj5B1c8HdMesolfklprTAkPA35dumrWQ69qXEyT+uOnQHpFjUjDSBt2eSAp7gJhi4WG5FwQ3WBGwHU8NpUrqum6n4Z1vq9FYJdhyUhrlNLaJ6JCCHFA87bFuOVKB0Mu/tJkOaGfgXKFeyMETvzO49vlPnL/GV1zKXd4sSM2x1P+/C4XHa9cqKwZeQ1rv+ohCHp4tXDRnx6OE1dvcszT1Hl/yu9GqKms10FTYILf00qmob/fKrsmlYSfG2os1NzWy5PBr2MJQt1XuZ8R8UhmsJKh61KlfJk8zQZqe3uzhggzxGyM2RnXZuJGlecgBSuQHSjT0WEtAwX+ATf67DynvbBx/2/UOCE6wdXXKRFL7J2t3WQfe+CnZWns3rjZserP+vNbVDgzKC1G8KZtTTvQuL/NoiGKBGck/M33aDB+WgD5TpuPTxTqC0O/PILlXrY4UMqG/Z5NF1TZn/5qCdnDLbrOhK08asLwjHohWjYcmlgpchys1vgYDBz57eb9raDsCCOLCSO+Gy1V+rOOhwSUKHDu+1Eyrk8n+TuXC7kz9ro5efi2lb7DOSEfSOj9E2L2zJzSkue8Zn2McpxDBr4yoaJAN8NRrfYQzvLilQ+ABv1QI/FUxU2zq128nvsIrN2DmEhad35010c7BIfxtsYBwpVLv6nU4VkkJPveyGYYs+Tw4Ze/U9MzLPe0PTDDF52uT0LZvsY8IRKRLFa87hGdjt/L7fRpY2DiOK1wGlid27oay1wpe40QYPo64rHPxNTBomGuyQ98O3O68IfUpaBcaWi+QKNQedIsk631PpjDPMIWiDkDT46ZFDMWDEgiZG4kGGdYVk/GAO/8ZVkpHavx5Bay244w3AKatXn8cDwI9N6z1Q76R5dMv4HES/MI8sVQ5rBcy1wXldF1t4e2FvWX/brZSe/3VQFsyPQKGOJ6yNe4vSic6CuDI2ibVDCkTyXISgi/iWkbRLP0adOKp81Y7hqSgKpWFkU3j471akw4jOGuCJV8vWFutYJKkUv8eJVtSwQShJVbwexH+6/875vwK5b3GfuVbLkcGm35FolmrXQy5tU7vAKPY2Sk/ZaK/Dg6CPyKkIJUCqf2OcBXfz20WbaLaWSOGv+bn0Ai9z/PrWL8NFlPm+8GTXIPOOtIX7Jnsnf/YkrZkPxYCkpS9Fma0W9g8WKaWWcZAEnObr5hefYQEe520ARlRJONolgqAPb1hjm6EWK07/Efl9lYIKMKTDPvji2MSPjLB0gAtCnS2/uMktzD5kt6cLmaj8OX6we8mH8cOoP6OvlxmYpfga1hv34xPZlyco9LBFuimpZg55OKJqY9oG6rrdP78zWB+QrwsWCl9B59fnAgqPJwZVd42wdoM6qYiyoLt9NeEbvUk6HnJJZmotlK9G68g8ApFWazn9nO4WLZlT0X3SfA9C4QM/1tO5hZcaBVWy7PgoRPebkhpl1Duv9Fi7jlOX6QXlryd7kgXFj45j1N0KulB8UXc/XvWz4yIpU8HTb5wzY9wrR3PO4zI8vZHAe4793FqzB+FIVkdcKmiGm5TEuxlROZ1muxlTsWvGxcnyvhQvdsWPANZERf03BtkMvKEqSjmtHpmxL+0aBDdBeSVQno517A8JQH+raDebZWMa9x+wOJ2RlsgK7h3JxAOiBLJ6Dy/ZxrPF4Uuba5SwL2aidt3sW1xLB2fX4jBYlDlnSpzjvpHBAo6CXpfES6Vu9BphX6rawnYYZCLk9wzL4/AjqQ+gwwFnnrJ2mmgBSYXl+lZdJ4DiAQR6DVrWetDmFgID61Zz2hU7RvDmGfiryjLXCiuECxQwEiSXShmZGGl32KerIjFdIw0Wzw3hPTtl1M4ABL8qsjcmnK/wjTjqkIcEw4mGp2CvINmQMkbkG2Lbo2M66FHwJC2EEsNu78fZozGxWSBqDACP+VQJzKsSjFy/PE53SQo/G5Y1hxJl9btssKUAy/nqLjgusaS+P7e97Vm8jmNLnRH0jRpzVkXvjEeeSLC58GvbgEadQR7MdqUptqkgJ8dBx7xaq5C2oR7l955dq1XLObkcV1xGqslbSDfnvrgTNtGlPUjMUevZbTkZUO7l7Z8Y38jzwEWjTR2r4Es3D2HMYT2nhEiQpNk14ykaiehRC/naKvkVk5rvQYkgQmX43jSN6WTwJPdBDufkHUMabmKelsXUNJQwyw9b15rBCeOsLCq+XrPF4IbXX92kfQQOi2lkHNLJLjSW43+yzGWSC7T6ccyGeplLaRGvo7tDv8cX8IqRvmb3ue3db9tS1eRguMQOq3QZf+eB6RZe0BOsLSpsAVyHxyqjn0j3mreA/NFVNxsohUzcTOuzwGBEJwGc0fqYnKAwBTp0fjLWi9/nYcSnXLHMcWAogMO6Mk9CZD/K+uQ1k3xx7rTCsBtna9SLghlLQcx0OUdMnFYfETzTFC00fzAi6k7wZs1bo4m/8KW2qNTYg5DnSBiaR/Hz195DHj1116crJGpeUb25mDSsZs6D+RnXBjXi6LLmxrW1Ec/0wUG44iCktJr0wBp2smJIOsTT/3gyOlDv6xS6b7BW7ZxezkJpC3JHUeoti5ZEBokdsUhIXqWJGujlWVgTaBI7F0MiC9k08faQZc5LqWIfR0loPKTTIMOpd3gFV6Gs4Hnog0vAEA2p8vN3vKLG7STHKCvAnX1BGubG04hOz9FiEvGwskiVokCPtuTlNMc6iRDNK0uWt3olrr2JdX5NRKzk8rCCPy4FPU9Zf7QcLjBX8CXC9BKf9aWK6roXSTDmsvwb9pStYySziIP16KAa+pFcJVFHLfN1qkG+RssCQpKJ2SvAb3/Pgb/8ZijsTYhqpl/k6p0aqCzwVAvfvqNor+kQxlVFiTCt6oTaHuVUvBTgcAlUacGd3VixzbOSflfL6MNUcdSJmdE/w9ME3NC1/zQCtuEdmDTlvrOyrvR5A/1h2mg6AnElAPCVLQQCuefllXef2JXP7G1TgCOquWZPwsA81CUBVNY/i7X4tGD13HkCDCDV5qLYfNieEniO8HsKRazuAWh84rYSRZAzbvsFF/CK0iQqwAFzG9gCezNp59LY4aECadM4CGD/CHIUdkPQ7tlWXJC7hFGbLhPah1lGJMJqvLoxivcjl0CyCLhotZHEvdOdQ1MMfIh4+yQox6VayPxwJjzB385ffAS5K3ikuPqimgD2ZwrESAkOXQgQoHo0yW5a83NLSe7314CPeW7WlErK3TmUQpjUBhE9+2Xp7fczteZI1PMG+E+WqoniLVTXQ+cY+B/d7iBgJP00REYzLVvxYmtyOhppVcYY2+9ssINzsPxDEJ60FAjUnlPUFts4i+o2snox8d+4S90bIdAT3Qjh9EwJJkXq4fCQqMLJ/jHzjta80zQoVRGr1SMl/fS9XvIrb2RGtBdo77ddCoBKMeq9Ox3xbD0QGb/PNIkXc0cGSmBs2+ZlpYmbpuxA2Qvx0ipb1DfGDCSOHKIlKw+rSyNu/whlX6P/W4WKQkx54nT9OpQ9Ax39J93Pj0dfcM53vHXXiNmz1TkjqiAlPI2ed8PyqZhOQPlUa19PSk5u8+nCfqP8dtFEeCGcWDxGJh+as3541s6520hs6spE7R3jSxsOqp2iw8ACU57XrvGq0YD24Wf3iQjF6VjvMheXnsRBdNWXundeDCDabwL0NkrgSSfbYh2PYEO7mdghqNgRFMnOFgXUGbaerhKs1TXyh+xUMEgk5OBm0ksQVplbCQTdXSWjX2e0kLZarv9fKnVujHWxtuhn0VJE7MKkjtIm3zndfigbuUbUewQz1ji+gb3DukD+cVIdjwY9kF1mAQC9kAUmxH5Lx9eeV0B02CAIBqWHPpL/Pgt37NEytfTXVAE1g4gEcojTz7zoVjlYYrhVqEix76k1b27mWiqxAA5/C69fRCcFJjDOZRvMLDM6spJKgv/gwSM1CGgxj9HuJ7/6Zk7K4EcKSxjvaf88jRQ5qK3wiKXouFNPBrr7acZNqieRl6mheNwM+sVMVYkeLQ5el33JxTy5fHG7Op3x3Oq1/a9JMM76xOYg9jp7lcK4ZucdSVIoHaQSS47Yn+YgiHRV1hOnRGPC8hVpGMgs2/Nb9lmlped9/BgTO46uS5d491TcPFnCR+OfR4Zcq70dqJ+oSDOIPsjt6RLq8j7RoxtQh1cLfxBE6djh4eqpD3FiRPWQ9QuZHamWEdly8ytoKYiTjqvl/MZZ+15bTO9QclxFe0v8GTKf45qnVAsbqSlSQyUmztTWnEOpovPrLwJFOyrUQs78k4SMmEaVbPagskY1L0I4v66EkDQHwwWh6Dx5z8lBbIV+423GJnLcIhU3ew6VUaSlo0wOuLxHUKVu/X5s4gtFSqNRQLNjCvAPmKhL0TSkQE0YsIGmbuVMgjZOzMde5d50a7kYyq+psCVTmEy7giLeUDsSohVIeI89FGMZWj7i8Mj9+9m01di5zG9+C8BcJPAYOMss4uolZHncERB5eRlfOCE1Uu7PcoUvzyZCFpyk1QBS0vJzB0yntcGeXNz7mMBZs0AShuLQ0mFsP17R8dRCiKmzGduNKeXtcH8psOkiUXIMYN3h7BW/VCmxmvLqdbuYZSxLQMvBISXxMTlmJN+079AshY6xm5AZ8hezACYSGeMi+2itsdMn7ofjN2qghGik/BdgBuSAyG+NsiRbcB6TD46neK+URsxvA/1KslzY+4TiZ+S7oInE98RCiMFPm/uoaiJH0E9fmypXRSzQcX9Zud/vi92yQabKRfFVPz+ftoN0b5e+jGb415LUln9b/0KYLenHDjfZ2SDkQWBirDdwaIa1u/I3gbM+FyZKJxriOaphJ09DI5O0wnyoqSSakQ+oj/2HcFkL/xLkMSiUXtXII91bMkEjAd6CKtGrU2PSKwUIkFbzzorhZz0AasFCUUz/EFC5iEn4f/ENaJNfQ6ZijDVV9PJ4fhzqYMnMm0QmD5bt/PAODxMcE+VYCu4OX1Fhcj4nYRy0o0g4Ew4CbWdu4pa9jMVbt2p5uj5kfsu1vRulX4IpSJsnchsCVAythq4WL+CFjzqxxpPQ0uj6d0uDNiKXyKzO6JydetYlfcgsCo8m2X1sl8Z/Aqj1mUsVQH1eZNkhb8eBrTnnM/hJr/XSb8HC30PxTyx7hOqGW/75mnZjO2KzNZDlEH7nZ9wTOPkFL3p8GVf7Fp4NcnhIH8K4SGPGo76YTG3PitsBS7YcMLpv//oGsYgwHJDxw3uLsuNX3Lr/xzfLE4OLT7N7UDr8dFPrdjqSKR7eQZ662uXaOMJFetIsGo+cVdKfu/LGQqoL0JOz4FcCZLljybjPm6CL576AO58yxhAc7dwb3UK8mqMtqxHN9Fg/fAC0P8mZ57lMsfZ2IVWXwgESmtThdgXVmScIg4OaFscjb/5roL2yaP4SGHd7SMNOSnYN3uzNfhhzoLvkaN737Li06pmWMnNP9uwJDllj/RGZPbUx5gnjqeRVWrbVAAkPJo1f4cB+8Uh1vHhAlHcRWonDGWFmKtJbOrx7Q/Q7G8LM0RnRUasofZ5QdnJyuQtvg/TC5djjzDfxQWXR1g1MNxZjy7s7Ka3t03W86NiJ7tCLRJuKda7fI44NUSl3WUpLJILZDW/U2HGB9ELxsRR1FrINIGObw7m0zLVDSJcbY/1nXFyEkl8pEOLH13ksAMooLR2IFtLxNyNdE+8hOWCv/axpU/1oKPIdOSsb6R66j6+ironv7qFLOEI64Mf0rqMfuYeXHweFqBgVwdkvFOEoBhpn/Gp1MddZbMcdJoiBdBr78pAoS7Xaih+Xw6i7ypTBTDfODlmmrmMGwcRaUz7i0PWlvrbCMmYxZ8RL8bPuokc9Qg9L29p94z1VLdrkS4YpzQPk596W9+NwCZuxCctNPyQFnrRx7mQtphfJjTClQGOSz95TsZvrIt4ieXahAYR1AkSl0QOfpDIHMWKkMzDyIPtS3ZF0+rfIOhbgZYFLh7DH/5Pgta1EYmXMECSd0Q5x3N3+E/k20qszRJUDRcfHOBJHD5Q9CsZ4rqnK6usSIiMK96admvn74+SHcEo5NFCzuhJsx+zloe9AqpFNRMLPFUa4aKuQRd9uqBNFPLHhytGEIXyJe3QpU3eLU4NVrjz65m4IniRazR+2nTaph3Z8n7PJ2mATxrB4ILeIKYsw/ivWHSlb1O8FVhvgQ9opFgJxJV1nKIUWrmC0hIurhPIb666WQpfrfyHfQ6qp67r+ZKjMSzBUYLNVWLWcpktXLR+TEZ+p0nvP/Vbw5LkYFqORE4JKdR3a5y8VweUoAVnSKS2uB19gIyaAZY/iLfKXXE7lZ8Q1k2kd/X5H+ukRtB8x3OdShD22lTGlxW6IFQhsATpFxkM3wL2ldf5hCh6Nscnj/c9uXAVFlD5LEtkCc5nM4MA+yxt8S38YrmIb2l6Y+TlvNTcsqExdV37om5ucy7yBWNNj8IBaSNqIWDDHPLKFmVINouWhcWZiZ5k65hp+4sKhlr2ry7QZkBrRfpKAzXoX2tcNt/Kf7MfhjuZP+TsqAaH1Tv5rDSmolRpxYP5dbrm7vjqZdd4/n/rcSdB9NP23YZfPOwCs110DAziq143xu7vS+9wwBHAMPZ7S+PzHXPx7x7GokPDWoSB2Vc2YJdGJq5rhhWFKefQFBgl3G9x8970kuokox4Ir0u0owlrZ8cMD32ALlJh5aHHUD3JGQNmb24XDMlsaVQyqVJK0MVVqky3qd//kCN6EcG/GNWftbDvCieY+OS5SOcC2fNP+R49sG82LIY7lKymEGksaq/ipQK5Ill19NVipyjLF2OTWkt1VmxS1efQP4brUTA11IQx5kiLyAiTmn1egvP0JhpajgjhvumbsQU7vfkcrouGg6rU1cQqpTx6LSZu800Jc2Su1a3HmxKXNi60T2ieIEoYD6lxLJhaDa8HBcYCAqHtcto3a9qlTYuBGUHjqaYhAsKSE6xAzcmkKjVTzCfaqBBiHqHpKmSMMSmtsa1SaGrpcbUhH0d1e3kbnbL/cho9FRExuXykJOhk14TheR10sGBuvXobIg80ZiUvmcxzNtXQ+UI9euyXjMikBoxJ9n438qFI7OgVrqK8ETkECXYo1l4qeW4qwx4NBpbeBoWo06jI3WkQ9JzkxySbI/hBOZxPLRFGH9BTGlN3DJnFOA7wFrRhM8ClRbBdZJM1JNpT+GlbgtAMvohgDcPAmJaCgzz0gWkxccD0YTzLMYTB9ad2PeOnRGW0WA8T1e/zkkUdPoy092wh8d4yiQx7ykwvMSTm2rX8zPladpo3F627FkMljm1spvhq5Qn9CAnZIJFkOeHcd+i4HvsV9Ij3hrYZctVFp1TwHNrlZ8mao9KNQbiyy+J4dCpnobDeguN2TY0ZlaRuOAILUz86QmrU/D9q6CdKRzUhg5toTpbekIqtDjhU/c6U7lha4EdeZBLDBPM7NWX+3adDxrO8AHKmbui+EOmXJPtHcfKsfGaoG0b+QOdAO6Xv6JonCo88kOi/z5/CYRfH85abfIigEF9xM+mArzhoJZZj/ATq/WwmRdIMhUWqDw8DVra4Iv2JmDiFpceeapNsQc3p5HZvpLRonbR6UTFyCqp4h7AsPHZPSe1WYmMkimWICLpxe26KaAMWjwF4qO23+K47RShkh67WRBmNCf5gVc5UD0n3VS+nctu19Fpq1tDtHo5/UeeJPyyVhEZfnth/UrNKkPj2OF2YhylbzM2iNU6T6Pd6RxUqMET3QcfTEnL7xCGpx3qGubD1NdoqX+qINEFoJ/bTD7HY19rOt6i3VphNBcGXFLy/L7cji98cdkfHnlAQTSim9XCwA32ybyQ3bbAtc+0jB04GfECuntjgOrs8Ynm/7tGLpKCrSPqQLZ6M62HRxGOfJZTlvY25jTjD/2KB2WaaISKHOho0raBolXOtEXaABJPqZ+k21cBM5JxSFy0Rfkg+krLwJ6lXsBy5CCdyIzoIj9a08Xz6L8VuDDtC0lwP2lSHol1QraN8z1cqRd/o3KKc7PhAmS/0W4YFUiV63E5FNKfVFnmmdyQptM0dit36EA5iB7EDw6wZ3fOY9FtDpvI9Sha9DV1Pz6ekTtzwMjJUoCBKGTgDL6NRgSdKQp7FUn0LMatVtcLz0MKGC1gVkelsYs8I+KEiwYe8LZpif9JDgsCPce1VVJCuOQgqcwN02jgJLemGHPao2AmgK5m5zmZmMiWMrHcUr96URNM6LAyyeRmrEWwZ9a0C0uNtpcdCjT5tAbKLU30n1IXnp/+VOmP8Y2zBdfhorNkPqRGIpwnn5APeXVpfJr2RlJPWGaLCfKDH0RaW+kHrQg+6Bgn9zglijORou0ctUG7xtq8nFA6EUpiUtC3Tg7WSHQVGMqBxLDT7S0+S8WiV3mtJHpFeF/SxD9l+/ik8T54MlqTQO964vSRxY/RxKItmU996fI+mqRPg+aoqar8EaMDV4OkTYDwBA/CEyDb8hcgUD2n7BxhFSXvxZHS3LrdmRHkb5fmOaZKs+KvdbaUlIteEejqfH0kyUTskGmvs3CryZEjmkWGfRpWOuIqi2BmUn/9aRn3L39iQIt0Ra27hfaHMmjQAsKISN+Y+zWFTDDeIMNMtSpi0VtalWy94wZpO4cYNFiWKZ7pDeDMbpr7s43ay6tPoafrW4FF8seYAPSgX9xcORKmV/nh4iHtmyfjePkcFyAYb5GVq3w05DlOeiUuhtAKHo/GXS5n+skqKlLBqrSD7SmLF12nL/oCqq7WqbIh1C90ZbGRx7qruq+nFkGvySG/yswTvXYcqy8wv6wUR/4gQxFQykXj4EEG/jvD9h7q+aWnyo8IZbxvnsuyy6pQuJ8+VY2eTuqFmj87Jd3ihfqAL/r5g8qKd3cMShehLFhpVH4VLaGxBKF8Yc4OamvlY9LI/5ov/OBaOiH6Yrt0tfgZlldOO8NK/viy2ndkb2QIuXUQARUHq3kod4yo8AxMiuhRkk97wkdSJkdV2dY0etnS7rbXozaAsgbgEenXUsZIur1JFZIeFWepvsGUUKVlce5FLt/wMTIdrRpAWS0jrrILAYdVY2oRorPGvOPrinV3CwvVNCg7g7QstvZQVPoq1jgbeSWZ2zK95kXYswaj2TTfXvWUzffqwn1MeVyXj/ita2IkSMDsjGnc0DHx7zLG/3zEGPpBfFAnR58BqqG5fwY874NllDpJsJkLGH2jJhqDonZpw9/4PMqfxgoeFANd6Gal81mUVPsyylb4SKwbTdzx24N9iuzdWgEgYt/+tgQovK+ByyJjMUCw0wpYaAhChi3uVHJvcVV3fTZp0wmPdPCWAc3ZdRLr4yT7JNA29qXCVFQ5vKMKeHOhp4Q9v5nFy1yVahu8fxmyC7R6b6lzgwxZrb0eE6eksWjqr/uV5HaBthLDJ1YKimxLiVOkuFvzjMICQ333DkpjzbBuua/al6esOqNDoasjlQ5SL1++mO/2cfG61nFquij6r6ZqX9FA4j/59Jy2HXtPqJVmoIPbi83iLlN+tDkxt/vh7KWuaIdonVVAWxBUtUwQns4ZSyBc9uR5uS+ob06Dore/kwSTkACPNJa1LtZQ3RTWscLyDI8SVjPCcZH6hWv5SP4zRF+mMEbAJK/RTjk9wfY1Jl+ahxlLJNFGQgsBtbIcB0R5ujQmaZ5n11XKXvO+7eWto9qz+JMzDI3qBZmseW1Hfw3qpJx114XVIvobzyl+rc0jwwhZxHXYLFmKJLf7HfG0iqK/SmPcNfy0k8h8eqiSoUJNCUXBBwAf9qcv45l6jd5hQBS8/mSSF8C/Q9YSwl8rk1E4VoqXaXyVlNoUe2Z5260B8+S8rih18AY+HeohAserG/ByKXeLsXRJ9WDeU4fCAFPeYU82+qrur4W9Gc0GrY5DlcI5Acjoy4Vpn2OxLQdX7eUsDnRYdWDks2Wud2owdM/8rentImY7b/85ndTHfKW2V3YCq9dHhvkQ/MwmD9UZlUkSeZpMFjvyErN8e+THkF7pALD9qv8RhnSDj+1tXotM+pv1NFsgSP8i5G5Inx2yHYQsTuLNppJSFu7mQK/YFoKMSGKbKdV87gKc3jR9+U8+ihxaZsCyP/p+enDCxE31RShkMx6fdCe7aAi2mnkuAS3haOXOUbicxljD7YptUHTPsJgrzPTh1yWwc+GsYAE4Cbdb33mYmBeGiIaC57Wg3czLffjgNfMDvupY+iGqfR74iGzepzJDjS9SUREMO7upIGZfaRZFlu5JxTcmd3jk5N0M9k5QKZ3qVUUe6RbcAWDTvytDElGI3zSeyH1OHZjCcM/Vpts5YDf8aE0k2y8AhcSxcXttT+sjaIbq+WnY24hWYsdiDTGs1YJXI1pC5RkWBS8TsBMmqQjRvYJ9ubVXOrHk0CrsenrxKiN+RujfXqm1FuSXzkMyRfq8IPG67MpWCegPHUyrrMj4fRO62FN8dDUrPo1tHXAIJgcmgZtEcEVBd1lp/EjS2dW/O0DehZD1FmfzDhwYfyp5TEKbgfnD33cLKK+1LGyU0lK2W/hvkuJ+jfDqZHJ6gm77eZ/FlMRtJjQJsqFQJxatm/bkX+2/yLqQsYayvcggxMlApSRVdG7ENSUqQyqOZEXaVc91vn2FsPhG/InHPJ/LhhQIIrJdQwzFDzfKVLPL3ky8rvnnbecvCmcstBlkkKcxxBBvmQu1LZQVYLAqaRBc3TcTxwGdxw90K90dP4XiFxQK9kpROs7aqduN5CLGa7bLbnw1jPc7QLEQZUuswSNdOLodQkNPN0vNt1dh2oH1/pfrgPPblXFrcypBbP0qeF1Hq76MksfJE8fulrnEVBmRqLSNSpAP6FVEmCQNDIymxp4JXA8Oa4sMR2Z5AqPzjRYYbnyOHMevy98a9TCYON8PYcBvmzjqaCWaZs046JARgTNsqcnmuXSYYllRzBJGTAzyQxL0AuC6Fvvxb0mPO4uNd10gebZESvQ6x+HW1CmlJHk6k9gBupt/iSyIEI9If2l/LLJFRqCjhypQZubBO2fmg9mfPItlfboKYDD/2x4oZIXczmrFPHtZr43De+tJEmIKw9pUovhnATuHsvTajz0kOJkmL3UDo4VdWYebX1fiNHYCyQxvyS7QYeiuOLZNXFNUwQ/6N72w9e3lJdtGD3B99nx3gY++aVrbIq8hVgfVBM1qGhMEIV7dKAvgUF3u+tS9ZDOX7Y02bDu+cL/cQ716Jl5gaICyKnj42gFnT1YBK/AwNTJVFLmI7lFBgr1gKmrx2Ll89O2KhzG8pFRwQyq5Va0rZqQWvJ3nPuW8by/+sJ79WzE9P4KOoJtCDP5i5mCpzKHm3B3WOKB/Q7SoV5AsSfC+ywo5xy5r5l4RwmCY+Yo4ISs6MUJya6FkB726HC0+sphURxyF3QSjv4Fppxlsj/YOU3tVAKBo4z9VSd+hcYqU0yGksq4KGVMhOf0lHeBk6Hg7ufoI+EptKEnovfBDEAmLDN7mEClEegnOMZmGGwoH8rdQGG4vzVKIka8MC2wv6vhPOhCe5I0/cqyNF1z/Ys7sJtCIumN5OtUiArgbV9vtFZfUxXP7HkND+IbH32md1be4h3a+C/a5lBROdIcHGhUpqeHglZSTZMSCpOfPt8KgQKAVC5daHJNFAIql7m0DqDk2Ryo3oz04JCENr6JhFz3gaxXGwKPfGskjlBqmMK8LsTF3IJ8H9VsoykFmSFYHMNbA2oaYnfAfRasphGSgk8YICqvrsa6QHGHgcruE4tQ2/DxICufe3X4ZtKmu/o8J5u5Zm0hnYaKXdjk3icmLZpTzY4kIAbE1jsT4R8M3voo7WN3LZ8lA+/7lptiWmyr8wm3LOXkTmWU8WX9WltnrfLw85B4FbNDK8YuGOfUwTUOyPs2pa7HIZKTm3m9KIdUPGnKXdV3t+kmFebdPkQ3GbnQslk592PBtXaYunYDEpnBC4bcer/BZIZ1s9qecH8QevOwNK5K96L9YTHtCj4NvkjXWfDmK3OYyNfvI3cdk4qgu0hS38jdlRqNR6hF8f7uW3r6u88Et/7J1X+FuZk4KA+VKST9cRpKld5Unknka7fFLKYuYpO3cShFfz+xt4Ti5B83byASdenfGoKcf7/A2vI/gX0BarTveH4eGm0wYwnMytlxINM61S5lyGLvmx+zoOycatTUJWVr3brKckmKVPPRrKPiu55bN00aIiOvlp9VyrERqOjZ2kIt/m8epu8eQthX7WWB9SylKs/TSSbTuhqWpn1nRlx7xXfJvHj08TtJh3SqXgEosk8MrbfY2401dFlZSxLzcsCDunLwuRUOs1UZR2aJmsyRLUNer86mgIo3yLxfB4RjuTs/hXPD5GwjCpmyXqC7x1vybJktkhqLlnUMiSiMnJziDuDrkndaxMTEYXLDlPLV6D6ykLhYa7+YXxB5PyCHRbRYpEA2xX1VgF5RnGFzUKEvwMpJFVtG1htn22BWbkmCZY3aqKF/jhq3McIfgwla8k0LTxTgjaGpYaLgDFd4P1r/cN1vB8+EHEhQHaEw5DKmOQrpqy3ooH5Om0uZciXlKXJhJClmN/G10WNh1ZChpfgzcvJB8SW+UCA/6nKoZa4dtHcYedkR4zg9EYHgsB3OOwxSILwmL/1OmzroekDaxDjC3yO1ASkvOXucM1DfJZMdzegKdEujaN16HdsY13AOrXV7CWm8OP9UHQLrRMZATMzDPniMdLhLmlym723JhCOz5pQkOUrzqVdW6zdmNyV+vVOvtWoTCouIuBSMdudJT1jRQONV+TBxd4Fvb77llp5R/NgwO7THRCrHyNQEabFhhJGAe4ZsHn+D39IUM6BBG4vg1KIGxekwkSlywvh11zPDrXxFi4PChbHu6GH7bj3Hpr5ekzH1IUubUZN9iIMaCaMJzIiBdXSL2aauJsg74Yl4wGwRYWEx4nyAJYyewXKDmOrwrh0R6N6GGeWWZTX8eQWNQe7LEAkqpA+LUGs1JlP9DJ+vrCZWkdC5zAjQUtff3VxTKS6RSJpDDcHM2nSIfZxJW6BoENvh0ob0jTqjsfPINF7FFQY+G8La5a099oxN4Pr2N9Rux/jaA4COC8zd8d7n62cknr3SGgo8D2ACIBBEd9NjzU5vZLugFwlPAvL54RVpSNrdFrvJXQBMobrcI9erAKr4CWToh4ljOyewESX+qtnzGQSn0ub1gwq3MfE51S2LdcLEOJUYWRYv2PaLP6iBkTiEC64xO9KvlM+4EwO+sZEAiv/cMgDIy0xyTYo1zgVz+q5UIHbIO1UquLPpl5mF5HoaINYEcM5JoL/U2YgalndQMdvT1iek/cymqBPHHGIEMzz410oSZDf1pp/EeAZb5Cv7RMTckTMnvYIEswWcLam9+MtF4nvXCjYscu9xKFHyklTzU/WsOeOMNqLKcy+i1qgnbkV2BX2VNYg3lcEIdByW3LkUxSy6eA62eKalYsFaMl2fvPeogmcVzfrjwS316pBQH6Rbv0Yg1jlGatuRA86/42RNyy/KkLRnZlo4u5yBfS9p+CeQUDkoaG2ZjtTu+HVIIIgkNMdO8JQbqLP0JztoO7WKv36CozAqd03QuaWp2gJbUr6VEBswzc4sKPsxpOLs5KU4Kx3W4D/6KM8FqcXWFPBE4UQuyKgA+yYlM74oMeGXht1vtc29TGpJreOGiC7yXAh/S4L4xG46AHnh+NJEyp96kxAW7EDbzcR1sS7Mt9tNIvw7WynFCx/3NZ8497bKrcljFdpws4lfouN98IiHVSblURtPTKVnKfEvVCfVLDsjHUDYZ0NXIv/DXJXB1brfOQiqvmfW6Eo5uCfhD0rGhV806RoQz05At6jWXroSgvBzAGlAjhMkwQFGkhU+DhZX+LGhOYUiDnowIN4w0oYYraUJwgPdukZmTs51FE3fN9ywtHiM+vYyjVBe/oD7dg+yrfbDBSzXsDz2STCvGIRVoMxFzGv/pu2+Axo9U3LxoWms4sSNrLDsnR8JVr9xZWH2BN8Ll89bNoQt1JTVY8cUE499q7tt+LP46RaKAX8DLXJ5T0B8uD34FO6SJ8T0JSTvC4wOnMDQ2XFuozJwzUgzSN+URWNSaX+Q9g4pLPepxgrXxIUeExPbK+xmUEW/+UyeJo6CiRv/yzTigwVDxHqkuG7Y3CCNWbaUrgQghO5ZNrwxyahBBTlsEjXRd514pIPeFjhtNbmg2Vcy7w4CV/prbSkvIm29r91qffcRrssyF2mlA1ukZt/auamajkvr5sPm3jrauazEfxLzQcLD3g9FHbnpiwaD7ISdppn+waLcRkIXf3iTd1LiViP8u7oQmbOiSFv/XiCED7DBTJyNxDLzN3clMGoB3pvWnJqyg+hxdx3dHn0cZiaeCtiirulunkhh/4LnZPSgx3j4cxPQoolKy7zHU2gRGgMPaLvru7JGwEzipZAzP/z/sth7lCTCOZ0DOxa7d8dx8fmz7UA9TZA5Nvm5d/6NTNeD1LycnEPjqG3GZCAxlYcQv6muPhmugOFUqGelVU/2CeRUKTsSDjnmiVtkHx3hCux1vrj3kyk9SNcunarxpYJSy85mvDfznYWLhs1JOrjoGb/TQSAvhLzzHLBYlCkeE1XqzRi2r77Z9aFVhUsw/apdqSMNg53YmaRy908jBb+EsvzA7CTgw2UPw7jVZRBDIQ+/q3qbUWYHsEMyZkM+/f5qy2qZXnQtEAl0iBNwi9Als98FHqhKVqaZVhoEa5F6Azf92mN4ErOW2kBY87RnFH+xg1IeFpCKHVmu1cJjYUEhYjeA/pN45WCbNkhrzU/ExrE9xtW3+4dQutqRgCHnLE0RynclWnrvOFidv6mpmtVm6cl0U9YRhry23F3xZNOaBNCisoku6UQ4Oaapwb2kIWjZTlCpz5P4oPRpFr8wwpsvAgzJW1bTJasbfPEfM0zYVa5z37usYO0rOC3tVxqDfhomc01ibBE7+M832qXfjRRi4UZbWrFJR5n3Hj5/hylOknSThr6Fu0ZGzBUjLWARjtdz3gGOvh+2We8odMKzA/VAM2Xe488aT+lrz43AxsXAP6+BypA5ybDwMtx6qzEXUDzlbvQCs1UDRWMisN7GRaxrG4qluRBJD859zQ2pKtQP/TgYBSD1wApAQCqN5L0KDB074ibNtzlAAA6+mGZcYz0Y6uOlwfP8pACgAqWGOV0lCOBK2hjBFzVzMfeZznZFaej+JU7hRtJ9B2Oc07o8E9LHLRF5QpcqCeWhvdU78dIi3MQXrwJQHy3gZiJomm0WscpN94cjbDepDNJK4wmtx2zXDvJ5X66MjPbBAHFduqVjttXR9yOKskcite6OSDcQjCx1SlncC2dID86skVkUyLuIIrzJXoINy8pEuO4QC2IPDM+twvbAB4bTsMHFYUNs63QL175o2XxN9QxpMZuCd/WnMjK9XjX8feV3GfD+uNoR3H5Z//fQ8Url4l+xl/Idj9sY48S2HFKeJbiDphVhkcNFMAHOxrFLCV9fLW6u0TKb4LSaSlGZWsAe48DPbq17j0/nuBPbyK+4YvDVMQKYF27SwI/bgTL9bKIgg8cpIfRQDAPlnh1WU4xxLKo+8YGqmJef4JVBwEsfDM1ry7le8LGqaCTQhexi7Q/jI5HCrJ2UvQt+/4u3lZeBp6TIDEDBwGnX9McWT6Gi2kWZgu21TzNSclu9E68sY9HIhfshYFi8671r1rFICD2vmeJxGdn/97kWdbMKbe/4F5A31B67IvzNrH0IrUfqQFakI88KwtoUuLep5UsZZVDY8LG6xrLFPVW/V6NyvOhA1XLbgaz6EnNVNH/F1kEeYbCM2o32PeeXugQLMbFh6u/y17JZPgklJfGSD9TymdO58ZUVDBTwofDIUsQ9rRL4HLxs/3ztDsLnAq6etxz/T8Ti977VOZnO3A55IrUWNqZAOLZGAcIuM76c4KyuSOj5p2wnuGdocCVhQShCu2nJdpHaIsohJbH+yZuTwFz5Yqh3iSd/UF3kv54mGFAmHkWGybhtE68km7BPIONh/IE4DTKS5iQILSvvtwc/h/6oygNMZopZBoO/aRAknNdsgPnAJGn6hwF2VHoci6EUbbHj3Y4PlAT3EB3Y4/v0W/y3wZbh3bCF0iRultA76z6eaHGqZU/TubVkTs+WcqfTc+IiWJ7UBqPMFro3quZV7PKL1RehUpvr4+CgTBLiMZZBM8Vc18a1/WQcs98CVaDl7klZbB3dL/tmAN+KFnhbAjC8Tm/13U5hxNtlZGnEx7D9J5uT0VLoqMUj/np6ql8bmeFhaDe9/SCghButphCUVDLO4n6ndjwnA42Mx3uoE0OtOdUk2E+d+e8OeTaeWqfC/uCzoWEGOT46RaNB8CmaEMJWZ5eJ40/R31B3pVtpJsI2WHGRQ1wnnxev2XecXJalpl4zARJzxO+EmaCMupY6SG5kOU9Sg6Njs6q0quXJuddhSInHG2zn2ioD33MaauOEIgr6pTK0K9l0ylj4UYk5myj3FOTX2zVa8S9QU1nYzxeCD5h/zww2LdhkDUJzXJG9e1vqfzPvDkpA+uW9huxZjkFDEQxALpSGdiZYxunCpQ1CJ5S4S/Ks7Oz7yMO3OmZXuMiLcHYpKWlqE6Fm5XyEygQYvLCRrQmDyhPtMh5C/c4DfDMb3pLREMd6MUQ9J/QvY+YcOjr8U8jMwASPc0iihEe5fnnyev3aOq2uy75OJ2pm9WXjbNcIFfy1+ioEu/HzZbYT6y4Lrx8WBAWAdX8HxGZWt6TJU8DASJeNSK3QTj+89Dkj5dqOTS/QufhJs4RDmQhxbhaJEaMC+/QSSBGhhSi9Ge1cSbzXttaqtxSB267nA666CuLs3Us2UCzHsnfWxF4XgX2R1aR6pZTt/cYo5rhAzaR7085gOyDUmqO3zJFI7l1vErERlafnX2CKg9AnR+G14KeHK5FCGgajIcmsrz7XUBYmkSZwptdkIJwlDSLIfOX6h2I/HbrY8TsUCHcNnWCZa6xnNJcIi5XiTXZmOdPSyRSd5EbJpbHpQy+V8d6HtxB82J1K6gzSV63JxqFO6E7bepF2+HngEWAHs92Lj2Mraj+uYSEvJcDLTlacI8LOZU8mk6dBW9/pbOY0Rs1M5P0U3nJ/NFJPwui1Hou3rWrsiPLyCxOaFlNubeZ8sBAI2GiNrVCAgOReMrlG9iDObuRGpSJPeFnYTqzzeZjJkU8r3OedLRdu/JK0xHgp3wc55HrMBCh7rXBfAPsXkpITwZbXLl6/eYIokqxAGQGS2wMyfj55Ii7pely5idn3R6VwVxp5i/sEUjQwcIcoJlX8nZYQv/9GErZhtAf77TDIE18A8fZcOuP9AvOxo3eVuVtjkbmA4gvgt59fJP2dDlpKS781b2umN2W1EkC2CtKYfaCkJ2jQ+aNN+7o8PiPNy9X5az5qUMDPVLY/IQPjfxSZRy8gjLwde/xxBDkt1Htg1tfl9kFiYSIdiRhqlQpSN8uBR6dOJeYW4CjK9o/SsnjGsTtCA+hB2v4MGc72WAEbuuPMAtI1qwUkxsjd6kx8mZcEZwPOFXyzuOoCb+oBFgrleJ2M+N1lpLwjo7Qwahq/x9H9qrZEvZIHMaBgK8pQVP65pFgU6kcMpZy0n/XmPytb/0EAz5zJ43qSVk5aWAIn70EVqvZsxbtPI/cwo6Ea1Ls+SK/PASyccDC7K4FoHWoIqkKmgYk6FIZ3AsHkRCQZ/jYoHTopmhsijsFyGR7S3WXQt5qnLP60unHmXVz8ARQrZJy6YMD+T4+pMRi9NZUzgawNN7uEt6nFMZJBHeArT48wlIWDb8u4CPW/4SbEBH08eebdPyGqs79Yu16qlk4A2Kz901MSswoXKL8/39cp0yAfVMHjhDMjt46Ts1yVq8KZhLs5FHyKs5HFNbUpXR9ILiX863bjIsQZcJur4iNkvpyESck5fyEVtkukXJt1cqb+PZHPj0tv+LpDe2QO5+p3soI5UD4qYPnR1+1L4NdBpdtlcIqR0BFAVPHLxRL6W3LSLQm8qt3sHecFzsyZZ+PVsv4g3s72HT52tfQVb6YcZ6ssSQWoqikqZjNEH7A/I0/LR0pieBC9MN7zX2qO+neYQ0W2hE2y2d5MwWuTydvkwfXRZuCRfLk17OrZYMHJJa9rkTqWbrc17aMCeDnQLe2Ypyjofbhe2DVTlbO4Jpi8N5OSYSWSDkB+JqG1GiSYs24Iab/0Pr0DqAGG5lfSzRN6WoWlD4C1O56OqjBOXXaxJJuOuvsaBDym3n+PCNxgFaDsBHjv4CXwozriQ11eb6wFzXUDP8+zRJ8AdWI9ixORiGsrimhyYiq9T3OeO0XyxwdNY7KcL5kQSHr3L/ArSHNHZeRHrs2YhorqXEb4euXT5dqTBEaqkkhfOYjst5beyrQEr8MOScIxVz1AeO4ko3GU83obdR6t+Kb4Ze4pKTz03v5Ibs4k4zNsY90dgxz4q8QCnpdJJr+3JB2hLcE/7LJlbaCcaOj5eDmEEg8E12dosEk8awz0DnDzXr3aHKmhg0kwP2M8n6/n0xWXYu32ts82duBKh3Fc9Fapun3enDdYFgYfnZ0aeL9qBZUY6FVFJVArJKRU3AwlQRQz19rNjbFgGRU+Dr70Cnw3aTynngBlEzB1tBHOCu9KcOvjDFuoVKQO/DLkXDPg5b2U8vEztMLtBRTB00hQN7S8zgM1ngUncYUdrfzKBh9xKPA0mj0NoLFdV5E77Gt+ug3j8aJYh8Iq3F35qp0h9mcHM9pHkr7wq8ZiuO4q7h6Q4egOKLWa5lbraaC5xIMF5AdmhppIkC4emq8QpiiSJJ7uvkI4073xSiJ9z2hvV9gOCXBbo13l7YDb4zjJCAaZFLfI2ADqIrl/Pch59OyWmGKDfYFuRFkKFWTiB3yXEsJXMlQN1DJmD75IxaF+/N65tFD9XGL5cWIFrD4jk26DLVnXpUEolh/A9J71pyyxNcxJf19Ggn3F62xVykOWz4UZT6fv5uIXn+oKAbJcE3fbPN98TXy4RYMeOFvW5RV+tBTmoDb/H0tJPWIn7oUqHZhjXEUWG0MLvZ99D6MjjG3qmOF4i8/QetfpH5HZzplydY0nmwE9wjtrqQfMLe8yNn+lM/FitgtcekFE5rHV2tMdKNwKEea8UvfPJLAOfb0H4JEzCvP/dTj1H6NyR7lHX3md5ZagOfBi0WkwRA2hRj6PQbjyTjvHaMSK391PQgkIQlemFYN0xGCcG2ji3qudvmqr4OASQQCYgxRYbqVMU6u2tSRybUEF9Et/YDgx4xPSDNXwWpV6fRFmfkJmJEd/hKBj6G9DTYPgyR8JCVo2ARa4HpeAAboFoYWuXun872tgzcAGnyOXGdzly+oinnwK4vX5Da/jWc76udNO4tbZmosx1KSoUyM65IjaHIYNZbM5nKKWKyCko/t0s9uCTV8vuQ4Y6Jmo18W/XaNm1dRnSEQVvoX2fqpcPIeAP/qHArtMT9/gJEkLsTHiU6Rf5K29cePBmyzPC8Xfv2suLGTsySHK7WQDGw75DyW8kB5aZF1TkAYb2LUtpc3IfWRHe1Cm8aeLFFI7ktpgo3G8HngJUp9+wRdtHgQfKxgKrPIIiSpkpnn22W4vdy9Ri2Pd9MhoJEQMwfWW6ODZt/BU3vCZYEp+sb9BZeETlhGPZh4v7MbY2kCXvxOdfJCdp44fklT04UDG+dwzUiW828qHQlNUi3HvePeujfHHQAYVprdCIzIBNljPridwFz4bf+SVNHbUwIFAdnh+Rab0uIwrCZ/I3rcCKZi8Us7tAUPCJA+tNI6GA/z+q0LiUSG6YKkpFN4i5uUTG4hhM4ee0aF2qDsUDBn350KhvgwsOuxLbEq0XZEuM5306UoUVyFG/KK7JyGviO5FJ3HyZ6RZhDUu++2UUy642pveWYXFBA66cKRnebeLnNUT4je0/uL7wr79g2SybgI9jC5L6OOA4tI2k0MEaGNaWjDGcFRgusKxy4SMEWl5YfGKpVweQZEs2RpN/QmUCNgliCBp1ymuT2OtSG/6jHhN3WBU5qMTwQ7Yv02ByqxDkgXx6wcNBXGVUme9zWPUBn8XU9lP/jB2xIAn6z8QvXYd32wsBEUpkthjgAc0QWE3inqB6Ei1bLDrZbGO4/pwTUKfUor5ANkiJY7tTx9ptHjZVMZK54Tv3OqW8zMDTveCmF1PEmm1SbAqoHo5CMVlwF0QBw9bp3YfskwDsoYiZ+MpGLa0J93TNSD9G4WekrIngkc53qR4b2e+RTYcC3/GgqSaLppwE+UGxQMk/lP/ShozbzyIotUHqZEPMGZ/Ab7xcxPdrtHeJJG55yXk6Htvmm9vd7fUL2RM+dKZ+IxU7sdWqgmpal1+ATluo5Y6k/U5qN7rpaggm6glwso0goy1QgL573on4sIdz6UMOpW/edB40b2XUdSmirGcIQ1ZMdbzDetdLsR4K4eyIgJvypimEiZzbBsav6pUTdntyiQw9tr0juGt5oXuZ/p62HxR2e7FH3AXbVIpfHUmaIQ3bBMzYf3cRrrC0XFX5Ekok9nJGUQOqT5Y5lm0WwaeIU8HrjPAa6z65PGR/EUUrsrS5T83xjh8pw6cuFMvlxcUdSoekyX8RaCsZ0N976mTyVPjeYlqHESZVgAncmh4hzCj5gySRiBSkwluxSdNAtJ2SLRVS8GibwVwXycrgQifahDL1wux5R0TJe1xXBTCogxD+10Ct+Vt+V3YhjikBGW9SPsJCxyYKMjE/NkKoNmCRI/4sXPd0pbm/HjH2mrB252Lvsetd4rF5juvyOEtw1G8gVWy61cvDpeSMfWRAFxSDFH7MLarYVcgKDf8egg2PdOoPHtEHm6MdP0C+M6H1pOv1kBFCpUl57zKIzsVjOld5vqnXeIwDwFGRuVCrgMQlxX+vwnsMXN9/JOff5DcWt+1K4NFuQmqyeOi98fDbL0D+/xjdgw4/Gk2KERPWjZcRSFLbmhf0JLvNIbUPGwRT4a37nGx6pRqmjercLJniH0Z1DEiEYnoalElyBXlTPva2i2RTErYYq6fZxg6G77FATrmkwy23tPckjAULo7zRviGwmAVRQoGlYcLK8dTzCm2JAJODJjFf2UsVONLcXzS3/g38GYewQg8vlhf4UkvFNeVBFA6ktVNUkjbN8MpEr37JBJrgYNqkt4bFZYccHiLmrlx5sRMhfQ5bDlO9h3mIKRqZqU955gZQ1NjbSr6DYL79b0HY2Zjln2eQO7lL4Mb+HSvkMH/fHI+M7ac1KqyyHklnIpR5oUToVLhiDQ5XIYHa56GtQQWqzZCu8Mo4aqOJTRnlN7sbIg60QBgZUycuiPjJbCdhTwGTTcSXz9f8im0A5GZEvcpqv6jZ7/vMeY1BRAyQdoTe8rK9Q4TfQ3W63O9M+gxqPjJl/UCMyHMsFoon46tlzg+K9GMJalVaDy0t1337lePG291IuYgdtnDLqzytZL6BH4qi2Hiz7SFnlDg5f4gx5aVdNQkl034VcXDHzuStn0UiXbw3hDkEt8ZoC/RWuS8iCoWwyA8aEyvlwXw8O5cYDwWHBf3A3FmkGfwPgXuJAOz2v7+jJiLAcQkRlTaOkkGNf+kfPk5Hl988DzJLREiMkJYW8yu/CTYkG2r3CDM3W5glmHmLkwrmZTTYb7Pb9hL68dqmKBs6te4pvTAPXMAXukKeqkT/D/v76Sshi5eEQg3eop/cIuKIkxicALNqeKVW6Tq+MD7qVegBxqiMFhqJUtE4eWMTsm9ZBR5USa29UOIIg8DuQjSOHK0fcYwPPWhdjhtRDP8m2c9SwhDoBCaFSvZLGZWvxk5wUOFOOhzMl/HqXkVJUMr/lfKqeJa0C9CdvvIVKEG6jzPyLJ+ROsA9TDAMI67eyhvbGRZNl9D48pBZ4r0Oz0b6Dau02gzFEeRHjNi1CnBs267brjaoudrBX11EK9VOrog6v7VJDBxWdFKDsqJSGxz/Vocr2Xf+If0pG920tbiSTISOOm7N+Lelg7IVxGu0WolwXEH956HUt8oMvkFgOfk9590S2gr6BbaiLOqUs1+wbgnGamb20xCgjyc/iLOBQ8MTN3p2X+iqzN3L+OghjN+SBmjYONgzPGR+eVRBpK4TvV+psb8cznYhbJYPzqaLhUKpj++XmwdeKQiZqlk8TxqgSFDFZsfaXepzlTU1HAjhJgBHLtcIncAyYRXSbg6XQzbNdN0/ZeIjiYc1iJdbP8Ez3HDA27cmQ1XhKxOy7sDeyJQCjTboURnyVw409NUZcujDMOynlhtob2h6Hh0rXWLa4VO4Nq0REGHvWBDVh47mDabp0ZwrQv+QulbNsu1s7nrSspZLP1NoAirvonnC0c1QOxV4b+PzY/yLzKguTQq7Nqr/bROH/PFk49PLwLE9AQzpnCQzEEkehXe2ZXzVbrTEjvOCP2fV2M2i3ZdS3rTv/lSMaot5oxAziPKVR5XKgFBSFUpBe/AV95czxuJBX3AMpcgGEmD/oiPCPCEip5wetSafah2sFa+cF3y6HHPxlEkPWfo14/mf305JsuC7egVm831eXOhxwds2dCU/NTNPEUsiiPwEa6wOJmga1SzM9XQ0ZSwJ3i52Gwi6WiJMhzXsn855IWTHKgnqSvoHQbj87c+9fumpg5Vme3M7gALu8vVmmEh3KszsaafZeP2Cv802KJOeXaU4se3o9CKxYDsi2FOPXbZY2+BWtEN48LB9CobhNhEq3PhCdZRCrgWxS/Jh4UC1lzhfPTWhX7Qs/M6QUBP/kpme160Zs8POqeTcwT4NemD3VvyqPSrsiBZVKSSuCq5PKT22Xton0kYl7QNVgR2c07In33eM5jlaocileR45ec5NmpQpzyIZzEqVnkgbvcssBqoZzVhChPLeja3obQZYUAfc8IdzTtEg9UYccP1Cq8TxKX2fcYen7tqaUrKfcb5cuW/+gOxwuQW8giiHboKwumUCdCg13y6DSJdHAPKHVZHMZ53XJiGk74FR2Bwcipz0NBPkHxIWAeRZSKTUI93emaZJeLDXYd73JK9zemgYjLmZvMdW6Tl7kLyjVmaq3xLBs5PBHePvboQOYI7CYeO0uY7wQt5c4xzaFu1jUQFH9wBWgbpUz3CoIUUjT01TNVcZoK9y0mwJKCU4PaH6B8FydzwzapEKQTK4alNIaZO1NVkoCjk6rSgfTQcl6HVsF9V2ScEoCWUSOcDpb2yndX2y1EMzmkDDGubaedG9xRiujkjRNyBKUjppbz0pxZIIOs1sNoof5qCip54XQYf7VfgVT/bzQz52ycm1ooduFzgP0vvt92T1aZIh3FgisScPldzU05DR3E3vx0NpyBMPu+AbVDxEyDKdOXxDQDVJgTqUKPSNufNT08hdGvd+iOHFUkbG6iltrVzNFgo2z06EYkU5G2gnTA7eCsA4jC4HnRJGZQpINtCAsfvTM+2t1MYiMCBhnt85w/Jkwq4rvpgZL1yrsClj+oGhXdl2PVnjJkMzauM4WovjNRsoEk9duErseUZGFVkNKwbuq1tEWKgB5Qj8pwI6ng7c8iiFkDA8NlXOjJo+rsGbY2abk1AkFulEfkTXY8JKE9hW0DEcI/zF84BrYhCYYW3kFw3xohv2joUrYTyeeik6YkopmIsbS+fluMfR3YBjK9fl80+P7qBgnKOv/mSZpoeELZkOEkInWGs9yMaBSm0/YNniBEvvnOaWX9oaihB7DUDXXtIaAgDPJbmp90OhbjPQocZanJQwsueiJgL7+RM7TirtouZPNZBslVlDumRO6fa+uj/WQIyXg74iMN8spG3FLnvexiRoMTymMwfrBXzaLgLpYrGvAIiTFjzav++7vYP2G5SqtpyYv8dIWMfkD7b0a4FE9rfbQeNjfo+i3osyBeXkeNcIew/UuMwMghn5zqXWyE6KoXaTxaGo24q85+0BxKVp+4/LqpmNHM3Xup55Glw5VrBgfxtQm72JUALwsvOv+tsJNxITgF4B2dfm2jOXyDPWtfny9JpG2z0k2E5LwtkGqOYObG+ivxImWGvw73oTyYCw3PTyO3/G+iaQt3E1ftV69H5EDi8yPqIinF7AgW15pZo+MEWncyrZNcAxM7LSZRpomvlLOHmEntRExNJ6XEF3aCz8+ynAl9LC5GSC1KaekGpnY5WmMLc6+73RdF6y2/YR7lzCEslhHpvBHV1+h5lwXmTqm9pqJt6UG+3YSJ7MJXO2aEnnFkE65bh8LXmLeWFp5LcOf0ze7eYfBq/Zj4CBPIzjULo3f+VuaBTzOGTZKljHNSLpXGMCJJL2g0giB0Pzsrp2iyJqE5ELPfFwOfQm0/lDVwHhQL76DrEMLZb2HYO+JL5P0Fikdr+32jCyTueXFHdvSQX1EgNTrYbkzZwnD8DrZSr8v2Agkrrpq5eFRC0tKOiIfu9mZoyHtkEua8weoOM8Y8dNgwJdGOp4shPl0Lye1VsitII4Q/wSFzGYDuWD7G4Z0ws3JKFAf/XJyeRlV78JYweZFhIi5A7odLR17uPyp9t92gWnNle6Dr67iDI75kpzIc6hQ6dlkIpX3f78Rj3Bcm+W3HI9/XeRQqCTzdhORjpS62oEO0q590+u4fmYU8b9w703NRqlurepCdLzaTTeYyhMxA32xJA41vRRJL73hIpNkB4JmObIE7xMpxLQhC44D/OsV0iNYSZBEhOaBq2VG7dCXViUNYglDOofrSLFJG2I5lkZSmnXbDq3AemZJrMXW8RM4TA/UIAdS9NDVZX5SjA1tWDCA2XR9W6pkAQcjFe1CS+L5Dw+1AZmEBIQnSHueKdZLygaCgal5GEFELdNjaEFUoGcccevrERN8yNR5nVLS+Ilcs68UHgNDFJY5tZ1ZpGsVYxW1wG18U8kOj/ju9GZzxUOX727Z8+VT/Z9Pz5hE7+GCinaMBEhKDaV6WdKf/pIt1+KBlA5tA54EkKPOvPvpbS6UYtfUMeEXiDKhxEW9xfrbu0oY+d/aQvXATwKiiV+RYFn5WJ/kz/HLRmnD9PrKo9OqBYJ97WT8+0z0NU/GDQkmzuiftnbyMprjqiltF489RPE9EtybggW3B9kge7OJP6S+l41gm7PMgrS+Y6dDCzXDhHDUA7e2jzc5wf1/b2eSpRen4jNcEXbG8hgXynYihD6Hyzg307DdHC8LdW6AMmAxx6E8Py8Q67QENua0gAtcLsZpmgCyppexSrHktzOSU7Z/Pu+oz/EdImnSIgJTc33V//iZobvs/O3tqtEYdwrpdJinrrwSQHq7UUmWSfcgogC/nr1wp0HRmXJUIqSFRROmCEpf+bS/KHm21TDWe2voEAl/BgcEQ7l/aAvMPpSctmGBCkpIYmIEr9z2VqVeglEw7oWYH4cF8s+NFHyGRlWvlQtM+bA9rGRYDxulapzcQcQCGfgxrsyerI5tEr1Fj8RYanjDtuLRHb6eHgSn/gbvwFl7hqF8gBU3pgO5LaxJvJQPqQK7znHFOgsj74uQwSUVrVtcKltQbGb8Ds6GGxvsxy2k0rruqVUrOK6SBDeFKnEjK+SbrOL7zJgReQ0eV0rYqXMG1PHgLI1D6aY4zgJdPltioUU7kXEHM3V0EhanMTqSpRV2Zva5+QjoepyK+d02v7yhquAtFNDZYoCjmYrRubw4KeMhMaE56hAUJfNQmuDu868BxwyxPgeqnBiEF6HQZrrBkJqy+3zT7aNd2UwPSNu+4a8RAN4KSQRlZKGdG3Z5K20hEhSB5GhjIlunW0mQkfhF3gqmVi/bIb/1DdEPFhbYpqUH2aWdcUQqVBec2oR5Eeha2GbvOwOSl9tOA0GizmThp5GwAEyJwRXYLwBnq+17KSLUb6ayXYvuMWv3bgGrQY8ix0CyxIEWQcfAgz5PuZEfY9iuVm2CJyFnCHCKyaOrUlQR400fZNCWBSpXk97grMg+E1QI7IReltUl2ED6YHX9K8QWM0V3vglcntUS9DFP6/C+4d8Y1qoavSOpNpMpG3H8APk9MPK2h4S3q9TTt+srbg6cWInvgjbusgfHGvprrv3lQSPyDhDt0AC6Q6t4bLhJTgncWWtaf0iNYAYChiRh+CMMtkDW3UvTlcRolTjlPFWZOfQ9lFRQ0UYly2E7cSFhGtroDoW+feoKy2R8Ru2XfWeKVBiae74MAonRI6JcA7Op1T5CIbe8h5v7IIfBSsKOWpVYi1/Q8En8d8hAKoT4oNLAGE1K2JyjNg2E8Q+D0YcE2FitTZh+sJ58g8/mgFoa0hkP0JKp7aXgcJQ9bHrxk8jhNGxKXwyiIo4cEV0IiL6LHqYRcNumoOzz29LvUdhmFnwPgR2C7v58oqRo/q9QSTkmfUs9BjnkOvRZAhxHf2sq5FJlZvp1aiPxlKUEBLtngH5naFic+GkMhbXQ+owhDxOzXnOWz7eV5JAd+RWhqNC6LWTn2rnt4y7WrkvtBEbShl/v5gX1D4b91eSG6hfqbr/PRMVzG87Cz17jALDQVDBX+Y9ngO/f6KeqztUSb+igQxLjeYoQLz/UmHsO7YLIRNDz56yOhTRG+RJWOwhBTb3NOiYYexgZJorGIryO0MzS5q00ByiZXHE1MOsRMgtOQ2fVJlfSzrI3lKjas8B0NXdikh30HH/CTa+7leuww1gqesEUFU6d/3WOoB6KtHPbkL+/pcrDDfA2+QEzcqJS14HWyi64eFq1hTshumdSJ0KE5p9xob7EffdserrSI7fR7+41YeqMDVQsVImEbD9rCreRtXO250T+zS9hRLj9F1D9Rcr6IRnpy5LacwhDRJ8QfhHox4l0hHoVEYFSuLkfYfNaavsigsblCmNJ2KEZY+6g27RdnP8lQJk+WJskLaWlyvfnzuPxxSEW9MxAubwe++9AqkXFl6zT9W4cbXlYxnvv9W7lm877nkbtFZMKf8DmBsxF7/QEE09je9TDhkQAIMZKyExJIi9RNJBaJ+FkLngdIzxljtLCLyArX8S+VdLb5ghtDxm33IY+URbC3Y6/rNQYTGFyhbZnOfbl0pkF4G9yg5uIMGd5WI1Sech0POu5Zx2m90FKDyiq1EVXEpbkrwKeoqDeU6awDSAdXSkEpU27iD2vgFTS6qXnWoU1rJSS3JWVqBg0NvQHc3G/OWVowu92sYiM987JAUMXQE8NypBBdW8Hoio2cDQVxsiehNBBQDpAGo8PDInt9OER97BvrlMHcZBxtcwcEiwxxaPSR6D5teqAenuFMOwQsQGOTVIvMj3b1mw7E2b1xux8Kxnj+Uqj2NYAfh1Lwt0QI7yiBnjWs1FqFFtHe6skPANfC1FzXQ6RlRb9uSJSYOzk2P5eZTJAfsclpv5ahyWwkwc2ZwFbnGR5sdxY7BR//WjZc5kMNZx5Ye04AET3lJdW0CVEYg+YbSOg84YnwooIwYqCoFIcHp/BmIXZ3F9bSEarPNi3MFZWfMHKcvWJorE5d6j42Evd8mW6NC2gxiFw7ycdAGcmRH32We5xDkp3L15XlwP15/S08Rk5qIb80caeXzDzCekOHzihHsksz6iQB8FsWpRh9CXawKs+fzzzhrtjAZG+MHkXO1fcaGvmI4c2KEanzvga6FTiso8gQlKyVbtyKrbzSbPFKXZ0QkUwfhjGBC/dV51cib8hDC3bqh6iMh2A5rfCbnS57pSF+F3rXhdsaxmWq1ax5dLnMqlQ2Ugz5YxY6mwNtKN19xbYpVzVosYDREWHfVcH8MT2qwPMAow5nXyRatQRyBi8j55jGwY23PlBK8D9nsepL3li1j0w+crVYzUDZ5hBPCWfvl0RzHwAAgG7MwfCXBJVb6on/qFOG5X3scwZTtlxNYn09NGhtDwcial6zZvhTODGICRVGJ+NvzFOJRUvpv7sdBtyM9D4Z+v6NXbD7xYLoYJsaJxTbW0hmi3LO+7TwVjSzsQix8N2+pGc0cKktwHHXt4wrgV06wGQ9GodluDsHwMoLChl+42UTsirDcGJlURELFORDirjYk7swCVJzkmZEkI5XrHRJlcDT3V/bDfa2y/m4sVBtT4FH2R347kOQlT7BXTTLFZuzSm9XSpYI7Lf0oh69DW2qov8t9XS/RJ09IokfTr2AXhrJhlRlPqy9hGZjRaRuR5wZKHjxsoyM6ByccfqpJ/ttVHygyROdBcDeWd9fkJ7MvvrUNN3NLYI2QX4j7uvLeuCa75tQYV53FMJx6hAOmOzjUqjaYaNdaWyG0s/Adisoq+lZq3J3Ev8xtlfo/WIhVAP70YX44zBTXnPJTjR0c4E+CwERsPg/zUdRNyEDs2T2WwNVZQQXi9+vVYnJ4nRgbhiodNHZJjeh2cmtcjhcMcEMgzatddO4VpZNE0lOkE9WiK7/8JQ+nyu5V9HLLg4n74LgNLynGx64OV99rvuRBbLt+O3Mz29etAe1aHnKyz9RRUaYYGueaP+8sFP41/4SytbmS438dTiFl0UDOhKWaxa7nyz4TK0lINX0JUb4RljWGmsQArV4CsX2K8wWcPAfg25/S4TbzuQlLAHcEwkXnUnppMkjfFYBXx9bHIlRGBdiovEujizXRTe6lJlTvlSgSAjipA9n3cxU5+Z7/K3xGpC3jeh7eEFb7TMKU+mDgaiqNsSygEdaKv1/dmFlQUpYUeaJp0ygQiEg9ixJS/LqyGPBclAy9A/qpH0qUu2m5nz7zMas7KwievXuZ5pTAtXqikGuTKlKVFYwv7dHrm1Kyo4RUkQlj0ZJP5wacUKk2umfO9Iv/ubcJ9Y1wo7sb5v2UqXBKmANJuIX0gWZmmnokJSgUQJxbXRsE30bnpH8TuPQkn9H+/Dy+x1V9Om5EnoG9uqBWD/K/f8oQyON62EzlM+3SPCHezC5SYf+V7vh4J6kncOEcKMn8tYDVtplQT+obPOYEUklCDI0c/j3hFn5D5RSSM/L6TrCsYKB79/UTEBImXHvX2XNrXUQhI0xtKmKv6/xVkSDX/tbdhaI+HtNOlJc7ukdQ5UJu0/MxVZ1OQgkWFMlROicYNoYJoRD483EsIa/IVRNv7zjRlCxWDwy01+gg9GEpn4qWGvvtwFE0EOETVHQBX3vkmGVUDyZDinOZVHEUlf0HN2APcQpb4Tb8R09cafCSlBPQa6CuzRh9+WsHXmnKHMG/poA1Mg3BjOu9Nf0HraV4Gb7Qu3p2/h02QqkQJXyA6XqAUXQn2Pr9SWRAYCNo9zyDMCPc+o/FRKdp7w5u0TtrU93Y8sZuQbo5XFnsUenHA5vcm/h1kNQMNVfMQfE4Hm3DotgIjYzwFI5UTr5w8dHlP0Vwjr9OMlEEHCegZb8YfL/v4RSkUsC983FXMj5Q9EaDT4Eu/F96VnP4dwUrWDJGcBSwHB/9kZj07+XMMcEl2jNDm+Ty8T0obhPV3QBvE7X4mJFQmCRY+QmxHIMGBcH5C0HptcIzTA93yyVeNEdk/o7fpqAgxfOgauDPNKgAmC63Y5lDLXmwW+zofRspSp9dlCORkzZSqT5bQK2kY3zcVOVfpD+N1pPjq/FWsFUBHNXtGi9/t/jZO+1MIXc4rErrRLBsFWxBd72397KRq47B9BSp/UNLOUwRVC2BpYAnKeXfTgI+SIjcsa14HpESSjxVhLhz3z0S/Uzh/xbM9/pdGZYUEXzmWhmg+zJ8RLTQ/5nB9iaNMuLU67WwptB2I/uc3JVMK562BUk5nJcmihZXvSxoXKSlM9yUNjfvpC+rgbWZRGrEt95gPAYsid417eRhhHeCfOT8Re+K1D0EUNnfxsazj3iLAsM19Pn1cQ5ohe0kfPocoNobA42X4y6HzJZAcLlmRuXfR11WsPejZjIWzUq86j2/qzAiEUe7ZalcNV1lud4B8jdrHqTFAPKi1xbWp9yEw8wYMr83H8/dm7zdpRXR2S32ZBctPT5nkcbFb6XexvD65HhhmeKYLtWI0IC2Y9xKQi4xr0k9C/46kS83hvU9JfWaMds9evE617oBFf+bfaG10Z/OMzfJZ0HxwxtBmmd2RVG/Cdt3j19zSttLvinMKkcToGd2R7DAt58jsBQK7dRa6aScVcEK6+E4iEh3ZRIMMSJbMBLchqtTPP/iutmR3b9fRxu9F6aDeY0Q65ZcLLgb+wSWWIrgPLRyMNrTtuEbkNugE+YEwZuOXePh2bNPuW60PYtVphwjSqQ6o3C4DmuV9FBQia/UUpJYrDQBF7iIhDGXip2YsoBygk+2SmhDh0qgK2tpGLbH2dl5VPX3GwClPpDHo35XsH0c9VoKLzDS6U89ZQKzJnDGs3j6YIxMPRAG1+37hVjWm6Hq2rjK8POSpBjhDIR1AeFXnNNSS9KT6Iz92M3mVhe13NrF/r3gqYkeX09qW80Ry05e9F1+kIVzrg2xrqGjZQxVMoC3duPdNEkXwTEJRGjCE4PQb4oXPw2tLXOlZvnsk0cpPSdwYpMasl0YzHO1XAw/hvWjinMuRPudMcE6WK/boRRs+L01UPUr78RAK/5pDhR4YPtw/pgRqR/PYIgR+ZlYNL8gEMoMR/UTCC1novAhsOXL92srbH8W3zYBDRD2suaQeVQ1S3ZAxT1/qF8YNeL65eUhBz9VOfR5REbcJOv07YHWhhUow0nxq+VH24aQvdVRLwVcVrX+NcAgg4vbIgoarRfI6c9Ud2OGzXDnF5WEPNkkgpC3wZG8XFVCWYgagwvtujN9cscb3WcVWqpdguspCcyt2qJNC93WkYMY1Pq/cRp61qKgjpVKWJxuKcApccCjdR8s6pXUL7ZEaH50VHm5H0xQKD0HATF+oZdOnEGsWNI5HiMyjJc7g1BaPR/ODVrXAsKiCS2gcrCd3fLVMQxl0u0MMn262wNCYhs6+RE/hKpUmKZSnnF1JyN119SYG9fjvUNaS0IVFd8y7bR//xrNusBnhN+Ma+83xJwezX6E5dvburomCys6CsbQfvxoQ3XgCjGefBf4Dm8B3fS/D+Ug4ra+/gA0DpQF+NUaQFELZUo/7o+O4C3tfzXFgFpQpme4Mu/Vg3BqJ9q50/zXMRrllErL7CHguRwK9ckIfl2cNP1wAG514mfwqdldJXKuNWb6yro2g4AK5Lld615f28tPvXVVR9s9LuQ0Yp/Tekhcoe1/GsvV06COOfvFCGAeP/YK/n/fDqn2/n7C9DIZEvrGRLOLNO5/3sTCThDa2RkTJMGz2F4GGj3GrME7ZrN/fYLyXpp8qkXfttnaMAgfU3eKmlcNC87RhPJpIddYYAh//MIZxsPiq/4TcJAJ4bU5VtXQ0HlpNQlag8J1+NRbtMEisRzNbhzWA4aHJGelT1OKAgzE8pRxT7jT5KcUkmI7qR05XQ0Hb6F2b5OcyBZXQ8tIDFsD+d/8oLoq+yx6FytGjchxbAay6wLGaluYcQVXR2UBu+vcv5qd4HO5gd8bEJA4nJfMcLGJePAeqanxLDFbM/mPYaCovr8fgCvfLYcn18aX56rkRM2bvJbF00oZTpZVj+/+/rXPR+qC/UZNBlH77LRU8NN19n3rb4cnuGAwKGfILx1Mz3apH6TwwB93mOXlSmU1lo9W88sfbv0TekSVx7er6vTw0v4OucJR7o6cCHu9V0pk+JUglz6mxU+J/3c53aQqSNeQ1d4nqPjvZ9sB84Yr2EZbAOTFbom1gfZKXG7d6etCc2EBj5J03irlyP3lKXu2ddJ2M+vSiHhGCmwZdRb4bQ8+gF31spW4DnnYr4JR61IZTjmrGZK4rBYDWgVm6w4qrryL1G+xTorJMOFgI5N7Tsc/277mcHZKi49fgtkCWDEzNQ3zPIv1E3zUe3JnHGseBLc270Z98Jx7GtsT2jIajU+iS4qEbzFiFsuUnqFdyGNb83E4cze4gzoXN7eTJp56WWncf7kPFfGDP2sbjGrsAY4naTZiJl2RN2Q/Y/fj6pe30cVaM5w1N96usW7eCMPHBR1RZjz4TH6a9yyJOzaVuCYYqSR1u32PBFGTG4IiVKyrjRNkmi2SemuBK1vz1pZHg3nyp/Ux9Rqghz3P/oKuZx7pEO3kOLvI6oaO3VQan8WBwdQeQ35LbOZUeoO436ftgoRI0oQQ+AaaR0MVzDIYINepnKSkxAXQ4ke/DBoQYsmbmbtno/v0d5QU2vfdIj80WHAjyRh6geV9s6D5WJZ93Z/SJtUndKvRDdQbekqsR5l6OS9wYAbLXSb8CR7SGVQFI+FzxUDqh0MQai9WVQ7OaXb02lfyRV54iAKZaFZT3sp0ddmxZBMkSIHNd+pmI5WZ/BKVwIgP+iIcLidCHlb195yTLRDO0BGAMwnTtAe1NY+5PA6qxuXdkdx8cPxDBYMak26pl9vbGRxCdfUtuNEdDF6RmTxEabbFc6fNRIBJ9xLeSrqD21SvwyjyCIAKdGZKVvZL5K0HbxI+ZCUs8k7leR51LzdPdN7a/YeCX5BpOdRDJDMpdeaV76HG2pPTTwNW7tP8bYQyc4Fvlk8kHILwGjGP601qXlbAjvRw9TzhUIu1oBVlVQNWxdOl3owFmWxTZjU9gKlCm5Fs4Cl/BQ5NYFsVnuZEPAcQ8gPh8A+Z1R2FH5TmlHPHC8LSzHwMdvGBwFNVEYmVh8i9JJeGMy+NOFAwOlLCFOFcuEDVjMU8fEe7E8Esmc7B6QspDaDPEMiANOdn+wz9wO8T8NlZFOLyfy960D3W8o0L1g6FgZ669MjTJo8RyPP94kFRgeHaCy6mo71ipixT1vKqi9FeXIMn6GG75S1aOsqCgGL1Bh8ctWvRDn/tqutZIiAaukX6xEg8uGUAFRf6GPelCdv0ZDjY0ZammL4d7PenfBO9Stu5op3OLViL5FO9cS055qVKI8uU1OTQ1P04cn/y98mr4li5QJnl42CrAIk2dIr6JQJhthvX4wdNdSQTyiHmJAw1owOxrNemXlndGoofraYkvJYqZCLeZKTD0cet6lUWpYmCVEN3LqcT4jZA5jMOOpFBwv0FMsYApQ3XxqreziORWQNurx+OGK1lzMuGhufJ9uF9DrKFnsBOrGpqVdrPxRUZHKpl6D1VV3JbVElBDzHvatAq4g9QietsVPa/RWQKnHTN02r/OMxezp4qRq+gBo6+MK1QHx58DLsf/ww0IrBVPJXz4xeBbCze6yrYfDpYAPoAkYXhSCG6ygAjTnAkEhbcS72UVfZPnCGitWsY5+mgclvVrdwZx35jy/00uLMwezQhls+6LKulbzmD/tA9SekbjOM1mhbxzvZvhlbbEpn1ZSmLvN1NHGTs+bvBkuJA3i8dijVMh7Vf3wN0Dj6xSS35DBQrVCZDLd8SKXj9RtvvavuTHkmpKUVOPgjr0wLwP8iDG/uzwDeJ1typvWy7hdDx/PDGOKEp348xpG02KusOPK47JLFA90JtdZCc9GekM+MjexYtmeLj4JUvaEeyENF4uPznuzSA1p48qCgyKqFna+i4WjAadVR3WVGx7JSItw1fRxnF6h7Bfyitu1VrgV/ACzFMMEM9eSZNDgdsrTA17wmA8/psujhXzxQSx2K2q22UMxvkKgVb6e/dlBvmqu/lHhYL2wNWfyV87yd9p74AHqY659NC7jxwIKPl9HjZyxacMQi+m3rwo4FsNZbXcxKhdKRALADNRhyzcD/VRBoa8Ug2mIkuqG7UL5W+MIY9ghHBnaJLrGb/l4ehk1xc5FSdjri3Idmjlk9Eiu32BUlrSHFVIqzadZPslCIk2zF133ui7LBJ5hV9By6ptHhJgUrmgxHJo7I3CgznDcTiGrRfW1yf2YfHaLudqBJn1Ky6BECemerY2cYygU22mYk4koYCZTKdh8aJU+/ApaDDtGg+iKAuyOYN5bLQGSxm598/XTC1/Crtu+alIs99B1vGwDIdIWkKGZNooEiaMr/6g90iGG/YIK2AKYupCExyZuDy14Iy/tjt/2GHrRKpihvnAQS1V5JKCKXyKhfUDCVIZhD0sy/HGJGlvOpB+7pTZWqmOdR2U+Fl7zVcjds9aEWOqrlA0yCVTdXPC7Y8K3ABk4NOn66scEmM3dh0EyibdMdGCgYWs94D/OgA69a6kwzTivIrpGCi/H2eASjZL19nyBC/g7hseUIG91n8ceLkLWNicaLQXusPq6V2PAuLpFzZGaFeJ+uDumchQ2E83juC4EpfEjoKwt2/dc6EK+3jtw3Xa94CY7IrauzUM7aOyHLzZKTB2LspwVfRxvGVdtxqs6y98SnllyC/5asJXW/5COrW/XV8QkSjSiIkrWimTThdQMykNQTAxFBO/O8ePZn4tnfFLXfn+LvMFZcuyyDoSyuCpjVcjXSY1z8LTY57wX/TM8cf0q4hzKhMdjNHU9wxQW/rvSIUq8ST8TWZp0885O0tkmU9C6q0z35zu0qGSsGJluTa6PyvYF3TaMVyfcYdbJXr/RgKdwpimQoW+l+4chSRIEL1CUNN4W3iW/+HaYMuMAJuLCkIYutCmWMETATAskCVdlKjj+KamCtO5z3OOgLbkeey7TmmexrSOAuc34rBLEykY50PakGLUPOQ/0sHkdU3P4GD9BKleIv0rQV72KZ5WMiNq5cvc+soORAZ8ibUWYiS1tBAT0LZZR2I6mShOR1pJmbBX6je6XOZV/d98zM2avhpoNFKlsSU1NU3tN8xYeK/hmlEfzVEiwOfL3E0qM640cj0hrbebf4JIwbfzc5coy1Xl6GQSApQ/ejfsARukcrFbzt+PNa5YOsD1BzaP+xKdWEzc6FYgb8ZT/wv1RzIwVX+J/EThyR1p5aBfQbpW5SdPLb/2gHo+408Qcw2JpJ53aT28+28XJdbRaNSQ+4/h69CWBoD+IxM/Uad/KPPsj8CUd7tU53BYnSDMdQY1pRwe1f7iN7LMwhWss2DtdEM6lkHs3l+Dl/7YRCZVI2T3pxFH9VpHn1TI8CbJPiI03rBN2hhNH9oPpijXmeOnb5NW+pVrcvH/eLFtBJqnx9S4ifOOLZxZSSUpTWZBiulSTuZyLXkNFXR+n4Q9W2eIIsIb7ReX9WPB3hDgpL4JiWnQ1NEeZNOQyg38e20quXIT4mPiYEXSzpqWeDNJb5od1to1XSZUFtxMBX6UtNDF1rr2+cBUtxDgb7Aft/xbTXftDBqWVEkExpKWWRU06IHiS1Viktw4XFCxQ0V232oDkHRQQBseE1MEBQ6p6G7CQyOIuuymcb+5lExCqcChqVzZzlmZVkYmpV9wI0jT36c6g/wNPzSE29yRpnkHzFScivXxAIpvuamjLWhIqGSWOoQV5Qit2KXPbhYPm8/Y+njtvbpnQmcOkO6dbY3vHsld/d0e29uK6DFID+NqryOX71V2czHvSli+FHCYW7d9k4ZoAKqJJUIrNniI1A9Ca/nQ8xiXA/DlxSvQ7W/i8AYJ65wAItRFHZ0/NJVFeLPRcLvpds9jrecB7c4CLSUoG4WySed002waZwKuXaDFIvWad5KE/IeNAeLFPGQOoUtQMTL5GeSDFJExH6nxIOQ6VqPq0dXEoz4OP9LZhhWjELSuL/hZT7WER+tTbIEbio5T9A1J6imkHlA5pnljLFhNmkqsm9Q71FP/aAjDlz13bIxPmQk4rBg/ivB1p0EPtFRgnKAO/+K30NeCNdMIkV3XCTKFs66uWfTePuG5DzSyxgE1ougJWteU2b87fhP4008rWHAGjREI641a1DE3VXXf65/m8gzvRAhztxyWiX4k5LQk630SokgU48Y/elGYZKSFM5nmbNpvH6vwHsHWOe+XOeK5HqBSagdHUGshVJ0MdVhYxw0f4rTnXKZ7NlOUPHrejiJ0jQRuD3edEvcMg/LnXsGEQkj3QqgStTRvQiRQB4BIO60HFZPIwlEIUMomLorWed/fBIQQKP+9HknFc4N56a95Zm7lAYAgwgAH59c1KPVFv4jLmT21gadxvtK4I4Twy+WVNWvSd7D/XWrrtbnQJd5LOyHEt7yId1I6WTCqDu0l4sEYbiitiw1UiCToymVku7buqbuH2bkxSOMqkX5ZY/7JmYS+VzT9yE5R2vmH97jeSOQNgKSmzzbYrLgvzp8OxET4bQXShxBNj9Y4lrXITbaoV44Brm5OGLILNpPoTr8Sk77bb6+Vpv0r3fwVd1JaIqHBP7mOpZcrYBrfefdhasMVKbEPDY7QvxkN0c7uwYJpyKWCHoUkvQyJzHYrmLU5O7iSNDACXmkRYasVJfcFlYgIRaa678tw8C4MlBiRJhiZAf8YwdUVYZKtPTxgo9LBrFOsWLX68K8O5XhOB32QIRoGtmIuXZcQr7RdShBR1SolCO20EvGpA5mNOwZxte6jkcIbWVRuiFfF/WmdpnNAFuPayt7lojhCK39jYEs/WEyATqipP7ANC61m/H3KrYrn0FVtXLj/6dH3iQM1xEhmz0m37fiPlgI7yBjRtuR6MwIQONm0kKZeJ0P/9ZG+z+dyE/3HD247SQw83PxCHvxLXns7OuhZ3AID8E+S39txY8DTYJBsDTkVRmzVUj/vezlpGtglRDgzxcmHMPPPHpGq6hx14yoNCMteZ0d64NCBFZyjFpXzL9siAR+p7S1z9Abdz46cUSbTkU2aCX5t6GFfKWqBN2DPmEXe+AN4rS39tGIR6v08DJEP5Ns1PqTmBsr9aCkAR+RKvRXxvQsGpxNVfYfbY6ndnaClXgxNNTsSxWcK4870Au29kwBd0h7iojrBp72zRT8RMb1E5FV0SJ5aecXkY8zpWF/pOWNHMRuzsbIGdxSnPjLKKES28BsMZP7f0ig3s0M9bswsbeH4d075P3O8ei3qi9+rH/aEnjLEPmmrxFJT19mLUowGrmKKp/kHYCLRer8aoVBnHiJBkB/A3099h+laKG9x6rmIw/AbxxemXtXM5U3GrEKWD0D4zdLfBVly62uETXrM4Ft/7OAzjoLVNh4bZoBDI1qYQmqrlfxK4DKvfNB+HuQs6C5Ey4W4NZoo9yDfNRMAnIT675x1/X+xhNrQQEQ9UQQJYEU1NaU+pgCMWc0MlYATXTp77WyZWp1kxKApRcXZtcvf1tmLQJrrf8232LeaplTXt7B9bqFEeF1juJOyP/UVDDZkOSN+OJusEnWXJHcTX5b4E+RzABZ98PMAmB9WTwhie5UTcV8vqx61rKsLywA9F10OAkor9vD/04dfriv5IMqGbb+PRe+5xj0ClKiorovRDcb/TiE+SDF1qpdwvlwPHAn2tKpCGtfnb5rFQNG4lZHiTAI0rW3ql0SGYsN80hwYvznmW/apEZWKcB5ALBBTBx/GQuLO5d9qL37ePC1H7FwixgrKFbmGUqdKkYvTKfJKwnCXIggc03Gl8LQmi4RQHDoBEE0H6gWeDg+6EaWtVXY5ct/axXgVsBVP0PT5dB4j2r6/ne2EsigFlZdhIg7gWoCg0RvHQ+KeAmOQjBDhTJ3P6TSDZMfSCSmj2qQpWI1SzeTrXFoQKyXK+lEuUrh87L03EHb84FbC6omEW0A6/9l+RvB4YGuK6Hl8fAxlPsMu7uuo7QUNrnEtQJfffVAPoeRXHnYCiYf22BtxhH+PxPo1u8gNcIpfdc2XxU32vHNnNrdeJZwYNWZj9Tm7NCMVIwFWclhook45/1Rb6J/lV27cpAYm2bQYEcsZy+y2xjdj2BF7FSet7CTMu20fx4BscXqgzoQFwjIj1ZbqV4z9PmmGwJbnkTk7QotfBM4rB+3nlJtlEGmQtzSxeHvYFjOT6gpQ1DtayuZfr1SMeW6aITFjXerOqU5Bh5JniP8VYRGNs2Yv8DZsv8WxrJn7p6903AvAZW77gE8C4nEC5XmvNJvCA2muF9m0QdnlGkfb7lhGTBKP7QQfpfVlr8H9zzbPG6MNNyaV7W9FQEFGzHi3NMWQr6m6Qj+9JA7Y/Vf5633pVPb6v9jc0CFsZNfIQsZt33p9E/VhUtcyuc/mZsvnz3SzGr2JCDY3kpGdPpucGsbkZpu8Pe9Lh2KaUmb86dWmsTErtT4mxj5qltajq7PNyiA0h+LDbCKRz043blGvJDFQhViV3yDwegXKVLpw31PMY6G5vvkYCqPytOPidlihbdtOuO5yA8hH0oRpuLcFRmpNUtqWP1jXP//HmaPSqnWTD/9faSJetlZXstf51D6owZ9m5CJUvMiuc//k1vqdA1NUjW/x6riar9+oBBMZWZipXlujIUkpSgOJoZLphjVeGMcjtiYNv6/1ePwYS9tA7xp/QXvHyFke+eJ/uF4BvDq29pFFYBV/A9qML3kqFjlkZS/ayAM7OmfEVpTySrZrsy3MSWmHV2y41SeaCtd9T1B1ei3CNNfZzqOuf/5vsCuB1OOVQKK931ZEXHp59CfcvGbG7RcY+lydwGRoNmE2AO9usPvHLxtjkAUrBtjD9uLEU2sS1y4ctp9EhDnJw91/T4xLKAM8otpc5+2tWbxIBqok3GZKcENJkXV4y8Xib74fbgpMmtCsbgl+GDFyao+wht6HOyZAgcloBbFxN/CQWIk3f8h2BdUX8U4jqbtwxfBm+SWFYClQf8Wz0OayMf+TNWAwVPSxrlO8ZEpL45bwXdIqotJs/QszH063mmdYOARSxxi3oebIaTP3b5y/vLR2T4/HdqFUjy44wn05mEOwmp+bp0eXrQaqPzSUdda3EwNypZ4gWtK7MVXDvsqQCT6MQ1TzNzqUDWVNm4vdph527GDHEzsW6zd3B7C21hXNgJd5kFyvAwJto71KmQGXsMlQWuvy8HBYO922lKtVRUCjmNGt6dFghnsvGxkbYqvlS48wg/XFMYlr6Ceqb/tRXmvDIuNw/htSiUVdNfchouNLKLhvPRdDUV42VOHG9APpEpMMmr/AEb8+OAflV+1UI/9Hyo9E9C3cyueYZ8LFGUItmL+sRaWeYZPaZISeNW1BN5JcdbInEuF3tcjDYaCCb1YGCEpzpGbWqSMJtyNA6+b2dHXdnwrjzUN+WBj1ftc52HKD2L87tKGX3B/G50GQxq35vpRb8SDrDOsicmMOxqkTu7hDerwnYZch+lWe6lggITCmiqHNbYfSYuRa1SiJL9UyJgkuFTxMxKhy5uzn4c3IWjhQGnCvweXyY1lcxbNZPUq3LFLLi8zHj3wzidgJC6fIwOpDJql+600VZeZYKplSvtkykQOXy2/VIrPxR31GwV+M9Abchxes/+huJETfDhFvS75UPaJ+cfR7rNd7S/uvxgC6AW8BlxCmaPh1H5hGp8kJIFaLSuWfBbuiMu4k667hAniKCTqjqkaAfHg2Xb61hIwV5e4WzLsw/ATXGAKiTHLKSUvLrWsnZXrJx8Hcb3VerXqHHv4JrpF70yK0IepbI5tNhgYIirvOOJdjzT4H9b2jfMFiVKpYgBo64tG25GkYMzsWQPtIvkARPOA8GF7up6JlZW7xZK3HMVTPQju6PKSH8zzZIVs82Ou9NtHCXWa3l07bNbENEQ4/z18CoPS65ONcfF39+ZwYFGFeIFaWMri5MVW01H0X9jrsXeAxhKMU6Re6TpygMgjkLJO75kCofZtSnUYQn4kcOqRlSfEUZv0xyjM9m60GRTXTN4Pt8LJ42XByofpMBR/XIBE4b1P5inr4xBNFi5vN3a8UBB/Gcwdl1Qs3E/vE6AbhUCMYj7vj0TtwJji42zUpF8odFCWF0n4R5oqrFBhYE6L6r6WTFntciH/2pLzNFrGVOAxyCePd4dcGVBRmRbPrsvfhMlFg6SWeff23dJ9nRRgqZJaaZTpH0YT7+Z4M0MBcUTzT1Ac3UwtAZoCmbkZPUZTdGSdkpWsJau3Fsj3ST/ZQRTi29w9w0fF/uYOKybFxwaN6t5Tavi0XTsspYSzP0zcpzcLXOB/A2K3EdfV1OvIe+G61Ke1BG00N5aCo7JnXzq0twILRlVfUUIWvaK2UpW0zjoi0Rq9HtwAx2pGMxy5J+goBumhtmwb21t6tUUd35eK78FPa9G4iOj0nkwd81LVaC3cVDOJ3TTYMcqCAfs6i+tygBqRqBpMF22alZoksw26gdD1t2sEw/RZNeUkRP9hXQvn8zgbC9B2WoJebTCHAxwFxTW2QgZ8rgfHhAtVVL7NYRJOwA1zGtCimOAvNKR65XomYAnA42UZqa9O7n7iTFUC5lnrkd7VxMvzSTY/RQtp2OoA506KZGi3J7YRQraSOyUE2rclaZSb04mezHM415f5AgmlN2Eta7E1HET7fvl0ZvhPZWouGfObgr2UeHlG8o3pGLo6C7FEYyqljjwhOt4OU3DFC3clMyo/mTOXk68Ub4N0eAdUTRJQXwzVlhSj2I/MXFWFsersCd2VQjX7vkEaVxqZRBRxHNK6G8jJ9p7Wt3zuMdF+eyTzZfZPBPLT4jD4mLLxgN3Q7ZLzQ5140E30GnkEE4bl6W19LqH1xOw19L61ZZ2H0Btucn54qNOM3vRSk/dyEFeeoZpTjHW+v2fnPo70JJDMNBx+Gnd7JzhutqYDWjbf9aIGC6ksvEG1Lr6O14SOgfJh6Ay7/u74/JYRKzHm8fN0svL0TyxGMWiRozptW5qUZtdl/ZoTEEF96KOuultoY5Fh8EcrxG0j9cpb2VKywYQTMnx3MutsLCzGhsx3A0sXC2N5dKroMsmqpvyuf+LaQ/IiNL3v4HVXSyuvHSabiU5pcgFJBE745zV/t5a5N1qVO0ZI7XeXSh5F9DY7p5PLBMBY6CC7yGgV59kvuTJ1MrP9LeKG8aQwGFMKKNVy9SXR165cgRBy84A0NYCp+FF4aOiL1HQ40urEZ2gw2ydAoqnB+g2cNtCAYM7hbijMJMGmkZAg5yJ3ZmI0F3SiLIv1Y4LOWeTbsGJUfWbUUXH4c6hH3q5eFDD2OO/kuaph5hqJI515QYtwv3KXZkMXj5kbF/ENJ1rawoNx4Is1D6HB4sm4a01xSbuAx07+fPTptjR6cVHZG4694lJsxDST2YCHRivqeftn/a+SmK6C66DNOCcUdFfP0llwfE16D7Hd80o33Lu2FzY0D0mACyABjtlSnLyveCi/h0dLY6oNhRcpkmH/T+ui0YFvF/4RAE4sVIXr9i92ln8WAWOp+ZOyPniFfmuGC+cbyc5pmjQV5m/fFUUj6NBAsuCioI7yPBaYu4P/c9EzXSwhUE5YZWp6gDuJ9UVcHdh28E+o5fuuErwPDaH22x4Tt4ryH7OrsGZPN8/sqZBQA9C+OVXO+TC+AnQdmV6wKUuS2MKoFX6q2VGvE2tpCRcNDqEXVFHCZ+IIkoQH7JZfcE4SKl6TpPelv54EyNOQpZur+IK/rsF9jKbzuHetot9dZ0nX0yt9dm2HGsNHx83x+1dsrS1zdrOgzxYBFPVfHZSs4SKCiSkv5FuiOHdBf0Yc0h/bGjJeej8JT2/qYxt/cmnIQygmERn4ZMolG1Bh3EE+AlhY6l77FEDtUIT9wbYlWBgftBhvRLetFYE9qauRSFc9yIz7IT5HrxcvkvM8GFf9UeNp9n9lbKnBxXzDsOh5yQBl+VhmsUIPR5UER5tMIBdaQcSgrVRnXfRk8C1kl70v8C7ls5OIlLxr9dHbIjlMT1bKNAXjF1FNeF0ez4LqK/OeCcVY4tYYVbUcFzIA1H0scTXt+7c/dBUvmanM/zNhxztJ5n1zH9nzDtOTkkY2XTabDPqlMRFNyoHB5XmW0rxs3Lt01oWPxSLdqYnVBU+10u7IC1J7ti25wInl4ZObk48AoAkMfRcHATatfkKG1gCRfN7ty8oJbV2eWMsyEjqhkoEC546DQ9Ah1DaDK2pZHE7V47rDaJq7lEZnUPDoktIHn6O6m8Y1WEAj7rQPJGHeNVBc5ZoanE3sJo/7d9IJ54CoUCitLqc7+r+SfhFdQchxE9/3jxJBnf/4ws05jaoMCAY0HRkl2D5kMcAeUpDR4KVNmFW5EMjyTa5wrsCjYv0aAoPPkm88qCjwdiBw9l4RG+duHSaP0JwpQeKLeDzHvkEK3tvwe6G3KOV1YcyTGrleFaKQ/5WUKxuHPpYOXfSXJWKbhWPtiRGxj6B17EDYWuPMlggzrVceIvzzswMhhSm56Woj81uxZnb6neCIO0Xzokh8l7ncHf+0878Zz35ewfwinhkO7bIPW9PshWJndUBX9H3g0v/X21ac2stP8XG0FYs6sz2GfHLeKJkahj/2Ps6q8Ux/Ct+DA7UmndbWkN3Ga8IhEne5353zHqKP3q4JR1qX8H3QLuzGfBEAMD45PZPfjmoC3Ig66SucKtBRnCWUOg+cUWGNpY+1Qt5vAr7ycdyGWR56wtb4yXhQtLJYoNq6XxUwLiX66pASMNsnzIfnLcHLu8ooDUPBbkf06NfaFcms/1Hb1njZUgdKdUrY7TorrJifJ38RIlDTBWFAdMai2jnyQsWV9k2BBF5P0Uj974Ds/44QIJsFZnKbxeRyodSFhBaMzZ9IqxTqKosrGtUe/TZPwgt39Sl+zPz+5v52HHNIsM5z8aIbmoe140KfO1LkYzRCz3OWCWE06m1net7EKGH2enEbdbyWg4NiMMRhPqnbDXPW3uXV6+jY72c0d1kP8WF5sffWOUk2Em866MZwGgIxG9/bTOGUAozskaPWkFgIxC106oAN6HZrjVpaM1Cudt4pwQTg9jq96ejtWCNcter8Qj7MXeWsXunqgLm+GmHYuEvp02J6id50Hl6tfA4zlW7AKHrbUlZ5kxUuaXmyV4+RN6JmFhG9qb0JnxEKoxRcqYc9q1T9qyk3BncunppEDR3bRtKQ0WghPBReIgxxvMv47JhVFCPrlff9WC+0vB6FY6fNpJGsqaYGJFsMdNToR0gknIisPo0+r3T+B7VBHA9yNpoXPNdgu2087i8rAQI2KscCbyeJnJQs+k8ezmwCOF3f97FOJWhLaKGdDDAkz9s7mCraSO4StleghFx+p6hX5MHlbnLdiGXTFLXKyER5b8d21qVN7UAiUilFaAnzUeQhZLKPlrJzA6zadb1s1r0gOg1A80Inal577mBzIXejp6J+/XA/Z4ltXjBzCo/0k4e9Gx0OXTI+UROaxS2xxHUwPL6yFPwwOzdwcXoQ85eAk4uyoKGgam91HxWqvO28k/+oBPPEOMgqjhLtYXht2p8OsRg2FTMpkfkyoW8ZX9QQuyjlNlYRRva2hVZX6lCECdb19gXXUkrQsVP3sswXNZ9nKr6e/zZEtiKJM+GPkWZUhLq2JvUHHC50Mhi9fArxIbsNA/k1WibcC3Wudo2i1zpJV9GYkrTrgIYK2ZCDAjiQLK2VzydK9B+GS6IluulLPtr9xoH6cpEpE0Wr3FHtPgFKJdOuxtg8d3TjbG68VzQaLJzqkexIxGebYkJ+lokZDCN7ChQksXhJfu1xQWlD0fKKJShElaj0hYF9WhD9oScNR1BtSBpqECUz+UtlJMzfXKC97zEhwC4BRLJmm+XpNpiJ+7FFO7E4YpuTZ62a7Q3CaG064ic1Fjq6vvS56FqquiEgXuhA7VVUE1cgY58Ov0oAwVSQniHreM0T+UHMaBMt71UdU8XzOrWhzfs1iaXGOtzXQo51MZ096qMzaGR6vyGxQ6uqHVAnfwba79i181cFLgEzcPL/Iqhde3/gi+/GcZBni8VLXUlOl/XwNDM8VyIUo2t4LWOjpj5yRoJoyMAMRI+AP8//riUU2bn5G15JMGnxlH9ThhwNUdFe0pilp6Y/Eycpx6CiZ5viYYuaroSFCG3m44cu9g5tRjgC6H6ZId7TqVW1I8I13cZ9Dg2o7ub7hYjkxJWErlDBiB55nEOpebmnxm0SN3AxCg774g7naKPwBUR4xTon3YN2eF64qIR97N/FRaPT5ypPV3r6atCp6k0x+vjPhY1jridEjACKfB0p7T1G9pdIfUjdqWPVI+5tQtAcF8BYhCp0JhcPjCynoCud/MokW1z9aEbOY+jKE//Uc6NBmRvTf2ec1mE9s3I71gnlx/Zg9lciISC6+OIBAxr/2fznbKvWHP457ACDC/q/S6p33p05FLplpjqPLhaTCqt/YbaxbRJvV65bmIewWmYUwbxq4cQ9KOq50W3JsCTDlOhgEG6VycDPVJZUgvU2dyTWdxLvCymKm+tSO3MWEsnFvhRcCjQ7okjWQDB+yMgLQVqDmWZUhKRwwDDb05FToNDZgNR0A7xgylO3B5ntYPnnrUrDTOmJmr84HXBwa8+F8E4yGRc1aHaYNHJdPuYb91d3T8AP371t/eQe3AyTQbdyB01hB2oM44uVSNuYOBRN/6fiGE0JfRhkt7Kr/m+nqXVK/YRIvBq1TV43ZziD4nQiIVsi6pfBb4cjOBleOBktgwlDFFXsl+eaaUxerULlE45Em5dD3WvJ0WeN6e4Vml3EgqVkD9CjG9bFswvuuhBGsr3YJi5xNGL4gBz6CipRKiyUrxFwjvU/u3zbvZmTTAy3LsUouCP/U8YwFszioET83+tSS1budGQpSZSe5qhq6DYX0x7U98EbXoLiL/q1IpGCJi84wkmjI7lVpw5W6r6Qlg1rUY6DCbz/Zn8m3HQqfTF+g6ncz9IHXMdLmaemoIBat0BGpscjuLeHGPIISAfKLJ20GPv0slEJd6WEOK10CJt1sbYLo9XeC4UfEdVWCad9Z3RQsJpfV/sP6t137Eepx23YHheUWFJH7D9YJyCS8ubR4HBs2PKD1OmSPYCKeWCCxvew5J0qkkZ6vtUeZEwoxpu/Hs0qoQ/IxkKBothZbVrdF60BoZnGZmWsf61lEYumEdPb99VHs7opymcgjYN2zUrFyE1t3b9LoK+RTRKF2aW3noTIlV9xhOjEL+JSHABFI+FWo2y5DOpeDsql96eNC/w0s+RVvpGyRSFOc1mw+CE2YBg3OSPEsliwZDuYx58SQltb4LOat1DO41M/5D6feZN2JURjJtsuBPt11qkHAwRmZUpuaG4yvcjDqFsNDKMI4Ah+zr5kH9UKNe1Be8rMwQQTiYPCVeQ0ltrOP5uITLBAnHhyxwVR0Zuwwp/jjA5rkajrXeph1WpWZM7CTbfEvAUKXM2n8Mx8jVHvs0gx0oURNkGHSCnqYFbK/C/6hNvq4ysfE5eAp8bRN3KAUc1NwVHHbm144yk3h104znSWtrvhwrrRImhmpWWomEmNsYHjID5Pv+61L7SVHty4PH2Jg5kv7xDlrrC2pAF+hU+b8wrYFFMMNQB4ztUZVy9xuzJl6/BpZ8KHrc9ryg0FRkgA3r/rAPrYOEeMGRcoXHJe1mTO6GX1WUtEAmYbfZ4/Ed9AvCfDVHaTWRsGyq8Kn5oHGOfpixvvLDJh8ZWMt/saTHmjKRY43A/Q7JvscbIlqe6IOMxrOtanNy02scsI9uvVcPHXXTz274TYsJXwFrHK0f0/uzylTbOZnC6T/JPec3dTtwIWwANtDlPa4UlBIufCjHnrZQg5m1qqC43yJedkgRdmlFYUYTn5TxOn6hBqR27V9MEapssZisqa9i5iNaPqtL8NfXhwhWoosiPjv+ryvviEPt2QG4LFNdLX9tYZbvP+MnVwMZFnIPCz5/jscienTFjr3VRTxqHoVsYLg7E1GdXnNyd6Yx0i3tUI+TMpA9h4LbSScSq2hMskI5R5M0b4rz7ARw3+Q9oUeeZMxnEJviWJS0+tJrqw4Tpy+rzpDdXFSE3m7EDZDCFCPiNMYEAXSwoDM6mr9Fv8gNEuWkdWk6l+96addzUBKUilxbZcBly5WMonTwuVdmGuH5hgDePgaRSX126/juTNmrgLQXPLUJcnLF1DukAqPOsAdFqTi3AOU9wTpqa3gzW9ajpsYxh+Oeo3BkLEhr3crKhsECa83sfdDKJLUz2pA3HWQfFDHlJsKhCUffdOGHFYSOo9FVRcLtEXLsRfFq9AA2foINiXoBYaNMbera7EAbAw8MeS1P6vJn35BlL6qe8M2HXDX93D1GW2ETPvymOZF19Ta89Y2T2r36b3j3IPmTDb7XB1K54RG8NsM+ttri2dOzws5r7xxUwhDxJKkwLyyPKWUeDlctC0f61IG8IqEC+44wsZbC6dTbaNYIqv0Uu8Wb6AXzEy0rVABzSo4JwHLQsBwiLECOdudLjJiF8+ogtUcdYM5rWvZLUGoO4dTt0wYhK2uzdyHv9+czhBLdgjtS+RTEoEplP+qEfJqr3T8QTac1wkLF6gjzkIqK/8I6Rn2edTrJ1SxYNR7Ez67EPJ5kUWPlBfxBI9+lTax/tKLa2d2zUfLAdjnnxs6VgLZSFmc1IvJ1gGFH+idvxQeByjNrxr897Ao2S5+i05te8PTSHWzgsVSvs3V+knUsHJuX1iaVeoTK2LI9xu4aXHK1gRH5KX0LBpt0reZdVom2t9BY3mYIaVlwp4vC9Q3/XsVPmBQO3sGCATftVHbB9lZj7QHMYUz2WhfGHWuNE23TeoVcNAts/4kB+BBZqgYyfhkbGNVnCcZPYnBfEJEV8q544TLu1V/BS0BWmXB1kxk3nQOplkPfdf3Kx51QsxLoRKS6O9czw3TLjtEtGZmbJOSuZpqeL4H3vfNl5wdZv524mCxtNqoSq9BPhjm28nenXrMbZVpnYZdTWSFBp997bl+N8D6PnrUDwJekQB0aslLjSnD1Tb8+8mDuVA3VaP18cv+vtyCXX3MyLR3bB04TdBYNVu7gRWg58kZyIRXju6sMquuPNXGH5lMc0EjnZQt00gVRkXcVqgNRysJuZ4EypdteFuGHeE/gHTcZlgngvcPbUq2wcATe/M+KQBO27Hx4lEoxIfs/AD8uBriJYn7D9zHZYvOu6/CmnSZAI38Xme0VJxhAqvKo2ZJCDcyRaVvFd1EUUiJn2WGovue84fJ31WtTZSNl58C4b/7kwOCHAWTWc/6GzzV0+Ms53wEDYAAg4W1gAjmT75jl20LMs8DC12IjTZOWLFW6ldMHEZI6+SjWp+fLBZIuBplqHNSazq2UOkC65le7oBb1rzOsk+3DI19UBQbtfEvc0Uci+7uu/2zLBcRP6KGIy1RN1RDKrQX7ILvwr3cCuQsbERR97M9kgr0qUvOIs6Lkh+a/Cvk+37tsIu7HMx3RAtMQA2qx65ZnEyKAzx2vaf0/mwKGatPknl7brXLmXzHdp5npDxUZl1s6Hv+170ic7BErI5jWzIQ4Xa/QXtDeUfpyZcxAZMWyeney6S3zRvRnlzkOYM6RWTG/NeRuGJDhC7VbXAd8KDRhY2U6bT12Ux7eKX+IKlAyuUV6USsyEBUPpoZyfmBUNAUKlwedRgkiE58KV9wy6H5VnEkXqTgKw23gsQM6uJlIYkRJxp/QzkG55wBqlQE+4ZrDSnSWuwSKEIhqRzckX6oHBjoWUV4sZ6YADyLTAuCUQkVU1UvYe+A5pnsqYSavBUvkHdxUmc5aVmV/kfHb6XpQ1aXUp5WYzfFLsraGKNLAUV2WuMWEjZFtBbHybg5Qk+23xzPUFDzvg8oensqG/OVQgUFtYmQAG1Fh09WIHSmgtTTnjbhkBPEy2d3TzJ1RrHe2nZQn2+N2goy8jOEuZNPXM+2UuFNHIJ5S47ZiWqh0z70vUp2tvbqOuuvdcK3bdUIpphLSB1le26GdghmlsHoWdWyFA8B+uCNZGyNT5gdNMOcD17C5SGTVA3bkZ/1lTpFxp6STlJgowelwN9fxaStegB9117UQr6Nc1VaSBvMXNsCaVQ+5GLAOU/dg4OfgEo3j+7wE9PXlb0kqkEfYUJCTnKsABs8C7Sz5mRGtapGZWG8hvcsCHCb+5McSYFbd2rt0L56cR6Mkp0Ol3k0TCZGXZBqKU6APYtcPhu90OEA4Gt55fFpOHvmQC4qcamb78nRKABVWh0yll3RUUsIcGr23Fl7uBQAWbxqsLStyGZrKe25/6Nez3wVZslsRMtY8eNCmwzf+fE6jelzse27Fme+wNDcjVmRTZ0Rl8cuD362yFQdLvNEVRHjpBvtZwqrrrMFjstz/tQ1aMv7tm4za/k7xYp951fGJDg/ZslfTq90MKcqk2CScy5oItd+GZPQ6l/NN1LsWU8HUGSm1UDQlse/waRcPmaXUajpMK1fkbXnMaJt3iqj/Ajb4lTO50xEFCNBLF61Nx3lzEKz9siRY4DFJ1ToHaYxEw8aJSdhu/nLA+F03L2nPeqcHn8BFN7GJIrQRkvUqKh4ZyCO97jdmY4fMtjkIjCGAqMQARlfM/E9EI6WqMV8uLruHApAPpqqOEvzXGe7JeSrSt2ivec71YtxtaZNH3R1swPMKZHBjS7/IrkxoNBw5zGOdAQ0TzExTuzn/L9f+y/Uh3qwRQ9YokxbTqB6ROl/CoPBgMIzsWG/nvRtjwK9kEZHIszqIvahXCxjHpHCrELn+XfK5RcbUaIiAPkd4bKZjoLqemec9AaWaDvFJk3OUjt8okw8TqpEj4ZytmJY8o9K3KXCO+qUzo8cOA3djLywvVgOzYKhknCcqdcZfB+DWeWjyYB5TQSX13iXsicbf/lkX86Y5z9pWeSoMgd86JVy9vbObIecFeJhz0NXvSGPa67EwQWzF6CcDy+ZTYJQm700A0//cpiLurXMbqni1UglUWdlVvhlK3LNFX/QMQ34zxIWMGCjfF6okDDS50nbJEB/hl1UlS722hfHiI5L9pgFH6yJLrNeE6NVPpsljCgSfQ5XHy4JlcC5bVHIfxbjzv36OIoafhnpN5VLtSXv1SzkykbjaJzvvAXjn/U1BP0hbLuMSGRItb4XdCa2u8iO9btbGzH4vQMFBLPnsJOq7pk2INrk58K7y166szRaBrlF6mOhcumo8h9UfBl2fn30A79B5T7b3ZCG0Ii5//cHgr3rsXRJaSYL4iRpGccXGR0yDPsLAGumsW7fTBJGb/DgUQT8y833gJ6SJdfpA70rRi0M4xtIoEicmBgdKAvHTh7rHrW4VRZ/RFeNByO5uWuozUFjmt29IsGn6Jmt9v8gkFNLFGLr3aghjBzeSF4DeCPRJ/QipPyl2JR+XqY1KtwFRIdGYmDInmfXoJHe9Qjg/IKlRdEVGQT5WQK7n6JJ9nftI3M/IAphXbhtKB5+Yjr/U/b82TYReyjhw9uy1EoqTCpknAXxC+jCgmKGtEcafnHn6IMXSiosrDlSKf03pnPT0HWAS3PbYMVHHEZr6KJiZys4m73I3nabGjyp0GnKSvod1LidhVtO9h0GCI13YXc7w2gL5AbbDE+2vPimRZFyludSIf8hLm/dWKjYiD0m0/jTYYggSvKhKNGMkn9g0ZU2A2YTkm4k+AMU0m63NJ5z5QDC2A+g23TPtlngcvqwbblPb2YpagSGfPQ2X1RdWlVWjp6ZZxPcMqG4e9wI1ZnhejoDjcWoD1rWB5dRJ/9+90L5HuJm7bvoesGrkNc462T2ZdVhdfqzTauEiSXsrYHVxbYudhb7fHRcFxQNfBSIAUm3N+80SSL63gHOKoebhdlL2NsBZ5NyiSr+uXyZQ12yxLPGscXWjTifKFnmJDolZo7Drsg8WithpoyGTk7+h/yMa37P/dN/u7aUO9PisNE26tqwTFjluW7W+5wBRYlchGarb2H9e9hM/y/FLfNEl0TpelRD7uMcYtgb2QLAMMNUuCcR7f2uu/s+8rDq2EOCDLKl5BeENf6YTIbdvZfGdf6Jvin4DCk0YenN2HJy1+L9Aa2rz4IGPNAA8c7Y85H8ZppnLY1uuKe4WybtMCbkLfRXBn8PwDU12bGaQbsuqw0c884yjBsaZDsLIzeCB4DAAQkuEVGKtcaqPy0xXemoqgl9beT6zjt86n2dVmc6nF7TXvgKaztZ8+xdvw8LHkLNILf3vO/t1pLR2fJTfiMuvXMrJwsjcKGSe+fs+v7zt/XVc9Fr3ynKRN3Fab2Awdg6WxU1owcxQDcYuRMQmjTppEqo+tXL6aGy+WxwdfbaK61lohmU4Bzo/ZfG+8JylT911hwKkq25Mcj2MOByCB8k17qDLzupmZ+x6DaG3mDGqZGDLJYJgPVXPXHh+1VlAmqI73h3CJhZ28/BMykuSEjRN5ClRVmUIvX+hJcO+L6Q6vmS8f8D5r1EC/KtW1J+chsPHhN86jiRUdu8r8mfCkycLcpuiWWAhbr6vXos0u9KmXMLg5PpuGltEIGzfdzFoouGFeCPQJvF9RD+vZAlvdwiNnAh4+n9vhk1bX3bdQM8wpp2cnXEHxeZqp3ioMUW0mRPMUEOWL8Apj2dogDc3/+koUN2Fq/Zy6K3zlTR7J58KxZSnKvIZEF0a7jB7MtlXPJab8fHvhNyPanP2VjEEtbH+qXiV20zrrVwE3zwrdCSfH4alcNG16DUsOYPirfkjTaiOumfv+aIqp8eMm72mWTeLgZtH5ckwhZnhA1SctrddwKcMHddKo3cxmRIvWc2ESfjoQAWpAWo415eUjBs/CkzYTIio+LdobmrTaZM9XCj35TS7jzM5yM9fGKhZsQpkGBxIT1UsxoAx2nzElwJAgueT7usRsGI5m10LAIJUbxAad1MukIqpjA4cZA9AggEbgHDQmRitJ0YELer0z+qmHL8o7tvsOFg05aj8ipzdsUzZhzK8NaJYv4tsCszUM+fYCoZaY3s2uTuObxCHeO21zJxwagYcNrYA+k1ZdnoL3u9EZ+EEvLxuG6a/gpjKIL37H++3aeUnNDovxR0DZZVHOszctQ8t2Hz/I0sY6EYzKJ0n4lkAoIjwARzdJlaTyIZKN4eOvfe91lSdXKxCcv7eFi6/KHgR+20hf0ywC3K92QD7ClyYdlKvoD5RacZLGmOxIa3iTt8ZTQMygZOWJmuW7Tlk821iN8iyxUxJ4w7AKQfywAFATEZz4xBlfy+eNPj4uJlPn7a70ZMUehxX8ffbYxGIjMWZP53dzQe1/1nwyMBq9lvbW/XjtdNLGEozzv4PeJFUq/7SivAd5TRNZeHB4wRXylhDNg9HUaJ4G/UxAghz0cgVWL4KWPd2eAiwGuhb2GSNp4ieHfHh7Bd7RsH1bXDaz1FXnEgE4Zjay6z/NVsEVpARGyP/C1XpmpiyjlZH57gsf/pDGrF1g9xWx/3+J4w65oC8leJy/AN5zBdyKUmREaFzbXRPbiqtLszwtQ4+hcoXxNXTjejObfTuirvmsAnjj8dGaQCf9JPsxxKs1SB2zwuqXs/rGiRelxazMkAAyBLr8FwrChgROduEQ7YzrqqCSuSQp/eXgTKWEc+wjiaPEhhwdv1jbjlduc6vwZgJtN90kDUkeiZSbXRVCMmxjQgcE3pMPzec8pe3Mt1T+0HDLANxToj75JVr1Lzo+pR+iLqiDjKgO4ybsRtZAekMP+gYSW1xBjzaMshnKrXvK1SeuG6/Cvv359PieEShu4f1ZUuox8HFEEOYMG29o3P3hKVEsfLE3kZli2txlhwxxdQNsP7mLFudV9Xfld4aB5YjubAVzod7rgsEEO1I6/nokHWWDqEVFuCe81yIl6raHkfq1/3DiiEuwEy/it1owce9rgk263+wpwZEcIiLqchKyjGpytl2nP7zHmH9v4HOhStDPyw6uOD6alaCZVyllY35qK/TqqTNW2PkBDiU9P8/7yaCUEs4Z+MwmUpkOH1ZFKACWpmq4OzasYnPzZ0WeFh/oHfx77wCk0lWpQAOIkKcg3HYfpDIZ5zynmIwxGzhDTuaXtECr1GlBZrVCzCQJ4vr0q90SiFGyXUKie7bjntvEpLx8J3pUx3dSYW8Q7ZYv5h1kHnOlY89QAyzhlYAQDkxy+B5DIfe3fYQMgA80/+tJFr/C36nPOa1rtinXqAVkb0dNvfx2ge4OYs7Am/Sap8VGazoG2s8XFei9TUz08b8eT1jVKb9uCwBRFn1SbkGdE2xCOZ6Z4hr9Db4KBHHno3VLgsPwgswtzGX9ncQqvKYKGb0dBJqDTjVKVG6QjisO8Msm1V4SwX8bf4uFC8/etPqBYmGBYPi971mnwZhygIzoIr7DPH+aphA27e9OslsNwHucu9FP4TA5r/2nxklX7uzR2qVRg9Fclmc1JOTAPxR2wrleI0NQBWhkRV8ggIBXFqz5gqYpHQDfq3YuDhCgBA1Yrm5Js2p9M97BqMaUQPUm2CSIDBcsLbC+1Of7jBSN3nCaYPmr92v3E/WOwzZRLipkIDWP28qRk0eS0OTBFZz1uBgCFm4q1Zak7vvLtsjc4qr1PcOcG4WgqMkxzKqU52srvG4BTyb7BCYvM8LUXkZsxIlKsjNZBG/3SvjPC917Oe7+U9FZoc25HIBqQQj4mqoUJzLLro4DR407S3mn/Xt5rT8cZrdhIWeTYbbF/YSCtTu1HWr67URJS7LrOliXpm93SClgvQTHvgXZo+xhzTClM9IbztD4i5GbeJqPdmqNl2WZULYlp+TaupGy40VsI3ayjSryMfrccBRxVRaKXdsWPxQDjyp5MiOgaYu1PXm1RwNChweSoBXCpjbEeH/kBhFhQL72boSitcKkFQloFrP/krK+cBd7ZUcD7djxHSfayNmLMUcppcrU2HCH8mnSuMR2VGntOtcs4Ah2oXYpaD1EvFaG8bkpBvspL7B512B0bItwbL4+FBSlQ6MSG2wVdauaJsRHNCOipv/iTYG2u8Itx1AnTM7ZaKUBVZ8+zVXUWNiMPXiZeX2uW6wmIfuO57xrT8QSw6dXSUx23dAkR7voW3hqvB4DYW5+GzAQkbWZVQsLTt8DIuYgrqqeVbDv2PRnMq1wWqcTzenrEp4bTbgviX15MZngDg/ErsKOeSFsxL1uzu/dH9PBO9KbTA3Rzm4JRdQrEzJOB6nTL5VqRs58jhsiEOx9YAcCG9vUB5Rv25+OL5wkNa0snO8g7B2OO+LI4ZBPnS2NsUDKdndehDPSCWspcoo3kNAISju+m+tipZh0h5QYg217WALvrGv21BDKg9JuP8u6dJbc8oSIRhE7MytJ5I83iEhMk8MsWjP49rrmE/MOQdyujOIXSr5A43i8tMoxdSotdMTNDiGCULvozd7+1ev2AhEkCQWwG3fLl0SU4xSJTv7eoJmqSRq7sZEMZ286E8D5K9Sy8M2k6abV5izAcR9+IvV7iBIP7l76RIO6QfAEB0Zw5qavvC+3oFNJ1zaGMW+I2Tqsid6I3IPqeY6WgeOQKrJxnGKy+Og1WsmsAWRGmqaIVF6wXoVe1VAZiSUEFGV4XuW3jzn/WshzrUwPayY+ftm3FmBgGw95dEMSaB+vqzohNpXLhcPTfYuGHxvE1W7WePSSGUnlnVqVlW4Zr4zys3+vGZZkjDfBbd7SNlCAo48CDEb7L+TJxUrD27vVu9c3PoAfmMyf7TgR7E2rB2mQadB5/WrzF9YyTN3QeFOBSXrq7C9wwL9EM1P0Si5WOuAXWF28iNPRBdgKofoHLlP+v+Ai0EFbzKNZJTApDbHjMXcy6N+QiBuJX5/LeL/vcpSTeq8KeeZ5bbLXAQdSIK/LXA2J2WOYF/oFTNeH2MB9mRMsf9b1AqD5EdJcu9S1LFlawOigOc2koY212MiuxamISZHx+o14svLNsLM67EdtLj/TaTHbujrZgZGwInAipy54f198Cbea8B9Obf+hDb0Vz+s5vQKWhuRNeP+7o9hImUiqpeCfiJghAnZNcFOyffg3TtwI9vY/AZ4gi6z4N+GOx04NxQ0ZaueB4dCm5h4r9g5KCQ4zNEr+L4sQDFU4fJybM6YcS+HsdyiHePgvxtwbo8lZ/R1u2BIgLZVCpDZuzhuyWF26Mi8LNGrmB2m7TrGhkHdG4eLjlFNLR2Xw4E8jNjkAhgeHC4tNpQHfKPBdNkfdZ+6WPA66M2rg59Mi+F/h9JTjYMKR+Bu1DkWrzMVliefI/9vQDNAz6bSAkNAfrAOaNbHlrGcIAbXyT6ZYEKgel84ZdM7zqj2Wv1JIGqMXewQFZeamLX5j0+Ze+7Cn1n8bWtp8tYh3Qnz/HoxCg64u13e5c/z6PFDEHyATXj2aWQlThRLg4NVKlbtzRCCQBSc8NmdWi2BS5KrVPXxney+SwtRfATgiyE7CwLoNxFmK5/Pt69SKIEK0ydFOdkzEWEP3RnOIklKBvJiTR0BsKwXWAb10Uqjk8ojJiVBEOYRIXSZwiFVLSfaY+gpSLFHb2tLpHPpDzKhUfadTGFD4Nhxkis6hBxb1bPygATMgERp2ewjwfUNSquPuH1rPVoulBCwIyxsqpeODHAyBjlvsALsOFwU31g6nC3sZIorDDfDGzMO/6zKDjXC2blWPRbjEPfhx1gVPMj6CLOxpFeDvO/osCPzX29XWFbyGi2U6JloIdi6p7vTr/E1FI1Jg9n2cBVpeqYur/eJi3f+ihMDzTjTRgdkPOHWFV7NOm+ZoJehVClZqOlFlVZFP+qNHNaQYPzBzRfBgj4DBSwDZUG/dY9pq7QNuiDbJFPfEwBHd4C6RSA8cLbk0Ksw28lvwVg+BXrWjyxHNz6EOuZahB8cYMVkPSz9ZhFQKozbwPh0+kV7JAcFrMHTMDHnro5pWIRbhPNEQ70Q1oSDTQANvL7u4tR/aNy9TNwBvscruF55fM8rYswbA0A+SJoIlLqZBAcD8rjG948Lx3a4DMwvbR/XtlQc+Yke7WhOoypQWNYdk790lCmiu7Ih/vVl2HsS8M1XFoWK5SQkSFzfrtRRY1d+Sil8v3RjKQcekP0QiKnT44/97uNxlpQ1/W4z/KuussrK62WosLxvvaFejAO6gR21MH3GWLBUL0ewaoAmr8kxH6ih65fRtkZajf8Dx9VmUPU/YzxpMFLLXTGflL0DjfPKVRBrbXQo+igfzr21IqI5Cz/x77WeuQT/lS9bX/Av13xyqa3T5KyI1gB6UKURz/hEoWhCJZt1OASTOaM7CwtrAbYZty92m07zDSZVH4HnF9QqiM9jS3X2zinRG+B6oWDAB+QmDah+T+CTTWmnvrIyzoPIVnQD81hq+l4B9cOMUNeWPoqZwEH1fByLf0Xvza9HDFpAjBYEsMH52KH+ryfP6kXfh8evayzo0CD3Fxw9fbAyBwp3fZ4ybQqJwe51u+VUaRinQlmgDCFtTVfDevHIa89C5XuuQJT6tNfsWoyQOrdOBI1f5KGeMjTeeZ77H5L93x8Bj3Pe234jxsMFO09zZyWdL7sda+wVy11PVdF5JW1lmi6o2Z75axILgcbQvn+UqGwiq1eV2e8sJaHXbaZnfPWawi08VrFlmat56Sw+36juPR5YA2DyKxlIbQ0+MP36NpyTjAzu7UGyPRLH+6+F9hMiKNoH3AoIo2v/RWoNgjvYi5IEWasQFz3fQ1hrYE/4ooCkmmtBGH3V98LWJRrzVjxeHhMcD3GHSEY562LsEgI7aCm0KBTdWI9yM/9JrwiK0MvxC2MF6hNx7H+7k+hWQSs9I1VQjcjrqqCA04bvelAVQuKOiiY5ggdvm2vGbZdwKCzfhMjzLqxefpDWIZeMgCKGpQX82ilr6wU5U0F/7Y6zOkllCVX0QY0ye2rZCc3d9GvCLAQoHQG6Di4CndDTBEmQPPFvWZ5DuG02qMEE4ecfr+JwGVZYOsh/7l2JDiuqPz1IZzsqhgrqmahhKCIGIUDP4tjnN9EZtQ3/Gt88754nsNH2oW6+xipdU1fOgesvn6nMLItw/aZHPPdY4cCk0cMyEqG81JSogycl2w2OzxCKTtUR4LWAxGSZHtYeOqXadaizktNtWieHoucu5Th8vfQQhOqZ02CYD/fyoYbTGqHGMDxtRXFVXL2JkQWkCD+R0oFPrCXqyamiFGqNV0RzVICiKfB5tymKx/JiqPhOxJyj2PlSL5aloTS648kPOd9b3447IdR5+fOMbaI8lAPXP05OZBHq3OrKO9ko/8uslEdKVshrUpcQVsIuhVvbmfNdi+DpCHqRYQyMLyhyLDVv0ACOKSCdw0i1kc43412/7/5CUeDxX8SNh/e42bwYOYxfX2NXwAHA7r3FdKdqUv50fxO1ddCOcWE4JnengZIbmjoSSfgRinb9pF/tQYTl7lloH4RFSTlZZGhA44F6BQvRA3g3JYA9SJDHECCKBpcNRLuRCWfOU4alg914s8W3g/Fp0U+HpISsB94O97u+fHUlRALDixGXjsLt4mh2abI3/XztuUNnL/7Pbn1PYIQ5LYt6m6TBwSAHyxiSXMOa0O5T7pDoo61yqyuYu9Fc0MZU4dL3b2uyJbCL1SqPMVgsP/OXm+hRKBXbC7U6n4rpexfNeM/JrTTiaoKbt3OpYQEsGCZ993Am5EtMhNqacCY6eszP2TATlEEuYc6tZH2L3d7DJH6GgOUCQcABxCpul0h5GTx3C42TtkDDQD+dRRLn6nsroo6HXB5yIHyjH+39eSMGCylc0J2UooyiUxqnIs1jxNvw1HG8OWRTNvR6PmiI9Np+0aFMQ+Grar+oQjaGBj0TsmM26phi2bhWnHd5ssLEzDAYFe/iwVvKAByk7Q060IF7yYayWcjCIMIERJvX5cryJ3G+jt5bvu84wGRzFAo+lwJ3BTMSCtpg57e3qV8TxnoUeUIb968v0T/HCh0e64sbv9XyAGvaDXl5AoEzceFRQJfGirmtXUNMljwjVkj92nNV/WKmTA9j0eYszh9SF1RL6yW1saceSX2ldpralpf6PFYY8nCBPTozbEwEvDmn0+aFlML7r7ZlS0jM3mp88m96R6BnbCDcqpUZgOHP/9ohmhc6BoiSLxzmM3xattBTdP5y4vY6f+FHvomv+JZImsvBIUUyUUr8SOuiov/E2h/c2yQ50VEXSuaI694tmswl8HosrnkYGJ6Jci+t0M3udcxJfDmSyPX9O2lDQA7x1fkthcHa5rgz3ii0LbI5CQGfDWaxjrLWqZc5sBQJ2Z++LOqQA1GGxlKgCkJQM8lI78JDs2fkmF2d82FCa7c1IgyuliiIUY6qeRIZ9Ney6mv6reLe5mMQ860SaaPEdsx9umvM7CXJAl52nSmd0PcWzgKir60Eav/A5+TL9pJzcWYIiPcTnVVGQNFOodvyFgi4twjKc90AIxbmxCnejgYSQcqsHmhk/fVyIqEdUrm1E8UV2RWWXmeEd6sg4vnxQJFtnysSJph0DxHr5J1+R4qIPhMMbfRJiWbLyfKqSh0EFsUYCSVGErVr1DS+fUb0ndF2EQeFntpcL10VH1d/dznp1CDfpO8bsf+wxDU/XUek+8RoJyMfTjR3TQnMsal5McTdBnUIfkBgHQq0to0/cqOExYv3JsG2xeO+JPtAHQvOsvIpP7cCdOvCA9i6JQqz/sSE2wmfHy8KK+4Nvx8sDwytbhJOfsKGo6M55pGAUXiRT9I5vVdVuT3kM+/7JthLzCzfqSjymBDYWbn969vxcOOiMA89y45GF8cq5UdK9NAcvCKZsmU4fahMZNP/TYMVBdkiKcflO5MrBfk4GDK5qzSZVX5MG1eZlD9Cm/h0aT39eomrlMaN/TaqA5ByW7v45E6O14zq1FHajm+zTiLMKkNVpdR3WTHvDK8ehLdKb3BTS7e3h4xjcbiUdZfIZlwi3Bt+kvcOr1NC8XmrYwC233g8zFburs2LdWcXxvVd7RRveiedOV40+BrBbzhVbQcGOBRUFgR821C7XCO/fAk9zIB6d1pnVwRUkJ2HL94IYFrUJGmkZzwhLssoK8UFHqxXvBxPOoJeh9cwUJkLg2a0q5fO61WBdzM4NIUAywfa5yNhBdkVatX+cUU1agvS0SGNecqu4RQkHFp9h5Wi12dRx2WQPsgJK7ev2uaXayCFPHMzwPux+UYFjMz8DQotCOv8sowoJivlVkLNC0tVh5uwOlBGLegUt9izmdEH9VfvkBM3ly9cV3CrbFgucgdBXr858BDuDuRXbYifwqP4/O60QK0EG1zfI7qf5Tgn5Nx7inZRpm2y6K6HMoza670de34xi2Vbd2NL2/fcVY4jcxf0ocChIup3yPEiOxn/pTqCH7lvfKRl32SA+0kyNBH0E33buSJP1qOd4jUAwQa7IWNZbjXg39YbcWg1Gr2CcIeS7z2rljM6cSbFMlNp36txQ0v9zXz6FMAJ6HiCKZYoQxBk7hRy60tv87OPh8D6oh+X2pkvLBBd4y5XyUAUdugoj6Rv7K+RoCcCLq8+0jvDeizQT79wc5nmRubiMHXTsumXC7HaIUfkQTTqg5xWjDnk86MpFZl+6dbyFatSeQ8K58pVrZL9kfPnk82K2qsFU4OiXlri48oGOghxsqRzo0QKLxBktubeACS0NioJ4QqjJEjRpyNZ0tSz9VR86NFssdhCXtEurYYEk736jC5+Qc0h6qcvYolmlg5UmP8VAHgz21wzYPn6kfiuXWEokFml7j+pgHzuCHm1cq7lyCp9sL36Xrs8vEvB6VHN+hA+TAoT53FdWMJz5tlAcRFVfoeSRHakd1tVm77dtbOu3cBYr5+Otw1m+rKi0wTf6L9YnQrA8cm51OCW36NU2WDrX7lAND5PgTPjpmmOCNbYSZB0GZ6WPIHHtjJNZiIQl7NOy072ztvoyPaBgcZTmFdh5QY6LME861Zqj/Gp4A6YQOfR12NTJI4Le2+zfKW+WXnGDudDb95I3ckYZgLTgQWIHdeIIY8zLXv88z2iOpcnlNRBuBPzMi1bNRNI5dm2bXE3Tx61vCKM7pklJ9abtepeaqCBTvePwGt4/RZzzdneDKu85MWxuAbiVz/qjabj9kyr8lx9hvSK1k2rXsYZCssGRbUWSWKmD7Z8zA9FE+tXUFzEvvgogCJxrQLX4Gm8TVNTN3TDW0Z0UK6YFpCk4VYvfGFOXTmAWEW4f4mjTvZ7MgArPFGt+qjqhHeQzHNd9W0aLrvOmxZBOrC1+/1z56GcHG5tSpIlN2caV8PlvQi3YnB4l/eA0ZhKKc9pMzLB7BKWgKw89q1bOF/6cwPjE8H4Hd+jUD3oirRXy3HpenlOEi/N8XjOvRtSSUEan/x8mmXP4//QlSy8QJIkqUDjlS+F//ohec4uM5QmIOm6pCWGeJL/seJN3A0F7l5GKTF3E+LsL37rSon0OHeEu38IX73vJCKfF0ahFIe1wNXTxIRf+XZRzEN2NVWJMLVQSR4D4XuIrNagqTjTJBAackQZ99V5EJuWOHAA/4XfEQTu/Z1ZNx9Yz0FIrdUOBqMJBMxp4MMmWJQ49ewoGY28lzM602Na7Ypvp08GmghnnoEkQTB/vl7caoiPQmDGtKU06k/pDY5CskWcryGg+FH8N4LAZvs0xoF5ZaKO/NpD0BCxZOiCUoetC3JbkX0XGMpOJVSEjloR0KM0yjXS7X1MdmYi7d2X/6GHeWehQdAdDqj/xA3xtLekKSbitNhGR79rL7lN4DiZnwxFXo5TghXAvmfM6ZWGyTflNM8Nza3hWmw9TWRin0OPh6zAdQWqTrSu0DrjCtvoRhSTOZGpElp1cePgxxf4Vl5Er2k+uDPGfmUmIzu0vrsyL3cPH6pRxNfmQSGBtyncNErKfJUeKPRIeCh4N5lMym8urbLWCejsCXFR7tS+JiQKkRTT8qwmBG7iMwrm+bMrgp9NeyvCViakYoeGh63wJORN/SD8tqGF8lm0TN2l/imnR+9F5mT3QQti9GOa3pzlktjwnD1OJTJutulO+6SNlUn3uSYcmyODJXwg/rgrlpeOdYj22PG96P9Q0TQyEgzU8F0X6gNFh0Yxo4FDqtsa8nCpwTSuOCC5kM5KZqUt9i3wJIPJ+cze2n7kPiiqPv3+y3EFZaaMPZ+u0Qc4YbhLRQ5r4OyNYNRULQ9H7wt0ssQbo+0VnCKrJP04Rii/hogF8IBRDX1BhKBV6FWvMACmciYm2pDSG+kLhPs7aXXU+GYFl5IR1iM/n3EgIO2LOsrUAwfKSsdUshjyaCXN7MLZ85BHyja+sh+1zz0XUpUQJaJsHfUkTfgoYvV0x8CVKTLUFTLCfa1EXm5vNOSxDwtvjjv7OME7/oB0SgODlf5jfAhsondh6l7bje4E5I+BnTuyDm/QWRo3Ti/U9KC/83baphWXZxIMPojqBpG12ts8G/IbaFLysRBZuFq3c/rK9eI7zEJ3+5IojNiKeqpddpmFk/oZgqR1gb2HLsztF2aEMRwZ2NJIoA2WYHLBQ0ogwzqdetwaqWGOo9doyBsLgm75hiVYSWvtw+saP7jxf+32iOCxFJfR2bmGL/nyLW+y0ytydaxzKPyfRmTCDOvI3H8vqMNvsMKPV2s7Oj1zDcXdACYneiUY5ztgkryUIgEuC/CWN5f57OCQH852k9/6Hzlba/mJP8jUdP6dAf20x7lZmr5hGZMb8059Pn0WZW/n8n7j1HdKj+2L2+2tF+Cu8f00Jr+ATr0sViBow0yZ82bIfGxY2QFKajpDXD4zNJY4kwziYa/fAYzODfovo4RAsf4BdwJXaF+SyBRawxrNeOgpAaIeYmTGTJZO39o+pu0EEdd8L3CxwOWr1sSV+7qWMrvuXkyS2Ti/nCNDQnICgQ8fWJ/jPo+KjG5Od+nPKFJPG0dWlU3sOTUdUsKKx+cS2FdzMHl/jlUrGamx3gfmBeO2bxBID0kS+gIoxQ86CUZD71zOO4sm+LtixOb/9LzIZMIWwmz97KBN3y3YlV7YtxrUJy4lR69X9i9TWgJ+ugvF5UMsAKwhD02g7Ke2BxlGI3MQPmabR2sWk4RhupmMoSvzPnw0ylPgXb0+vDyYq9nLG1kz2sajPEExVE4wPDLIfkWS7ICzQ13rRbChXrMiFWgRhLEdiXgjfcznbTuY6g8igivA81VaXrF497IURZpUbfAzvx59GEwWDXfELBwc82CU05hHIDeB86U+8X4heN5CmeMI+yc3w6n/tnrdwVVNW5rQmNTxFrqxetbsoB2KnGcEz8YrcpXsbh6+EhurWclZGbuhy9XCVbcHDS9OVrg89mGtwfKbjAIAUHxM8DZDGxQVYiBH0ydWW1mmTLomaNpuV6vpDzAZf/2jkXUVq/W/HfK4NQSV1W0W5QoazqHxVk0IBSDB3mkGy/4ZeT9gyh60+PiBKrzmtBBoaJZnx1i6CI2j/RnjAzOHg3OQX0RdlOXsYeHK08UANdVO4OI8eZXtzIgw0coWcSHSmjWWh1NnQyi+0cCRI04UibzbFbJnklA7NLwVKRrz2vKMirC/tNU+q97GgjwtZfVQ0bnejF0BeA0ZVxqQAuvs98fzzbYNI5igvpXQU0NByxq+LlCfX/2NqoBw538AN3MD/r3kKPdCdPO+nvISuhyIRrr1VaZd5W8YBWtWgXVW3Xs/Xj8AlS0Vu0dirLadZogwyrQL8Ia06B+nHhCVqksBuSjVaLMvylHdpnj8F2oyQPcqSErBCja/v8RbxFZkm/sVKjetIyb/Ia9iozh0JN20BtB8j8V8wBUnbV7K/CNnyUvXkUhKBteTfGQsoaqioa7qr5/MlsXn3SHImRxA7FbPv21gftPgnMyO+SdF4SjIbFYvtaVA3mdWTKDgbZFmhGxM33Oco0Ghp6XsOfqj6zP58SXdJNmK0nwlRbMHhGGUELLJ5YwxpPpyYMl0PlRheW3Y8n53UUo4sA/YXpnn3wiEEP/XdMhzgRdGRpCNQ1851GnHUcpNfqEWjbUBNu1X80WOIFbfRYy+hVxiBihWOarIFaEAfCpF7+arAs4IogW2eSELeiTlIsWBFWw1ryQZm139uV/IogEe3RoRPgdbR17FCOqKEj7qCcDBDcvrpesn8fbg1oBYhqx/ss+AyCpKzLsQ+4Q5Ly9w7yKn4eEiINSao2tZWmfc+HKuTYmFQNO6JKw1J68q+V4gqz2zKJy9vy7w73Q0a+RcJHZc3sGU6r+0vBaqVVufjoRsTNu5e8k3ol0rqE4Qzza+9TxSMNSzRpzHBPjoGxEFdQxLh+qCH32bbqp54konAswXYIzVJFLddKHRNIxl7GLSivqwcU7kZzZVtmVj/SlXOw9CfffAfpvSvJwNqkaCObBEHazEi8Cx2tyv2JDrto56a8AWxaiGOj1B/8KSBSUjQiZdXFb6mwo6dBYPJ9A+E9+kOhtHz9iU1eipaND7opjCa8SF++BzF0gV5803bALUmYC4neLZ9CsStBo0+qgwIM2WllbwT94fWMU1gIb4Ce0cAXCBjVoLOkBx7lIGombTY7W2UhpeczAYIUcezWHpaGtEseVc5sMUr2MpqvD+uRnHZIOdwxd8gLHUu3B0leYbRYs6uw913J9dzc0y477OdEEyUlWbNIFZ0ynx2qgZ9YZ24JkM+ZAS1m2+C+2V0z/92oxnpbq7tbJViLK7vD5rLFV47+YJjtlQm9CdpKZkORIamGXqq6ZItgh5DIq1d3hyy+eW4PM7BVHydXi2Xuc4SjTo0S5M1DHWk7jW1rdFs4Zt2FVujE6v2s933KTLjap8UgSqcHDCJJnFilGAhG2GkNaQyDkEW+XuAOgnDdKuwb8YxckDvubdGJ6+2n4lYhNZi1JHCri5TTyDwZIBikweX7mf++8eyxEx7BfKbqVX9tpmeMQYFFwxSM67d80u7JzC+Np3TYvYx+Vk+19LSiiyIdE+La8dwvILIOvnFUhT1SiROGu4rdew5LsxHNAI0fsPMbrRVYqhI9oJDAM/1autR6GyVFtAT7NtIJhuFbGQNHW1G1i3rPB9uNQcSRtPtptmAxFutbbPrkUeyjBPQA2XzPXyMR8/72mVcHQ7QvI5R73zYLDOkO1PgN4imUrSYxWP9eO+GgOzVWOnfylS/iOSyUj9rdNyzhi9+m85WWwKzTQ78JSrwCN3CEyJASUXqphNX6IuOZBh3vhGGmc9Ee9yOE/dZlxrDKWTW9KhZzHyC8nIZXkCCEDZFEhHshq0o1xIysaE0OF9ypRYs1FeHxuhV/FTaABd9m6Pm5bfohAZMPpQs2V6xd7fToPBGKJDM+otTbOKEr+Z3xidtMqp2CNshbIGs+vCPMr6Idbk1SEshqzWWaR3jYz41FHizYHNVHjC20HJBe26yPGKXOdV5pUPaDquZtySLctKAbnWWThpbSpcA67qxE8KmgyVqBtv+PAslK16laX+eNJjEw/VR9IAnkLZPrayQak+bKV2SaAzSgNLA12WZvp3/kvfQBI159f9gw+gfUXMiRaLa3yyQ7G0E0cLZ5IeGUM+1pn0kC3+sJwzaDIIt9eYvP7TwgGBJN21htBSbRryJQh+Or/nkVKKq1AGTpJtqAoowRiftNqdum8wMZY+ZG1b32aj9Tx9H+GcMlRMPzrEGogiTBCZ0wAGAQ3UYF25POa+BUG+gkjSwaxtsYE2a+nfF7PRVoZ/ay8VazI52X/O/58Ql8IQm+hfTrHpgw3Jkjv8VHr0Lm3NQnB3g+W6nHiTRkk/389YAXfZ20+6vX7LsWj+x9XXwpWxIAWcuSYtPwbcVuEyOX8yTDGEMtRH8Bh1sLqYQZA9xW0XTMLTSXt0R8osL5Cub1un4WBKQgD8iQDJqBFPAUjvdQHP8aVAuYzf3CnKFLO/jfOLqdfwrME3r58+4fzbDc339sGojDgMqvX3TBftZJ/MEGqIpo/0XFwDu/PDdMBG8+N4r36nG+jce2m1uPaLf50UCpr9hhBWZUSx7XNuoD86p+45GyfVbpvXevZdM7QM0tViaOxlCRaWceCATgVdKZ6Q5jXVmmLZjkerHDHd6NFMBgP0+0qO8fDXSfq90B0O7Cd8O7UI3vten6HMs7GYMzdCoKwhA/bK9AI6AB3awYWxfWCDrYo8D3JNTPI2KKCkg2Blncbm22OYm9qiYqeqrjSvG0cVyTulweQH2OwnIGs4lgh4cDDNU0h7E6vTumCoesfmv/mMMrUERzBX/GDhgZPxLX7awmbYRVZfaPV1H0ZCQVS+zK/v5oR2xqDkDGhqIIB7Cm6EucvnhBkxLKT+liKalp/15UujzUyhIzSHiQZdIKIZEf5MUNerUMD+LNFTU6BEhq5qaObSPZ/xroyP1QoOl0qJNOYjtczV7PalTsGNhIRr6U6dCdjUgWBbzH91FrWt/NgsfqRL7K57Rnjqnb95yiknGcTv3OKYqCiqdQKWp3PPer//NjolKJQP5AtP94dMakHVhzRRk62UbJZq9N9aB1sPNQgThcshd8eyj4IXFgNLur+YttrmBs42MGWB4Oor+UIpACo2CGtPbvazedeJL89v0vxrtW1po1mHB1oMxKFWpFgpID1N5aAA0zV/CfS+wQ3d8Dmt/kEiTKRW4LSNgCtSvozNyBtwadWVQ4nu/ClJM+vbTQ2vyqcs4h1bw9++diOZx7uG2pKgyUO4nYnqpRWKexa8EUwiadpL/vLTsJUPUn0I3hpqiUAvz7Wmyu2v/QkG8JFLzSTBJcfY9jCQw91W3Y8u5OZNVU4y82yFaNcjTFqGSuSaOxEig1WUkNIhjXOav3jL0h8I5hwxBVWzlsl2ABpwRAaw9GXo5borYRmq1G1Z0tIyBF0O7X8qm3IMUKGCF/I4tyajNFs8LG1K9DhcT+UVyXGHlw2APJNADpQ0bvPLBzKQ+FJYiY9RL7KuoA70BeH0m+MPCCAycll+r2VRwN8nCf1ZwwJ/mG6jHBjWpaldILselVczOQj5L3bBd/9mNU3Tcln+3So8VNfuspbo5quDh9iyQxQEf/JzTxq56h+Q+SdhUMK3EVXQe8pmByUpIj6t5Nq0HbxwseCj0lyRuHQ3mlZNleTRakK8Sk/ik9NN9JrVYHKNtEun0Vzja4dvFcZCRV8En3trrJp4cGv1Vv19NciranE/igE3LdE6HsVEz2DjQ3KWZzKp+1EyAZOiTZfNwXrez6ZtubaU2Ob6l6mJpulo2n/ln0egqD1fvyjtsJIQwN7Wl5FcwnvZjNVeu7M8Kw+/Un8FQw7SPks3eQbREaTrGbR0Mxr7s/xohTFo667lR2g2wt+5/K14nt9Xok5oU/vhCtbw9bow5Rbk7xh/740F5lP9UmoVa04mvT88p66nLZ31eB67qv20NIHOabvHCRLBGicyewcURx7xIKlf3VKt+I0XbF9TNdDsSevrm2hT/JjXfLNf+4HNaGHnX6zEj//nPeeTTtipSMXGA8+ALIDkFLeXy/j/821f9NuOqgCt2+CUHssUCjizm0FouGz1oXh4Cyeua6jB+tRwDfa5prTDN4OOQDJNALiOhnc8GRYvmPnd8PTC1NOqa3qZ1kzegUfRC/VUE/3hVheGy1/UFLb2QhyPncJmf0ojM+6PO5MFcRW4wHXzzgCje8lnkGvuK4XfDZbpsy73cUu6uACxvwtEa9JBuguSDqXQujOBEZHxhRBIOQQ5XdKIKxTRPYQ4EqvxjPENHFgo5S5kpggzYrrRfh6obridkW1yb/ti5aIU3m4ZrsmvUILXZt6+SmBftcochnw7whN047xFlPZuKyPKip5AlQa5qTK3t9LEqgTtyyyiux57MqzB8RaBZ+eQnvXvdQLDYSRshk3DbPfDwqHzq5X/3mzSz50W9UuVULZzBQ7IbChHJevByvlYHGFG2mUn2YhF2HZaocy8goeMH0jk/5Ftj7DPYNjjhf+YNacuCycE4cOL4BKCl5sQIPE/BU8u84N4xbaMy5/F0vkUVbr2dxfO4k/YIPL4PZaeegjGQeRnleHx9mymQWSbqzmu2AopISLm0uxEt32NoUnTddikFw6vXA4c5yb5O/gD1U6gcCaq7lbMNXDOi4wv5kkfTI4ELuNLt8q4De0cVnxY3UIWeNMA/Lh1bYf4Gvmdi0dbzv1M3gSlMTCzHqzxdTdj6RaVo0RkgqijPOQxIc2pBZVFb7R+Eu68rGl6gayGx6760ctfyv46bAg2FxrMNFdiBBilbdQo4UquSZa/4OvQs42Mpr/s9VwLQrRrb6tTPq7oJWARQ8xuNvRUgoNcYiDzb/4DLOF0YxvZPovZs/hiBBAOJHSVsJOvG400enKXp2ES2TorLw9cnwsVZtYFEg1eLG780pojEmzw5u45gSEsDEQVHqDD91bWca7jmnHljdg2vJAMjjnaN5j9p0ApJqEyzYBVQ0QwgLMVePIcCWlnsC9mQMAtUbNNiafflqJDEzGKTK2UR3ncKHSJBg0gKdaaI/kZbxbeZmncZIxO9fE/5HlbpyurURs+ourka/8kRu8MQcJR9XyQsh/WVD9BJHz57k3vNH+mlZnp1tOWRA0GqQZK12cMaVnLH9+Ujcv8xWsLaGrddAWuukPu+6BImGrf0AVJbdbK2LhTRvQSCofPxQ4vOlbzgyipxHYp13OcBrDC5UaQp5bm3G4Rqd3XWyvsyHOZOctRxPMgcv3RA92njK0hX0csCca9UyHZGEqdM9IIl9sXAxowhXOM39VZKKpa2+YV0Bcb3MpqnZPJ13j0AuWq7bEXOtSAYAybwxw5vB8BUV42fryJSCZkoXcvnAnNkAw8/wShHxrG7FKC3TejcjAkByayem4ySj2+cXANlGA0lwPD9oO3IgrG2ukdV1fMQqgF6rwn0sr1BWY76AVKBRr9Cvm/dd9qwrwupYH6PnxNK+GOBMllW7xZFHWpEsuZwaR3DNikjM3/MLWzJsbUtqKgpEknSPPBZJKhaNjNunbesirQ0GK50zpmQUhO2rYUlN6NCHHzgmpNeVsKxXpufoJJ+ILv/OVo2ysGxwgqf1/WG8uLlXhAlb+QSf5onxEBuTWINkGodB+nNjbn2PKJJfjnNL4ubC9oiUmgTkCn/grT8FYfJd7sly6kxRfiwO5/dKEGNqbB0CQMZsMGlAetScUnr4VmYHRf84olpyr8iIdUda80xWN7T0hNpxXYtcyaCuQUIXgjebeRtDsxl3wH2aagK0e7MsaMYRaCtpoYEmbxPuTFTrosvwTTvvm/yQUBqSiYAGrGpTXA4h+nsJaC1JTAuVE1rTdsjmyINje427oPAw1TctHm8mtA+fDV6ULu3b0KSmHaaa7fCgIXQ7CsIXe63253uEA8KYW+VRq1e48smbyOaFJs+01KnisAo1bvyvctV/sRIcHDxQnDyfyz9SRBpYWatD5TsmKpWxqsO/sK0IXjR+v6l7UwDlpy4ngMqLFIwB2N/lqI26LbswSjxnPyAumxhZUEjZocNClodTM9c2ztopoTwybWbuaTauDn3uig/OjCRLMgGupC0zJ93ccIwkjMTXd6CZiArymzhXr0trKdY/tOFeOUvqcIsFTEC7UJ/E9+XERfxR7arsNcqmkp7zaASB4OcL6YnJVV0l6KFkLNfXCvieFgLtAlRd+b4nLcNfNeAHfFQlTxoR8mMCsQ8ycnkyJfGQbr3hIBu/vZ10YgFlg5Fyt5PQJO7+OpvkoZocxvsfnWODCm0oVhP9EVFiBybjBchYJpG1LmEP/g6AP8EyrTqfs7anpr+NiWxWYpsClKUILfELnNALsw6VKdTfwumIIoGXqH7n3MRRJRYHuAPzm3nxkc0jStIOGCwC8uPxJyws6n2lSh30t3n0VzvYLigWTAkAl8hN5D7zeAa8vKK+FlrcCI+DsLwr40kaiL06RgCX9hIGv87s/Xqoc2RQbjsJ4AfUVdvfplBWjPMvRgNbhbwxNCy4kkbUm/TxZzi0G8+eQ2LRiwalOfenfPfQNXOQ7VCIySddq8pkYHi6nIQYhE4GSL/Ynzk9An7GofWBP/yqAR5rwRr0lYkPRYZnP/HLW99ZtAoJlmE+ojqSrZRJspyl1LvOkc307GQoRsO+VgxBQGjIEvKDg8JH1AZjVcRd9cFF36EOA7Zma+S3+5IaE8viuMhtpnFYXcX7XzlikbYwNOheMSunsIoJCm4D9zFz6ltKOZ/LW3J0ezhaFM0gHDJcAyyV7ugkhrSL7zqYcqF848XxS8RNDkUdr9RGAd9yCwKrAdsXTI8TqvZXr2MP/kgNcOzRlIfAaiMq0OStfYLEmCNtx+N2FABp34hE/CaswjlVhqi6aXoSmAXF0dknf1krWhC19gkyObY7swY78YJcZBLUSw4CVcuNg5gEqRCod2xCu+WjWaVonFVSvkCJwIFk5LzL8L2qv8ZaFd02qV+Yf3SAgvp5ufZl2IgMun0CDrcN631javTgs3zVSQ9lDfcl1k8hLyK43Ds2nVGrwIPgIsCHT0B3Be0KdWSGaf8h0V9W/YIYxLeWetgVzRmSM81ITZFSNxJt1BlpuNhgbE4kswj/nkafbQ+kZ8kZ4/aV5WJpOsfWJiueJFS82p02aFIaXPT3DGo5cZ66iidvsazQ63GGeR8Ff5Man3MJfx9s55LFHNpMwNoZslhXwG+dfzMHdRZkfMCg+Yalh87KgxmsVWQjpr3xNGrROZBsX1Bhaby0QizjdEoU84mF4sf4Hzai7aXgU4P0C+enQRm2B0jUVb6f83OE0Yz2L93sdRcPTocLBIdKgydtKUUtCDJDEtZH8k/Vhmt8ZpWatu8Mp2X9Kd/MLX+EB9b/8vzZ+RdZL24f5BIuCu2dX3fM/SX/u+YuLDHaFNh4EHa+S4filXFKfE26U0J11BpvFJx9FLXNgA+xEWbKjxB7oZv+rakZka6XcRFDdnqtp6JU5CJivbZF28NcG/BBVtbbSkfJYrKz6qhT+8CYTFdbUQDtvpsTHCoDadZH3fEHmLsBKNSubOZJw2RsPRASmUziGFvCYbXmYV3L2p9HGoG4RWbRHRrFIdTbhPOtvuC6g7tr5j3v6BU0Sl6OxRKw53kMa1yft8VL1Tok+xVm41DC2OGDcs6Yk17OAqQFkwMO5tYRqo15wrCVVzuyp5gRNqMP1jBqvneOFF6HakdXyqcRy0pU2GLLiINUgAabm867u9rRrfXzPo3zqlscC65eX2GQ77Qm1bwbFcbuUFJS2pOqtvTtH4DEmDwOKfPrqwJ7tvnv+QZVYakckt/E4wbSEwLMifRbu90HTd0RMrw6aM4p32vKKK+5fq/GxKFpxI0Nv6E/FaGIPVAwXaQQOqFPyPFJxNNnbXz7KOxoDwtNsuAigE4LnfuS/cKC/fRmJ6iB/xiI1VaZUYHdcn8OY3isCw3MSYBrpIR4zsxVpQUhE3GBVoCLWsnscHvJbWI1pVYr80mCHQIoMXy3egv8I1dsZD8/ePqxMIcRPJp6Dt0H7f077pGHIEbm9k4T1Or294HHeNr3yi87tAzAcyGOXHbOvuHU85T9huVWQVqe5OA7/w99ABMVQmMIbYDa8jCL47goesmnUg8r2QjHNnZQ0RBmuU033eFqLEwlJzWi1q8ANKEJ5cnNxyX7jbj2FXenYstcodt8bcFYkGUHCdJxsrJAcSRCU2D/1siU6ldSafNQGHj21Mtuaj1h5dkdlu9odbzejtZ3/32BqHt7OVjTO1KfhE0TuStIl4E1xBESSDH3m2vqiIJpRuwDKX3A4fh+Drv/fiq0FlMwUpGv7a70E2hfLDaUFhylrXccwy3SwoMG3+0x6gW8zv2bh+gGThuzKY0637w7eYAzMrQ11tZJkWqUD/5GssN9ROr+BJYiFL2Fe6tj7FfNnbIRUhH5KAOe75O1to3LNmRJhgzcZRGMmZYz4iz+8ZnMYki3PY/0sPStEWJXAiOqo6OTASsCvIoogPaJxlTvXhKTxhu4FyIU9UwnYfWuVuXd8BmxbsmPjYg/dQWnJVLJvLea+t11luI6UtWVsWANPydK3YYG6VMvfpJtZ1EnbFMUv7N+USz86E7xSEs+1lCk+jJcGvkeHM6xWG4538UHrD60T112EqO07N7ZLcz3rK3qC/RsTI+P7zgfdrJH/ZhZtnsT+52SkYpW0CJpcVp9G90ZI6v15gamFmUAjYiH6LJ8KNiuiRQCAYHxARwiCQMZdoSAmJl7LRiKhZlXwQigg+ibcWMXHOYawJsOPZV40NKCSl0pc2YOvMO9qlpfa3M5TyCR2nE9QTzLXoUlWgKtPKH3AJN/NwEMk0E33Jxnwa34a8MTZhZRQkFXYotfXGutATEagrEFQwTYZo8EHtgiCYgv7AJg1UaRIQQDiUKMa3UWFl4GyApQHdYAvNsSVopz4w8WkgIwTdeQwwue+N4jyhaLPAPTBQrN07+BJeGnFe2t1yXfd8Y1xz6HHO/wbN+/nNeCaWEJYSXeJN3QHpdNVa+3s3WHfQArrEgC2g8l3s/ZJCoPIbCrUM0HkKmiS5h2JT2lY4bBw8SA7GvwQcKogec69Z/0cqt41s9zrp3GlE7vdt9MNOU0UB6aqJyRInhN3K44kYecH3DSQbKgOG7+NARXBNfDW9W2d/abgi9/feTP/2Fk5NMt6hY0nyDT25rq9lakCBcX5rTbm4hx8B/BDmwT3GGTYYxJDA+EL7VLqpWEmALuXp6ThlQ7ewa8IusCdAVwPAJi+gB1Hm1YUMq6LS3ZhJC7M2KuHRIxkimlhYGthsEZtzDbwDNVYtgTmXNgQlQwLifiX2Cn9an5IbAbQ2NJsro0S4KoxP+7vhhRzrbEOKBNtKPFOEDVbKZsM4JDBV5FVSG6rdqvy/1a3GU+ZLMKuo31r4BJvsYoGvkcaVNROFBY6F6wAu/i8itrjy0CH5VcgBd4FHOr4Wh8Vev67OAKCOuUWXq71zKSxYikaWlD8T6Zs7kytTuLN93Y6SX900nv5t0zEaZL+D1I/oJlOGj1Rn4ztKTzUUllP7yTD7Oh5HIZyCtCp0E/XW0ivPsbklCu1lkZekOalOCOTRmeU6djJhHRMIcj4UO99HIiONyFY2Rr7IhId1wVHMJV5SEki1qUJBKhHDRwuNJPJ36d2ILwNe9gFW+kbMy5Z7DY9xXBALPU8t1hpx+Ap6px9/mpcuyLSrlHgDvmhHfcUx9PfgTyYygwDfilrUF6uqqC79comyLlVjJ9fZ2mg46kdk0KSxmIdaAACZqB5AcX4GkDVOc1EujyxB1gPJDpfvb7A6CHYMqvk3LfS8xr9jbozwbjAlRnALv0O96t615icRN8LSSjTvStwpzM/4YrdflaDDCu5maXTk77UJ35fMaDdwg2/AVYJUG7w6CxDDeKXA6AQsIaMGHk6egId+eftp3bW62V1NBlQemA71ukx5H6SShy1UKO6gq+8PuVHGLwZuzR3XpL24i157X3izLEeO2ClW9ugM5bcj7NxiRB7n5HNmwPmPpS9XCAOkb/obftKthOicHlxvvX6HEtT2POa9i4GTS0hpk6VxTUxUPthZzXyPHRTvkvdFKF2kzecn1tdC8OU9Bg1Xcfv3kxsKJG0j4H6DQLmTUur8IjIyWsyL3G7Hn4u8l45L7se/VonJnD23hkMOJrGET6OAf3FpUzDx+v3y3hkCO2XS4W+mYYGuAMGdCBwaLi3V6Ddv4q69iu/59Dp6n3LIPz7twzm9IIylDLNMhWQEW0xZ9TqDRN63MZZH/d3i5ytTfGi4mFunhzVENlzgwGraMxHNTU08muZtZbu4WGiIZOqmGbtDW2jhlO0Wf3V3RBDMPXkbsSu85Qybya5USPR/Kwi15wveEOgtiKb+vWyoc6sY4Vj+9d5JZH/eRcFVex3DeP/VPq7R3iNcjAYMTDe/lq50PVH9op41eKc9dez/4NIVAogfIsFugkDkhZNKYZ1L/ZajsTLvd16e5oukQ/x+nsZF3KXO4WKz5+ZwhyNr1UbcN6WjUb8b2iSOmoPIg0riYFSxQKmVZhloP6cntKcAqWlI2I5uf/61Jmb4U31SpegUvUsleRtAl+f/xp94GnndOJH1wjuNY0L8ZE1eS8aFbjnJUTM9yWkn/E2WeEH98aS+qbP5af1U0yfKTpxUVhbXhrbfMgsOQZB8S18EU2nt5A2CIohLleD9ZYCqcMsg8H9qYh6AhtnBVXeDhh6Z57WxphYtXqmu3GNV2vxqGco4hQERQSXtszZHTafZWFkXqzRoagsRIX74otGKHjAGM97++vGcM1mmp7QLaQ67qpSC5cKVlyO6VSQVEBUWg2CNZYbx87qE3vC0S12L9aG78ZGos9SBdSWa+qYZrdhpFUo6ahc1YaaCFm+e/rcT63O3djK+vgVHazgSfM7Z044HJ8MU1mT8U+E6IK4RL4pnhyHZzVPKs22aY6UsaE/tUN1KxIV+8573CfSjVOe40iXZYVmqGtSnkrQA68arcxNpAoTD/ntLkHQZYkVC+qmhE84BEQnRcPMhD/7RnI/vLKmoIWTO4xapKXgxIwvO88Aw+mTi42zFezGTo/pCXmAQwPtUd03j68fGt9Ba06f+G41TXJRGVmqkRnQZo42aRPc8pfjze4mduMgeFKykg5TBJ0q519JxXoyd+a9NJu8pRtj3R64h5DkewKFGzhXri9Zl/O1fLD+g/mwnoZEI5w7MJQm8y/F6AIgvq9xNmhmVmNWFGqag39VZ/ULf3DhaYaEXNhZBswWe5NVBQcFMWojMKeHYe7ecpitA2ZLmBp+6E1StDmWuMEMzT2/hxRdkLO+FvofwnA6epd0lB35RtZ0lFyvxWql6cYYx6lILQDfIyfcMS/UI3+469wq0o+SiNSO0szd/VA5X2w4XNsnfE5L3d83CFmUUPOX0Tanx5yp6f6O+js8KRJ8/FFXmeoK8Uo2hpkBJJlicbl7cSVtSQwxbryDMYV8pNIsmQ6eiFXeXFJP03tYljNQNMPPk+xiU+fYLZJOG2mW37mzW6aV5V3tR+qM99okCZw0eWsyEMgqJbeRwakBIKhjaQNaB8T4WX1K1Bxkzqku3zosvmWJ/pIC+eTP5vfQ9o0YsO2lAI4i9ewrAY3Crb6xvwUYhZ58sr5/1WJHE4hoVPq3uHYkroIS6Ly8QUu5rVcj5mjlzKuzjh71UKkbLsC48dEA3h/oXN78KyzLD5WDCnIlsJvalCqoJRipylcu4hXjLM9zaIX9YMvhm4jAat8/Kh/W/gIMziwzWrWogshI4gqmsOZAlGAc32oqbP5R3OrsahxmEJ9pnS99vIHy364Xji+d/wQuuejoeaA5CcOGnOhJKGhXVq+H7+nGEPdRHGxNkF/tDEeuhNsVUNh61lOMtT3seox9OkaxjDgzAD/MV9YJBvHWDmSQMt4uyQJ0B4FXgtRgVRNeJjLhEe7zi9M+hOHuyTFY5va2Ve4700nSSRzQ43OEJ/5NOmOoDc3iRzLdvW693PHJog5O2FvvNk30X5ea6lBGvTqKkTWxLhaJXowDtzr5PNVLDg/CPzY16MUVRPDJkRKmiQyW7rClF9QGkpv/kUnLnqpY0+PKt5R8H9S/fFbkpYqAOi/yTefFa2Ib8IJuae4ycq3LocQQKgW0HuP1qB614abzsdrEtrqXcaP7bd4aaMsENSWynZWIMcY5HpBfRSfkx72cgMyK/MHvTMMp8zzdG/Li/MMA1k5jaqwCTENRYBI3hK59FrYaOEDZb8DYBZZNSu6Icegk5Xp8rhLUeK9uBzj0MVouzu5O/YyYTfp1UxRixaBxHFpJZ0vMbNPIb2UyNkiQcfazfrcVCIJRh0LqzJKz71OD4Ups41iITICrQBQTf+/zl2zL4uf9HZqUIB2oEXjM8EXolMuBb6Q6O8o3kxPCYYERK2TH8G/Ecl4KGMbHo8qyd4KdClATDX5FGUgQA/25F8xKwuHLOSSPos1fDVxIBu1nFMgWkngGSxbmDc7rZvtiNDS2hDeOJg+Npo/xogv6fdUvqr19tfmWM0P1Lt6/eHKyHxgoD2/M8Mw0Ay2JdgH2KASkkhNK9OAaX2PfHruQHT4txLeSJu9uptcKA2Yz1UAF6pbHxPC+EXo+VM9s/sXZLUXXmHToaUcryQtWpYsVES3psTYU4YPm40qqqesg6VdrPULdqtzfxNZLOE6uq9DLGfLfFGEnG/kh2eUAqi9JmDixLA+G1CUk/wZ7mcsndiuNJkbasCrX6Z/5SIWCWPom79ufcCd8McL8AJwUWdxjN/kUoEWNZ6o4L5mxhN4oSYJZYmHcvy1P8mOn/6b951sNIGXPwoeQR3V7Khg+64Ck0LbMktp3/uSybhDT9TQq7dUp3JrKGPjZ2QZjKEyXYEPHkleXiolMQjz4Sx0uUPvqCcx+crTLfYUIcdhFul5hy8mOFED3umZ6lYcLU9Qn2ewTWjA2nbyS9klpQj2vTFCQi/goga/QG0nb9AaZvqd7n1DQLQpvl4JuAnQxOmubua3qSE3iDtGJPdLoEc0SNgGIsCWWt9jAcEzQSfJKqBJG4bc2CjnMVqpptRA4baKBA4BYEQoq6M3JGFOUdsMZhET2LmU4TYzfZ90BVO88h0mwauMYLtAdAzQg3flxZnNE6CfTz2L9jYCm+Rn86J1Ebw+spSSL8fT4ktFUwX35LcN+i6KTpZygoa1cufjALIwt3h3+7S853Q7xE4tOs9bYBF4N/tSTxfaPMQUGRatx7C/pbDOVbbIPKiio+TpqMjDMwZX0tKqMIMqrAPVZkG0o76OPY7/vMepdemy5na6zzZ2glQSfFWebYfnRYZGYqGdlQJRelORU37au61nb4a/qzJIQQhONrGO4xiiabLlAvkZCBCiJUK+zGEq3DMJAI/AXr8jBCpYWHVFjTCMHfPQQ0ADwo5tAb53Q1Rc6mq2g8TWfEAXAlciCuA02om61fZoy3yG96i0iC9w7Gob1I3cEh9UyBvz48b4xNYlL5Oe6LzKc5weqyHImW6KVHFg6SjBWvtSKvt+WjoNp8QCkOW/ft3zEqQ19ObFGB7wL5F5+Z4e7BxgxeSTAyfk5IbfKwXkOmojsQFtoUN0wjAnnXqZ56qJJXAWd9Yt/EqLzX1B4J3+X9jUSN+YWNKDyEDvHvbRfQ8ilGPI6ccDEDEE1nZHNFeDXk58CAcC+T8oyvQIcHgpPuR/c5om2i5zIWOalgjs2W5sMJRQ8kFfBZSEXXdUXjnjNQMKVHCDOt0HoOjxyeOyFo9seYXA3ihpp3FQwCB7eRgD0he5PsloqUwCbd2zUCr7VV7TcB8tqFU2165QW/k/ObXgt7afyR918UT/KksOeBVt+QvzWzxh9z6vdOGzvfx2hG8bFWVZ6e1ECynLZ3IczZ5M5UOGzXzUwwevHBxKNcd1rgv9mzbIOLrFnYG7QCZzcHq7xwoK2EwAJklDQ4to3MVMkt3BiNk0oO/oak/K99pCDo6X2fwvsFKmP7Z+Igz+OAcMAyEhNEaeH8BImR5qMeXPARa+GyzqkJ34a8zaIYiEa1kJq2pM8XKgi/SwG0dyT5723zG9WLhi6gd1v37oDKr8c4H/uDMS8U60ESXaUzZBQqdDhe8/2R5VS+xDEMT3Z0roHLyjugpfuA+yOkptvvAIuh0Xu3ZMVCkcUw+NedVPrNvUgzIxji+pHywUiAVlcx9/04bJfio5V4v8yhTAInq5VeR6FU3cYMX68zVVPdDLpz2mBDIeixd+bE1e3JfFlInHhAz86d4uuhJw61HKY/Wk2FpOJhqBavjHypZpI0wHtcvubzi+EY4XB9e/olACk4AEmk4QcszMV7xEcddxgBeS52coK1QV3EY7NUJbhCffQ3AB5Fcm02m8Q6RGJW7SkA/4DUQCK6nqjb+CjgSo6ChT9CTeYxFJZljMCuVMF1f55kdVNEDyk3I47OENlDTAZbWchIn79O2Nk7cF+eeqkvng0xtGjjBQ8KGnCFgG1qfRMtE7mYgxI1cAGUomoauDzaLrXr8DUPv51Y3dgLDDFNrXxfKnsFOTb1QKbFm003Ozp0s+Jjtq0CFwUIuPUneA2TYw8WKfStQXfyukdUl6BLNr+0XY/DU4C5ntJw2o3COxcDQ0QfPH4pzatBkhfjnfogvaEyonJiqT8iTMvvJ1iBd0feZp1r1Wdx42tKMmXMRYZixVgwa8ZFxshmvQ/IhCiNEoDcjQ185bzleDQ6Yhfi+HrvJk0Hzey4MnWYR6tAea3UZ60vSNTEwIaya+wPGsSSv1uiIli8RiuPccvKv4k9jeR8FvY9KJNiNbP7yMngAqVX3oSOwMhJs5BNh3ukPTHyERBg4UgMsdXnVbnjw/BYp7csu0q510BqRPDXtLFt4Zh++2FsNTx4QTvKmUpcaPRnmWXdIOYhAawdLzbdSYtM9QXlKBZ9mgpFfWUgwWHfdplMGIDLkI/xPV6GfUjw5XuYo6OhCS9GFp25NsuBDJD7gxC/gObkjNVdfgSVi0Ra7GQjFZV+lmUtjO5stexn1Oxaf9W8T5sNqPxuHdOyNT/5rZrVG0hleXWPKOMka0o1qR1YEcd2tLTJOtQqXo5yrDvVV66fopqAASmfBhasDsip7IkX1Sv2JxLYDWF15sJf1WVIYIalnWE/woAvEC1vDQsvmnULDKdVJlChKMT2/HEoPjWZ5Kn/VHTr/VghTuTZDCPfXJjMd2UN2qKuNRl4kcTHTJahTCPVrsXnP2AOfiDMOrPHSAOyOYqgL8YfTqDgIoTk9Soj6mJV2lAQW5SXbpa4RU6ziRmtXVRXiDZAJOpLEqYjtBC14wB7ALztVTsZ1MtTlfuZJNNNR+6RxQPYERAWd3VMXlad07v1iudNgvembIpRJj9aeR1aBxAsq+Xl6xa4FaalNrEtBBerlRfoY4j7/b+WCG//DNRmRSbjSnQ882CmbjRbcAHITocViwTS2JH0zzkjtu5WYoXFWTUpbjSIiwgLTOcZAIP7BKo8SZroAceFVKvw4aP2jwjq637fNVJNvib88V7mBxS3OHAAG8fE74/zThMMJ1HmqkFQHFUvT+TKhJROVeT5IDYilXvj51uJN2PEhGiJpXIAY6HiX1OqNNS5eAwQGsB5iTTt+v2qHOkBehNbcCOr/rkospX2lsR15P9tyoY3T8tKgDLAQJkuCz47MnVXUiQ3tW3s6bUqwoRvVZ8vvvV6b4qf+6MoocX6FttsfV2KrW1leeIEJIeUyQ+m2NAUAdQLoARgZQoOnGt3ZLw668qEW1XG8K0Tnt3evI90qDGL/62w7hDDNWDSIeWcJrLjNBumd/0QSYyfmgX/NIFqK/2T/5QJS1ZH1eMylWJSOj3Zfdppl1BTRcDQwVR4s6Z3/sc9qqmgwEIL4Wrem/vc38zx4Ctx0Lto8E2y8FnY0Zt18ETOuiebTkrHw31WBP6NPZ2S20c9lHfTOBoTiv/t+ILgTYJrOWhnCItv5dyv0jR0WMdFJdry31hMHRV2j8a5ZMmKbk1Pn878+9tw+cGOuFTQq6q3GouVTYGM93UQT+qme5a098XQRfmwmO4iZQNNhCLEBX2P5UxFYykYsPxTtR5Lgg0FzTO4bTeAbZ/qC+21cQd4/yHgot+L/VC461AmU30z8gl5z44L9FzCW6bl/eaDxSPKcPCN0ca+O0KFIZp0JKDbnRkrVK7i/JHoU5T2Q31EQlespqOUm2agqg8vlhmZTNVS21uyPNRCwzcQ/MijlYZYBNTmbGj67nAriQcwTQALWMHrCC9+iLg696VSqQwtA1TDG0qExxVD672ji08xY7IqEg9vTgNp+6kgToSbeRev/j4hGultjZYso4rxI7XwLDXVZXhipt1e1nAubDi4kfAhojvJM8mNpRfQMkUxHDZwbHoxP/Yoh6CExDkpYreLMqfHAbvgo/Hui9t3C/03OQohq5QoVYKK7ZqsaW2sopi08d0akg5thuUo8CTq3w5NwnzSA7F75jgs70dCPdbxZhJTu/Ztzgvunp0jpjC4H4BzWaIatJ/bwnkUsljRBPt55DCPUwdhyLYlVc3Qdf6Y/3FjLZ6Tj6YShDWpYlqf4iQeJrqZytwH0HteLhFlzyJHJZPspZC1Z/47OyqYBKUFghQPp3YUMqQTfwdmkIatAyHKrrBfJ3XWG5B0hXSz6pDGfoc18aweWOtrNdcf6yLU4ofg6Ak1bp84WpBAv7sy/Ix3vMWX6wOnrg49Pg9oooaHC231knUha5VlgbSEhuAOlsKKvdG7CXfntsHD6DKC9qPRPMxvra0GODIMATSGJEOSNW9+9iri++wUJfm8Oucm55XbqvvVB91kbT4G18kcURc8h2qR+rAPaOPdEALNkv36YfUNqopJzJ8Aj3/c+gG99Iy0bCYo9PiEedNo3gvD33MGE/mUmYXu/HCyJvnET3ivfC3T5fxmEaZfqIpqcfAX/y3BtcQpV/eUYuBb/m3udFp0jJxpHqI4+8LfSHeJao7O6K6YXGqY9b1jimweFXRWYY7ijpUWa2o74fTw21UXygYcngvV+nZP/j6eSv7eGqmllE85FdJNdxIZZwYqaVB+NWdO9A+V2BdhvmYxsUz5GcTlKkNYcaOpWLgxFpMqBHF/mc3Jy42sB1RMromezU9Jgy3bF9sSS5PPRgJ1+QSdVy3icq9h4gaFkKaVnpt66CSVXtDxZAA+WhITfZ/aY3PNgHDZIS+PSRTpOzuewB2sb8S/v926uG7FH0AW7kXGG/MTFMWJWWq8UcV4CnRiPOcwGes/KQvW5/vj1eLlhYRPTYHzWhx7mCe9WqplAd2X5sUcr6v30RoEFcM8hjhtNL8XmgAS0UyB4B90XMoSZjr0Y2heQDrusHZjBw2HvOQ6C5crdzxYEeZw4kNub/PAeVb6KeuGcMxyzinowqd7Em0bAWbXu4YDukzz8QBmfEBdXoCzbzjwusTvGjVQoC12+BqEP71ktvPZSKOvztYEVkbgrRSJihrZDU/WDdWN3BBjFTwKMPboFyyEl9/ETelGBQAb8DUrN8OeecTjbiqbZ1ne/w08z6QkIf/FslasuycDnfVMHbFIWiocX1nrYYkVNMNEzstWwVMtsV3VObWXitVicaqJLJt9kdvLTlNP9dSUH9RHfMVAs+AzEPX8BeBSFG/c2wM6+exCfQSA4Dm8uuee8yi9aPlMdQBI/XHehU/CBX8ib8M+hrwmVAJI5ken+0rFDcFCOtO16yUPBpqFdBCcmGCry6LCL/dgm3uc1gFGzovUfmftMbvEtSCutbSfhxBdqkGrqVaPcToqv5pVUm+sRlQOdqPJkTtIsAvqwUGd8wTXnwgLWbHynO4Jtymaho23sVNi3M0u/dzTCq1AxTkMn9WKayJjijf8D+UfUzajtl4tC2B7d759lI+KLlnfyhum7gZEHek02TIxQwAMAj3dJbAAWlnd4TMSov7Mz1AWRKcSK6ECU91IfRWqfhPZqradJso7gEMs+qI0kjuYp8LFhVfy0y4lV+zX/pzOigZYWRJL29ma6Cub+M7LIHmp2If8EsDWPp6B+Gu7sh/VVkaLR756biW0tZYno8s4IN8Htk/3CH1Wqx3SHA3UqyGRmFp1pblAbMRNFHWHEmlYgbzAbD5P+yiJGebhDESxs9L+z9GM3e5v8Ninvsz14Fhib6TLoADIHegq5wgQrDSdcAQf8hVnu7s9AvwYPmQOT9X76yj4zjHAJS5y35142al410MJlUepmPyEfG1ehTt/rAkGq3CRzAMv6c5Wl5IXlXrou9YXIj8Gh1EVPyGt8rrPB5DS95xltL96Tpbk8Z6ukqZf9E6sPnJAvyeBbEqnzNcHgr+p6LmFiOR7RfE08+ob9Giz5GSRwybSP2mxmSXHGfV+so4sZ7+XRG5ONcj5Wu6O2MV773oqkF7qEvm3O2sZRzaHLCk6ns6h8+xoovzvU5jhEIUDuiLy6mAKkGFfobmNYOaeXjU1ucLeqIuITIT0Q3z56vxndEWfnGejGQv5An+/sGBDTWLBrLIWCp777iCdNwVp2H8j93k44kT9nA6I8UnbJ9tb/Lzculxv4uj7VtvOoSiAetXcEI6aTt7MtRnPSOnKvgk/pXZvlOXFcACMkThWzQNQAzBm54sjCe499YmhhUei+Tucx6wnjh20GCfUkkMTwa+0ObhUd4Qt5JreXkW8kceKSR6DH3U7vzZkCB9zYqPnL3Lzx8WWLHU3jyP4iGR6qAwOu6AOAo2nnmPWTgKZCICcGDdGf9s5ep77cCZKNz73AnOgcHNPIpgTDDDBi3rUuVx7uYj2yUDsHuWH7jYAy2s1k0epPN2yyadSWAfcOGonZ2ArGm9KOiTgmiORxftnA0PiX3fZCA2zdKwJo3dRKJpYiyC3KcOSyDhIW9M9c2nVYCj2pypWjRYXqWmXhJr4SkU2Dnf8Zw8BidquaUAMlSuj6ICFQPocMDWeL0OEwrRh3Z/cdUVZOAIya2RxrOor3AykN/OVUkeb+urANVThHVaRaibuUMgZdKPS4HkFn3OB3u+8mo9+MT91G7oynrEZ+a6h1/80TY08yloCZa+UhZwm6ECqrqAciD7QbQBmZVutlDD0Jkp8dDIjN+3/7/eBFy10DPGgENJNuYltJtqySzifF1i4bZvI/qEuBg+tAOLTaN+nx50aoPnAP/5MfTJgJUhiAofngSIhocZAZiVwapalPszdNBpTiZyn7hxe7JsVaiRXtn8xEhn/AZrW049J544c/zQshl7h/KH0Xa/M93o9MY2eRnYdMTo8ysCc1XLkYNjtjtB9v5CMMMpN6XuibY7EMkS52Z3nCkqmaUMjgx2+OLDajx765VJfsgcPj+wNLjHdwVE8bUk3coDTcrF3Pf9AyowpmA0J2pJ7KA7ki04etK9yIlanB3CdRYDnFPFX0KMKK8sfinlp7rNI4wgZiHJrfBiYHDGOWvNHwLkZfpTgpyYhBp4N+5Q8uOHXTSfoizqqbcZxK0F7iWYmnIAsLPFDzMrJkUbHLd50CLNKifXQXF1tYq5t997JDtaQmzRJmFwRphrPXhSwP7emI/2SXVMeq/H0S3Qkm79hwWYC9pchWeI7OR8WQNvbZAzqQyhjjOligjIEKTa+EDVw6qUjTmgy826xmnClVQPOyRylrdwxi+ar2PZwEEaTEiatoanGXcMbWa451xA0iKJ3bRYSkzpxPgChHZEB/tLbiZ7mCAiKzzyq6805Jejb7k7nY47aTCJxLAjfGK4ajGGlKXUyD5eMtML9Ptle8iQhEE5JL/E7LW9RDmMr12EQ3vkQhqrLEZtbRzToftafbWDv//wp1cnegqsUwjl09KOwTJ1bIwe59eVt6Ss67ffmFqHZhtBo9J+uaI4ZIt9j2O6LjqnQ7FvWCB+d/SupnB55u2tu+5lBuisL0EaQMk2v8nakzvFXCd9Hyg4NC+T1S5RiBpNERHYfTxlGwNovdNPyCp50tK8edAmOs0QHftyT9Ktec+ezpvfzcVF0KkhAqCqyiENZVLmT5sQIkUwjcMKM53U1aD2f10DcnoeSDN1oXu9Vs6l45U1xVn7F75cjcCAnvlz4at55K1yLPEtMO9LVNLXS6y5QR7sTzQ1uB4eA4IIPYP6ipUdjVkjEV4s7HWPW3jI3aalMR+doNm5S5UeOTrU+yW7zOBSe7Aj3GG0og8nAvDpVuBUlm+a3uwzAK/aIrSyjbarKp+hv4+G7WqvzFpONFXuD5HCJKQaYOrIsL1g9a2NFUMfzl6tDFSOM6x75+FLf3VEDFLgi7qd93E8daJjjbQU6EZjjEuX2U2dIQbOQcxsvNkyQQo3NW6wYmhIMYHagtcjgPBgFQk5SfamaDXG3FljKRA+zpCEh+y1Z8omSXnqB8FTpZMdn1TGBxtTtRsPqthlFprqPPUHTUBYWeYcSgj4NZVmrTridMPPaYtHnGtmq4PkoRtm5rb6UShdSbB6L+hGrkEOmM8+fqwF2WztPWCEV7S0JDnbNkcnVCqBGoVrZ88pF/BX5E6WogjsyM3xpv1HmZmlthmQ6LyKqmS4dEa8TVTvcdtbAsx6JaM/x4u5anM1V2jFkH69x4jP3OzcPZI40U8eCp8m/8piYwdPpi+QJN+OD+biLeZgvDkPf1KU0pwE+A/mYUgTVjYbv+jZUAW/pvelols6kjo7WVilj/kDl0AgvF0cS4UEfzbVlkHaPl8/thvljhFRjwHftSIwBYUGDZIa/OAO9tLCAp+LBijQjWbolg7Elu6jlKlBPi5/a0DvL3aCG/11kPFSdOoM8cLf2Tb1LTk1cxxrW9j2o1MPCmrrAsUAK3FV9T50OsmJYrTxpSXVauQ5fkWiShxJCnrZmAdxgY+YwiINU2uQqX+jLDCNKsVsq1IKFffNVMFYJxD+pDFOYUBPsvvsFgrb66YGc5aEDjMqlCcNiCgTzSlVy8nXKUBVfu8lJ66C9VFVdO4XJMwwLcUbUb91LNv/QxzH8nCtLUYo0b14meKrmjcIg/x3U0UCLzsR9MFPq2nqEvsfENJUMhkUgkt+GCYdQzEUVd20rvr8lWVfftNmCrDbOS4Er4a+nGc0IE66mOjws3yxX3mwPdXT+ZLWQ8St6LreWh/YOn2ZDAuhZ8HEofCjvET6uvc4eMLAhMGObUDlofWKG3llDXSGpfiNhCd5GJ2abVQ01k05q2wuyrAZEjiXf2fy8SZlRZFdCjOZspZVQQ540YLf5QYyAqkMBhhR0EkdROfhKGLSsIjPmi+W+8F2oTeKpEfH4GSRJnwOwDiV75iQH3LcBBhd8dIbu9BHo86uYgNHkmBPD2tVTh0BKNa24G6JeYDJCVZnTuhpiikQU1YUEA9SeR2XCanMpORRHbFHyKEafD6K8AiHroQlRKPc5mB3vDt8J1SsVMZfXe1/SMcQ9SxOdSIye0Qn9EfZqtDjRI4Tbo5jnc+yz3jH/i5o0bpPqauJMk+obyQR9LEbLCv80YUvije/x9/67c1aRtD9uew/60HABtvF0KfcVHExs2ZVNcOJvor5DUm5aqTxBWw95m5fdg3RiC+A/ttKDg7wxO4z9mScJq4mJhnTqn/it6It9/qnpaVN1v1t7hSWSG+GkY3t2YPPxCLWjnQA0Qaj8ekY77REsvF8nBDFSHFW301ul5612Qqp7Q6JEOiGP0DGqRZ5DM69Dd/wgf5asz2dHJgxWPuCLACeQw0SA32Y9RaDlJYbjPbDllaY2jIa6sDZMe7+EH+cDEs2lmctIGL/AlHUbtRbWBmBl8pbRHGF/5928rFtaI5quSZxenTM8/vZCqZQ7Zy/gzSIxsnUOFoFB0yyo/tk9uSd2A6zG1fdggbp5VL9HbPIxInLLQHNaILUPbbanfgzvTCajupqc9raX0T3ZvUhhkrJsbJC3zxwxRylByK10qEqy0/r/MJcbwAT+3QdkEG59s/eCFygVPEyQ4jQymJTkSWyTsTiQ5OejcVU4jJ4NkLv2uR3Q+ACHM4ZwBVn7hKvoGPYz846eyWGdnY95B/0xs8iQ31UqqfptelMLzJopzv7hsWr1qz1jOSeNpsB1I3v41fA7OqMNhRoWVMmnvVOffHevHqP7nmE15RDXOcijuK07BSoLAYc69Mc704W4ZIO86m7/L8GCxs6jHadJvcalwh5z7CPYYuWjXIbleK50MVwJqqP1pOFCRuV2+xYci0Ved8AL4bxwpCo60EvJA0irIMpWmOVNNQY1sbrEaZmaX30znqbvpHGS+dG0CAuErbHWEZiJKJ+Z5T7gewSWrntGkWmRMj4wacTO5UCAkhBKphQFOdZOhxDvNmA2LEJ9mgf7/1bwxIfwkEeyrvWwg3mqRUSzQX6bTEezTGFkXdQ9Q6KU8xCT1zn5JcwrYDr5cfaAiIz8gEaepR64EPmv+AVwDgZZ6UQaRnfPFd27SvAT/O40wRZMj1Z45d+bq9fLRsdVJJHQrUNm1Xw/FtslHomVUgkCcNA6TM8FCW77L5fow7wuxW6Gk/WxQ20aD0bymKjd1ZSvUAZ1z5XN9n0KhCooek0CrlpzpiLpBeJ75k8IUgUb5t3I28pwdQXPEI6jMyiZdFSi0BWCnPPmripxDT4c6qpx6EP3kQvv2zOmtNxyJP/PLwQdd4wwX9iJJIOIZ1DGh7eOZiILZw8d/u+1lFjlJJ9gNxtApJ5t8q4VhPjIdOXtcSgNsK7Gts76Bu5C+Z6IpQypbufkO6/Zm6jczq9IjhvDtlF+sUTR3q6n+WNlMnv8Zbd3faEpB6KLqKjBtV3zcwX9l/x0TzYyrqmr7H/2CJHgHg0rSx4I7WhxccNwiVDPQ+2RSqtj693KVuT6xPcoFe7f3U3ENhwV2HNhjWMNdHXF3vUNYE4n7ZPBUzf4V9xWkf+/hLTeJKyXjXgbXn8uMb2TlSSzQ5fBMJ1i/0cD8aOMzbiGN/VaIGzGCpmQSK4YcvF59a5vFH+pcVFZroEInCLvgv+X6pLMBzJjE643YanBUEZLoLT0yZ/FyAt4+zCz6NsV1vwRqf58LANa6sG+plLFUDmDiKqLugJNkj+PpPq+lsDR+YerP9dVjUPtrzYM4ddGJM2d/8+ngaYdh7xpzDkfVT0U/j/Z2mtRzBk5iIZFTRrFNHYehPp0MkZ1hzmYV0Oh61NEhlowSVAJXiVtz9ElXFJaKmlc54GUrAVluPtivFJ17iZnBCd6w/85hNpaLC8xnnT/PqkL0ULu5blpGsSGDPCkFBXXnJ4h9fygru5Hox8OM/V/Gm9eOOUT6N0tYKCh7NQruvz4cLY4rSSP2kHeYPQd3d3XR/fE43MvcJn44EcfpkIJAkeKzhM41EhknDmGeyJUHpazHhja4BEwOrADTNyHqYBq99XH0P0adZ2XKJHE60UFzgbfxwtV9BEP8S3rbsUo/D3CVe31UuaTl4sIUzJ9MzAyHAzWUJiYJ9YRH1aURAEKtpGwiNTKsRJpjW1+xuA23xW+qmjiepctPuZT+U+mnoGwOUIYn6oXnbJvgxZZN4QJOKnyDhDmkAsEAH1JVsRTHhxrkE1vLPKrJIZTkNXNS8HQH9vwjZYCqAKUIxvSVWhcrPxxxDqNLM7pAT2Agi/wMw9HG725aoSK61DewxLe3b7kHuDZL9ZfKtPZTPhDWBCa/u1B3mGpqSs6d6RTSd1XkIKvrlMR1SBEpwRTjUOP8gmBJVbpqFJnJnrNLFP70Tlr/BQEfZ9811B1dBH2LUeMc3jxqXEvJtf1YX6FdYtCFU1wOlEfPZyI2AUxkYq3lhDg7FJTYxg7P5Jhq54l+rBqLjrL3Fe8sQzrt3jZLZmxLosl77BPfAsUx7m3mzoXRGfim45vnFWo/70rwWQZYxneHkKakvxxWxC5RX+B1YvJydcp1GDvjorzt5BsbRyHxT5LZQVUs4WGICakzdKUg8SBUzxjvuRSlqCT8H+idraKrLbRum74rx+KI3/qBnwVLE/7VK3rPPC2mZ8r1nEtB3641+muXAFwjGZJbr98XvpPy/G3tAKzZVqhMMQOZ9s9tu023woBX7LyUseKHU/arMiz9V1uRsRSb+1n8gJt4fdgQVPrbmBwLK7W6vW8tovxXhmphNa0z+eqyhgIRBxFxRa8uj/Ew9fdIf6nS2Be8UW3VsX3HlKTi3CfOqdmnSyeX0LvIJkOPmh/nTcfu/5nSCXBnMZYQ8MIYV4jnQjVzJEGq+HwRS/22Qk8qk/yi45+azgtoA8VNtrmQ4adNGnZ5uiM23jOoSsTC9CSiywTifIAAWQZ+QG/cb7Nq3yMcAzvCWdfK7Lw/CEHOnPPVNuP9NWileMsQWdvXvzHFv5r+jGCwFhuyTV4bM3vThRelSJZKS4tM5SH/gIhblY3UNex1TZCaVzq4cJQK5FNUUlTnkkhxuL0vWXyicrlBp3uIkZwZWfjNm0DYApM1bIXEaa1BHh4cl+XtZeMJ/0AfBNAQ0AZZCSTXoPyIm5kZR8AIaF+SU0+lgeaqH9DNIkLqZJqrim5/5sPkJlIrW18E8jf65gYF6l2r9Lxfm1GiV+oVqEJ9aRlZWRrZpka/IVF0bGrCyA+7CqJuGXsXk6SQU54hVIYZdifu66SkqoSoJ+rHN63cnPQyEHVtWedXlvt2Qpu8LvR5vZBk/GvVSFCAQ2isWQj6XnDPseeTVV+XG5Yv9saek7WwmBE3y5qUrJ5aaSLSy1WjGx4TWjHKLES9VZbtw7PXEyrEpC0Iz/JkV10rTD1cfo05BtYB1P1xc+hA0RgnNfxeTT8Ltp0H37T+uYt6Ws2drlttHpgmOsk+iqYeNEN1TeNFyDgurM/epcVLvOcxsjL91xzC/SDJY+ofPJZQcMPU07C6GNnQmupoAS9IvR1pXcKYuSGHy/2ebmnrOlAUELjMbwwuDszdf5mmEgzg3cDYwLUKf0PaMe4wJtPAmJRnagov3y42LQQRrapkPPKC8f+lNLYlLGH1eUbXz/2HigyaI5Rvwz3W/Up6iN4oOieFIpGEc3/cTmcXL1YdTHpfbZnorC89cq6zYfGgxB0sayMPHz8gPO2NWyMCRWDGRoSmmF/JfSxwNlCmPfodjJApxA1qP9+BC9Vjlr0c340PqQifEI8d2Pl5uI05eBvYf9uutctkQNnIl5N4lZgo7BpcTIaqiVOhWMuKrJEGR8yeS2ZLOxyfyzRgCR8752RIs7PvuJzYvMHqadxBWf8aMEkVmVica9woXg32cFEoKm5O+s8NpmWvq+y5ghFYTOEYE02gAaoCeC0sZwRxv53hw1xJ518tMONPtEYlWkCgi9buF6KC/EpnXT6L/xdsbEqKaZCvjIoapfxum4g6IQGoCV2r97qrSgHpPcyyfOzolZXTxgyTvwhsQs2JQbfLOPFJ+NBzKazibc2IkEN7jDfSHLxHFXAAJp7RJSu46h8oJ9loHA4IdDnhLxkA9+rCfIqQPjIt2rKCy2j/x6XElWGtC/n89iRhMFKkJ/m5STj2kvSBLjskKS7EnW0dVR8z+3v7CoFxlMreZqQbZyYAuOzHil7zOXtHxieoEOfAGOiiXrXV/AXlwjZBJeCwllBh24PuOMpoeHC9FmsW7csPiTDs3teAVwn2VTKGZagVD3BA6yhvdC/YoKvltAvL5WkmRD8LwGt6diRLgZ/D+/w76lBNvQgqK8Ng6a99zjLND4bRUGYBDIAO5upf42HdzM8MkjJT+/MpeYhh8R1CJpQph1mKneXb3S+eSjSSzJonAbN7PrNG4SFwBDh6LnH7Kjj/bF3KZKm1SCadxN8UzGDR8DLKkeB2/fQX8mSZ/Is+ntjJ6AmARQga/3c/bTPjVjw7WpQlBfs8+XL428yGUY0hGlFFJbE2/p9ts2hIX74cNtWjZdnKrliTD57Uo/yC7j8zX7PZp591NHq0Z0RNWgTbAOUrvuCZrxM10qeTzOA3OWMuwv59dW2sTXqnUEbI9M8olkDrAQ5Ldxxt0zH8kTNGW1eqho+9cmJnDjnwKqnR1s2obq5cXzZy+hVwDGiUAWUqbGmMsr4xyvjkztksawS24SNNzQfN7uVp8nOCOkYTcgCIdyJYO7uG+tpznTs0i+qROzUHAh0m8w4Qyhy6j1mTNwXNoDYwJyO9eRU7+Xeblac6abFnW4PwslkVgzjcr9DNc2DkyU1g3UJ1feoIZ9Y4RO8IDmLK1HRlXySPYVrsizhkNvZeiTdWddTqJxrRXf9CvSdKIxViRbGyElPDBa8bg1O8sX77YFszNn4K0m6edYzPm+6m7mN/SZXk/Rm2P80vi2OhSp9k2+Gc4G1hsp3NNvQ8s4ZJh+mcVv37nrPIXgaZA/V/NJ2mGKs/1aOvN1YR+FAaSgWwGdQw9RSX+pPWb5/SoYJudB+jvnDppu5UJa3D3sP60MQopp2+of4GVWHnwO+YuBBYW6Fl9AVXD4t0RXeZyVmIHJyjpj13Xsiplfc5OCXasnlPvhGc90EXOHSKGHWBi5fLqz5sQqDtUJl6C3e7GvzSZ6Xx8Xq2u2a5lly4xTQk9YF8qfJtGpSp7AGApNc00bQ8TOq7HQopdAnmgHqVJJH7zCOj+h+Y9ysILn/EDXzF1R5ZY83YviZawedzPg9JLbV0UXZYjWWeRw+3p2qYLoFveZFL77bgE5K1ZHvG+wIoRxzXoa7rQ62dGz5kbuwFMlCKfIKiDThGNejSfv8cngfLJi6AAGNIZOMxvP2jttXJsYESEb/N34QH3sSVuTWwDoKbXd9/IGa4U3Xhd2idI9nvFHJ2gPO9hIpRPO2dp8B5PSeqvFQfccP743sYe/D0FNxc7sk0/h+Ndm2PrU0lRbfeEQtoA2q9pECjYfDFiAXp9s0UgVjPShlZBhFifwq7u1IfxxX0z66d7CyNUkXg6tjN2EG9mGxWo6MTvngdmKOauNJav/MX369R2XZSPwbCaxXkg1Sdgoo48uKiKZ6X5OqjWTjgwh23CJkmkZtCZi/AkkVvV+mIwX4VED03rycr0KD5AiesUvIVpglelk12PWAnb3fQPknDb0o5/Ll656K5/sHQzitkj0P75sLY5LzhJcp1K1k18YFgpnIOHuicjTtMylyaXORRQgJ9uolWCuMIszjP8aPYa9Sol4NhshI3xJwmWzFaTBqfDFK0F1cSO8I+aX41v14gGtJuvt3rLYopA/PjzLgmS+W0fiIQN0ALCEtgMc88Whh8iIgK/2t1+lCkHVNLChLpgVt0iyNQM+rqunVou73K9CMUueBqQqYsZWYceY0+jYF4YqvL8DynaqmFGgbknCv3leqwcjEGATGSUZyWAegeuq2M6WbRkn0p4YimgIoA+qxdCsqhkZeqdOF0RP68MwaWFgy2/asLCNopuBhedfGxnCfYbW4jJkPX9n4yEQmTlMENQUpTXDqRuMNawViLvu9TWSxecbte2dXPDmhwluF43MoIaX98I3+EN/ptVc+xhZlsFDxHFjFsSzXAsBalPy+Jb9db7l9U6OK3RZii245mVJVhSfT+ei8BUy8wrqiqXGDvezR9Y3OSu0TRC1RXu2lNFeQYPlQWUbD8oOHi1yLd0tp7PcdwuYuPMl2ET0dx+kP2UGrtXalmdNfe0ZFO6+fjR2HPlv6wgW43z6+CjOU/v6ktrj9HXlE7Y84r+Y1RQQzNvLlrZu8oBx8AvX/z/3zXMkp5gw+oIwmn65xP0kbmROEzahyf+HPNwssWVs8FK4bUacEUCycEQrpG4gBqXtxVaZYYbJGXCbjVZGY8AGiTcn60X4SmNHViZ9m3NJ4boxWUAUy3z9s7J+tn88pIl3HJYqsOnjwvs8T/aikJt4oFRRJTqyhcnddajKZ6ToXYOFYY10aSkCFZspua/ia0wZr6RWGCTOZRkRjWVqKu70wjPySttbqcjFpeYsojS2IWrlSMQlqRKfUlsAolcgL9HeLg8wvapNQmCvtOrGShBe3/2hcwpg0a/RYxNrj9H/0z1gyQAAW+vZRgkGidjMhhAqggamXGbGhF1eTAZ+sJ1CgyJllLrQ9QmPyB3uhbFKTdfbh39pTWclE3T8kMKbPSHGXXh+kbnpNWry5HA/vcwbl6h6Xka5349KSZXK1cr/KGv+8Se8n4ZGcxGorzMlfpzdosfsb4CeqrzTfFAy/H8Wsdw4x02OnaBaFwDNZgNe7ux8NRbeL23rhRLVmnYCgvXlv0hMXDgbF3lT3mIxoZkUdo3QsSj7gLxxaQ3Rw7L5ZKgdZ8/d8B0qG2uWP0fs/CJgY56PR5VlBqCK2E1QVBQXmUihVvtTzjwOd6722NoQTisRV9zpZes/lRiNysfINrMxpCxU4s+N5rvNRaJjvlbcu6F7kwF2hpiu3gV/XwgjoPjvlkwQw+X2J/Uj6TRzLyyt6D3KKFQvtX1j1VDWI1gXxeqEDer3CGXBWmPGs8dGTgHmEup8P2IF09ddN7hFG2H/ro1fJVZl7KwXJHY2cf3YTNAX48Acz9EvJMDpWryr6MD8LrJTfWoVyDkiZdH35xlZiEUx5rTKa08oO4H9t0y7jyaj13FaYBVcyx2X8Cko/3Yj+fG23tJNQJbKHwY+XmZ3ibeTvOOfObD/Xbx56oAhH3Us0eeCUlU3/ljPNuzuC3z9kzhhfVdsMNffK+vthO7Y2bbepTd/YPup3eSo5z/xmKWO+0Lp6YC5FaAytPAxTc06H6ALyFkaI9SHZMHfHHmp+mlyqOLdXK87PBXWBD6SqBlK41SnGaZRM+VHgGAqe3pJaF0Wsf97b3gyL5Yrd68ac6RFMidCDrK24bcjukg4Ne43DdBZIYa9nRn9+iESFQMimZLl+sv83GSxcNSZFZPTyCSxNH8deHtYkS9S1m+3EtaUYSf4m+lIQqWi9LkIE7M1n1e03zRjktR0GoGob34U0tJpRZcGSirI9h1FqmtURLust0tiwVL65UQJMzEfbaVB6bOTD+Ku6AFUda6FbLfddJfG4TckE97uvQJQRXk3Q9YwtCKqV/ouf1GgCliN4kCd7SeWCW2k3aqstcBKfkQb/wTDWc1dwySNhypS8WqdHWvKBt7LQtowtdJarF8HW9YuWfULPCSwh/feTIUfv7qREcXj7Zf3OOaYLFR2I/JSklgYQ4cV5ctmoGZM1kE/yV+9zZ+dmu3+xQRxobWxJETpTANtVb9k/RjeZyl66v/i++oeGWryljGKv6F3GpucfQ0Mj/bgHzy2N4ImpjPCcARVcVOXsiGjdEsB6rBT+TcFR2yZog5rqf2qdn1BQoXfKMakcA0IOx4iU0GzpTsUnh9YRQ4NrnDMO0Rdf6xTX7557hRmqCknqi4g70zQSFKyDmxwjEafAoXulTzg7/6I3q4zCcHu53dzmPVSp2VBAmrnMKrrw2B9vsnNyuKej2pUxEIeI1sKo5j8A1H/3MdanaI0XDRvwC9H/Bja6oGsdwlhEzfAZDMW1rMJwsMp2gc98jyuaxSMYivXlNbFcGG+IH9dHld9l/lg2vBIQzcK7PmxTDRv2rKoK5Hi+YO2/Vk95x6sy3utcx7aq2w/L/lHanKb/Kyf0iAncCm/fXSe0QjRoSzI6taVLUoL5pNsZPZZpUDeA6z/Yewj3qz8tmuY9jQphIBSmTARZWayxTiaQWdpx+e09/bFpIRPlLCvM6AqH8pGJkbeDh8My8Ea6NLfSsINw18ag4FdXwZrZNYy+sJajOTZjQFu3YCXVaw2ykSdD+ZPSLJFDSisfYS+r6yfIQVNbbm4jl/XwYOpysP1I6/WKOAyvtWVH/CETsy7XHp/vujboaj9h6fnVy72IPtDLp33FLUV6ZhEU0ZUOSJ+fOzCSyL4TJY7lbAJ5qpYGmZ+AQy/xKYOPXiVGqWLnPo3FvXvwHUCYViycZTJsyScNlrXAh5nA9X32KH5wC6jdQ0KUypaoP0iOevkGeLXkeN33T2uRellsqoLDxKYdEnuECfC5USeWcO1hlm4NqKEUOB3bMAZLVXQw3vbHt2stIqCQN0Lf6AB451giK5YupMF8ry393vSB+MSp7t+Ao0A1D03xyRtFFr5VnrUrUfi2/jOXPYisLZ5A0hcTd1IF/5XrvjjJ8qJLeLjEQXQMS8Ia2zjfuA63llDgeN9kYZNWdGyPt8SGy12qYwOIjcpfcfkPW/P4/uTA5LoTEYwhy+S7bwsTM32kZQhnh0icvVHITZ9TObZj1vCet+McDQExlej+DG6AFyAwHQJShfBwjPLfIHqlAKTmGC05MDPWUgbtVCNLwY9ZmF66HgPR13rD/dG13kPKLBWvDCMmUyPAfPS8uzyK//6UbhcPX2iJkkzy0/qpQ3YPrRKA8WQYhkHmXBe9d2JU1m7lPnIAmJEg/QTJAf7EQY1eKrO0NI4bqibClIo4W6tHIISSk3hq39J3BDL/pKc/aTCd9Jd+94Su9sONRiyYoSAA9qSWDPiFNq24J2X0RQVIiiwdxMdPZnqk6kgjT+3K2LJ1LSXlZa2fEd2mzVWOkmCfB0AEEr2QQ7ucp46EogwaDwngKS946dpg6gvZvayjJbLa7msaoj/os6YAEs0v3obzVXrvmOe5syTZF7pBRKx8fZtgntx3L9RPjxwS7Zl7kFn6e19WLWSPi7v9432NxE08poxWhmfHUPxho8KiNkVvwkIv4Fs2FxhtPzeiQ2v46GCkoZxagWZi4W30WBO+d5iH7473xUxG/ry5AOQdw0/pzC9HM4wQ3DnSO8utL2n+nH41Ktqo8dmX8O/vrZu6KF5F7T4dtcvOpsUbosJoBemjouCkDkvGTjkioj4AaZpN4/AbH3pD130BkOjlle/HmFqc7xnR7UbsgtoUuEbHMI2H48DqIsKJ3w6m4ZFFeW2rHkBL5/qczmUH6homK33nQAOFPgx2npSEZCj01C2cAINo/I/a/QBbpAqShwWzh3BiDEpGBpHt4fQCcGKmUCQjuRjE9ovh/T7eZZLp5g38uD7+UvOkEurmHAvRlJpQSR7tQjr7JoWgOMrAS89HeE9k3ZhUX8MLVfwsED56LSikPJtj3/e03AVW/WZf8cW8IUYAL86NlQ6x6B5Ba+Vinj5uvvOUpEUsqMdC/YDAQSBFtnLfz6ZH05Zs1ikWOS+6FnEeJbFQLbc+D8jmqMvYKMpLrkKyxBjacWlziA5QwFHQu8HIPqWIsvSBCqtiZn4uaiCI0N/9FCI7gofztEIt7lP+QfQzuiuJsdZJybgMHk2fyzeadq/G/E40Sz0iqlZhoBPLADlaaHH3fCoMn55HFtx0G186k2DOlK7852KBJ88YkURGc/zmAKORv9+bxAvEUOeWcWJhIDuW1xNOXcHNO9GZLLN664M33aXfXLmZxR/b8qGEWpgvOWCq9CsKaCpCH5A8M6fmUx7KWadd1chD1BYE//mDdmO762K+/kEVWcmHUX45Ar/5Gkf+BElwWvGrayHppJB58uGCYZDJclmmgVGq5Fz6eJz9oW/n60c7CyyKxqxjxBH35j5CvVr9VOcVrty59BOSyox6MEq70+j0oaOCaKdDO5G4PIRlDZiGz9fM9Hh1uSfT6c679VpPjwmNbHCA94PK+BToplBinHA2wYMYJz5tEwhYHouTMLFQNkh4PKeVuU5SSyhqNq/T+Vh2ozVUBrOmPHRf8lbyIuGRUlcjiUgQOx3QP7uUZ0XHUGTS+GonxpU/U7JSRNyK9bfnI5sHGpA7N1koX8mr59I1XvJF3EPCNHbv6EOB9f3bW9NqtQ7ki0ch/6O1xPiFS2E2pMbZeL6yobtJfT017Jk2+YiB4gaiFXE8RPNLQlSYPHiGhPkSiqGg3aHYU2TpFTDBifWKAD9uHcnjRzYHiLp6xqTCDT68vLasQgEp4qdvtNKeT7iM/NoEpY0sdcV6cCW04Aq7vK2ek9kAo5BvM7VFx06xYxxYynqnZUo1f8TCMGYDbuHC6LFAY8tLNzF3JE9VLhBODcbbnI0kAL8MZi7owMZ0UBaA7kVEMDDWcZqNa6SI52OVsGmaDDF87eT8rjF88nV+Krna3CYBdSGnwsqzHhteoTch1fAlutoRFMQ6cOuRxTltag4Z78sGgOM9Fi0w+t88hROKqn/2yJlfZaBTKmw6V4Dd3ga/JO6Jrr3C9E1Dgh1cS9JU7n/vkuPlM+2ZtbTpw/sHijwnPZgp99VxO/nbWOyYnmMqukw92QmH4/OR4qdMYO+2sHfpYc6RvFSYqczGnXZE2DCFJnCiZTId6jM2CHp7itXGWHPgM3Nd3Yjsab47p+aj45w5sXk6UF8NdJ2lkzdPFyitJE6NMLqozBmV0uhU9l7ZSdnSQEuBlWLWLCzHj47gFJZcGaQQJlBdDY274nOUBuJ+cCnOe0iKMvVCrW/VSiEZVdfavaNGtieQKU2kHUFhdXlMSzBV6e+gZCneqKRijnT7598bQYFxy91VQDgjfdh84Iq0XMMnrqdJr8jucprSy7B30dtHkiNHr4f+JZdrux+DleEniQIatlpdUuv//pxHIJeIEeyKN2JZ0rtKHV5OoXcXydcDbjfvCHguucdeaVzXHbs3mJMCvd++mtGN1IJTG+7PmhgRD0Fp2Z0dywywF+S+gy45I0razBc3NyuGz7453+jEXILDvZzrdLReP0taLODQWHwSNOOY2bGIjrJo3shSY4l32p8KRIdT+p720vgStDOs0S20pd0KjXNrijJ0oE4HgN38851n7Zi3e1xKfCbRm3LioKRJ3Ob3ogXWPBxyDt15PFr+OUFbC0GjfGeNsGTsBNY0LUcqBBm9oNiNs1qapLbK5+fBFnzJyBh0+VlEWLCUSDTZx2Wrdwi3WSey4Gm47Xm9hiikGFgf2p2dpzoJSo2pEnHFAwgppuNfHaKfuq2Gja+CNuDfAbJQvT0NStD2VI2wAWFXN4mKGOvSydjB51RiyiWXElZ6uY6l4x0upT/jCaq+AEAo1tP/8W6ARTUz7sLesOR7FGKs8qAadW3jsWg6/Dmdhl6IRhiabl9KPTfq+8jqWZq2vSY8z85+TEFFPe4H2Az8oi2gSxKuVhV+et3dtgZLZVhRxqA9i3a4OA/QQunxDdVU9nwlsD4KQM9dyyxhKuvdE6hesO/aeqMhzW65+Y0rNzYiZyJSBe0Pbmv9ACRIe7YIo8dfwp0aXVJXnTrRT/h4YCEcEouK5/3jYgkKWqEDLlPkj2nnvAeNd+0bLHUhF6CFdUz2+L+E7itKu5an5/JpGOAkuQ+ZLJdesGOBIGAKzXLoyLzg4ekQsbzhwS1uTmP+zRdRv1wl80rILmfRQ8uW9mcxHC9GdJ9A8Kr+DGszSpJ/HEd1zX8srBB9l16xycGIP/w/eXutiWjiVH6Pr/QsEZYbqk7DUoLY93S8c4yLWx9QS4Mpeky4CmXb+X5Jklrk6l6AR21NOyv7DgqLyCHNFqc0SsLi7v0k8X3jNcuLX0kJ0JwhMDwv55FanO8DOyGqyypomRj9tBMLes6jE7jm3JfCjFxp2tLWOvXgq4JOg7JcUAq4N7KWOApO8NG/84Es9p65Yp6TsD2vvMDctX0J4brRXtE1agUKLLi29dE2v0O5mvsRJnGQMZCi8qncjuLCy3iXEOybSwR9D/It3Gj6OowxK5a/Ii82tZVVRR3EY7oNSMGNWeSwIUjp+yr2OugcfPLGp11soNzJDQcLdOJ/5RKJKtB+QcgeZxzhadI+UgPDfto0JKBl6YndXS3O3u9IvrxLTWe7cM2LPCXJDVLYuhWIEqiDqxBZ917IPUvO64Pd84GoXUM81+WIdQoIdgDia8hgad0r38CkkTglNUCm4JQ2lVekHECV6lM52eWYPjo0lZ0Pbh0hcbZeIsQp0VlSLSVpngSM+9zp5Vijl5otLgjF+j+kCfnsnB6EsNPeqCpjqmT0YtIuRq6H9GzKjrhN79GG3b2z0WqXw3gmaf3kKjg+h19Lk6j11U6CLaA5C71qI3PsRcSmDsASttp1usHLHa39wKyIyv4k0q7mIyo/W2pozxQUr/0bzadjiaW5/wqMTA9yJ3NT7/jF8tM6IzsovsNgoPATK4PqC8rooxArCutQ02A8Vh1oOLqhFvxlFAmqvZE3lnh2rvUtRXuH5jrETpYG28AnySXCehlSb7q8E1zcpSE3Bzd2Ko2Lsf4hfoopH8hrr7cOdMzDB4oLa7uEbgcct/1/dDZdkHEoDB/ICiA0+qY8Or0yUxBbe7leOq1mQTQZJDjthnn/6v7BM6hxKhrdVTMdm7buDaHXliNSg8yVF0br9xqrXBtoznt15JD5RA/8VAvKIwbSsc3wKSnkE4BYrPtP0igFquGCxEUE4KcFiVVajIwRfSHZuWqb/Jfbbr/SPeR5bpuS/dc9PuAijMs2w7qFsn4y2N76fpbjBAaNvxGkLI6x4yBiKTDAZwo3TKcLangHhYCNqLboKu3+zKClmNx1Yu/9GMzd4FviknCu1imLs3NRBTr/QBGhwLslhatWBXsJbNH5aHwnYHiQpO1FzFCHR9WL0IBTyjItwX7KDqc0odqZwv/JwlCh0jvghfTB6yeav2nOCQU4t4+aezL0gpx5NZdJZ/QKmvcsVHlye4+SGzWeo9J8F5baowXHqRAMVAmYIZ/qsu7jBPVEFFpNoAca96XCOpg9+W6FhZByYAF1ZyVlF/97HImaw91HvA6eJ4J2NKCpMWhvZMUMIlP2UFHYhAzay7OwnU6QWN9I63zip4ESbeZTX3a6CKIAxLhB7tBTg5gilNX8sXR3FQQzVv8INhvpCKIccHHFuw7TkDNe8pRscZo72qQOkP4NZ/3krIZhyXnZpg+n+1uTJsj7O6chxW4EeE0s3Kis3GM50p019WXiAQBQo+8c28bW6wQC1yYdhtPPt/tVY2gFWdQxxUwGSVJjv5x7AfK95YkLfZqi4IIdkZGzF9hogYvOae6hgo6CFaS/FtCFi78rl+EcYiLnMVu6dQWEdYPHGTmTgwtpECsyiumG0h2GS3TpXrXQZPvTpORHOEw67wbZ2cH8eHOBf4tiP3U/afV6y14uCImnPymoL5wAJgg+x3IodVYUIu2acl9UKVnAT5oC0+BqrqKr7VCHodwGsplRU2URjpwY4BVho7mHjSHMLBLqt4L6Jx1XswY+Rr9KpCqjFMfuuNHmuPfvpthXXMWE5ZYyfNGlPrBRjo3+Vr1ueirE9ywjWDJfg2KfM7wDJ7eADwVWOT0IDZyJqkeAtH0WLMnSombeleVAyfRWcKxPdEUosDJTIgnOF5sYgcU/oUznc5dloFZRzC2zN0LPHvGZ1DqgzqLep1E97VAEimOKbrd1RdHOQTnA5lcsq2aik2njVbwL2ACHeN8DkC5sAQaZeFSPSuS/H7i8H1wv3oWviBOrLCN3Ck8gptxmyIx/Dmi/XSGMYPSHqoiANZRTbN4tesr7MC6tCiB3NfdZ9220im0qQE1TypOsBanqaWqQCFWSpM7iF7CBrnr7OrAaCs3xDmUq0vnJK8gfabiPfZlVxAlHfSTb3ZFt41vLdH/NV64pqgRulnC+gV8QywGSJlFx1S+MFkmW0VcPa0voz/TnOsilQEHKu/EI3cuSQHTlkBa2NxpGsIirCOQn53d4wqQlf01o3GBd5oYixcnsCwwpo3aiIPQYvSNZU33+WQEpiEDlCn9996Jx27O3XedMZt7Re7Wt06sV/sYsVjElVIVM3BJvL9HuwH7O2BIWE00YE06fCfGbbvlXDClB2Xax4uPRWMwCSqc+MqYw06SKbgooIqJpADhIpvQO/BiUsZyrEazsaVjcTfoM+AmowQT64OYtiYK8oT7YvxFgYfQ0VhrwZhSM3czaSkkjsmX7mKpzRCAATtvX8/7Zc8rRULhd9XttjrUmaHKkm9TMrVznrffR8PY93+o2CwP6KR9tXWOWpYNZ/VdDPAQ1q6yo4wDiuNK9++BcuZ5PFOSLng3imEq93H0MSYSPt2hFdLeElYsyk1X7zZr6roN0iYnuF+3yErbs/T0XPrCRhP1iCdTLyLrBCKKZ+t6Fo5KTsFuoNgTTupkIZOoRxP8zGLZWOWqJ82HwbW9aadWdSOeXFvqfnOtnH7M2De3FoqNH3knvscgO8tTgFYzpEZusozc2zUjFrVqMM3LcIGM0/K7j0di8bqDstqe8OMMQ0kJAlRdPTFVIul5x9j8fb/K5K/WBnpSDaC70xEZWlt/js4IHNLq+8OOvMCc8r1Rb5aN2hV8o2QrTbzRX6KU9mRv3/DxryMtgXkkYjIw8DdKw+QhgNTMwTNA6RT5no2lLi1QPvRgAnxokeFOaLJ65wOcAF9LBHyoK0n8zDl4mqkBI+C3odb1tBgw1IG4W8sXSaU73wOnQ0reX4+yqUVokU7+CLW6Wo+miR+8VhhTbXZBS2374a0yVSzV1uX9efMvYtzXShab0juAkIsEg18ZNh38LSRI6m/xb6+H5ZoFyM+Ses2XfCJBXvTUCjABiLXEoHIZ+WGJfX/d1WlPkYd12n+PrNYWDVPW3kC/R43YbUdDBzuCMm6+uU5gSO6XWpWMMcKZdCU6jeg5z5oYXpAL13+7toVpZwRHdeHoyjH93Szu2ejJIyIMl891dN1LWmsjmZ77ogd5Q2Ekl/zT4JkhOeSsGm6yiUHYhW+DQN5oPo+JCp1i2amg2EoYjMb3Nja0W9YLaMJwKmIlHaRllcWAilz218CfYg72hV6ZC70X8ctfn/tUYliiF6etXZGAazjzkWI71H/8koKQcs95hlm8YQPb/Bdt84grIxVCbHAx9/BctfcSG3L3ebqgx2GwxQFFoZbonUK8gH+XukhXDmvw730am+uxH/x0DM4n/Xsy8Jxsl7Mf1f5Tjw/L9G68pYXUv3QPeOwgnYuJIKr2ombe4qDmqG3U0/MlSUt+aiQlbGqQyzE9JfvENKPkaz2ls1fGkwFmHQPC1WmylsHRzdgIWRlJ+u4L1KGF8IAAP95Y29LOW4fKhVI7vZK4PHKwp0YAKJYusWHl2jk5b+kr1wBKx/qXMG4CzWl2tf0GAsPCBy4+dYrF8+usOoB+d1E99cI9g4OH+sp74ngdRjGD+Y8/98QnWHNGpDL4vnFScn4HAcB9b4hRCVjfoiuKZDfrtTBCwaUV4OPJfhYXdQTj0yPsClZ9nkO3woXTPVk2Pb9En5rIQv85q0dwvWOmxAB9Cqa3j/3zUincG8NEdBf3DP/TVqvG+MFMsNxdeFfPOlY8vRNOcHn4rGOvUJGPjTZAPYSvN2EJ2HH+Z9O/wNYDj3KcDp/7F4g/FCZHyVl2rfRlgdScYmSFvKDMltUsOT8LY6KWulHMsvKeffErJKMaNRKZ0boTnK/U5vV+PUaViqUBeH/oCLdQkOk+pR3t6nGTEgvYqREqK0lTIqEGGWAdMJBDTmszp8GSJvW8H7kiM9QqaoOa/TIy6gwgFk1IlOu0KEMQNgsXeMhTFElq10hXSZ4UcXOvpI0tahaNgNprjEoU89tuDrnSWoMe2pFS8rpP5Mr6n5QMDUtWQSKA74xPC7Qf3b73BH6SQZe9cGesxrQCEwVcLFrWwalzoYnq+zpbuAc1G8Re8QfueTC0rOD8AkJH5WyXdfGPKeg422Q8+atIwCbr0WvbGsYp8SC69pGk1qELGv8luIQAxH6cW3b+gjm9w05tr214T4t6WXSPl7vTx9EEzwtgfs+bwwiLuBgGdbKBll+9Q69M8wuYsq6WAu/apZUOx3Sd7gxCW4xSy7mSFek6CjFhUkCUzDrnt5ZjejVIynfVbc/uaQT1Zo0/VD1iJZzdscyDFoyCO/lA+JNwmxfx/3kq9K5Zx/2rN4gpEtG+oPJTYOC/MAb4WOyAWU6GW7io61UpmvhG3tHYjjlSnH8imSlf7cqfmCxg7rvxNxa/GmJbNJyzlOH8ssyMwWK3JyHnrytVQrMB1bZ9yiZqfWO27uQlzwTiKS2nzJ9sm2WAMsdb5ympp4QtxAPEwWio0BM+gznt+3z2upJj9zHq8sz9e1fRXF9BzEHUr+ywRFWeudyV/qHnxO5Uzb7VjbUP4XEEnSmHvErQaFUSSSssl5NgZk1lCk5agxyhRI2FScv5EU1VhY4FDO+JaGwupLfnvlBrYPl0BlPuqUBYF2G/m4KWtQUE8MGUv/iXE0PSv4IkOQmssWKgj6Ff64sxI2jFqOLQmHXDh9IqK0PTo/kkdUgYkO/omFva1VmxfUIah7QhKD4/gZraAoCDgXDvD5jFh2ephlahGQXQVz8aM6qZXFCCMGQ/OSi0TCA3l+RKv4wFifOErL4YRxrhRzEsf06Kr98CeCRZcggU5iMP9aaEBPfAbTKNXCr/rTfn13TsvxRb5WZyc6iTDlgkwaT9sCHTdGBBcpf8mXtwP2skOY3+GU4qhG14h41u9DFhXfnYnIsYG8CGTqUSJhL4eGikHhsF42jXNG6Jtu5Num2AFqQJhVuWu9iSuAWz3QAzdIk8gC+KrH8dZns53kraLNBo0NDOaGB0vKh/aqAjqcOyU2S0FdkK6tbw9+yBDabP8+CV4jSGAB3Qr8WJJW4UutFOEiB8Cia5TtWY774tLibpOD/YRdn83KgiGmBd9t7TdxcVaBgghAXvq6lrXHd/byS1fNmAfREAPJpRRjU9wj0rdpm/BilOmgiU2nF1QCWjU2aIqyPEfBxszaGvNHK71gtuk/43qm/zw28+CWAMA3fJgSyekHQWpQbi1BFqqzjHEI8UyVpNYjid6alrUyHjb5k/aqgmnPb/nwcwdFS8zt7lvDyx220nc8IyubzvdZukPJdNOrrSfIFZBHSIMCxvC2lx69kLlrwBRSGqbBLXhcBl9R6jt5/JqQXae93YzLoi9p4vbrmKyJKWQPvrQLcSCal/t+hoLJL8G8LmVFGL4xUXs71PURfOaj5xQ02ILfJfblBw+oBsucCzG5mFD6697qW9VrHEpU5jVE2ibkpc30z4TORG20I9MPrqXrTXFRQfpGDRsVSe6UoDrFHu+evFIR1LGZLv78fci4frowqkvnyXjNd7LiL6s6zlzA+VqiwebKo4xr7Vi9A8elPthH+9ku/bosvOO+pxhedXmu4NWGRz+zBVpDWzI17Nui/oP67JSGLVGu2U4qDHJwzaX4NnxKdnjQiGsp1bv9QWYjZ/BouDoFt62BEVVH7jNWYd6gvX9E+pB9Wj0NGH9X0QgF3Bbunnn1jTvFH5f3QQn6rlPLFcSmkwsaS5CmmB2WS0T8LaaOcPV7cvXGGS6VXFb97FAdCvLLJ8JmJSaHnXJT+CWnMDy3y+AjOOZ8EN4UW9/RbD16H0UDSrmXjltAU1WYEqAdPQF4zyBV5ghqpsuXRMRllE0lbautxFLR9y+dVArfFmoRq5wGmpNoF32Wax5LvdkSpBCjkgXvJ/a9QieDWQyBPm6TutpsoFsLayFGZ676ZFF/bwrF07XWAoUZ0CinAWFljVKULad9iSEvRTxlh1BPqzXVEOVyJVnG3DUMUdGisoT9ofFLpEwvPV8Mc5iLlIQXuJRFSdwzvy/4JTOcmhsC6pMHB4LulhqhzYa6+wDUZjIyl9PQNz2KDFCIYnUqU/FwmYYPbwMVNp0BKc8GNzJ/dMZ3u0fe1w14fMyMjWjKmkA+/jT9jK6embUnVDonxGayefh+ypGhlYwAiuNv0uwPTspwigh0bIQtniRRFio2zKcgbW10xYF/S1p4HtYkYXh+M1NEzWMDecWzSKw67SVc8E964gSydHpzINtVGrBw7eaRfNrVPkaR1Du92ynKZphuMamCLvwtqr32MDE0PqbHM5C2kdE259cLzO1YX8GjvOF4/GfN0HiM9sZXL9L6IQJ1qAnhBKoUO/HKnqbXuYGoN4o0uALuRcIJ8rkKibwO4NgG2ltFkj82JpDK6dEXjVnA8tCG8iqmn/zI+0J2XPeHU3HGJbbVDehvDdeya+NAFPHu3N4UV8tNSnetpIGMV/uNXqpYRqCKOg4oXW0APYnyMqzeqqeIG1WSK8rkQ155GJPsYqbgQOe0yAKP+ECf000KYyWU9NfmcLrb57o1E0uq7/UkGOsYYKtn3t2o15uIWjqbWKeOmXIXVO4fhVVaSyu9mj1IKNbAZuBZPn10sdtRJTGthMsAHDaVv5NPFiCmxZdczK1oeMSh7vdRLBkS9UuApVOEKDd6qKQksa8IThBWGRxEdV4i0eocUZ1tLW5G8CfPXNSf2GSUG9zB6TOXsk6ELth/NJ0baa8lhVYJedfZ3MxAIiRTq2DKX1TKVqbOnpQxkzP8ZqIh0ofSAtTk3Rdp64sJLDGR5/Bz7Xch5RioevrCbpEkS6K4A5HayctEo9vdBB7kS8z17efoTEv5T/PGYJUskRXHf3bQgS5xoRu1coN6vKGlQmWG9MiZ5BJMq3i2pHh6NbV9g776hpCotjdEzb0yqmLJrEZ+91X4gwrvU5rYLdVOdGGsk16jybWyX4A61TT0w47RL819oD5tBdIvfBuTt889Jlt9yTLslklRpLVvl6Ko7HzcUIWnVvqskGVBtYnteIV9HAYOInudk9Cpx3or8xlcPGdSRVTEZgn13stjqaBsybDrymsJoAzLJp1MHJNFBWRAlwCodS7zo03yM5uRiVvFb5LHBSvpx13/zY89zF0EgjFg4clYLLwFXN9Zuj6foJlu3gfXliS6lbQAUjhYyAw0azkpLtORHa47/yAgScH6UvifiswItb5rNSjN3nTIOxRUfWhQD5R16lU5OcuEmqdN6qYspWAosq6b74OjvVY9qoYjlZwHhqXnsUAmNh5h00EdqekEUiG2RSTJyAfex5E86Civ6JalN/VebdDwOFUpLLnIzg3Zg4Gq3g/FvXyifsAfOOvR3qB7UHHo6+COWyfkmxC9F9r57cMsU5hur7eUN+HWSfZKE1jVz9j4WX7x9bEm83aJPnH7Sr2ABq18pigjwpChN0pe+wnGWRyea6H72iwGnC70oY3WmCQ4p0lmPUhjpgg8iGWoKBuvnqDDUGRzUNJaEMrLbvZgujwbIlZ/NPf4DgftUW4d8ppMcJ5mW0iiZqyalKlCmb62Tb24IvL5/rWc7aCJeNFfSDQ/L/bphfX8QLW6CzfGrIq05fPA4nUQ7z6cM01kO80Duxh9at942C6ym22QQRM6gGklccsIGBqi6VEKAIfbLExyKtA/BxURIzG8eHWDhMUfC8lNTVDFyZE5FQc/tfIqL0x3iXWYjKXJQtoXK1DPP6iQc2lN4h77J13aPC/3780FNwy25JXPbZWNSP1aKhflH6pJCWVlLPuVKJ3terZDQBnRJlQLQQKty11W3k2/757ud9YscOYp5juct+Hr2TQeNIqVYa+3mH2E2CROOebrgLI1VE6s9J0wocH59kd9ZbEizLv9ta9G+hpAjWwyrPPiqtUZqb5f8mD6df2vKvgkkUELCMfRJJA4RUa+MZ5bCHertqYdYD/RiuosovRa3L4hXZ9EakrBYWV6BlLSdOzsfPsScL30urDZukA4Oot9xcLsJKXzDuWATimAqUM0USBoqSmCfiuJBuxKNVo5MlxlIOkEwVwiwvMUXjKPlrInDp++x6Mw6RMWX+hqj4cAOyOqTBWhYEmA1mwpPfmVdQod0FTIBaJSWNSD+Cbn9xKA5lk5HKXzqn96KEBCP/p2t8kVYEPCpuvnN6nHcRtDg7wBq6GwQs8Qw8IjkW1OkVGDthAPi0h4zx2Jon2KcNXbTFASaipJfUqQXQT1em0P01f6zYgT751NgSoqpRPu4h8PHqlh4jO2O5NUdj413+P6r9LyiRXjxjMdjv5hol+mudT/aBrKijs2ZvO0SZxTFmRRCyAIlcVy3SK2uBIu5XOfctHR56IfXPV9O79xzua5kCg3y9NQfw3nPqi6F63khPCW08YYSXsEf/3KEdu3X4eo/C1wzJuKP3E1sWk+CM1uJ13J4Drw2nC3862/ZXFIgRGrny9zcS/sfdX0LYEsUCVLybAWE77qBhqGziPmPsQcwwphkEexjrEfoJTN4RGvoGvH518/fRyPYxxlxqGhT31Pjuj+F9kTG0pa9SXbo3fhKGQaH/XJtBYKTXA5xrxRXANkGAJCKZe70ozx7irO77XPk66QcDAiuNXGDCSSEvS28yP0Bf+6bogs1HC0VL+BSIRVSC37cREYlaG5iy3lVU4MChQkHoaBSb0D5fXCiQS1iBVVtuh9OwzwU/au4xGl7nIxoUXvaL9FScSIHjLiTJT+GLS3bkcAERt78Fi/fzPd/Q7+7k2u1h0Xydy5Inseq83UbrwEsYmr8fMe9FJRlpyZjsLQYnT6ga07CZfvT7zddvV4U9KXMGFzljYMndWaWneSI5tgPUXOlxMwBmgZEZ/TTlX+crpovqAyLN7o3Z+I91BkEu1KevDNcuU1tRWl2aFzyC7w23S0qVQg3StFm3GlQJsmajPz9ZD/bwGqTY49XtZgHng2yMFiPIQUtUhsg93CG36FWcGVJe16vkaLydjFJVB2MbBAAcq8b7W3Z/tPTKnYUlhj+BB9AdqRG25J88XxlyCTx8j8TWgZr+5quTG9fOZHVp4DS7z4hjDz4x55sQoLVBLIB8piMEY4fOObObbW+TlaVijKS69tX85xI1F50sU/CRHPxt7NlSUX+Vzfvt+Gi3nARxO9Aahakb5yplW1NI0Qtujjj44BwUhmrBR1EpELWOMxwoSEoe/Oj22XwS1r7gIp9zaDIB0DLMYjf9XTeE0Y8I0CfaSOess68/gKR56RAGIcWz24qrhyofwppOZ9JJHVBVU95QIpWhGtsNGECF5nWv3fK1gt5CjnlnEBoCvBs7od+WoLFwZMgsrupOMp95Qv1ZtJvtOKj7P2fcPIqkBx0Q265WV16MRSdMapoL6ORl+p3llZWi7qdJS2cehXcaMmG8Gogx6LrASTBHgtwJrBRki0JrevckddohQzp0ytUK0CeD5YpqKxlAUdQAMZxPCC1Hc/SChXe0zPTwBahZtwny99JYQ8sAOiKXsSltOkosLvbo0omriu9SaPwh6iuEhbRROgKeMPZrIfJMmDlANMbyZjwLXnbDMGgx+lOBTLO/5wbZyogYBYteL+oj5al19/3vaXXkqRC7oURqSt48mAZHqHRHShYFUbb/GxnR5mARCFijJy4kRBSZhOSurZJ39Y8Flf13LvCDKmviXrLJ63m7g8U7/OjUkIox8ByZ5XRvwX8dtkRaj6bn00SFhbY7vdvdc0R2aFhVg/UNo7qDTTtQ4cvHuiZX6qeka7C4IKNYNiblXCc8/0gQHI8TLw+c3SPwNZmQ5yZx5u1nmcoGgKvZmpbk/TK/fq/xfw90hQ6KJJ9PX5vaTfo3xfVGbLhrcoUV66bKWFhn4b7eMxXttZTfo22RT3GdMGeSKzJp90nmBZjdT1Foxu26o2e0xmZU6AfYBINSqoIVxIuC61UK/eLhYqV9s/k6rzszGiXKwB5L6LLPbbx78/pjO+s7z4qd/s8mPM3kExLDeyzcb0vg5YTExkH3OUJj/iDwXSu5mGuevoeGtdl3wm2uZhbw1/Mb+AnbmpmRyiLy3pGTw5EvenrOmU3pJkp+3B4O5JF1T/CW8fH2pmaaaNgGsxNaiobfWMXi1hbGOakczZ05P1AfMDj+ua80BM2okhYivAvI+CnW/Xd1rCi+6MHAjZQx6quT4XooPILwDp4dorLt1+K4+CaFF/Idq+8mR5MQM8bYN2n/w9LqFTGPOzHwFJ0WEvon9Oc6gu05eURB9hCZ06nUHNBo11otEjbef5vT37n0UXkAwfFnrrAtc+Mq9jbhhCv/PNW55s2p6yfKZc8pfCwRi98BYWQU96o6w+pDfDz1ea5ILYsv2g2mLUIgjWzoUvSLKaRtEavWv2yBe8VGhStuK955c5k+KVdaymeM94bGl9TCCbp9sgBkAhH5s5PNjAOK2b1V2WDeFYPDLONDPMexKwbjDQAGYy3kgKFaMsKEUW/NjmvyxQBHs5hLMGGdr0ioJZAtePx3+iV+9jh6NKkuFn49fUCNCgnLYcYcgxj8krn+9i5WYDsVYQ+4oSYKTNGdeHZlax2pv9wuWUwORWPy8iNRfjtcdISeqjQgKEgQ8gOBgXKD2aJC9dvATcjLamVRwxDOoEVrBE+jGBmyKz2OwnDmy3e/d6kN6kf3Vc194lBdGAVosegW1Mp3hPA0DDJokXIABjE7Q2d+FQDiQwY2ES2uXO/U5Fo41JiOnTB0bA5kJvnkuoCL/4o8lL0fVPi8X5Zy4zdrD/OIcSkoNEta8Ev53QYBoAIZymBBElnFGjvRbL9S+qO3xN8jYIUhLZpLji3ScHGocyvuGSPJMLZiUhGl75vardb7jqMreH0WpjTruGWv1EoAWkQirDE8o1mr9ElNJk80K+cmk5VToIsDvQIfY/N6hT2V3bF3v+URD8W31cBs2nm3p8OFDBtM32BjAtXIyYChdTi2kcFpUfXKVQlHtpMyqUsMyEbLv5w3zOIVMCXzqiGXIGtgfzME3Usbn1kgXK4NDayaKNz5YNg03FdlUIdPaoqP7JMUx6PA9n2hniJOD3XB0Gu2lOATm+EQFjl15ed/WLfZZg4e4LCSNcW/TqpAmZjhm71bZyQGLYOdCCA+tRHyfi3twhPZYnRALLbIqoudsi0H155Sm85xxkNmZSALMA2DHiGYRsfz1lmC783BkNsJWZpSo5ne+34MWbAceIVqzYp24KpOoVCg8/1IwBS+paUxD/WYOe4bHeBu9vHvZq7CivSq3b1g6XqEMAtah8l4Vwo43ZIEYvw5kP3x85OePkSDz6GTQLIohb0dFfxtQDYebVoTbxZ4/549e+U6s3edKv/jky3/BC4PVfBxCqxYbqESBdoquRnmqXZN+Gr39Z9Ujoc9j0Nska7lijRy+Ela4imZYOS66yvdxXK5dMBwTsZhT/7/wY+4PW42+/yc8Nq28DYsKVBvLgYlocoK0fTWhLe1K/Klgow5snoPj8v5oPokWyx3TRFiiComIH7quBRdcUZe/1DJSM/l2OiL0AhvC3A9K5ZdOh3V53iFwbUNMLtt1/Gb1T992y8i/8MyTQmErI1vGxnBeSC9KOetAaMeR4dKWOTy+NldDeHqiprpU8QvuZT5Uj5AiNgHhY5nNUCFmXlIzNUZKhFRLel/598aoCIw5uQlLL4KMR8vUUAKt8KJzY0iOdVdJWSmINaO0tFa34+M1XR1HfuMi+MDmKKs744L7B0CZ/qylnxkR2IFb1Vuu/CUeqxd41Ds9d98mIJ7v7MaqMcWXYhWMxejM4cYv+qh/1/muzCN7T0NvCjthwocC/Q4Caw0U6bLIvfNYP92tT2VnCtsWo2tgriG3UuUoo8EALhrBVrzG9+KUYsMflofg5ZbShmj336/A9+X//uVsJdxnWBeHB2g2rvifRWhxaD2/gF9w5p0khfOU3jBTNwn5EM51JF0wBQX1N8Kbquxmx1Y3L+ElHMxngrEZqQfuCTq0t+iRA9vHY8I9e0kJkya6rATcexm28XYcLQRw/4+wx+RlbefHWnmVscTdE9QuxX1qFU5/qoqTnGpaGCEd4G+KDih3oAsWeX0qEb8SdlXIDEqdBgCXN1IhCmS7Ong/9156NptlJgHt7bCyqnc297gQ3JRhpXl/3Zt194RVwp+B8RupQqKRwQd9f0u8KzNrMHoC/oF3y5HzQhN6UVOGqPIqcPj+E2CWtanL7J2W4izqyQSlkXcNAHK3GZ4E3MXbWMW0wz4uWPSsUv0A0ndsHctByWsUdwCXJ7Jwi90bYl+IipdCk3aKxOx5YCXYDzDTxKCuzNtJFt2GzB0S/D3ui/W10OmUf+HRy7OfOuCZw00lTne9njkOyW4cu9KguRJGjDsqPShW75yGhscGFsPAByzOWNEVBDp3HuWaam9K2cgEkl21pYH6r+rMuCNlyLzuwL3/cB0fNuZpYmcJyIbDRS9T8K49JLqX+RYjhvKqoz6H+ZuncPmn3Z+jLvmGmCDp+jdQN/CwsyEGoCJsgJ7fsw9ofrRcVk5ap2fvcNwsRr45JWU6gxGwiPx9w2ZZ9qTFYSP/ZgSU9AMgrcr4DVIGyEnkP3Z6E2DVz/T2TaIdh6HoALAzhJ6AEkin2XGW92SREyASWi/QPUx/RomhWr477Pqb8j5iAKugEGJnZm9ZK3fw4knWwryDcpCMJ2x3CJs3TIDctYPmqAgtC2DGLxIZYuRC/HaE0PSecRSiDbrF/UNm/T+izvTOI5GYCs9VoyXhYEF6vZf1bjHX9Qb6aRbaFmA259AtP9FvhcUDJUWDie6+nPrw6sdcMjmgnKykWSNdHtzLOHGW1KwiaPP1OwBfFW61JQz08Uo5BGSgxC+nGwDONFBXcTAgEUcmaNgrqveZFlGazvdVnrQ1dUprDatTAd8BFSWIoo1bg/ZzsMKytJfkz43LqZe/XHYxkWg2hJXPdpATZls8kFKou0dDl8o++MUdq9VvNEFgCsVhrh/AYgyV+WuTFsDAOcmO3v2hTM4zxXRMRZyOi4tTOeV1CEebKflWhMR61OZb7MJZGFPBlICngmPXQPmn+Acj5V1y1BwA0pQMcMpMvGLSiI4r2Jn4O1dFqw0348U5zuSp8uqIccuTA2zTOsqd+Vy1Tedn1V/iFwtg2XIf7nfx6gADJ5Oezu9hL8R0gZVCX+qAAbX6OwImkpZe90V/eevEEZnu3j/yjzlEswXVSVlEl33PavZyybFA2NgKlB5AFN/C5g0S16mzyBWdQz/eLPDq8DX5JPdCcFLc0z3QpC6X0AJgzc8Bl0kUR2jUM3zOuC+jnOnsGsSPqKisJvpjDCSVOlESltHPrtZY+EVNhDSfeFHvXc5TQklDr19w1iDpFfUiNLhlYQM+dQsLQEW9OB68O5CTOTIJRADPFnwCwV1Yvk5jPXPk4B24qU9gjMA9XQE3F2BpMqhcTMv6loj2YMpQC5ewkugHmrfXKxF4ngFuaeJWPX+C/BTx/yC9RFAAPFjz4HyvU7pKZUG9npCmTIVy5EgdqzAyVeJ4EuqQxs6IXd4E/4HaTfOAQaB6Uiaaku6tf9GJORabXtECwQhYifR3cY44v0LjnqbjpKJbjiss2z90XeW3IBVil4e90h/PnXJ5itbfZFb52UUTXNBg2LoA0URorGz+3q3H/zD0anc+KApd5SC9CtL7AS7fbdopoToRuy7S3Jbl3ChslOh8/3PzfYXK1q9fet0oEolr2scEMpWjvl464aVgDfqBRbn/vI+8L34+BEHsrRd50dBbo1nJG9+AD4+Bjhqe5QFzLS0DYL5Fhp1nCKbXSM/QpExXOXbsz91FHsATLYNu8TOjaLbeLD0vQNgDmrXivmIFSdfMDnTNB23RN0cVYP+E+zsvo7EcUMwr4SWfRWUsYCqi795OzvIg8GnAZeQNz8hl7257hhy4BdWGjh2vlfEn3MgPJKi2HrGysi2DvWGyCvZ1oHaJNV5d+ntPtbth5q1ExVX6zea9jUe2QL31ooCqlQcA0mBfeeXJU+9ozi8t6mMjWAzZS/Bs0iBZFjaNdHSptzFxuBMus1XbBoqs0PVQsZyTtug/E9L7jnQ8OIzLhRwNlZyv07A7VS0G/QxVE4xmh7/xIgy7kc5IT+PkmGHPF+X1hCyVUwrd5+8SnyzbQFsTxlZB9d4Qvp4grI93mNmX0+Mi5B/stASc4kaKxnkaGQXxoJhAqoBdZzxnfXC2Ews1So7V56kSbs8caGcOL5XePDlnN4FAF8JV9GLxUFzZ0TpArJnvyu8kyt5p2NfUa8hlHsMSIUxLCS+2io9VThlB38W17zLMmwEcUdoqI2MuC0g5NorEJfAam4rDggB2HP+pjGhdcRWXySdiox41zrteZaOZkEwG6Z3koYlan8RCfQb2jetDLAUegovSmv9q0TdSM5oaCUZjvfMWKKz3L6gTOyHYzHD3lA5Q1sMhcFIOGWY7sIRuhYK7+KxgIsmmAeHWtxt4nBEdRAiWuYf5ZxRyTL4JQNmFMVSOX1+A20M+N3bSeK7jKy4dTkBraMWqpHDWrRYHc29TNPVUzwrNuE2K5kFboJ39uVPwZpr31tiBZHcEfSk+l3UiUcV/mp24zzdu892ZDpul+I2YUL+zQpRYsAeFOBhWK/Ogar+jBY/jUVRbXPAlqbYY1kAaN/TVhvDNnh73+uJYSZW1yiYBk5kMCAL8WL+OOR6B4Rfj8si4k3dA73csmmF01zxKteJiIxJ4mSu71lb59yzrWrtjpbcM1nuuD+rluP1J9UwMqyIhEh4wQi6VCF5hhAyCkHWEM7Qbk2ID67F+naYmKFb+kuxlPhPzEGxMFmm+DkobR2cmAsWzuNKtFZabZaSFk+dgwSKXysgASkEGh/BiDcz4ujW2S9YFpNQ4iYwFrb3qUOea4mdsucS7YycV2MlFPZLYMzh3/teqn0qFATLVHoVScXZsmZiexmcQ1X7oL8xA0UXdKKmD97hckOeVM62ZXHSNKsCC0YMLygeAfWJzWFItJ2IyMwcGTuh9bZ+vSU2rva2Lv2X9Qa11xnPPNYjJmZbUkB19h8KLrO3u4sX9l91tTQtlFUsS3ALTSBN9iUfMLuNmfhlpWsQL/knCZL2eLEzO6bOOPkM/bmj+86p+ygPjI78THIvEV104733JMHnop+rWgZHDQ9EX8tADuJvjSK1hvsuymjrbhPZ+0J4HeOCxnrZMQgeH8F2FEmW0i61LyM/pRL48OT0YMHQhN6286HNAZzH4duP+nrTugz1jG6Cg0cRvkNXdTp46R7e4SwBlK21vZmgro+KDhtxKhGxxx+vxzL0Ha3zxcTXqbL0Uo54USpe4M3egfAsI+EWEmVy6/tIi5uUBvBfVOAYBi5cPoy//xdKHPFetIE7GLnjI6Kq6Wza/QJs6Zk15nZuyhYdntWxwkSfnB8MTwy8uiUXgrOpBUmsSVG3p7SxZstUKZuzfrIX75ZAixieANlBvtT3Eu4leQKKnGFwCFaO2lwYP4TBVbL9JDw9Dak33KfBq7jGPO6ROmKP8jE892YEkNWyfcwBS62kPZ3g8JaFnYRj1/SqHokGVY3XO2E1smTolBauANbxuBhILYfall8jExok4zMFbX/3tzimhRYgign8a8mE7+G823QR5fDIRLxZ5AwehRyyS0FB+n7dMGuTQJiLNxmy26vYUKdnN5OuSvDfGuUicIw1RiHHdkPVfl/70ohD91P5UHSFLriNiJLw0FDCaJkPwrqjhkQ+U5SfEiqwL+dPq+flFuunT9/P49WPuO3TOJQoKG3bJfKBtNYPCePHv2fq3atmnNBBOWzEfCxCrcYD0jpM20ro2Prw6AJmwgqicuGrhVQQO/DOi2/RsiaZ9R71ktQ5DBBxjkmlPX5JiGWJsPZy2lEntCvtvZPwoSFdYkL+6KWbqFqZYTKxl7OzDL2wymeqTRk9uhyX8mBINpeKprwcX6bp4Rwo6A7NA2spzX2Qtc+7g203Y/PIo3JpZlzLCpiQz/AGMUQlGTlkGz+oKS25ZJ6RrHJNaTGQD1azA/NzbF7yUt/aKyzb2Qg82VAkEr3CZ94z4GJHvm8+QDNuqTu3PieYIxOqYvEXSkXdmfmEUgEjkttBQSE2r1N/ErcdV/TEQCJxbHhH7R45C7+K6mdXgIx8GigsFUxLBcIA1+iJoMJzm9EFAbbcF3KHYnj6arbS3j2Ok/C/YC2r96Trlj007wjtlOSCvoRXmodIc/taj+56Agn5AVybJ0wnqlzXVih5R+zWtmEG/RShjb71Zpp3H3t3m9dP5LtBQiZz5pZj3/c29Z8te8cormfnvmIWd0qnAp9uu8g+CTVp4Qqx4HNocqjHY4I7qWyc6/c0MJgD+/Opi42IERMySAWkljUlO3s2ToXR0bu9MoB5lmiZ/EnA7w5jjKYR97bhT+nf/y+5x8lxqCWsKIFYbwe9N7aOSTAAHGXKIMUCpIBfQ778ayG+coyATnYqUOdEOP/eWPNguYJYAi3YKzqOqJSGVBMHm81Bum7zF8SNlWqcq+fOFQKe3af8Y+XZqGarDkNBWhiS1aJKLT/0JXvc3xjsFi/83QlhqtUEkbsHht3kDeVqPCNI7tnu2ajWlmIOVYEqie6r3iDEWL43fbVbbg2GIbaLFW4xgzPCNbyz9zA1nTH/V66V0uz6dtqrX0E/fcGswWDy2e7qped54UhrfOPt31/yNeRjU+Rql2NN67Q7ZgGDMXt8X9L5bvaf8gnckfGEfznJsv69d+e+UK3GIT8ApttsKhpLiZttqHEUmmgBls43vp05nPXIg50ewo+fNmcYwhGbPKJ8fSLxOzDHwasvBDVxhBPvlbaZJVsy5TTIHukWznVHCJS0hRzKceW3FPveZNqgubIfSH586SfdLiFj1umV8hQm5ML0xMEnXwWfUBe80Ds+7EURcS9mCUBZiRt9bdikRaRMWNQ9tZeGawa2Cklqy5ECjX58hyALHABgD5ptMG02oafJcAAl4pWJhyHy2J1OIzOCBX/zNJLMUPGhKKlHhGa8MCQjAO9DoSESNCh/NEbyAtaJxiWT2uLaUhXjeKUKjhmAUIGE/2NkD4sZa5kY8OmsJR5D1Eb5ZLrUTSgG6jv5M6cd8gOsPdI6rJqjlctvMna/WPBdbD/YEoCso8TFd40KnKkTeOZIdzdO8uNx2mfqcuYPEPerhpxxKe693FvLH/j5aNW/rvr2WrP967Z93olrQNH0lURf+hEUcDaYdbyRSZYQ4a3+1+NNBqztARekAa3rqV5QWS5HYQ3EpZBCa1bha6Zh+S0ygSPtwruUL02BCrS05L/ECusaWsCbRtyhpZJoptTthaLzKzRN2Hk5LFgPkes4ZHTEw0Emd6rqD4SDjZM4VLZ+32aX2yd3ZbbPwVLFV1oAL77SenpkZKbzyFagnuxaJ3esgsDuOJO3h/DD5Afa7yJ7qBynKX/zaZywfMMlmsi/yyPlvoRoBkUZZdTFXjmDNFrgwEXdPHtyAPUcPB89uNBT56wEm5T/AWgDYVUWX79/a4EW7F9mbjAZKX1Gcyfg8pSXs7DBSMeALrTcAbNYoF781lGVS02B28Yk14YuTzbTnGuSSbANcQzD0Z8U+eA34qd/3btwXg3EPfmQCUVpgGhLKFyIdyxQ6Gg8ueiM4RwjGuc49gX72EH86vz5w4enRUwOF0c5WPlQoVDeWTbPoJqJsIZl5F5Z+fn18CDQSnQbw0RIKQTggoiuwzI9fAUf8+8LkxWULrKCepJKjzYVqB77TwrEJ7PQYeBtcMN5lnVwsCN758zFuFSXVg4WGY7l9w32p6HJKUgL7uMuUlwuXvojJkT+yRNJOGyO5GTbDm3Xc6DnsV48LaoUUJlVSa2seIGp/ONkYQy7Wo1KVvljO9vPlGuEZIiBSUfG1IG8W/7GHmYKgdOUSZ7QFb0hiOqdzW0//Tj3/GJyIWI4Vs1e6JKwF25KVPjZge7/QneHtAjelSRbnvTSvRKOSvgLnLTO4u5FwWrdTBkJU8bRsQlwixiDV3WYIdlSNUSRbCIiDZzG9Qpvt0hRBe4C6vUXxlSC3Sp0mID9+BK+AHL4bGPb8x9emN8PJlNwa1Lr3zlpfwbNT7u+dciUXRo4CWC0wk5Q9Byt4a/Hb8qnQxmycdkqd5GEhPViE6VPNUxs06maj2MKemv7z8YSuyi1OndoSzf6WTWmBH15LNL8IYPAqxEjeeOBFCOga/STBvIJq3c31Km1MR2penWVunnQOKt8efZSzy6rPX1sW0RVc5ebQediIWVO5PKE6pxg7fJK+iNgQyY+riFxUMDREnrOwnzgH/Oy6VivA9Z8Y41V0iK4QUR++45cLoIOCxYzhABnoVNAVs1f7FO0v1pnqeKTiNMI7FgOitX6fStm319QGO9pByVxSqBtY0ohqk9C1FK6fdkQSyfGDvWvA85+qiIHx9PN3yjmUn0AWqbTeW284A/zU1ODh4fYWSAkRSjT7nJMmyEQbmJrn+2EtjNYiR60IgLWt53R6qHVNieJi8MQ+aKX6qYOdF4uOf9t8U8RJRT5yZQLQyQ1taF7uHoN9C2C6yW3fc7GdnZgqVIQxEKT33F2KtXqVIs0m05g5JNBFkgqlJRAfY6515REoZh8E75o/yM+oBnZBYYaaVNfphc9y+wPCf0hKAPuPFGm1GoV6UYdDKf2PXlSp5QsBB/oDThASRjzvXhHkQN36ZPO5G5Dam2d1Fa93mcQNbtwijSkM9l6VtaAf1dW7zeFaOfLi0KIHD+4u17zDm/l+QWIoe/qKUgdCI1GAXSNbTqF5i3cdwCyBOgfJNmHTC2wTur3aaCIX38Obblzh1M/4huytmqFirTnTdpmXNoO3C7DEJhO8MI6+vFnRaHbn+cgaFWhrp188om9JSB0dYJZxgRk+J09uM02uSJ/XlVlCGYLpdr6vkiEE8h06PdFBLQGCOMYgpLm13vGGYWpJTjwu7epRnNLU8LRAQgYkj0/kEdF535bAr/nR+skm8AKCdpo+St6SxjwmugOF98cAUNWMdYLmr/h76HgwER/JrJk98EICOtYzsfUSUr3ILVaIDkhj83dXfPZPBNyKqO9Yc06h23hQd5xwHTbmsXVIH736aPDWNs/cDp/QG2OSc+CuaZ8sOBdh5+qunz2Rk2E/2bK87lG6YhPq/fmZPpuJmPV2y+2+R6OqtfqP3oUiY5l/IYKNElwObhUBTMsqtyMVYQ+RmxxYLIPAn05o8zWAvI4krPN9lPMflh1Q1hEGuPsL7fg5tHrBRWaIZ/ooGPLw6lHitBsSJ5/PuhrMJTp6bdxElBRxKbJNQqRXdfoXBnt2Jf2U5BAd+t6lXoTS3F5emQvfl2zoktc03UTADIot4IUtaClCq5k7YriTSz2TcgSgOsVCIZnKd8cMRqjWL9gK4mSESqNCHPuiNvbaTtNlpKlBHEWFWNghbdOMnsNprER4AxT4PlIvWI+48YWfJ0CyTEr7FzcgM9r9JP2+UWjEd0K+KsHFKPDPZvUbziVuXz7YHTU0XkLADz3Yw7TNnQqyGm5+KKJOXZPccHJTPqe4L1qhCOwgaflrnKbrl/Q14OKlmnUsEsO0HVm2jLRn1PW07e/6X7shZHhrc4R7AxmJMfIW2dfon46bJseOdewDoIeoCzQkVpfNKyc1HZfWiwJIFSF4SKLz8MX/HP69rVRlDFNm3FcE/tFJMA71B/Wgz/pa2D4xD3xMASzRvp8yl32BX01h2azj6B9KJEMFvJWw4LiyH/Fartf1omNZ3Xy8c/bvrmM1ULYhXEuw7HG7pFIjD8g23Fk659EU5O0JVjaBXA2HRT86WF7Bax+EiwnxCPn9yziO/iEFexFTD0YfZrhEr2s6G07Oostgu71C2tDrB6TeCS1p65PHiBpp3aZnA7T+Pv/6lU0FcPsFHgwA+rqsE3Fy3oU4Qk2Cj0E1iTlsI2exIt8E5Xj/4IsWGWklg3SPvexH3jaxIr6r4m0S5O3eaGcynQJwuqrzEbez/gnL88HZDR1hQrpski//2H53grF4kmGeeFvsM5Aq9zHRbd65l+Hf2YQPwnXDcAdV1iHG4ujRmG1hF+wft/dWIDiopJdwOuwQ+HuUe4p/1v/oMec07M5tmhrSpdgEVw8u/bqaYukThlzgD85jWNS/DGCIRcR112ZGn549EHPqk1xyZ50lxAV5sMWcthr38Ltsy8fg82HZNBejY8TlKSMCsDoTZNP2L4tXK97tMlOvK3LhwZEbinkkICzQRTnIwc4ZAPtSof8f+zohn8WA4JXlHQBvsfANTCqv0v9ElMilYn1do27WlgXYC2lNnCK7FIInWaNeOfqmJL/Yz49GHD+rc9s6avpyr736GRD27nIfc9BegwH6MdQupyr3lfsPsQZHse2sbjFsfb3dLAft9pPfeJtemRwSD9+DiU/M6abkFyECK4OI95+97SL7paZ69clnSvS/L6KNTR1y/3CjLQVbo+J5AdPvHSrVK48n+BP16GkA0s7RosypqJhLrY/VvqTnlpUP8ETMX0Ym1x2rK7XlT7tjmDBjZVHXN60m+SKiHhz69H3GqTiSaD/u94rAJXQdv/pgqK7DV+zJsaoscVXdpUmvs/tjANYnI5NLx4Z9ou+dKMJJfhaZ8oeau7kIA59aYzGMVjSsUu0hAZgeS7awywXmQfhQrezI0/GWSb4ijpCZL9SidnQbpOgDpjrmw+m4sJrXWgsx/2DWN8iPhbhC5aIw5y3D7k/mLu8jTHV8bQj88MiD2Iz5ECHclMWELlhk2xa5gn+efSN7cPjHZ7FuWTPLb0iFr4DasK26G2+tI/YCPdQNce5qCEQeDxVeHaCEWk30n55UsNEyHyOATcMswlYgvlgR0fZ0Klb+UDpxfwC58iGn9r5LdcfGgVpbgm8gMVLUoT2/3LUcF1ragp6LXmL1dpB2YcgYgCcZM8oWJH1b5kchszluT9WpwLYF34O2HHWhT8HzgVyMbAJn8d+7Y3K/XQTXjkbcestSNciKfMKeuS/j2jZPOWHGr6ShFMOaOegWp6EHTrJp7ATwEUin3nhxo9IhYFBAfDL64bSFYQCCH5mxVJ+7ZiNaQljjLomRfBLpxetyiFazfe3s3yjdo2GwYMxerzsJ8LveuOfFxECgI+9NaAdcYjPVNxm5T8JJV2ttH4M6i+k8GYfwweNIm3C78rrlkO6tjv5w01h6nZ/RZguEcuTfctjEB0gWoTHGxD3uUo+0bLPkNgoDtOR++Wn4sYX5RYO9hbVNj6oZZEKiId4MeI3iE3XocfqtG9lEd7GqE37g+JZx9r5AKFdafCJ6temXwh3spor1IKsThz1JI0c76LNTMV2YL0EABSLM7hpoa2M7XtDV933J1UtVfosC8IqtS3fSXc8GSj4OIO0RjX+1nrzAv/UNBb7AD6tIfC6UatS1yFGW9rAjlaRxZk0qcc0AYGhlYNGWH+g4ZNVvPAr2945dQs/IJK5OP+1OswzOhQpTUVgZPaJZe9liyw2yk+IZqdfMfWhFV0Y2csejg3VFwOJJ8aW+JtkxqiDo/XR+ShkcF66lkEW1s7oESDHqq+E3nE+zpdEJBLFNF6dZL5oXzg4UHe1yLA6z341Ig7Kn7WStnQCAuGOMIp2ZuY00BXcZFGyMw4HT0PmVQV2sG+7wxcNmDDdgHI0bNZQGas3J2O2Af/JlxsEeAcDIQHoB9qu5MtVyMkog5JtzYFXjOtBLJ80GM6OqF2GNwEfE0p8cg5wFdjvlPFco06y+BYG+lfcxAPpStMbKcxHe2zTyzIdeX9bTcW2DcolqamIs9kXjynI9eqHmMW6/ed9waBzF5W4ppQ4VNDgPx1mcj9ptJEqWhesQ8HoYKZyyrrwicTQ1Ssd+Hy0H/qKF52UnbEAb26PVyuZIcqD+Uq/PrFeTHRSyzk105lwHehB8pmvaUDqyGOyKcdg5iDGthTX0c99QCcY+NLS/TcoST/GjEdTVHmm4HOuKa42rF0BiKEyr9q/r7qJ8rV/GmOvkw8ketqgisCjSzTiSZNK8sy4h/cQDLPyyfH3zgJ1MVdNJKYL6SUyP+1vc6xq0htcj3RAI04eZEt/ovGxTkt+bM93tMltHMKY0lmvmSf/1E6gzc3PoPipTx0dynq/d/4RH0Gm76X2FVUJdpK8rzR+saywIN+OgxwKLI563jgD/7d2paOK/m7ROBMHeWSRLQ/DIyx3rPgC1l5qYQduhhzAF9UYcUXd7ADenTPR6+0UFErG0FqIBz9M9sCTVD1XV6fKQo6CBZFM1ZgQHvlv6IPtohQCYLGm4OXKfys+klvFcsmhGqrvl97C6PsOmPQzMqAgLMoqE9Z6dtqQrXUQ+MGGiJA3WbTRn4f556sNu01U7IXPt3Fx6oDMzOqwKEX/cC3YxJ4i10vdAMAFsUZ6DwcRr/i9e7x/b73THNQnkCmcbW+5CPGOMxWJ6Dfub6FMZa/PVDht63P2/hsh6ErN8exe7gIMImVwR9L3JkKAlO74YB6gMqWBCdw15EhvH0SbjuB8UeCqKeCuUkmi0H6HCIFtt3n+C6eGggilPIy6rer/97ZTMoiZafPJORKQKjysSzGc3JJ7TeHqxQG+I1GPVk3grmAeYHhRBsQc+QFWLXwU7DU0CHKbUraIb1NFbGxenpOXpVsj3XHxEH+Ubh/Mb0BRjLirWBY8C+8lelKAt63WE11p769WbNNngdUkXv6BEBfGPrW5VM/YT1lkmjIp2kte10VpRn8MGlfhrGpofq1K9ldyk9n7iYL/aj9uzqg6bBSHCGMe6pk+1fqOdvXuu0IFgAlCXDs1OgunrkncEDRdkY1BVTXcyJmbgAx6px1h6X/tptsXDO/ProfjkjXh0ZHmygYWJSYYMjy3dOOFDdlPiDsb9Cpkr4ZDHkT8rxHxzKNYL/6yoWjo2JzUnJivqm/Nx8IzyZNirdvZhZ/6RCVW+p1mS82FfQhl3uQ4OtfY1dZCl9EQtigpQuDhJB7LJ1smQLeKL7N2+7hXmlS5V1CyIgRnEVuUof6oenADQbcV7AImUouEcnGgiizzNlU7UTYEWnyKd4idXKjNZHsuuIPcwZ4uODZ1GbH+oqeKpMFTKHAthQDC265UjTKmqGC5No1cH1OncH7S7FXXbsxg1lWktnzJWJUUbaKf4mn3dIJbrEcZP61i19IukOzK+u2HzQN5oN6a5Hj7T6MM+y3W0jew6HVUSkSSAJJsxU5025DtuhoL+YF5vUIScCTVNdM4l8lWRm4POOwAB1s8RCleKRAeCylyF7/DBuRhmnfYjMdSkhUkSi2OvMQiVfOsDMZsQCXM9Fkkc5NBoeLE1RMFKXdqHYyld/l5n+jLxpNGLCK8VDkPEbnyA9fKPeKvck+AHRO32sGWlXn96IyLxgej2cP+zMWKmieEMr+RqrRfj41VxrvWwQB697smbQ3gpjxmBARv3E2IULJC6m7GRXMqI2nAepdY6OoQnLDa+t1zXdDhf9FU+1fg+HDAc3h3L//jm+Vyy09grKiLPuAIx6g/rEgqblsmoYTYW/v45J3nfcSWpO9Zf3eB+6LA5dOKclWvmRnnlEu31dBbpbtsIE+5NMbqVftVIs42kO9Kp6gj0h4+j/DXpbzEUvtBq4+sGvbRC4GEzPZCVmZwfEhxTwLCKzhmuiA6eT4sV3pHW3QIxScGvOMZ4tkyefdPTKJ3WBXzlkENy/r/59MrKTHXx9giu8tyTodTCIyR2fy/lSFE/XKcx9lXE/MKZpi/KuhpSLBByBui8nJqleSJksOf+DR4HAo+wjfM1hAxME8uMr8xYwCVw5BJPEMB9jwmIsZLU+0GfGTgpyPFdij/i0DJLe7hjOvrtbZa72piiIfmoGghLxXd0Hvct26FBrAT0alXi0f4dDW1yRqwWMP1ZO+j5zg7TiQFKnnSfeQaZzdgSmCXRBrGkJQdFNrwhqFiYzU4RAnl1S1VW05SoNSZmjN+jg6XcnmOYoC4zFcEcFHZCibd0m6a+zZO6QQodpp0qDa6iY9+xRtQwwLvMTLobvRojL4ZGvh6o0KxVvVnz1VQsIrHwacK2L9c4sSeR+DvvkJWiGC6/bnLF5Y6eOGWPcFh8flWn8YU6hohYmjskAzM34m5t4N+DB0/QbkUF4Eb/RUpTEUVXSOYwuOVVtYtj2dUIDubf45aDAMU6sfHQHOJxB0KKy+PSd8oMwLSH21cJ98lB+i5eT3BiPOOIAFE+U6g4SaFjxTS8QXXfqoj0m82AGhJqHwDR9GThz4aSeFOcZzHYqKNlFd1YIDCEw5QgMfA/2pc5bIZmFUPUAo6WG07uwc1O9FIIJhe817ZObnD1gKkfDos8AJpjXrFOsBJw/MvhE2EtsxTGvGSVefcLrC+QUZuvCUBUzDiAOxDPKfxYF67hjcMkgNooBAi2k5aCdVlCTJMkFlNlaAY5g7bVbkUJTxcz8CG74iVsfUDKqrT3UOX9i3YXymTk4FWOpuUzwRsfah8KKcRBSKoDSDEyAFH+uIK1IkKMF9Jvl6BQhuJhJpSVqMeh5MWn9eKzTbBIn/3TkbZQ/u0xsZrVHehPLatgYYpqmGRDui6p3F12QHMcOM8x+32ZaYeb08/dSGSW9wwhueUjjTIj2aMFL+1tKoYCHNx/IfGi4g6Ni8MiC/7L0/rgLT/KX3nPmYPeQfRGESpeeftxE1TiGHxMb/vfH6l4xyGEALzOysqKYg9dvfyjn1psbI4EcjkBkIXkE/yd4Z5/RmlQi8Mwc4gXOiP1G4CLcAZSvftiROsvAQ+387WhT6bo+OMV0FgXYI+wUM5n5UkVxVIcDCLySKUsEJE+AsAr9DFxGkc8uEEk2LOwGerzpPiPOFxYMnGBWePwjFfc+lWXrbhYlSatXyNXEXIRngUpNJnQcR+Txtxg9Jfnn+HkK2Jug4WMaG4KzdB8pHkaQemvKAe6aXxdHHSHbYnJTeQSPtcBZwwAVwa3ySkKbDuLfaE0Z/aXUDxA2Xi9Ww9n+QjYC3+iHQji4iaO2XYnd1iEEo5o5S+SoNkATqbsbvW900X2u47JWLhgmTUpRJBNOEg3RoH29NsPwo195ZGuAjuP2O05F7pfq521nONIBP+KXa99UukgB6so313gRt/k1I1bw/NVgQJVZ1ge/mYYI9/VwoPJVCx7Ts6CRI6ou8y6X7ktBuGgYFeYHK/Di8JknTqnc6lg2TcOoEJqBMXwawDpGNGwTm5GurJTYTIH6094z4OqRX78CosM5avKrXMTnLGCW0SorR/r8VRN8O4h4s5oFA8+a0395b2xJ6tva57ESkfrVgvBtZVUgm7yebuxbjhzbjtQVkynHD57VVESX1ECDRqINJsiqZnWIbhZOM2jXfbEf1X+ZEJj4Q/YBCMRLleYdbLrXRU1AIBfgjdFC8Xb4d6Cgzy2vrJFecer0FMkbicL/mwXRz+BX7jcQh6oIBWdYWH2d1mgGkaVYBh11ViFFwB1jVbaMHPiJXtBWHLP7TXIeVUrsfVIQI1ARMmeuYysbZCT8k9iH+wbkyexlIoMCIb8UqHFfTJZlOjqunJn2kLuHE1pS0zTRo1QmD/v7uFxPJCXP8PPK2vD6v0aDRuE+G5UMDi552/mpL35dlitCSwFuBzqZP5OIVj1GjU/npwaz5npMsmTIoHo6kbpTLxpEJQqcav5DZr9AcmJtOiV/4tH7zCly9QrII0uGk2UlEJeai21v0zvB54Nkm4Vha3NbKddWeXGVSA0F6VOMl4cVbMCBApUhdz0XxmTwuzyIS2HIInqaCFfEVWFynDH5gv8JAYbTc8sdH2BcMzouVvlerlwSFPAaSS3GVim1qkYsu3MN3vehrhhP2f3F48pmU1Nt5kEOSfSbzT0RBqDydGJacq0fe4eh/qxz/3rImF4PmOXQF7ZhhbtCZyh1irF8xse9blegNcuoKgTuZ/meCWw3L2U/zLKODJBabA6/vwh6nmoAKIC6Sm/XniMqnsxPCbRfuFK3vdX0bho75q4u+erJlCpxmt1doKRWPUEZL/bXWp1EM2Ln/ixB6ZExtY0knlrstQ0fuCazv9neqQ/UsrYRyHOyj33vIw3oiJnJ4tQ2yehcMONC2WEzbrt0t4sDdu1cJslngFwzVnl/AuJPH0/S091/H+C9RI9XE+eM7yT1B+lQEavrPoKAcrDF0o+NlM4f2DRN13Idic16UZnmPDc8jffKp2A/Gus7KPQppb0Ay2ZajTEuIlQ1/rDmBVDvYih+mKvl/o76IrY5+AQbJ0yWFk0dJf3sQf/At0JjBW/8Woo7BcoHaFNejvWkH6JAIghRbehjOTZEYMauKV7JG9vZR6iPgSYVQB0TQva7je/utncJbyEfjQufN88UTpfeqNDjCWlaqaIl5mWQUy4jdht/Ck/AK7hFCcn5mKeWsPLwvU17+OsyaB1yCa3nRsY976n1zUTTdRefQawTxGkutbgQAOfBt3f7Xt1v1ZUNcK/ea8m+/oVN6gZpFXXeEOxdlzVGsYAShWILYJtQXiE0lzr7+cvlm4Q9VB5UWG/R8ZhKXo7WFjiGb5Zz5Yatba4R+k/NAZmVXCmGQKp4/BXg/PUSOxhU08WdvUH6clmudj2MCUO9ZYsYe0SFqBMUDFewQYT8UI3PU2yMm8ZZx0JOPofpZfsu6MJ9vzBzRLsDSv7GxvGWAPnlJ+nrbuJw/89bY1c81FvN10U0HAlIT2w2z3AvaoGAacdZ6AqrwqxP4W1O8CKrS8G/T2KsKrR60jZSQjyj1LFKHu0BT95o6i7C20nH6aHKa1x2Ok1r70zQZLDv1VV06bccQD6C/LY9E9AJrJsyT7j14/1rLXN/B2Wz6B3v7LDl6tznU4JVC+Ks16JP0g1StQWQum0cyYSn2CkbT2WNg8hULtVaNsHYZBoJZUnCqTdQBbRVw2Noswx1j2L3YqXPlINLmX0YipToflOttt46os9lUBNb28+NO39F0tDtNN3RXrtC3O3GjSL4ubFU5hfG1KcJID6d8EdbJnfvMiobkhGCSjisrCW8VggEX4NKLFQxkP7V+ifHlC1V8s78AOnm77QI4o+aZxbNIOgCOUxhwAMXc3RSO1zFmlbiCjRAS+ztwub0Kn43Rp2H9PUe//R7I18iXUkWf8En2QKGVPWHMMZ8VtpPfIAnNHhSs25Q96wdsQb+x+5ZWj2EMGxReajVig5o73ZQ2X1TGxlhXjed7WR42uxXQCkTIiS2OavaUtzERjXBmeYhp8RmMc/8drcSOtm+WHEcMbJ1oQQdDPaB9ImX6Bm+bxSa7hE5oac0Ouc5GSguqORVooIXbV24PU49dQ2BiVnSj85p6+FdwJneREjArQT/U9H7tKyi9pumEXmp+Hql9UL0uxy3Zg6+JNuUYmGfI1LvQgu0i06pGmOLMMj3L+Yb0NfaZS+sVolTKpCfBz1Ln3Sb4GunZftwMmPUj6CqEtgBt5dkzwy2JgtFafT4LutsCFFeTpj40wEnYzheuhgcHIRY8W5INVvwiJCv57SIRD65mOPA0Z1WSlaiv8az+XzXB33gKZgXHDJu2o5Qv8jQglKy3Fw7G6snx12KFBo1GpIn00AI3VzsYSbtwnoIpj0UTSc+JzRnZ2PD+JZ3U3dar/6/1kSGv++Zq8MOh1YCLa8+s7jTf+j4usrOdJTfdoSGe3AhetjtUI7sRrvTLUvNx+ZxKa+WrOGbeMqf9YF+kt1qHlT7/jxpyGO3PhC5py6Ynd6DQDkrC+opOIc5iUOvCm2qj57XXb6aI8ha9AG0Z7JXHJMvWmkxqpXyy4PIM83gKv7F8SFqQ1/dixfBSCwPPdfvDsMcK+DL1+IS1Bo3q3cGSIFANoMrYI3Ktid3reYeTQJTXph+kQ+yyxAe5t1iZy8DRyvpVWdpdyLKxt+ZgoLPz7ounc7g3KkT87nEEBuNzuWrYqWPKSVuRnkY31M5Bk7rHlZWEP0X3TM7wfsIc8Gs3Lef2bB3Q5aNQPLmxJ0rHiAXcC2BHapP+VkVsxvdNz7DEPwh3EOyc+2ri05IKpV6C25Khtz8DTxXJ9RRmKCFhJC6eBY0prhSt9XqdMPlnKHliUXXLW0NiYQE099uKuGQvnVRBXPegVS97Qu4wKD6o5djdZDee3tjfE1lNnmjwGazpB53J7NjFmFt542F4jK1GeEviGdBWo4GFbD0hcsAayDGGrxfsLd7UIglLsDHYWQWQn5QcygEj8kANtfUt+/FWMbXlXQVKB4DkQ0JyGWVgHo85jpmE6nKJqqU/VBtYlZZDdlJsRcODWvjkgz5h7Dx3i9fimBnI6+jzi4Fp77ufi7TFOolcu68WFHBTMsK4q/PKYA1Qur1VO62QJJFclK47nylmpwscym0ERXg92sQSv0CX9FdRsoXBje9Mx43Z1YM8Ab3REphTwpnXSJIg0SsnVQIvkpKWTd4gGCksoi9rCBx/7JUIlApIqIyk3ehaC/qd7j0BpSXwvRvK/T6FHeVQyv0BjtUWDl4Tk7gXnqdbSpFDdjTfZL2jjMVmKd62CAh7f0A3QGk7JLdmPaCofnLHJtBY+A5ddUGWuE25qoVav31axigltW0sezMYlaxFOB7g9Y/Kh2hJz6avGOlxyhfDhc0ZLYMZKFTJuzWgSVpHh2IhwpP+Fd2jnNDLdI9TcYJVEXx20hrZpqK53MaatysGWwiv1GGVC2dFEhVRHYUi4n2yCWc2a+5EYS+1+px3pbscYN01P+e2kEIuhY/XvCjD18cNHqth3Qrz57ClDZgL+iDYDuXzQDN9BGFPkW6w4C14aeK36KEAfhf07VLiPdvtqpfpztfZ+q1kTyFv+zIi0+LVUFNZXv0j4SQu4s2M27mz776TPWGx2h/pMXgAUXcKOeah3B6u2GN7P49M0m6/M3iRBpy6DDpcJ1TrawHBe0kSQBrBjwaNKZitSBuNsbpZgyQ8tQv5oNj5QBTk4HWwpq+n++lTnYyDI8OD5yjvxvX0rRF3dZdVcWtpdaXbO8pIXtDlHKGFhqYe4hmLkoNWVozxIkv2bGUhwPq2aSha8Y6yWPf3KbU1/45rgiLOaEV90mIAnmwWzBlL3EjZIIE9SKiVhuSX6Dt7OJORb0fvjRKING6hybxQjvkdXyT56zxbkne9tHbGqJMvqCNv2+tVcv8Y/b0XwOO3xIzFzF6gudPFDSevlzc4HnyD9NAM+p3RkYP63SfusZ8593YE5M2bnu1hNGNQnd6UnDAj5bXR0+edMz7QMdIB0cYn5Xut+KPE1UcfAbVs8f0yt6Qj9lGYtgfPPuU6E6x0ekn3sDpHJEfGkLkC7bXQladGr9iIdZCWSMKJUvcQmiu/HEEfIjYmKsLVazmLBWS00zxCfq3NKDO/psDeNcSQVxD/VuFQ2w71ZJbVP2pXJuJwJp9oPFKzmFzNQy2OgUS8+wVGtviCN+MROpcGGBIBfXyJ8t9GNw8GKHVnYYbgp6Gi2x8VjfXQFXlBmnbWODolh97sGo+s71XXeU5SZQehHStMG7zq0KPXpbAikS+d4TsMy4ksUEnY9LF4B7DJGGgIqeb2XXtQPHpWOekZn92tqLyqfEBiM/k8BkqDv1vmNuUKmWI2U/B01jFVsr4gF65PFiJwgr/WqCp1/0SsML9mLgVILi4STpHY+KeJxgFrp+ejdRHP2FSHaCeefxIfKwoMTnUaryw6dxrTy810UPEupaQDK9AGPAvL5D/MjjqvhqUaOLT+wVS4Uq0fwEQEwdH1Q4dFiQiYo97qoHRCdD3l4CsoF8gvWQ40c9rw/URpP6iub/RlvHZ02WziO1MXE3fndI/rIPG7WbfeGTRnBwmPDaVCOwle0FfH1rkODGEdwlxLcA7JE+i8ppspmc8p+0YnCIW6a5JLQtyF5z1ET7QDGPq3XvGPouqYLiq0DT9OVTQBZKKtkZTQGuuBuZ/QyOblkm+NtiYYBh7lxhBZwy8us8bU+UHZOmyhPr3vdiXZ/FvHiisfpFg5QTyxRCyao5KKb1ucLnayl8+/Cz499ghlu57UwroFuxUlPZjb8VfdMKtNzfIg9MvTZ3wcxGO6GvynMrqOWRdKr+XLC/yiiUgHRPgMniWkoPA2r4+ABxJQjany1slcMvFtXQ35wRNMslNVTn2aEfNZf8ihnTzoIVxu63iba8UHWPDGNjtVqYYtDzUleJGkDskJttf9CMTWPxBFHtrItNOM78wbx+pVQI74hZAVjBmcONx7IOwzRgzyKODTkz9vjP+wFSMSwNvLEZfD/phsgfaL9M+EolElQ5nmjshrQgzGqQ4qvir8o0TfNYQ7V3y3I1j7/tX0BiCprdeY8RNEZy0kbZLpm1zV6YKaTIdQKgRCGFxlINn/Homg2kQxGTgyQIcUBYztSi6HMWegj7Q3Yrb2axi8ajXTTWDORAedd6A+M5Wzy7xNZRec/zhMC7EqSdF4oe5GdsEjpoOZ3MTAkXzWVKjcPl/ueckGZV6ENeirI5h/QNc93n3SfS6U8jMlE4IAxvynIikslWjWbeWFZVOLILUVxRHRNpL0XaoBvG/Yqpo98sICFeLv1CECoFp7+3vnerhuEc2x1dejQP+fsYciitKalk/U6tUO7g5CbkrqJnej7LEFPSnDzTx2g+cNsUDclQ0ay259ODOVcWB1Q7z1YCjReBlTq0mAi/xEy1mqNIixMmLiRsLHziRhqtkQ/RCEyokKcyqPKtjeOSUgY0MxtJ44k7Id/3MZCEdNsZE96u5NFdTg1EMXnKcoCw8OILYSGsGANgrCs+/qdey2iY358fkQyJsSyT2o7tn1ViO5U1sbwrPwJUD+/TCa0ZUdsHNC+reA7u7NLPzXV6OAYGSTbDwRq2IfPW/jg5MvKr546k9m3HL4ukmzfFuAIgn+7/FXIZMQYj2z0Db2nNi8wY7Rrtb6HJms9qHUquzuDJ3pbQ6iPEeFNVvJXnhb6PSijuL3HkvBCa3vKifYrZkP6rA86cYdFvMkTYlvNCzIloqt6kcaJGEuV0YQVvSZ/NyljiMEWaxr9ZpLZWMPYxf7FcaQWM9JfkOwW5BXF1bTs4JGMlwMLEaP8glE5NWeeI0vwhNmOPHETHZpK2QKM/+edzM3TDmmO0jfpiGBjwXO044I1zhCfxFhsgroEWJRljdqYYF2OjAMgOvwVvwBjoIUgcjM7O6zajbfVTk3R53Q1qlefVsBycSHsplaCwzVdauyrTD+f+vL4Oq1cJl5BZiyORQhEq5EvyW9SJfX9guDxwLK/VSEqDc7rL1eHqJdDUr8HYT1aeuIoxQmieO/hSQ9EQCUfra6KzOF2Dlzv+N8U49icq40tPGsFzFBtedLwEIYYU04y7bBEdFQkIdS3pe79AmVXtuW8HDUmccJxyv4IKj+D0Vt/yq3s/IPwngmcpFCAy35Llhc0XWoD5SbcPnmSY9S1jn0jIA1DVUnpdWKuPuF8SHGQ2Qi9hLPxoY+fDk6vwMANVdFBFqd9+P88sGAwzhN1zNebIMoDrte7KCpk4sDQAW7gElv2dIq/Dn+OzWeqr/EWPl0o+43xFLHb25i60BIYdz1qkiKTjzTcI7iGj2Ld/BfajL8ahfproUzj98TkkN+c/w+2E4SSeqCFHt28zCnRieFXR0ogWctW348qtJTKKR6gkbsY+jwIWNn0SJ2YcUQofzQHrxXybFyiSt6Jjmku8ijbL8apQ/0y1FsRUFlbgIqYpO/H2reLE+W9pSboQuMA4hljvcw/vJhr6emYhaQCgIvr9bip54+CWOkzLSrUqOPW0kBB7wnuJQBW/ym8FFwSYsTQf7htKLV81nNI9q90vvNjTc0UNsPVldFJ0d5tg3Vfc76VAHiWJGC85aiiS11bvKO5by2RRvruALDiHhG+Aj81UpHBI+qu0k+/3k8MRtXpaU49PtpRIGBTlbIAdMORmBRQUmADoz7/NU7uQ7vILgKK+X1BB1JujzsGOyBYAO/BnrGMq/IIAQQHtRjDDx+SBcUNvodPv/oJwird4YutZe9HRTQBs3h3jdfOVdv4IWMV8SJbLucljKbO0Ack0IJSRnx6uNpKZoRb6mC2hPw4qz1DjMEysVOZiIDY6l8dd3UVYs309W+msV0h/fG4p2diDpXa6FKbomDRAn3hja13Zn2Qu/FoBZgzLa/qYw7RQuoB8Uma8SajWJtYDeouoMX77Gd6dSpM8JRg1BQm9pugESD5ZDq64ji/32CRB2NO+rUxg6UUR6l5LEcjyreel+AXakrRDkFzPSGZU+m76z9OMzYBIpKSX5cspA39SUvIyQcuaPERV4jnlGrN75t7xxb3aHrOlOrSy52ssvLD6D4X8IcZQXSaaAGh6Oq65vTV9mIpRxBtmY3nvDJPYgpcVEOq24KTy2xmOkUnQ8vnyoGBm0D/HsrHcqgQ+MSMD8fWYXysXPHO1NLKVNF4m2J3fedKvQlsmEGYxux4BAgVbuVUSJE7sMvocaEf6PdcY/JLybMZVJzZZOVKRpUyJByVtis9VuTnBcxBeTAcqCfmSzSJ4IBjbiJGCBmU0hUbpyBfVK71LgGKVwz2NGfDwu8TJ+mlc4iev+1Yp7lcDb9bjqsRIsFzL+Co7wChF6m8AbrFJ7bbJTEM6t7THEuFJBZMh/jOCePnQzMv2EilqQMBVa29LPMnXtpZ8C+QDzQ/ZdmMZNc9VUA97/9IhXYN2ujtXstIlQBbw3XobyCp/RC2s5OqVfVUnKDE2MPAkjEj4hcaX2jLhalAPWli6JGjG4Z1b0tTquxO08Z30TL63N0KcJfsALFJ/P13G4om6BYfOQqizyXrQdBQ8vV7DyG529B0wFWGbvH1lRLBhphLxbGbyk0Bk4DUEEpRL1paP20QNfXG+Vh/yak/i7NG4QczJqS/84r9FOqQ5b+qr5HZkT2dSVICX0hSswnDL98A1kvOWnUvVCzVAy76JcyyYth9Hna5K1VIBzZJDn8MdYYgKp/++gqkv+rMy/hgbmaxznjbUWnzIz2a1Sav+8SSEs4V20HzOPRwhEZBon+pHR/v62H3HmxttMA2dSmN0ReAmQx+QhyH7SebuCHPbv3wlDZxNjHCbrjgFqBWXTc/+6tPK2kVPjcBV846qr7ey3YnWYpzjftjew6MllyCcH4cBhnTyKxE1tXpFBKJXXyylNBN5fsJuOWl4utZZbkuJZTECLFU9pI2Cun78DFHzRQlf/cCOoCvxqiPJozERp/Sqs9LjsY+wDzyqzcNmiHC4kjgEIT1X4AZBRr42RbfSyN2I3t+Djb2Wq+n8cxsNLYKMEse+wvdxxMYREghhHKK9tsM59a0Aw6NSmasAfMAQ+eLP9/yrMszNkrZpv+AwFWmGCxBnhMf8iSjoFZQU8+kQVSdzwkBtHyJ7d6MiRUm5TL2uUSamfEPMGSucfmxL1o1KGi+BU4Z53F2bOeTbI3LEMFBPnHeqU7jdUIy33KTHrDUcCZ5pnKHpMWcStVsCnC/swzynOwdAqrp57QEcCXllCKAmNPD6wTKpOGPlgP2dSppixTv/xeDMk99Pm5IUipSjJCqY0Jj+UQrHa+sb53RUqGsj5j6ytVnazVIhTHQfsXKUSmFtrKNmPaU1aCOPttTCUCQQf0PMIfV+rT/ytR3/4JTUINnhEILWuD+gzc1yOu9xV/t/dRKYEqFoG/DXxW7cSZyDYNz2zOLG84FDn8v1XUaSIOKf0reNr6WJJ4cVgnH329HBuZKRG/TzJxkEaHiVlvaZXdaKb9jIBLNngkb1t030Jb3mz1Jmp227lkkTlbr7gD+gak6SBYLTwts3FcLgaFlqakWw6szs5860poeiB+IGKMhtP6JNZUmBzERE2EuIVmCZjJ2ihwIsk8TxtIY67XM+0o9lu0xX287KJ4Xdy4croMGHm395cFSAdtZ8d1RMAuorqE8pRH/DrLw/VG6NNUyyxl2e1CvqfRpJaewbAXk0rSCLPqwaabD5RUcxOnbWxA2l8DaXyqoG8vaiGjH8gEClSPWDBKbjWAUmxUx5iNxxTb0JzpIUBMs7aJ1qJ3TVcw0t+l3NsNLMxTtOGMMUNK8K5BvmAZRIuHCMRX995yWB/k/ilcVyO0wBprw+zimdREkj5XM+0ze9c+Ou2t9gximluQ55Rkhuv8T233fIUpBdGwU4qEAPdV/03mBLv4s8hgD31AFjqMMv7OOnWTuR3vSjZoATXcAU8mmW0dLQdGkIgSvi2W2/YlFn1QcMYQGPc0mwG6CxLXNicejHTaXazbQsCztH2IdwFWDdlgUc3/MClvZi6sh9+MKM/8FAo0tci//YXyhxPHe9NJo8G2r1Huupb5QwGGNVoriSe5U2mQMB3jdfgCC6oBrh1ju1MktxRZcS1ryB0RJW/Nve4xbGWBYMmhfs6tzEQZ7gJdDmJGse9ahQHye6ZzsUWUCAexIFGQsQG+C36XUZdtUyGNlnPcQJCE8gQ9Fc+PaXf5RRlWLUJh8VWKs7WeODzfP0zMBeEc05aDONvD+xHfySvETu/Qwv2OjCcWra11WuPgC8ZdBzQ3WhZ7eZ8Qi6IkbtJQXvBOXLNiAjtI0iyyTLla/jtXvG4fvG9H6oUj1lk5BV21kTQIzXkbQf+NkN9mUnIL/lp3Z9FcDQnghVTZBM+u9SXa557ZMhULn+XyLMFXnOCfb2CADJqG+JiVEhn4BYoUuZbR3AeralgyJHj1W90Mk+Qjv6yU9ivhqQomKSFk5mu2681vzpnFgOYg7zRwKjBtEb6Fi3Cr/Apk8qrlNndMidAT48+gs7Iu55cd1zO9LDsfTPsP99xuVky7G78zyreNmw8Zlnj2Fh2b8W2OqC4CFUFpB343DnmTZGOG0hFIfFPkECK2tOXnrQZ58e+VqkfdbRX1bM4qZgANoXTzj4JoBc5hZBs4t7v6BiIIbe7aqyN26m2Wa3jO/Buq53THQSKMzKzyqFIv0I8STnmdoch2xj3Bd3PDRfAxyGaeLPJTUJPhQW2oyt0j7BIRpLatoGT2mOGQcPvl1bJyMDa/KRl7klRQAqygjKepzQH3S2Mfs/r4gVkMCsl3V3mfmpj/DgyI//0PA/mvfhf6isel2yUN+NH6EGUhYKfZtUFzOUCg6SUi5xZbivnn/qqQHmIov8/tMbincMDfKfYEQ9a8BaTDV0fkKilUoSt8Po0dCPvwZ8VUG2Mk+8zPhTCJObyQmQlkf7m06/kGXI3O6u0IU76P4QldoBrktGxaxb3eFSc0ZXqaWie/JVLPt7n1NSlrfHQXOmUyB2O/tszi3XvAERz1etGgL/J/TW9tepBRDshkMdA9iJ4hOySACiHGjoEi/GqF3Iql3Z03NsPM2e6moC1yvAWk6uwuZieKyZSGlovNURR/WA7fUsjhIyhYg2h+erx5k6jvU4o4Uta99lyqx1JqJHXEizHHeqnePLzjyrZTubJ9I44sEcioVXPl2LQCLVnjUcVhMqOPwedlK0NhJLya7NFFlCQcCOngTfMZMotFaSfW01ZBDu9jYUEUfzrdtJEZ0OMqAzOS4+Q5W0bn7UBvcVV5QsdUOUKRe+Iz6Viz6/5pdxg8yn8AJKgTnJ3q4NanNjtTdnMUTbMRKNsUGgBwz2SuSF0C5ubnMVvenGzzfEC+azfkGDx3H+JDOqhQ0jG92AVMR/2iQxDuQSeEb0MmXjuU1nI9bQo3Fl+cYz7aJ9XalBYri8VtXJUZ/P2xf+Cw4tjmxgs9iBfFNJ8hcmo7beftn5o4JDol6zqD4wQYFpUzBA4aQjbisJS7GoBr8HOTY4K9JCHTj3BCPi66eQLyFMASDIUwlef54VcUlfFhiUKl9e+A7BgEtmwVhdwWvxtdNGmfsLjpCso46gWhffkM8iZQnBv38PCik6BdaLh4C6uyM1Yl+hQtdwRWWqg+AmHsHtn3r2tdagO9YTXZ/CEjiCP7YwkMgFUzGrnTl9ekwTMusETrnCKitw/5+CVd9pHzAoCnETtChsJBxqZ0j32T1JQdxgnaHrCOCOC7zZpxhfD/a8sH9KsMEeVi483qqjY+Uus0vXd/8JXLLBm43paa7pmtAIrVo0s1pocYe2lKtOCkS8Z6X1M5Z9WoPtwH9IgqUKHTV4LxT/KmfyK1rCWzrTfU6cp2cD55EWt1YSxRBh8SOG6DptJ+WkCOMVS+nKjMZvEnFSPTlT+xrRFjW7pjylgH2dwsj8PKnOC9oZxvJF67C3Ia5i7xUMYibuTG85OnJx+6aMDyrwGgvi/GXA6S/vqz66yat97+IzF/cV0VXcNpipfwAsjYnE7iVZQKegr4phvSMsNPumeHJAQpSzBV0K32hJB7fmWscTgqocOCkkKbai33fFkRlDDSUQQHCwzmdWfTgJuYamy2cApc80zTcGj1mGaMOIiJEFj8f7w+KvfROcUVDCpjS/9y/wgBp6INUSRrj5qSUHiFm08j4Vj9D4ZRQLZV2iZpGAnT6RQ+WqdsuLRwWoe6Tk/J//CAWiD+wscvgOYY25Nzsg2z5Zpb5z4vdSvdwWE84oLqswMncNccm+a9wFVUP2PF8lVFmxjV6cACRIkDLJnMSPYdEuAYoiP9v/RQ840miGrcMUiBZDqFjnf8H5qAm9hA8pjfjvaIN0kpleMm5DTDhuBKc194O6r4wnKxNPb+UzgBHZ9BHeS1iw0WqzWbAWsYSjBtPtByiPqY4qsYGW3qs9XKqnMXU7qEyR2JLnREeN02YjN40cNL8qoYvlBQuzoAfIa6KvPVhxnAfiMreKnwa3Jz060zhikNB+ma3/PqH6jVKB+ugqj/iHSRWdAh9p+8xvEy6MakAtnuq7NJS8+ov+iC4O8/BtNifyC3s0f6psSEN62YZ2boVbPGCuZK0zVml9jh8t1WqyAtVnRo5ATH37jVo/i0FLDG5a0/rE3dX15bmouSEjDMnSHuB2YFkhH/txnFqfDgdb2w2kMtZq1NVmhO9uzFLMW9MwEX3LPr4MagGV1eip294DxRBFZEIMmZ601DKFqhrYEcLMW3f5dMYw679PbzU/hF3JQ9WT4+BCogJoFQ4VhnNtmbABmC3ETA75Y7FWW67QL9kCKooaZLvFBd3IbMPic+h/DmA6OHs0Qw2H60LkSDkwyJyMNnZwT5lF9t3O1uzDXN6f7V6zXkyA+332OouSQVCbiyLYpeokfsDTTjH2ArA+eNTWkc+AMNEvUMrT4YXEkumXWtKVHDdreRVf3SmuPzWMwkw0Cmqo0Wsdh/KCnLQU6Iw1bALSf4Ko+dPOoxC6UpG7GRvQimjXiZF6wz1krgtYvJhaaW7MxpB563b4Z6afL7I+exKFFy/NnjoXpUpe0texrXv/9wgMp2qvzcJhqF93HdKtpLf4s2DktsvUxuRAXF5mBShCCT8sNNVsGzBWxv5ysRYHsc8s78cgfYBKK7LPq7mKe5Yv876P9ivF1olCLfmkaM1qerS/lkfIoMq2KH0MxafBVIzVF0grCJP+g2o7jpTI332wGmgL+UmUOx0R+Vj4ULBjCSx7pl6ZjY3yTb5qBdoJxPOigJJ3xFE44r/s9p2dim2sANN4faaPvsbU4+8WkqysCABAoU9Gdt90VMyrBbcYZHNy230iFBmjRBGLoe2xO8sLpe5waq7UrIHCpBc8zNloJlUk/mH7/LXdY0vns8nJR27Wumhaf4gdELT5AQyObGuraxnRAWZU647BVjGFyGZLI4zRg53kOwgE15qPLinqk7BJcdMawv3UK1bdQTh+4/pxccFCzL3Fv8Dd+kQyeeU2vGggMObQWjc9Tu74svAJSPtI/UyFwsxYDqYlAZbqw6qm6mQxclcLpKuT8IbAnNTUW6kt6NPV6sZrnoGOIKjG3uN3isvTRiclO6LVb1Y1WvR4cBYC3fa1gAsEe9WYJlxXrlDEXQQGjDQkrDGaTCgnQUwDZpN2PR9GhQSF9/TgDSZHTRfBHaDA/frzw38z1XlZvrCtXPWCwNaND4i6jIcW5A3bLofeNaKln6GiPlpC8jxfHZGmY7P/15k09EqfPMC+UILS/iVsmT7VDZ6uRbE8xuwe1V8PHXtaQgjfkyg5OfDSCea6HnviliPAJTz5DhR6rTzD7kOT+MngsNGsvmJlW9le1u+dz8exSwTTsXyS90zdRVL8Lx/beYmEJoobg9QFOsrQoQB34vF6IPVOuzRxcPz8kiNq7v55c3qc1ch/GRl00KfPkcyCpUC2ZE/MKyyKyhpmxsh6EMkwYP3CMhrI0lsa0cXGKiu6ue/VUHX00PNCHSSbWmIsvxkC+CcpniCOztAfolhvBObtB+OQaBd0ShyWfQ1Ce59a//XKh7YZyDaQ9y7RT5LI1wVTmkU4gJ2qObfMzTg5HGUzNwj9ztkjOyzkxA0NukQt6m4KGmlfHlce8qegVWg5ewFzaUbwCu7j5Mmr29Mj3+Rc2v6WZ1KRt7iL2bOWlMRoLPZBNAi9Tz5CQXLzDmE76Xpo/62GgrmXbN7kkxDiWNEq8dWJtnEeu/jqoJus35Aq5y4rQtmV/ck+COtvTrEEl8NU5nEeoTxhKOvPYHRQQaEyaKh+8On15TpYUntWXf88oP1+B/N6F9C7dxHqAP7/Lys9l0TJ2NDnpZBUTtAC7knAwI789HZM2jUpvS3StEjV0wHI4mqbhf5Us1X/KhqzmJ+Dvd4hWmPZYSeUK3t691B6oDLFgBL8upSOlYN8ZDx/i2Ry5oiUKWq1K+gr6Yp5xooT/lBeM8qJvuFmJRiuz9De0GqM1IZmDq+3B7g3Y2PuoEm2k0GlTw6Sbab0v8HTfZnSVNxF1onQVx8SDQQ0y2QY/h43j/TeE5HvNSBgTrP5QnQo/YGFOXsSznQ9TnxBM2dCJStJJZRgcYzQYXSeq/hErbt8nMKolSaKQzNG7b3SMsnEw0xImF4cIibiwUgwwPOVvZt/9R3hANpuCDMDFRTmOhQ7/CmY0KqoEYPIUrGlEtFeAhLf7nbxnpZ8ZJjrTgB9VdLfXIkJi2W5GuGb7NhPRiQnHFkR6eYMhMX7X8ZSvN3Zl2xezxXgfIv2K+bMJ9FvdATcgaJlfljWGBhQn7muJsxBlRbA+4fe9nKElrobYYtTkusWprALg7zkCud4A7kfpUkORUlCSFJN55+7rgsb0E+QAYRXUnm/qbeIysbu7I30djcB7H6MLayV/Z5+Fo9qna9s5/OsSjhYAzVcyjm3XFvRHHqh+CtZKsYUgkQKDYn7+nlccDGVZN0p7S0lMwokHOk8ry+1CEmq9t3nXEoIfvqPtFczEUjnZaJiFn8qbhtBGircyWOLAT5zKCt9I8XlexXyXOdm2SogtPwD++IlwdTHxy2wXJgRxZh8tMz4ut+sqOkQpdNXOltGcY0hHSNQR/nEhbCIryMGIEwXAdz9cWjPw0GQ85KqBX+kp/NLhmiLVUfKKbTwY+EsXNYCLVZeGlVX3m0OwS8BRJxQa2jDo841KwcCr0xKgQ0mgAz3qrxNS0Q6gS9/d7hh8lkuFCf9mYBAM5IEHMB8BwuV2vC1wopukRPK2xLrIZ0DDPA+SyGlbHbJki82j1Fvm8APefZdZBFK1iis+sjsq3Qk2r0fddfEfbzvCCuXNCCvEHcIq+KuqFdRARAQBTmyxVNKbraMQTmekp5VUaYC2AU5ZJQQg3Xt869tx8mEy0FP3711vFEuO9de3Q/xw0Ucb/3hqVq5ZuThFmPlI0N6d4xGWLhASeTd+3D6zOD7pA+/P1PE9DZ/qP2S6zH2sVrm+KdczknHXvFnkfdCibXlu5kWO+0HNnjBc0ik5s/qnACX9A6Ui1QNJt+78TgJMxYhVphrCUILagWAL8YvO3JgqDieRxDaTyzwCZugR+JRWAaKuwi6j3Wh2O4O74NVCDKWlLWQffLruR1+gbHRPqSrCpqwxSjRGylAc5WiIM9pRCiCwFa37KyT7f2ZtbIYy2k6F/J760lRTdryMdWZS00xh8Lb0SpVmjZfn9K6tNJe2AtOlO3g5VNyf5D4+C4rG7Y+VoQ/UGAdyChVNknlxvHbXEKUS9wLREYFUniUv4Uk/Dk24t4Ols3JDWw0+OQxJDQtCCeMLx8xg/y90XWP5nbstPh92bFu/gSWYg5fkB2agjly08V8OBIbvoahY8L4VaRytkyykq5nrPpLCllG78AijM7tUZXpJsAeWGbBagdZ66ToE5SCZHuAobSfCgtnU4mjVwfJb6m0xiSZATDq4lKpJOeiiU54k95gFeNj06n8o+3K8kfO8X11E+AmeUhgkQfk3eDJ3q+RxQpgWFjLxuqUIrKNRjjS+sL1mPHUyelg411j4j6r+g7gB6ZVZYkrutndUKOhGAJWIt7FXYGk6rt5tvwJj59kkB/NDdDhq7Erjal8gzEngH/wHMD9aMhx2Gt5ZufzthuZCVStrVh2wbT9KNgMT4prFAl9Q6ngGcgwlHGY7ZH1qDcoGTp/Qv5yTENs7VV0OmsFLdtJQ6p8nVAifbdriUhAGRFq8jqVxBqoKbkMAyMcvzrepISL4+8/hOv653Zgp5WVQntvlJMEitAjoWPyTB3tpcG0GjYvi2jlM37CIXro7EgqMCxulNXWRv0YZZAKJJfkg36MM77eB/Y2kVBoG0Ozy6gms0s1VDFhKuDn/Oj8U2NI6bdi3B95RtjtD1arMTl56o4liolYLrlyIZRbz3TUyE9cIgacEUtdEodYHLTU4iFJ9LbGY4rCxV6IOffCoylLGdttT5Sj4+4epGERxaBUsi43smot+nL3zWOaPakBhHa+3ncfQOVcp9DoJcnp9TOCWBzoCpXD362E/b7UO19C9/LSRnQfzDLUdvok3/jc9gpP0b7RVq7Ir5z+wSzoENO+tW6NjFKmv+yGsba33jVgrIM9+BifgDOTLxULHvCokJBcbkBXsiJlEXwA1jJzJbwRs2vk2Vp0R0JLoKD4uPGd0JEEvzLw/THgs2Wqjg9qamwsN0NjLyFbgsBMBnda5kZf2nkiBfbNxKBnsBoJEu1TjbzE9NcaBXnq29SpgeReZLLKMzqnfMymst264IVVAqISfYqUQ0ZU7T+6c6hKwf+hCDPRd7HF6Byr8994IxTNcGglHZCgulgo4ypsufn9lkV1zM4skT8vfRMaOG+m3arhJCjd1mPTfheSaSKBYw97IbJ1Oi51nFK6FJYNKHVukppH4EdGAn5RT8xyKhuNRrGnhpl9XxQteMIt7Fzd4KzYjEIF2Me8LHCe3EtLxqGXdNoYeieWrBwl8oI6Wlc15cxEBrlxPlqEFpEZMZnBjibu++Y7WOyFyaL8NKHe4LeW70HXEJWS3toYd60XZVkI2j4UTdwyN9TfZhjIdqjVhHW7ET4DeJAliUcTGvbBMwtuzSnvzHeHqtpDHRaeCV8YPE0eUcleH87YgM6Jy7qc84QxDwyoRNVOwaHrXRMHF9hhJ6Mn471FcIlscUxqepj6VxbJXO7Dnp4LCVqRY6FpgMfrtOo3PB6ORNqG1nR/zxjuo8QgD4KZl1i1oRY+aO04l//dX0pOYS5l7QlYq+jkP8HHMYf7+5L2IUsEcjxuV7LSIQmhYMnd0bg1WPHHrjXSO6fjlYXB3HuIKu9i0/As9JX+F6V0eVDKeicEE1x0kgFwoFJdELkVuGD+rhETb+jgnHKOMnDu/pyc03TKyGlU8z8G1Ax93urF940MtyT09EjBCjj00D4sdQhDJdOMAMJFUSHzGhMcW1a5zcNcXYgL/86Ce/DQ5gqeEjmPm8BMMb+9g8JjzaNCzRTmHn0SckPADoDH+JoXmiYLz0mKIbgM6U/Do2UKGtXvqau7CQCrhZbWQJtyUTAPucl4R0RdVNSHUARb5Kt9SOGYRzsusqSgGFl+h3sZ0Dony0+yV7WPof9iKoeVLe1N2KK0Yk8VKxV0yLflXWYvwylxwldbubTmilH9E0EDIcLjfjFPFLjOMa5hU86Vi2AnY0WPzC9B5QxS6c04FdTiadNflPHhJBhifEczNI+pHVsJBsKcHFapQ9NQlN5sTjGGHvTCsN1NjtpjzaYac+v1AVA3jVt1LPL92vMD4cSMmECzWr5ofXb8OT1VkHIWFRupDQmOI0bqegit+Ay1mWNim/7gx0JktmuLSOlZJwz9uH/kFJfIITvsj4LtY3nhmJi6EILQXLpitvwefJCxuCO8mmfe0x2CjBEABZcIFa8elR01VNBS0mQXxuFOlfVNBsQ8HcyLsTqEKQsbPrEBq7IAPS6dK2/Ak+AxskK/zf9Er8UPeQTnQLB6KzhpYtfR0A41/huKWHmSrbbYEzuF7PqjSy2HMT7QX/4NlYc3WfNfh42JCDmr3l+hdqMsWrjFH4uKacZTp4AwrYHr7dqMvuc3+6rRXY1sC57GM/hkuVC/jx4NeYtU7ASphMzvueJsng5e38+ufGHJ62T35cwM0cwomiA0Tba20r+vF0XxngSdOOXz8GGm8M9T4IhrXqkGCYCXQHGgzggaULjkeWKvDowQnXbNudzRqTNxKYSJDJqxOnHrpijfZK4UN9qn1vCeLQu1SBruSsXn6QKO7Dk/MU/akoe6vQr2E+A8HJqQgAFsqx9qLm/ixiFjmjuF+bArgZ2KX/6veINq8smCP2izSW2mxapKUWR+4qZkrvfHLumrDwqW5NYIeBedDm76+7/WVG6C0rQ6BZb0Gbr9Q3gZMWCCbtIJ11QI503hHtA+YxCeVr9YfIz65sw9YUhQ/Tl+PAgTd6Ex48zpovju9yrdvIWd1AEm56VA9J5Pzm0XpCz+YJ6RKV9iS46tQLB0xx9U6eD0ugAobTklADzwSG3mSL9+3330VXxWSXNfVS+JgtCXy3WZHld0V6pE9QneGndDqfFyIuVbA7dXseg/IzYmnEezQH/McGXzePboSmdsvvGO8ZWk1Mt7rXY2psqk/+XgsxVKPxNrW/2nvAuIB+bPDpueh9k6LPqpzL+bmYCsMOLVE7paIL7NOHaP79yAb9dyI4xb2Cq9U3f5PPhd3ovUzT+IIcon0bzwDAFv7q3ehwtFeD7G5w5NgxxrLLDeepHLZtyCuXxCX4Wswki04Vz2G1QpqUL6n3UOgI0xL1y48xn553jTqDuys52JUPFQ9s1b/oktYG8osAbE7Cf0mR64XVqM+cmn0aXLs8pK80Hv1uICxIcyJC2ozQikjWkaLsbABYtFdtnqTfyKNFjPsH3Wb8Fkocdr+DQ8l4wAI7FLH1F8xrSQz7jPIxUUbPRNpxeRKyx1smSEXcQu/tHumjpSUaDZa/+1jCQ8HFSLwzwe06B20s7vsR6u+YL70Dl1rTssD9hZ7Zgoe+JJaGyilnGmzaG3h0E9cGOK+8nKdMDq5WQ1Fx8UgZmisWQxKR7K5JHgYCq1KhE8lL2mfJJ9UAHRIMaiPrA/ANQHixiNxohpyaDcpv0KZIdWRiMaAyRQw9p1pSLdp5A33hmSnpfQ2bUMMPxxAqSRn6LkPNWoevcwse/TMBPgYHIXk1CBmhHiGxKTGdZbberlaQM0M3JxmR5fF2UqfLLwfdT0JNaaQZl2MFxFNkd2kh6OXiVfOG7Lv2mD/WA4i1/VTsnjjDwKW51uzApC/2U/tDJT2vH8tkesikPmfQ7IZLliq82WN5dSKi3x29+iktlN1KN1SrPN4RDx+YAMztQOKhxzC27UoDgYYccRIA8iGNPHjvxBLh6zsvrWO1gf5YA4QpLTUxx4drc5mpzZD3Pv5ApGLM3JrXpApVzHb0uAOj9j8eIAqvm+xUxrQgm3FctpxYR4+2OsPjXfV3NJiyw45NQCQPlCTSYvC4+MnWvFye2CTCgXonTg1MbxEmZW90D0BJY2FHBvKYCCX6LcUkdfQelw4zZPRrwNhdn4QyvjvBBaOGGky0yW9YaV8ZngSPGrjdkqUcaCuCIvKOathbMsjow5SZsU/wtGfKZCX/88Vsf9O50rqKw/czZDvkm80SQvLUX5rrvQ/efneGdv0be4+FWlS4tQOerKwBGLqP3JMQsFpx18pdQhs796QxnRo3pcwR+uh1gX/gdviCu/qQEO22nJqRN/I/6riCevu3dD2w/lrm+clUfq050nj3uql1gmAq749RrKIw8OYEH/d+oxhSjhodN4S6UzLT1kr2VqDXCJ9dcHY+rCxUsLyc6cV9/Cl01g5z8v3jlrJDRyX+a4y69YEqZQS1+O2+jiDqIBj/MrukUkNJ4UZIt85ANDQdEnFn7v/tK1QN9YF42JMqobMD0NxSMoXjmipzrIBJ7VgXZ82Yy1UTALqPQN5fJQOhNLxp0TgSk4GAyGAal3JwGI7CS63X8wjR3n7m/Hw5Ympbm/xJRfi8vPjnDTmnkhAq3miAOUq97zyR2qhiz35zDfc7uU0oUyFsVhnwWeDWsvWlgxr9D2y3pO6v5vxRvrzU/JxbfMhqG2yCFUv1Cq80NKzDfACh11UcwdwVWBGJgnUJwCF9amuozydtEm/OcAsqpxk2NKaI8u+Pg+Ql+WjxQGYtCNHShw69xx7G4uNFzA12AmOu6nmh2fl+131YwGGq1UWxRVS2rbQelKMvSmdCg3Dech/LH7TDz7XJF8eIhCXf80Cvq84+wmTXmdOB5i9nnMi53dHKO4KNvwfH4ZcvDRkogLzZcb/Ymz20OYI0SJMsflotZgLKVpKEjTmx5zprPogkUkJDBGCXc8GI2MvfoEAnSX1E1CX2Qc4PfqUkVaxc0OlwLOR60zDtMhnUajgpoDEKxKnbpqDpHWPO6fNOGPoWRYR0bdzSffC+vjcwjM1PWziWPVO16aDtehv6CvcbhHKLWANxQCI3mqszOhaWnr6pwAp5CnEUPsBLo/dF2qH1l7SJUsnyRfeLrfLDbJXeKqN7h+heNuiWK9mYaNb3+0WlLzulutIaP8t0mvEQ80sGOeTHusrTVzzcqRL79ZzaGgd4QENkmendjHyvASskx49xtkL1GhaN7Ci8EW/C9XqzWx5ijJRdf2Ut2G2wK1Y7WuW/KXGIB0MMNW0kfCto7GFLeduIE5h45WoVR/4i7Z32jJKkjh2fJBLHijfTmm5yfSpOcbFWN3tH4aBNlPpFkxpXpAYj0K/aWTi4rdOD1+tIRL+mKdJ14TKsP3sOvqwahTZOvn1yLgrgQfMh+8tyA3SnTI1uj1Fj9oFq6qPa3RBCFt18xp4t6ZMmPwf6LHnFCcUHx5E4iaNMUkiogbK0lLVl+xvqiMKtPTc3HgWPDQs8umB51UxZHvK6MLVVWdFt25Ed4jyNozE3MVA1kEF/EQiD+C2+5umyAiQaHWgQBC7nElM8WKNPDirkqOuj3yY2adrFjYiPv5M3kVH+NDZAUjPg/jQmm7FK3GVAbGSOE2xBCkBxdY/95LxGyynQZVcrqjSc1qr+Cp1J2S/2bXghty8GVRAPx9XD/92YNkv76WHQXsYmosgCQTdn6JK67PuHNiH72925kX92jl4HoGh0JKt4GoDjRc1YlCE4ikf983zsPf8F0nACJMEznPh1C3dwcbJCW9+WyskMpmDrvEBON/4s3C2UV/L5hbCI0BL84izucSTGjyAi8EHuU5thb0EcOESQePFCvtuKa9WvwwLCv5Wt8cNdWT35xEKmrOm0DllMrQErJ/quvAX33WpysfEUqFbmGXVXM+l08D9JlU7QAXP/lzVqvAnujSynp3yn0krxPGlG+VhSmDK33mpmyFcd2caEj+LrpTgwZsTK0LDKq3xrHrDiuY9O/mfLg5KZlCM++1NuhFwm+fERPOZnn2kihdGSw1Lu3OGteg+1k/dq9HtQpUdLOPrs3jf+2huc8IXkq4aG+3vHRF2D0yRDxIolDvh/jAnziWTrUS0NLlX4Wtj/to36Vzq3J/D3u8HvmJTP2scGSHgz7vGYyBSPyNm6gJgNkTD5aG6QCZRpon/zH/RMUMajX1d1Ae1gE8CDn0FcD5XqgtQzyPcx/dfoU8ppHEFov+MMI4Pcw/0xoeB2EsTLAK0jBbGDuIR7GThjL4v96o+4R0EsHObPf4+PXXXg5f0rh7blpgLpaSXDLAP9VEeC+pAlOCJoB0Od18cnqfENG85eq2eCoSTsBa0u+DLWXmVGz6jiDt7kaQaqQNx9jMmnC+ac1lAllUdcSUWLyeD6dtpq99bfxz8lrDdUdMmp1wHptDgAdeQsr/N7Cnh371OLUIXCvRJj6K4T4VpItAwi2tNpjBSaRnKjycQkFaMwt7b4o9gHl/nU1sgrHVoqxMYlLPKRL02udjevH/SEJ8oS19qcwzCrxJzdeHoa6FLrjPhJhT5MEdf0RxN5dup5pcTh0GO/oxoi+lPs0P6OZTs8Y9OpvyC6xkwpcEbvSJUan2+sw5D/xiiiHZXMJNBAKAWNh+6b5WV/sJri4Kj4URZcocfiFVBJxANT13QlUOk6YcyXl4Yfju+jzqii+fMleslTVgFTO4CcU6ObF6t6r2WAKl0MUczcF0CIItI8kD82pRRxtGDlIxFoI9LKIhxaARjykvtw4z/wcHkPVtcdelqJck1QRpuJPpfHqwigxcz1tE21oMRKNEnmhYYh6Gtoy2PHPIrVlX4G+iF/BNBe2ESlY5kBtXfX2URNVhuA0lic672H6ahwsy7RQClfKjQxphkbFNX1zRBaAmYt7HyRlWE7Z/c0JkqVVjCESMlfpVVWmRTsBPpge626HNX1fUE0GZyVEqCcOSRsHk1vpiQUhrZ/6bqulYxlyFU1kULkTrDvXHYDjr/HoaQ3fMQJ/jUqCOmPQcSJB6kHRJdQGD+1xBzIprmDonYU1hLZx/ISTGj2UYoef2OApdBbX69sipMkWocN4URzUkauufUKaKBHgmkkpNTpPZtKR82OqQx0RK34nkKY4lYFSc0/tMn2CkMQzW14sL4APs96ve6NeEIAEvV/NPFkME2VTUa7UnRxGwHsdyD8hBUziCEEiGNGo4Ma3r4XbulKGp1TtyCpyxHVUy+8MjW6go39tqfQBnNq9PEtWHxmhKcyKWBMKMy0BcZ7oRskcBMt89MpxKRpCE86OP4GK6LFe7yl2lES6gARxI9nmqFwsrnP1w87MwqiSenRnpn55YPGxE0+en46wyAa1IPUW2xCbLjFyRnzJY4YrZYQOCNEmk3GjJfxiuMK08ruPuzT9gMs1hpeLIO+ecHJiElrVi5fxkU0KPUeJcmVIeyaeqGWTCpAKSuptWIKj9SJ7tfY5Kw/q+PKMeRdv5OCOpotOk4eX8rRJaY4cczJoVEbA/xMsviXkSlqFn0MDi3/A1w2iuVedmlnUxqs33msQV4H6fd3iq/t/4V4KyX7caZCKcehtWCGQxsMczSj/qwjScLrnFCsgkMGx03DhrJ6/f4ThVtK7zZ9nEXnvMrxAE5KYn+7xHivNLwWP5ayTfSZTSc/0CdSpFglh+eqYkP8sCAr39amEzYg23heWVDbeWpcEgXQXFdvjgEF2CH0iu926Y6iXeR5PE3It0ZgzbyTEObNUNMBOfTyKQLNd+7w3ZoSNxcNYaGKKYyLj8YqCw/aiQqQpIEkiaNvR7uCKUAmAjL0VAdy7QqyqVnnwWdHQlSswgJXjJQ0aMH+iSkrwkKnJQqX4yPIFLKwhnXLiIhDvA1VuR1u16zJiNdF796eBkuVzhyzNWD3WIl5qKyh3ag3YW/tf2Aw15vReCxhbuDAbeE4FNteJsUb7PA9D5f0D9EFdJDYNvZ/HRzEJ4BAEbDfvcjBgyoKS16Cx1tgivpDdBwqiABBQqu1h7pquS2XZlrJ/thjngYN6iXzbx5N+KjA8suIi0WaGK4zc5043DOCn5jl8hGowLMx+4YHpjr6KcewKLxp5/VjWSy0uIyKHZXc0IfruJRgOzmQrrIm8ev5stQ7ZOCXeQ75/oog6wy6pa59/Rhs8vR4zgr9BW2gvP0ATW3VBKAdzMvr/FHrDyKabiAjH9XhFef9izZNagsYDwXvBfEiTYfHgXlE6IeXrifLBg+cD60ShI1jh7QSAy7m05LG8K9QH+reVZ1nFmkG44DjNpV6hQFNBaNAfY+PlJaq2SGDOKkPOfckVaFOv5BBBNEt0et5c5+S6HeWpgby0lk5aYb1hpLBctGiXoZiBwb/u7TbsbjdrJPZg4bp31a2HCuhvam4V5jbM4lYn8l7UvYT4He1Cx7wDR6ykyLN7WAOgF8QAXJdbl4YxtS7FSC2aPMvQSIQbjOeFBUSx/VhkF/KUn+sZjWVva67zUTkvQ4b6Jo/O8KGHFeqql/1sWaiI5Bk7DDsZTcErMuINB1mB/1vSf2i7XpOCaI8hljrPfi+qOHJt31ZQJtdcrIhPwvnpGJTBMtvC8o2BtgPK1JGX7klkbO9lbWQHAiNjdZCrFdDvlvd2qSCkklF7hcg0RxT8ncsRu5ph/d84UkzGlqtMr5g2swbdsdFdkZN2pUj69ZU9Rh/zZ8TYzjhtQNykPnPm6bEawBWOs0rxnxxgk649/2ZllLqj/xEyPfm0Mayq6+N2iIBTDg0fkxCabCyU1NW7hz38PV023M/xwMZdlvm70S4afkOODiLZEswlPJSlQTrKO1/rgg9SCjZmKGJunt8pcu6wbabygs9mTXW/VWhb8XPczFLqSLo4RKUsmIHpkClP1PPi+dukhau2XUgvz9tSirYxRyI1C5O+vTAaIsZC+GpHW9i7gbVR24mjKSFBxz9rPqVRLU46BXmNeR7xFMJfzKlDm6/aci2BjCM+jdS2WmqmzGn+e/SFof0L0hn2Za90O7qHvq2nYMsn+XltNgkixAY5OnwZaNquACooX5Qf6Y2mvi4XLvTmMVt/RWMWPwbJ1I0x3gF+wmoBRR2QxljhjY6sR7RdpsmammzAcJlh+eWokJsWvStOWWhQv0FEFuuwMSJay/5kJJGctqf2lY5HHMDEdkuT/U6T05VcH4bXvMAPPNdPE4Jh5OaPzndVvzhLzysPBElTV+2YxbjTaLCpqxVFma39E5D/S6MYOOOCPruk5SvPpF08MR9NvbPITiEAMpCf5v+rE2hh/El3D4Gg/yJBrnV9a5Tq6meZ6DIEdVA55g1QAoGmOOPylMc4Kl87mTGr4FN/R5Tad4vvaZYtWYoDwderzmxINbYeY2ynevGWrdbO9936EMKCmtnRSVgwqg/azVEXqEnxjU4fv1zNxj5pqKI0PJbmQcf7+CD1Vax/xhLK/+CKp6bYpaCnKdJXK931xnzsdT2mmeYcuk4us8gNMBFWSFUhfoC1Df0430g98PZ7A+r1i/SVcThFcS6sOiZqC5Oehr3GE7GOjORdKqDpNiEz/YSdVFBtQ8a0rkh8hQxq26D8YjyIMSkgSU0FcaOmePgJ5pGSMRb8blYnCwEBWbUsqeB8oThE+q6W5r9hsu6Tf46ZbCCfXLvqLbxTkt4JlJLFs+S7NSoAi4Ha7MFUXEKe51YS3t8m8DBT9A3MbaxuH1CkiJEq0rtV8TSnOgANBU7TvQVQTYPOPnxn0OYeaYXoQR9uAG8kE1NrSLNBJvVKDZSfypOMgLdPfpHtiTxK6414NvWzLPzf+p0kdZ8p0QI8NIlB+rk08ucZmGxj+0+cw72Tj7t6H0X5fN1IFr8/7GrNhcjAxVNRivj4Sfd26vDWMjOaLJrgQi1ce2G618LEcIEO6H3qqAGSJfhisQtLtV9dHr7S8f99DybRe1P6Mm+dbZOhWp/DrW0VTkHOTwMZyCIlYVfQP3g3zrmNGaMbjtNZTZVaSs9+BpxnebXnGO6rVf+Ha3Nt4OdI6x17eHsOJW3kuKv5FWBoIPT5HSvVgDpbI9w+xkTL+ck2iOEETWfC6QtRiE8WNFaRgvgQS44rBLj389R/mUE1frpUG32Z937pyPMszMK4H/AlcgG1nfwEhKP6AmUexMwOoUlAxFmg5DTHhRizR7wo0l/11F5Kqda0SRWyut9KFbfdBwMg+XotuQsjO/FN59OI+Z/yZQ0KKaq581nIJX9UfpMDVMq4JJvrf+maASs3iQVCifQlJN8td05DxnCts/PYxdmHfwf29onqBUweVzRMUi9NAmG4Mbajpx64qkTJkb2xwH5mnvxmn6qp3FgPtVQda//jXkqLHfdHr4K3CTQCfFuljWnENZB0M9bcaUHUf+lNUk+ViHZ8pz4m7BEB0ovy7mwlDqGGI0zwZLWiGm16D+D57otkX/8EMfjsfCy6+RuXcAPvBVUMgJPt3SGYhpwE1mqyd/S8mkh+DUsQXFH/dhcztJrEl8C138GbY+P5GHHFFA0UJo1FBg+qaDxcZRNj9X7horgmN1jI/3jfKUViqmzhCS+rgcP12HXCa7kU95IeTiKLWLZjdvfcWk+q67Y6rg7NC82BqmQkqAnzKXuXosPKSGzVXlUw/YndTdyS6igE9eFkYpqtIxiwyCfvPXDUvlx6USk6lKjc8IFVqnhTDsVzzPl1ClW6GDxTk/ZTJz5/LBRc9klKVid8FQxO00aexxJ7DFzx9/zfFzQtFd7OQsE+crthSfiYU/yvz00B9ySowxW299M4qnOeZ6flx0+A8Jnm4R5kXmlBFC/eQSbR7ffn7uCwmjQWKubbH4E1umUcmfZio7H89bePbLwtOjJWwGZtrjdWa/qi8gHdwD8dI/s1kS0JcAUPOe9GPqvJ/qVaQ2pLRGN/h0DMEIQHpeYKFlVA5mamAtnLDzWDfN5ToEA0tXUsCE9zycCmwWqTT6n2XWzoCrbTeZFAPcMGXWRMXCYIcQOs8xIy0U/WVItviZwwSEbRrYfFNoksv5yKUhbnRYH3TXZDWPdLNiNvHwHbMFAjGmgbOydXszEYfKzvhCrxsmmUr4Sj+rCE7xen70M3Ci/qYllJAsc2wYAUHJ2/W/QeVHVfDg6CL+QrLzwXhMj/WvZEmtaxosvSrk41IO0LCGhnN0U1vcQT+LurfaC5HrD5PBoHJt+WAV5o+nMoPg7CR6kq+O1jZ8qx83hXrcigtZrCbM/YZOUaAMx86h5K5n1vqtoWOfp790wdhq6ia1enqjYmrX73FOWzBBShrRmWaxLC+O9mItZdiSRvlM7lUWIkbcZCY8VXROE5T6aRvuQ1RKLjTYRnLPlANQqjUxHdq5boCGkiCLD7MSE0JJ8LaJmFMNecC4bB4wfUH5NrpWfi/vvFL575tdqq9uOupDW/uURjgstHJCwJ3ceZ37MTLOgaym6NA2Mf93Og9JHvsgV737cwN/LnWUxqGCxhDXMgq4TymosTb1L9HSFGaT+xuorv5VsdSiDRJ+UhjjfsHvkL21PJ6F4T3Ll0EoeQJlWvxUII7ZrohQpO4Xb8gR7XvwrL+rkQYSZ5/vt3VGyp2nu2Tp+S3gYy9WCbCMzn3VyxOaro+/RhwpvaLNJ19rhHwQd51EbfYxXkToKZGsaljxEjwygHYFKwUdSq+F5yc0V/G1paMVV01qA0VMoUvpZztytHW22gPJKy4sK50AXMn1YGT3sOu5IEZyLQ0yPbVcKSRV4SE4QU5ukaT/jAnmdNP8twmZ1314gL3r6sGFWnnC71k0o/NX+WRYdxjfw3PCIKE0XOmkLNS1icG1yZeRF8JZgtGPMyZeDGnoAoPkCHLsXIx810iBRQi88EVFeH3gGP7LuwvIrOVDZ1hjw+4ist4zXQHjQQIlRtGsdeMUa9bwVDgRyJ0WmpN8lhmhTe12kCS8hEgSWCHo16JxD3UlLZ2s1R3jd2KgOdCdVgSqcs9QlNHBquRB66WkBuJHnzWp6tVDpVv/TGJ5f+plVZVrVPGBCXf5Y+KGs/UIkb2rSzU/I9bB1wE0rH9uJCJtG2WjG9w5JjbVzJwgC2RYmnPB+W9OUcoLwf/XLBsa5HcDp1Sh+9PzPeu1j2SLSpS8PyHTjvVAP0obreQ6PBYRon/l2tmXble0Q9DXsrGFO6vdBMimjOrSntHPAiyA9M+jGmea+EFSVf0ympRcTPYflQxZqFYTzq6X7Otokq1N9QPZePAGIqndvBz/ZeYXs1xIeQtLvGeF4Vw3CPbuqDmGG6pGCGSWKtUZ0yjcNkMVrnf+mAk4YfVYQjc+WykKDUMUPrhlI71pRZrfLswzkUsXBiJKnlOJ/Z8VTCCcoPzeAOetdtjCaATTn7BApVIBneEZF8LC7kywJKzD9uAuPveCStnX900JlwPpD+xhn9Rg9mDzS1FsAYue9V6Zn3nwZ4dI+Gt0/CT3icLu3S095qz2y5ZNkFjVOap8OVJHb2MXA0fos7cifzTMl307rXlKx0/RMWJcIOJ/a08tccjCogPQD8cB5ISFOa2or0EiQBaebbobeq9FrdRRFIXYeAlUy8AsilfpgpX9ISiCKGgq31gCLPD31IUc2ew22w3X9I2/H8wgbIWZFfTrSWOV7rAooKb61HzXVkk0nm4zjwywLpWbxJikh50LiuBvsxh4HSsFAW/eLnKLvRDIeNeB1XR+SODrbbRSh5ZCdtIIbe1qJOOVp3uRY856w++gsm5pm1nEZqZVBkT53tUD0jcUMPCojhbJYY12belSvIcipNtVovsF+VtqJXseJ3fwVb748JEgs4aO35nEowodsicQf4YHo7Scy+BOLRsSDdGBWdpXwQy00VC8GQN+OkUoUWNTtpce9j0VNWV3SJLZOBovu0RxoMyMqtwl+PM3Bj2PwwdAoM/toyoSsE9PEdOvgoT7iPhFo/td1705QaxsNQLM6VKmDrtfQw1p7PbEUXcGb/p5cswV121E4FjBUtGo6pO9wgwe1kb18DfbJdB7Cq8Nk1R/uYs+VubAPdDQWwUQQQ7LyqIarjJayqezJGusPaHkMld57ROQWMsmRG7X6LPY5FFE0BGT9eVJcX8ih0asgriYXI7qgfWWQC2pFQ42viI9vmtZ9diH2madbc9evsOXFZ1CxVvhs+ZEiLT0MIxb9wizennxiTI6hxI6vLUKVPopreElQ2KyBlMeFxV1aGHyySymr+wp7vtu15iPq01kFNzpevtBM1oM/TD986EDwOQ/ZxCGpBD6Ukzf8BeG6D2Na/E+vt8y9Bt+JDMC2M14Zc1OuteIaZP3IrYMECgmONcZbmUkqU1bTsJ1U83KtNoFRhTzuqQcXIqQleXIG/bNGIXwMbttNASLfVo+YB9WOHFYBpA3xEZpkvZJfDUQCmjaHZG5Ht8J4EQUl4w2v5VwaDn4tnWmqj0jvWLD2tUADRpuUaNryzDCwXPGAbEUDJDX5225cqUw7F8+Yp2zjDAl+VDrF4vkeK5ieySMbALO6Uh7XeeUmDyf2gY3AOTxg3lrOryCBfSDJmN2V5I7BjxltYXsJxsYvdiaQNjRGg4FGz7NXZDVjvrTvQ8kxb2u0td+ZWIHFlCC+BoVJD/7gbDEubAlNDYMo/7LSGMMIxITEStRZMH8MQIgfJ4LNq3uvJ22HPu8uK+GIubXEvdoczmFN8L7VdqPrBr1/xTDrf3dSjdyyZ+N21NcN9g3CZVT1ScjOegT31m5Y8IdlBgsfp3aJYPco5QCzRcf6J+GenuxI+bJi/EBucFrTaCL3qDhTF6T4oG03lRI1AEV/gZExmkHqkIXZR4S7/cr0YkxaxH+lRmyo8nUtUkkzc9QseHrouz7SvjvefKROWOwvoK1xCwzmNnK/Y0EpBhQ3L5ohrGtM9QLTDBNNLD3AYHmIXCwKZ7tRadOzQ3YYT3+XUYEdA/5Y2y90Y4/aG50idskBdF4KyzSX4gX4k5tt+fhspGv5HDaDi8KuvTPYdcTqfvWzWFEeVVuZXFlPhYmZuUZl1G7HovbyQ4yr84Oauq85gDmfeBlTyGZTyvPNoMfhSGtzNyH/07mhxvIEwDVCZPKeTRzYPZdd54SxPvPtE4sb2tuBDamF+VH9/iPevizrnOymNPxRwNvNeNG5P9Ce/A9WUVV3qskM3APS005LcHpGCLXOnd56UoCpkWhiL08OEaIgp1zRoK3XkQZaxY7Rve9gGBm2lP1dDrWhu1Mqs9GxRwwGrTC0tAT2IXo7jJ0IcwFNcccpNvVC+ARTmxeAnn28/aYYbtSUyn6/aL5yQWprJilnetZ5jMzNlabPcqJDQ8BjbzR6K6NRn50lZixS19FOdeHIoZD9F0HGu97bMOOrND8xtuKJgxesnbfQz/ZO4tk38/ToWIbYPMqESJju13vgnkVvFMALMi7m/kxiOO5HfsrRlgGuadQmApVe1QTM92RT3hpQXAzdjI0Q6MPlVB+mTk9HtkvkTxIyMcXD3RmGcl619wZ9FgQ1fp+2OAQBva/11nCh1Wi6MYMPHl71nQf/w5TQ1T/8f/M6gDbB3yoZ+S3PPjgEx76v5PrzzUHbHh+rE/qCQ7HTzqCKKfRF2UcqHRerMiKWLxYV14HDIKtP2wRD7ZjnO9LQAyvWF7JHIkO3ebexZh12RZkhvMnfwGUZm/7CNS/UucHXtcB+wg1SSm+NhbOW0DGpJgqr0tCJVDsUnZdPeg972JpO054Pn6ZGd3dzyQlxCevExlJ9lCFdO8OQy9coOUEq7+gkQHcXvrcPOv6mIoe31QHwrm0paZhN1lkuqUyNkQNPrpMTN/57U/QqSRHMN374+5UMPZXqEmd9piJQE11FetM6YVivbCmVA3b55ccN7Rf0mBjxMhpWcLnT1Tn+0NwwKBHFVEbCCz/o1pOEcaANAyiSHAA2MlKHre14NBw0t/KaPJi27TyO+zfiBscfU8DAR57eOspVZ1rbK0lurLcQ6D/j7I8SKFlJtZBOzHVbUjn/nJPh6CZFZrRQ1lE2xfRdsI2F0qq8DddVLrXSloou5TH/bUR6jx9B+xBqPa30fIe693ccqiN5eNhjclgrEPC/ugeszvAH51YEZyg/1QTrzBnztxeA+LPmA7gNIjPtMuzK9qA+n/pMthADyOdtSM7tmqBj1SBjVDi6X9aWk8DR/zC7iIQeDMZkYQgAUtHsnsFSOxmFX0tJSpu4DoG3swE5TAdteA1+ljaBO3xsBGrFR4h8RuBi9TarAgGWJlHAidNHoIew2vp6+Qdx8F1HB033Kk3ej0jsZwFlYx1/i0ZKKO7hshK+93v78uIlj06Oooqk/FxykU8icCFpg4DlcOzotH4YbK0kG7vbwQruj3Bb6MThR1MYlgAD6FHH+GyKND/morPmVUo/R8BqTwqyRz4qYtG3V4eHOk1RIbsuk4akWrhu+gUDUa2O0AkqcKAPu5NigPup5Dop50YuaRrqIF2qUtvMe858bSvEbl47/L3cIP/nBzrcnU4Jgv/S6OPpvsdxTQytjgt3HDRip2ve6/P4/u4e4mBUzkrL2VubmVpUszmvm9GaYGBUSLFBIGZ7tQPQ0+LPCMv3EhQOhKV2UBPb0RD3FU0h9qjG0P8Sn/zf0hi56gyw7rSDgxVtcc+ihWBEhPZlkPobAA9ZpTlB2QmybBK8LNEIvPP2qoTCHO5zFqOtOqAnGpyNt5UxoQ+0ru6zemtaFe9ds0WFW1wATddymQHEJQT2dBWeyejcg9ag5rEbtbOBeEXl5HJCIElxG7whwmc1FiLufHlEbb/FHtj7UsLXQ6wTWd4GyhcYvEsYbiTspJs/AuEEJ3Q9yjUDA8WZAtS5E3J5Awdwo+0ABlrWRU/JdUw4CBBtHMpMPHcby37/7h78+HVYkxpMjC/zrVfZLfPl+DgS3GXVbb/5vVwOOSyQiSQ7yNh8ckqfAGqsZOY+6L196sMTzeqIDBzMizpW9AhbnuJBNgumhwgSpPJMMa058dwtR+R6PUEpJlByIYKKAKJ/nvrwzGBoOiAoQRHy7p/WYq+Dg4VypxphNUMbKHLcn+Itxxhz/3wdHhX2pOxvPhSP9qomdr7YSoJMuWy8vIAXRzkR2YP0tOJncm2LIC+a9QWiZXUbigxcJqg1/lASvcwN0Qe1NeK/15JNp4BOqej2cqE+/9NBhnxLfjpiUdnxeqr+eaH8owVD18WAqmhp2anwCOCpg4NHYasfuwNBQb4riVmxIw2dk97vpkLbomeiTZ5or6IO0ZhpjXtdM7wluFlHkmb1+JZ/1pnHS5SVsZXqHqiO8A8oBzqWXl8fOewioGdhn9XLSkqyQDH8wCwQf7jachkcqdUnjw5aepjhSDaZxIecMeoVyAHsYlhCaO+KeGf2S5phLyN6R4g2TFHYZgJCrJ2VGJYPgMN7qWbWvKYSVCf8v8mvt/F6D38PjLVceWBDsmDT+UrdQ4AFNodFgCQzOI3X4ZyhfNUuJ4zx9YlhfhPdVquiJmCp3p2OUkfp4CxsLb+bZHbq/Bs/mRBmfoamkd8dboWTaHjBFl7KmFxSMas2nnYsyjQmub1CckoePi8KUm/OaJN09vzMhAoStPhaQcJOCgWBp0WmXS/mrpPiHhSiSrv2YOJ4EEM4fq8xEjJ+1jg/9Vq1gywXFZNhG+Wyjm7QyMIIt6ZfdyE/VD4r4dx62XWZsI09cDYRUVTGJPtUaW8cW2HWNqjtUsdwZtw/WT9rBWGCp3oAHaO+j4PKlx149ix+upZQxF8rV8X/DcllOoIFriNdlmp5QM6BAW2iIcHz/1uqSr5p04DhMpgy0QbMIf6SjfqzZpUSE+HfT/1/csgSNg8U3bjAAQOmGv7xTLHbk2sPkDM1ytcHrd5GzymHh/0ZV8VkDTvu+YMGHwgnFYRpucYSnJ8xavWcaP+HC8GrvLGdXXtrk9ZQlsIuVFlFapPgwtPP4EG0MtNQc8MA2tgyDopx0vO2s0kJTCQJaqPLMz43/iX8jB0+N3YOBF8sgS9YjwWHhC42qqZs6ijUBJBD9MEXD5o73JIoVj7AvzLLFnPP0VafueVVN25AC9AQO1vE984SFoX8+hgdMct2ryItCxqqrAiti40GP/0rQejmTHOeCeQwpYOL6WBmr6w1sUXFnbE2cRkgsHlZ1lUeTK1fE1eS8mMELTV1QvxS4Bq346xSKS7uRRasJfOp6Wvpo3xWY1wTRPmA1VQYPwHjCFVfxEQSRGLZ+Eqe1IKLmRIkPQiBW/T4stCinVDMfJ3aVSK4EHA00crNnzVbXXx8Bom237Rw3IgfW81wdEwOW6c/MHECXJ8PQJ5QTjDYOohqWDkG8DcpVchJwozQ2p3iKxJwrcjnIa/Pui0eJof9kmQVEiuYA2UAbDzwfYpLfsSRqyDOitJipf/Ay35IwJDvXtl2c0B1FD568AbKqS7lGZ/GDLAF++eTjShaKgH42jdmnxqMtXTytdyfHuZJV4j2v/kaBDKp4swaWWUv0pyfxZhWRrpSXk33zwkbi6Ta/J1AAF90Ar4DjkaylYqRcC/mDBb8CBr8F1pmoFYw2guOt2dJrk2dBL7VRJjcJhZxYQzwHmCDF80csnz3Gh6l47pFBNQqZP3o4BhatNXf+W7xWL9/iE1eaW8iFvbiAiHgBK+WEDu0uG9L53u7iIOLDZiZeS93JHCREkfq4q6zd132pe9V0CSzyBVOtYvKADe+LmOJfPNgUXjadIQNlvmL/v/FjvXmX5bw4+cZ9DiF0hv+M+bSOrQrrnq6gVxAkvACcyASoPEE0MuEhc47DXQ9xyj5HKmAJDeHfDxP85OR7HtiIOH4YtH9EsLKQqe8i1EMcMqUkpO5I8tLb8u3FyLJrqSwqHM+wttzGpYXCTAEhaiPykv9bqB1ILxodGzfe6gNPNdtnkfezxO8oQou98QDe1ovk49RRedBWKLQIdVQ6d/C6uhxYZog0wY+dAXLmrCw1yaQSmgwTttwqa8MbxRgeZTIx85zsCiZYi2XTrqvFVu2XrbeYrdoqgHaSk5COZDWPPqhgmWRqc9R9fLZP6mD9FUVyCDB9DszN6VWLUlzVXA0LC0lJ/iqCMZsgdxpVTqw8yqb8uRTnqZ8w2+tOQbX3vyYUhyv21sMdXP4WInPf0f/l4tFP8X0NKJ7DInpGG+1m1hmgq+L0EGBxEHkgrYOEfY9Oe6lmLjNVpc0rd0OM/ooUErxiA0TDP3yJIZNOWFJ+GRJfJ9dZe3RlowMOM1CWX4NeeC9UGXZ45yyqYXz6HDMtFAsEebarHVa9dmOQTYX4XGFJEgEmWEC8O3K3KhI7rGFRSB5I3BKTfXdQ8kIRPBs35fnHEYc/MjlC8KPYaPai6X2KGF2xfHK6dR+LgtMLf7sO3CwzN9c9T9foc4a8CUL8T4KzX3xmkq56VUmLGmxLPtLjJ+nYVO84mO8hGJRPGeiBmAlUZeND70Z25hZgcoGSh1Y+lqsk7hkk59UIYTJe4liIdz498dwi5xN0UWWp83EUBzbGdNhGEtjuTDUZgmPg9OUO7HiuaIjoj6cImkGwCIwyrWFy3udqlyoaBqnfZ2T/7lHXT3QZSGkpLA7K6VQwNfmS1zc3FU4WBVevn8Me1OmHMLCEse0/prACKMEC+KRJA4UU7LNmqKjCUuw3owSLJN8UQgBNKEdeUajDHebh7wLjd9oA6/zD0tEel6TQqtcZilJWL1GxN663I3Ge4c8f5HWw4OrGVT3WqtjTzb4HIxjIW+IfhZeyv4n9bKdbPaTGmrne1hTSZmyCAXTfJJDkTShI61xrFeLnRnh8au7jO8rd8nGLCU9vkwWt2d/UuZ/2t2UMxsV7Kz9P2i0pueZjJrwBi3FcPlpqyET4GngHCeisQR+wqO1sdBtg4de7a/+ZqInJ5Q6JQTJwJt7alUDp8aoo0oJTwPo3ysnPhjJVkm7JxHhjFZQTaW7c/fcTjtgWXodC7iFlMkxctVkUS7BINISK3Q534R/1lY4OhigawGya4C08zhddN/9kiCnNGK8JOVAAV35/cvfxkpTKv3EF+DOd4HWxqxeOlmk1Y4j5mzZcug6dhwJxLlR/VXkvjwaDMnPaJ6vWA4xZivxxydex9unhVHyalfQEGh54M+50x1XV61koIQnxyeOFRxrzVCss20aL+vu2zfim8PO+rSzVgkRF1iWzv8VUjIKp9pZot2pnXGHike5izZyHO/F/6gMxADsCf867AaJqtuuxXRXJyldW7CgaWkVCAmt8D9O5oq+pYZ4bHEm9hkttBm6pAn8Els4f+34DvLAE699RO/XWnL7nkuJ999heb18XJd5WvyCSxexuLOOFwMIQRitVW6VmU3BCMMWR5NWA0QsIA4UGO9p3TS4adftnS3U5ZAOdid7XAB3SxJtJRwD5lWsOxzNNCcu5V/bZ5OsWYk57oRPYKhoFJONfJEfOmQFvdv7pZ+V3fB8MHNy7CAmPWLdz8Veg3eK/WDyExv88TEHj5YkcelXGVZZ4dvcF5HpK2XmpGaMd4ScvPX+qWrOeK1INm64dziwNjUvVvON0el09VnwvMaec68YHhBfvnf2pSA8mBqf0ilRmK8bKy2CQy9Si8tAu60c2AK2bD+ApeSYUx8ly9/nR2UJxlxfjUV3nVSKEOYokkoaRgNl6HRAYOnoQMnRpHuzcjbqn5YB0R9AHpQCSnmxOZYv0laytnRzztqhSZRNeYbM8BQyHbzN0Ksdc6nBmZP8U682Qicri8+Vid475qDQaXMXC0D450yEm6LhmlspD2Q0EJoHlQsuIO1IslLd0H/AJsNmpqkwGvAmbZWZxIDJD1bpIBOKv1vvWFh17Hd6LP5LcV1DRcCONdIacMxhc1TwJpQPd9+K9IhnmUr1T5Q49XiWPghXSRYOOGuvGsefTHuXjbunoJFZjHvjyHTVCBA3Uuihwd4wY1ETl/wpLfsF/bYs33F2mxwZk1GV97VGn4eua789dLhxASJmoYZMvoFTDrrYy9wMgwmUWzrZg6iOAvr2lZWFnE5VGh6KwmkFIJqiIKWDL8jB2Ulp+wV00/I1pT1JUbYmVpk+CiaNhRPdJYm1bBaOJNeFMtTH8GWQd5k76VmojkaZfiP1beNJRg92V2V7N9yl8TOHxEE0upl45yLjtYTxpaDJ0kZbJbu+dIc+H9bvEQ5h8n5b2+kdEtV9Y99Z7n22rEnDgSxl3Tup7bjTHxotqOD9cX0bTNe4M3AbKvwsfBU+XIjAE0r+mzstlcf74V+GjKfvt5FFHXO8ZiqFmQ/SHdJSCRckjbKIBetx7Yps1Jtv6TZJAaO7FnjXarkSZwNciCaAWkBcybs9eZY2AfS52aHcLwAZj6iybwNBWzhRV0QMsSfoi0wV5H6ncmpEp/jrrh1Tg5U2HAL1w7x7C1D8alBYU1nMxvZo1KzLOIyyap6qLPWnlis8qTuCvm6wP260lpOTtADHN6qaG44x/EOxth/YE6rJ+hvbP3XYL+Jz1mrQ3pSHfsOAQ3BszaiZbxTinKdfjQdG8LZwyE/cA3zdzVxgaIAVw9j+aBa86PtBjon8tbRv5inVzbn52pxP9/FBLcKaVfqq2oIgCyC5iJU+8zzNiYlN/WB2xiUTPfEWdNon88VCvkdvxBpxRamSJRbWerr1kMEb+0sJKVMtR+yJK0Ipj6tChfCrfFFTE1g5TRzzidoQ9kKRbdRVxnOmb50njlSinEtnC7uuOBgvSJRRFdrD8VotxvWfdU6aoFjkq8vr1LrzZPywPY6Ib3m5t52er0TauXuTHHAlYuCLfJaFWp1t15SMUnHgXTbKRD/KHsG03ra9/5Q8K5JVPI+5mqcYU9ql4YhyvAuqrOBgP9ScMG8uwyw93ikyuTjvW4dQsEtOP6xvSGuwZnZCANSCAZzg1lqhg0zkrQP6DFrsj4jk3/emPWh3y+yTEglGFnhUzvAiKuNuGiDrSz0hMCQy1RkacFguI02S662AOm6BN2vNP3CRIohKSHJ4VWBn3fQxlpc1vNwielZLuthzkvvjYLM3nsxFq1J8mt2ppkhfuMng7eLUTNu6fxBaYM2SkOXp9WAcBOAviojMKz1gfVGSNcQfiYkwR57xXJz/0jiGzLWb07B6aY5ihYJ6GDe5p0gdkRlRH5wMUPCoZXcDNokuLRMY4HzXFLvJxHRjS/ErD3JFMvbhjVLnfw7Lt5g5fpgJVB3P/LtSjJvKGmnu4jk1AxnGAre7nO+tXPHFBRUctXNobpzCN9lBos8rA4wx82yQafwCOupBdtwqLLN0Xym2MC70XeNwgL2UT/9uISRkYTH/4LlYEsdEe2cMUwOmaUFiIHkvV796kh93ut3RYRcc4+MVxT8jEXZYIIt+Gh8FS/XU/wMwC2kIOhQVx4VTljsKiHNcEALhcFS5hKJkl7sPGz2p8vLTDzaq1AHAMQ2TBgp5/c0oRooXdUiUmrswai7sZaNiqySEPS5jIty6jeyeh5K2+WC1pfhOFtdjJ8BPsou0jqIeqR4rRHu6BKxOHX8PZ8DG7XdcfFpt7kUDPJsWaU6sjllGTwoMV3nRibRHvCagyL18eGhnQYklK4rb8a8bcaPAuC/AhDsWVd4Uufq/7FyLE2Uy5QSKB8ChwQpfcDGZh2iG+FlItpVRSZl4TBZVrscI1C/RFhNPOr1PuuFwq/RhdX8TAZUvZqcgc/Dg1/SPLSKtwWHMY1dG/L0KnFQFueqgGMYjBe3utipUoOPiQy36idd1iXvf2gfTK/ONm1yOXptFGjrZGR0m3KddnCLtarZm01o0zCMxYb7gexloW0PttHznAidlUxrkggqDtgAivElzrIbKpIHd1L9HS+up9iEyVz4P2z1Xy7gR9ER2255R1/nbvEHFuF4qT6RPrXNaktwurhZCMaUasoDD82P69eQYVeK7GMLmUiELk2Jel5WuIky4+XAQArg7JYl+qzwYmsTSTSwmbaUo6a6pVkzOd1QmovnFaLGJ90KVdye6ujhROKpHRM5eq/Jdke6jT05lD2gygdSPxacYzG9IFO5tOP1s2s3oF/iIyg7Zv9sT7JLxpNdOWpoZ/gAZo6z4vMQMdcTLWclT4f7OBVPuG5K/k8sCJ2NcCXwfX/9FFzjENWOoqGnD77QeJlT6ZvVfiPz3QLqTiOaMioUQrryPPhjjuWWVLUVvgIA6ekkZkQdettrw6QyYdUwRZuIDr4zukEuAbjKTX81VJQGACDx+prJ1J68+B4IjHA0aCpCpmNA4U9nwtG6HWc0zfVMpcCq71WCnVmrlz6I9u1mT2QHNrpqOh4A92h5noQX7H2RkR6Fof4fB2WHXBrA1V5BVgkNXWZLExgk8S9t0PxeVl+bj7tvpMmEaG/ZEgSMf0CoqqKMWEy0UwANFUYER55z3FXNxQJraGWtNC1Wh7GL7+6lK2eu16Y2Yq4z2nttoBkmxoWeyTHvcz6EblgetpXi3YcbM/rngJ545RSwV3Vb02OVOlujwC1pedy0j8GOJhYXHGBq2AdHJLp1p3Er10jqZavow5rEn9ObE0+f6iBDIeh0GXtkG7TXUylVuP7aj4RZvb02Je4tC0rSO4LXYSxNW6ZGSLORYkCMpBYmxLrnH4MkR6+BT6cfVJGpE8KRewIy+5V7MVViQ0oNQPVTYCJ+oW6uZAHS++JEiRi+q/S39BzqvZPnTlO3gefMtL8zBiBnw9xPHK6OOXRtONsxjOtXYOUU8QlaXPkBlnHkF37zEcVGFLlhMsCArOIQ6hyh8sPQeNiw9hCavluYKkh6C1UKKg1mwHRgvlHklfa4QQxUR1p6xQbBjp9qNwi8pubF1EPX5lw7f/odCeeae+UTyRfgvxFn7QaNKDsrN8q5Q1z0JKDwpPVq2BVZDteZmWP4HCayrPhRW2q/ccYksfHsGVKt1Gtpg3ttPJ5W+O8L/ELrusVqLr1uEa9RM1zMeQhEJ9rl5m0y9lljV6Srd4STr7tudKD3Va2WWahymM0ldjpaneFFKlN4nz9EqDYbGJVBjRWAkPWLqFcXycni3TXLoGVx0aPryqq2sKjZMZSKV3FSuk70rRnMzjv2hKSt1g09fntTeIeubP6yjEv2i73jAmtZ9BZXxZc/AMMAxkR2JC+cvUa1MnZS/NwNPTbnGBcRtdlgkE9KlOrcEArsmdtUwCNnpJAsGYtZe3s3uz6ATiEcb6cIYusuA72dMdFH/AHu3+6+/Fs5Ba2jDOcCd3jx6X4YZiA+omTkn+8+q+0qLXW4zelrWBdlu96Jvkdosd+mE7xVk36exZULOTalvykMLuvQQ99zPmkAODqszWbCymV1f1Uo+gg+YLb1uZKvwFqi1Mlb1BeZs+v4tMn1uG7EyDTnZTUbpehUiyrDM5dRX9+XgGnGRtz9dvoOGTQlq5IsfdXUEJ16kP9Vmwbro54A8SRyW/Q3Vxf+9RFzABGS6Q6iMEm+hCXlSGred/Dp6w3EbM61ALa6b8kn43eWuGDGjIVricosSsDJjtMgSU24XkYT73NssSCLfJ3HEVPiEjg8NbFDzjXNn8QWFrvcCa6TeFLjNPXAGBjNdWhjZNo/ah4Q7BqkwNPDza1g4p4E1JOFnzeWgq/TXtJNZPFhzPrnXBbk6ls3qt8IUEpxqUZjI6UpSj4xqhV/IYOLpGh3cSJIowZrQosNKL+0quCp8y3KIILdw4ZPnc/wjqfQK0KgYnugflgtZnnftUDWyceh341JhpUQePIj7Wn9yKOKRLD0auNQiqdMKxW4IGIgRGWjBwEbkvCI/e4eQ4AK8w8SQRESEWOQL0QeQN67Q5jVfaO/D3XnY7MVHZb6SPFf1QX2v3+/cZ5EbQSkxqHV9aQPi5Gic0b0M0Lk7aBJlJ6cgjh5fXJeph6zVMCe+x8CKjB3tbQfw0eVoNRCSGq7d/A/lBBFgDYyrGclEummle2HVA15dBE8fRCbPdQNtC+12RvrqUKQdzw42m4Pw+eVamTq5POfsUsVDGh+1yPdmNtRlZi04w0vFfcxCkjgfI8HJc+2FvmmddwDpvtGRvZPQjJsxhs7/yX6cCi9U+91yD9vG4nuFIwDJPXsVkLzH+zUHy1+CVAuU4s0YUEDJrGrSoheQ7EMJTm3rkq1ScEcOtM0113vlHKabnV8rydOPPX2X8Z7aaviP+QBy7/crAfgANrWCRzUZvFYwDWC/COhiQXQ1scMJOyuNzfcd9LNMoiNlXoPoHhY+TIXcCn0B1ioS0e1ED1oe9nenXQ9b+P88fV4FhwB8d2TZboTsFzTEXDf18GRGQZVBlM2IduYr7aplWNnN9JdK7tafuPHgS7Bb6/5yXpN/JA53x6cgiDVsnrlenUazARBidx0NWGxU3l/zANw8dakGsQNzR3bQ5oqClO73RPjhDF90hzi3TyUgoWaDc2WwdGubHfG+EplCRO51I8yNDU6he9SsYs7uQ9/yMKL1y/A8ySL9pxxCM2oXB8sw9ayPN5MOb+1LwoLQBC0nDPwf9YBFLSdiVaaK7K2jD5SCvObFyLmxifioZcLBTzzgfDakp32Xcos6KDlLJqWS9V51hw8nF7sQO34gjjqju5WLHZewGEytIDoZ6RZ+V3gnKw9e8Geb1WX2pOnBHhv0zf01sRAcVbecgg3VqJ/b+7ettAPRfHrq4ow3NOSLNZ0jjI7gri7sG5BjXQbPS86eZjeem0sD8KEpMjApx36g0SwE0RFb4Xg6krlAS3HKRhxRDbYXLCxxwb42SxRXACsDuTomjWEsQp+CIK7qS+Lwth6/S+kLON7zoBfiyirde86V0E5JpuMOhbIbG0plJs3Ky9kTC72CGGxGcyx8rDqyJrJM2P9VwWTiaXhXJgiKFPsHgfoIyYwh8IyHr6imtN1uQYgqgiVKS4imt2q8WEvYUKex/W3Gp+J/krii9yKnC27daSGnDvfwT6/sNUrAcfuraRlPW8V7zkjQdC8DVYy8Xr6HRPvfmYEBv6XjHWJVx+9p0H6wreC8pTjffqIXf+8uucaUHP8oGrB6zNCu+exsxbe0TR/tLlr4yqe7Z1992t6AU/kF4AqFOMZRIlIfa9nVGF1M+LIPa2VEcU0agJ1tFxb9LvpUn2ELhp2SfmivWlNln4wICMZDogibud4dVIoJMpRgD3am4gJyqTTIn1D61SQ063tt8RoK23X9QoQZF8huDAaCktzknBJ2UDZ3kwL38CVQ+gDy0VAVu7g/DEMNA/WyPn8BeBAmNpq553bjZsyLuKwUY8klWduQl6Tta0ajukNteXpMebbbOjd5k+kpw8vZ03QUAM8Nyagv7ParmPL7dSmM2G9Lp8Yr9DIl5KRNlUZShxeDk54R+KubCGCAvTpAKk0k4lXXqonlZ8sRdcnD3oBJsaB7YwXa2APpYS16FEP+ldqUn53dlK2JMUoE0iyZ4Gpk212gvfjxQX/CZjiDltiFhXMkhKXUQeWwM5+MR6CsiV+CwvuyDtQpx+N12k3Ke85I/8rOM72Drpqw9LWHD8s5Goh24ggGXHGghfP3mKXiGywg+NdYcjU7XyJvftAZMhP38E5P/Yb7ZzRqdDOYh/ybCRhyYXXXKjVkccr7sX1MY9yejKXZqSSmJ6ZQ0pjepyKv+GpXMFt1vMx4tsCfQ0kvUKTdT5XoZ81QbyIADJDaxQHTo46yhWXIwPz86kWwQgpiUKdEyi4TJwQZSpSJdQfyP84vAKbC12giyvVGLO7mhYeI/a/Dv10a6B9GAsffJsXAO+P3LMYTmVq0UOSMAlKZogUKRSU35CfBzvPIz6XGyEspmddcjS4TwdgPd40PlZROJhlxuki5QVi5NH5mqSIxWEGnMQavALoY2yb35NUSv116J9VzofHcPDYQGPxWQgBYPXwEf/GtriBMIGLs67KLv557S+uGHxXKQdoP3+PMffXD6ZoXY3q64nvklDHOIiPyDjr17i2iKoWEs0+/eOWgyWYM87hsecL89NHD42vIi/ujALEyCmYvOCxhM4QGvkhpFhjBba0N9yNjWrjU7nFsa+xzO5qDhFmDDOe5W8E7MrZxuqT7sGgl+hDj54E6ahC2FdUQ7tI+kBolewj/wjJ/QTHxkVccsZ7tCSjU80TQmIrIKBOzpYYkN5ToLaHZaZcUT5l4ISw7GTKaDYg2rH5qW9oLURtDqRw0gvk2Z3P99v4EW9EC0gnBooAn8uyXFRPXLs01RzeFxt5uemYa/ZY10j0Pbs5vUl9Lg8PheTasEl2bxQpFieQCZB5Q0FJRREu/Y94ZG1eh8oElLNMXsLauzh3/mxoMCDquXEjM2Jao17PjNhWAGZS6iYA+ZbD4dSTL61tJaMd7Hdl+nr3Jr81hdr6rZ5+2tel8gkxVvNhhT8tsaC3dZLZY+m2Qd9w4HgO6uT2MmAe12oAQ6UB7KV9xUeYKk1dShA+EXGaoJRvdXCzbQsB81PFI+2WOgj7FoTSpIoSV59yp8zJOZJ50lJi7vKT9BqR94gU1ajdqERXUzYrbzJi5PC61RN4UL4YuWlMrkC+h9RXFs7hQzr0OYfdgEKMWQEDRNGmgNWR0yO2g1/mqKjBd3nYgMIpWJGlLk8rPUvnLywn6ff8+cjoM/kDbD5abW4xE87Q7YIy+TmaBf150Ojhvr9IZQTB8eSVLvvqgM1ToruR4vv4qZo/RnA3SJfcjS8NIEA+NIsOXmz4vKQeitL2iJFUPzgOTjfaqNK1Paxy/tMwL9PVyBXwpN5ug2F7ga9UxirN3OlhGtUKQ3rqIOZAiVHA+zQ0ILdhgBt99QfwZS3mtmWbueHFHkBYQu5eh1ycqVcqnVJ3eWOyLxQF0OI4uVv5baDKt+hcBIDQEI8TfJ9OrzZGUYBfO8B/jv9pGSlzQdy5Lr0oNgNyjN2oh62N/e8Qk6fMyPbVM6/sK735Dd5/i9OtEW+sa8WEdONQe4EuW2u3+6W7GbHgKxceRprvZI4xjFGKS70Lb2aMo+ARbR6Nlxn4Lt+gZqeoOZtid424uGstAGvG7vWMvCW6Yr8ZpTc5jFXs+XW5lOpmX1suFo1WTHDQLY/zFcK2Fb15qjWU7nFhO8fujPpcaeXtG1RC870WjQ8jOItxtsJkk5+XNyN+NYUIwrFwcy9nV75FSEGPgf8AIc2LpvESXB6EhXqqoVh8LRHClkzKFmYqPueL8NYhp4jQXfnQanhPEM4duR6Ay11ylytMoMy0xsZ7CgG+CXo/PFNmxVSccg09GnF1JQB+2a6uTao3t738SGg9qacmn5O+OCoJznHrMvsl+tpdKRx0M9TDTft9BE3ZVLqweJ8ugrE5Bb37b/HkarUZz32m972XtIY2NH/n+V7wfrMOmv2OQ8gmaM6gvGDBYmwLANn3LlaQFFx6/OvW7VC4LhtOM9M0kLImBk6sLoI7Ua1FYx0WocFg9hDLfP1Q2/t6cFqomRCsTtTJtoPyYM7p2u6wB1LaX8qXrbgcQQkm0eHTKCNI4F/xPbTfsZqWECEnCatLHW2Zoe23Ho7R9nt5VAjRg6h5sx5VZi2wPPCHkVN2Ljd8j7ejijgZmyRCLdZ6IsF9D3aMC8BPZGJIYw9hfs2dXnR53bwW50y/n4m3mzaDzhY9Rl313+GQZiyfbVwzrzzqdeXDg742XBfygtZCkh4ReT8qr3yUhij2nEOJYmpJyA/e1RFOKohFFn8psPPU0eO8kENPuHxZSDJ58ANBzQDwb7Cv65UUgR7YY3aRE2guu2tY31eX6wJ220++mxCbQkqXIa0if78YbGZHD11u64Y/WeYFJ4MQoPIwzSTkkNcakvA1peXyknonXesLuTl6PnxvgfjjNXxW/tIXNYvbBZSNQyjrBbYNljmYe41ppKQ8AlMXyi9yGdbXv1Mt29bODzoEATqbfcCRSyzPLDr/OqaFV0Agy1sqfNjl9X87LEGWNsHvreBwIYnWtpt6wY3Ptqq6lFOGwb4GexZksPGZaz9fXdNh41BrnJAg/zUEw7LPBXaP7lI9pUbs4qp2XYoI+yHsmfBqUqxB2vO2X+4PD+Xbh2hSb8RobQ0QF9wPkSEZcvWS1Wcjr91dgumDnKpbCUgdnSf6EJ+3Yi1TVA+Hw8aK3IKt5JSty2jTsNgyj2SMy8XV/bRtG8Wvp5P+Hewef7qtzzMalURlgM/XtmsNLNvmNrTC1RqqjB+AJHaPYgRzb91CX8OYEQnE44jt/lgKmJ5O8LazOS+wgJ4bg9Gc3fFDGGxIziaI5GxGmT6fNf+pt5VPS0a4wU46vvwoX7Ki7RlsJ6ujdUoKwNG3gbfNebCmXNAZE+AcJQMA6kNOrf1oPEEdSxb9VZzpinBkzbhCKMJIgBM8idnxTe4cbP/yPO+BvlF+HdjeFpe6RVlkAwYHbccUyjxatldYk/fhUXUC3RHocoxKJjQeFaS/r6yQW4rOESvoItCBXYDw20syLDRRmQeHOhqZ58mdxNBP38SJJnFIx9bDssEjn53C74AzFfxm8OvWwicCDbnZEUFPdfpLzoCFa67Osb4+sq57ihu26RRQEVugzHEKoFk2cR2v5GPxCAHgGOL/cy3xeJZINXOE4S6HRlxwABGOs6w9uJEL9BfypR32Pd39vfCnYNsI9l1hQodf8mkUOqsAIFVPUYJapGcicbrPp61tSLM7ZSE2Culzw76Y6/ONwRB98dqXopiCYRTCNUPXHV4/LpI9N/7d/dhMzmetqtLQeaNkGTPjmFS5EyRQr5xDfvFiR68YJlkq6+FBA32SFMJKs+LQfyMNc6UMTLurcdqxApVQg4KSp01UzVDxdnbwoP7iqU5V1lA+IIUq/3ibBd281ZpU5vj+HEH6sMUeI66MVrJSzjqOKvi+BU0+fuhmjGwg/SP1j3PBaFtejmqLfDxD6i7ZQ0SX4wDhLjR2cDqny+psAe8jVC3DIoTYZCe87oDQPT3xPNJ4++G3B3Nv4qH4+USsdftZajFOFbY9HJyVVlWAomyiN6yCinexDSQVgO2K6WKd21nnomTSwe19KJc7EhZ9pPRzs3zLRauktNQ9sLLhAYRK+YOked5PnKo6f4ZUNsJSPx88sko5f9b83Z8T5xhY9GHUxGQ8ZzWe8DPIInyZ218WzY9YsDbeBhJRlBgTCULyYoEIwhujxbyAVBRELpcA9rGBkhoX7fWC8B5W3VL8OOt5rtfla0mQ2YiL6CM9mJlIE3WHEag4Q1TAXTbFDpNTTACZEA088zH/6UZHLw04PO0zFl2gYSb+l6Nw7D1OjZ/7SpFQgPFiv7b09lMckN/s+xTqjKuSDBaVRB2gca26zV0+Ys1njwmrruySsaITBHEpZvQI4izp09MoN0axR4M8HBJM61RuN+LIlPXnmzoUeYzTey4A0R7GVVRH4gxLc3PD/mdVojTDwhzPIvIFj+BHCtKlnKeuvqZxNj4drqHvYjibgXOMU32z5RzU1QhliSlTGcebaEo7DifidY0ptKxNUov5jcXdwLD9wCnpqfzfwCjdaSWYnCQAwb6zdf2Vbvja2+BOo5YTkG6nGMlUMFUoyjZEnEvbcTlgqZzRSwW54zN+/R/0MxbRG23vTFmIejfo9QzS/ZlcyXgtFESksyzt9HX16FiQ1j7Mdd6ilJHA94+PbfQTPpea/Gu6Dtdv655jxkYqUsS9f32rn0yQBs1+UH+hXjL7O3TrPGwRBMGs7jFawzAZN743ivyNUrSUdBYZLGNu/15K2WNr0qS90zTMHjt91uQXbjCtzSePK265tbK8LtdUlh8/1oiCQ14cnm1YO6yy3APumQXNjYbW39/syk+IMM2xI51DqbNelySMlM3inwR+BxfSEXcoGr5uoJt88VCq9O/0Jip8joFqasgN4sD6nA0e7whtioMcYwQ+N6R8JR4xv5sZAqeVR8pwFGd198zuT5QNsOxTFtXvOz+z743+PTqFDrBo2og41hm3A2XxFJbTpsOB1sfmMabGxt2qzGQvoNvmP8UtYKg+ntIKHjtUtTrhP7oT47It1AND0m/3gcH+ZJFURREgKbAgFSM2F+vZDBHBD9ChtTqM1LtD0IM+hbhsJTSsGq2S0vOEJQUcpEV2ehoJy4+s4xe52UuigYOPnxuQ0Tpq8zIsuxZgbpaQrapb6JyQr6Ycct4fZQrQsPZk+6itQJ9zuD64byfPN73PobX4OptDIi1ka1MvjUYmekRxgKu9vxk7bJInNvKKEDAUo8pZm5JWTkUAQe+R7nHyKNYo0SZTgrOPhycp4cr67TtNI3L8t632ZUMbaI2BWQKCEMokE5YZCJYFJzR6L9S9+FCeEP/JKeBZSw2wYK4LTahpkH7PGIIuMgdn9hn4E99Q4yh7vGewfzU+u3OkoZ/nPYo4jgpRCj9w+HgdouW/GNVGl+M9vF3hkancTG1K3prCBYiDLj9NiHMTF5jh9SXVU3Fm9lDwYKks+KdUfs57indOm8ZGH3Mvj6bEKoiUrlei4rXTO405PaiQF6h4mkdFuaBCatDSnmYsSnBNr5kdwdpIUshLTAIpqtB+CoAKyKwEYLtF+fcWrEysfBZEOMwcpxntEOqqGDCft/MjCPKhABoG3Dq5Kr7Hu/wF6GKrCBHPp+SkdWN3l4T2S0tBKCQp1XkhgpygcOUDhmIO+iWruZK2MVwvaDwg6nnn3mhVUuWxrcoFq50O/JcJU+chiMw5GXrue9qxu4SoajEnSseVIk3UppodO+ogXx7ED2e9taKwkGyNTH4yTvRxTF+txHn4+LVHh3OEKXFJj+zUZMYTZ/kiVRrgBu/SU5M4U4rNZQ6LjgSLa2GPVqa/zQSSZwM/NqDsXWYO7+qyTP5s43cHCKCO9/BMhPLtPWpwXGuappZl1/kks7jiaAnoL/85ECetOZrngzQ1rBBk+m7aH66OyGGHqDWCJDOsY9A2uMZdraFONMFzVbsp+VLcp0sHmXAyR9LGFToG5Pj8ZDESHUIc3y6o/Ymu7w6Yv9EBAIMzXjhEKjKW87/USpHRIGVW1HXwddbDXZfXmcWPjdvD96YCW/6pHsIZBiTsWQyZT0bFDAKsVKEeX/P6ZKkEbyjoggUpELXv1M4QHdW3aRIA8DfvY4xykP8knK/6dvOoodByD7RPPOx13rR3b5bercts/kAkN73Yi6no381HYtsOPxiHKHzd4reZFDlJFGX8XL8Cuk3uC55QlHT922FJgnnVx+SbeHL0RRNzip55cnZUGcEDlgwF0mvXXi7wx8eZd4W3Zwc5ARMiOytKDc3lnHmbrbntrDIevmEpi2qBsWgyFqrKQ6Ss8U1cCfn/tMl7vtLywNAhy0yhDF2iiT2zErFQpXD+dM9kJ+xepIPilRXQf6QIGmPwqs1YVITAYV3xFfuLTZsMAeELvPLfsA0I01whr1sibKuwP4U/u6OwjqAmKNVG8jCd5Nps5a9+yADp4B+fQ5W1cPM0MUyo61/joTW7v2DdqiNTQ9v4k5sTkfzrciOdJ8yrxfFM3a47iliPUxkPjiwTFvqNHFqy8mp0sYLyZhFnDEskYlP7B+nKJJw9UKEQhOWKQht2cEzff67gMKsA7NH74HGz25+F6GNsSOkmq/rhvGiq9Me0qTt64t11dyHrjAYa1pbiTogHjfmiJxZAOU3dK3IlfLzWydfeBqh5arrTeqGjDcm4UwKr2S7FzXENVVo/W6hUvAoFQm+eBPQf+0qvBGkIpA5f4qrZyMANkjHUpBgaG6Is6FFIRsn7f4Yz4NCP2la6/oCBchk3fC2wQhtj6sNZ5RBwU8TBXknjI3BJboSLqKLaISIPcp1/aFbsP2Sa+VlEHj8lQcWEtVRr6+hWeMkJNfHMgvf+IUGSLnh4d17mMWJQi+10zvs3hHDfBvG23McNLtmhzj3GgWPllTpmGX6oz0XNPZEhtQLwYXI5LemGVf6w4lytLlTsiOskTh46UaHFtwdkzaGzi7AbgeNDU7KxgT0qIOt33SZHXglJQ57oTvRYmwobW/xv4MmgdyDhBNTYK7Tq+gI9Q00J3m+B4iOCDvMPkaoqKgSmde8SS79VJ50Oh5UOyebXeQfbsfYrtIein818+SoSug9oclUJ0fCVRKc2G+yiEaBkRXru/VdkWyYmtRsL4zkjVA4WK8oENkfOfY7S+nCukkiqd2t/wh9uiZnLFa61jrWHBDBekDztq+PJ5vXEdftgWCC5C6sC4BsaTwCT3FT/J9KG0KYb04YgH9a5P2AQ6+xs2uGOleaioyk32OliU7ETSlvVaPAQt+gTiXWoTrmny5pq7yXw9gxKL+BejV5tAw8sorPFtCiIRCPuJRvpFBLXW6xOM3dK2OctE6dOu1cqhXzRggJW0HEV65Ae5uoOUMAocL5n9eh8MZpydNW7aTtDSwLg9AuXIBZhIvcRIevzJTbP1DNp3ABuC66Gjzi3Eppl/YSbCCaxCnoHMgvs4IasLJFm4/70nommi1i1keXIipnUcnVP8UIrOpOuxJ5EjI+ARDmsPDOHXqAmHOHA3j2vDnJ4gbmBhNxfjhtndJKx0yBC2FctzvINHYBu9b55RdQ0Vt2mn6UIYORnsN2AGoC6Od6t5tRfwwBVUfZxH1f/WbQ+5QTkt9wNpfSkULlMHz6OYnJ4TGHZO3N7PwrKteCrOBkMI2+R6CidPLsrOFHXpLJt33tIUWTMxLn7UTPGSMjP1ZERJPh+H4pZf7PF/RNXGhFIAOqEgaeM5tl1R2gZg1FlK5y9XVkHUA64MBgO0CpbUjLaeweTplV5rzhEl9P5GRVwI50u+jtHrwHam/38+3B3u+vITZKU/HI6qJopr35KaDr0hkNvFYxRls9xU+1Ix6tAeMYUM/xlpBmp0cwB0Xtp3GAxH2hpQztdeqV2UZ3EAK7aE9pyPE/HTpcI2FlJM47NJQJwPpt9EoWERql7aTKXRIyJwd4ntyDg90KBeceejXZ81GDfLj+u9IKTGkdUPJ9TZOOwI/pxxCDBjviUsEjhHXF1e5MZChzpCoNfY0nvt+LgCe58+X5Dsl6cld6fk4Vnv6NI3HdWxQufBrlQpfQzNtxXJjApPKqjIkZlFU2pRx6za5JLpTtlgfrCAhQfEWnuUV4O+Q/vJEs+0MGu10aVQ+O/cA94NS9gvf9O3bRVPjN0NoVjUX9KrPFMCCeC+t1QUrnyIAoC38jsDVslyC4JAAK9IBRGQGBHzaMSKN+oftjHEKQKB4Nw8pJgc1GyYDf+5czjtXJVHXJxgfLGMJp/MPTVbka0/e79J9THvhFO68y+3YcHkxw8jZZ7hsoJq1F/Vb6M0C1LX/c3ujX4Pub61Vc7iLLkodLgRFIvmEQo9+FJyzU/TfEDxPRZH4l2wZJw8HC9+J/Dz3GSe8DeDOTXd8oGN0bexFKLbJKfo+QnsiAXZ8W0m6HVlG5o7VuN040Izxb1HWfNcghEJIY3+zJZ1XJdQ9fHoR/5qnSBrjcV1m5MdcduPxzeSyPC1MxIz1vrs1t/7gkxR1j0oCQX+xkiPy2euCyzTGfMt5xzOjHzRGEiDHJUVJv/JfWjEtFzpqZ5ggPtJvr8K8vwAJw2WtPSLwYOpCLXPG2iNom69QqnDnuthoQysaLB5o7AGiXXw202mQ2sTy1IK8qXlfwcvcy3c5lXZvSD2vCMmbcJwhxDuV7Dxmr7c80C7f8wJONjM8YZpJL4xChCCBzyIMV/9KDPT5AWvEL3o/uA42V8qy8lARTwiiMULoqMlv4y8JZdkUnvvnLD8Npxcq6p0lplZSS9XB7kDV/vhqwO33xdbdLpBaOejA1NOgiqAUq2vFguUlZPy+GHKF8lLlUE+ob2CdfFZsqlWEa7KR5GRzwdssi0T2ZUSLHXKjJKJLWqL2sIiuCMBggPuuPRyS2HlQm/vNlMSBsiQOsgeTDSlF30L7xx4Ctg7dxufN72VK+XfIdoasmea6aGxPNEQK3ie714n3PfucekSMJ5Imm/wBW6guBMqT9kYAi2OEbmGD658LDh2BHg1xyxhg8VGldTyNPGUCtS77k/AjQkgGMcWoFCk9UiK0ruGMUQNR0K1gVQuw8bS/Zq6hySN97+n7hlA3hgd0W8dWr3est3LEffnO/gNN1y7paFhQhP+8Dizvmcaw6k+Pkqtci6JOA78lH2deREVkQ9p+Pilmp840+cNp19sED/Rw/s91Jm2sTq+fmWKJtV8sVX8K7O8gzNzCPZiX0voJlfk7LdlYddGOw3rLYZXelpsSDuu7Tve1LOGOZb6A0/oGyYtf2Y3PL8seD8EhkRfFrs63A4Z7lbTtwkgJC0SuPaUQvgYzQQCNCJLHOgc4fV/5bIUTXqqXmgdvbqSEjl4loZ/pLx4tl2AWQBDxpjzbKFf4I14vnbwv9/k2Yeyhn9WH5sl12cUHzJODKspoKaDIaxs+o3OdQVjfu1fR1eHCTYRV798Za4OlxpxhvY0fLURfcaKiEQIfscrwVMVK7HEOVsxHzLMONbvLD9oJyjfsZ0qVzKYEzWosUcjmAMPg7cUoeob19dfd1p7RXEYDHTUcboGpWp1i/fm92SVU11Holy9FCXsWSkBoNOk05iWUe3grxIw/3Q+ruYCCNdZjmpT+s38jdjRWK70QBpNNRcZsKrgFcJSZ+Vsvgc2r5Nm9Y+sC+t6tMBqwG3n1m+EE7l0odt420LLXGKG076OrSVuqzSsTprghJPd7IHJxa+phyg56oYt7oxWpmrxkHJT3FCU6D/6r7s+RIcoL3dmfRWBPmd1QM8EGJUel2U2foxUOB8vsgEJ4XvZqBSLwVhC8blSTiHmXuJu5onf/WqnMfDW1TZ68rXgujGqrnBHX829Nz9ke8fJJl3gEuHXAZW2Y/WlwfFIwC+Jn8+zLK7OE/nmw2Ij/gGlMEGI3R3Id92Jxu2nStf0ZYS/6Wz7mIr+baj07gzVcTXf1B0vYGvpsw5s1f1WcURQ4fs+w/er30tt2QZDxPDlbBe6cl0b+YeRERS/O4vmkrV949OJKm1H8oVOqiDCBMN7jIUGNUTSh0HsCbZU7zYhCi60eRyjSRzHhvi8QGkXVMcjvCAgm4HfGitaFKE3eAe6uVfnkKaxjaGrIl9t+LcFAIpvt1/kbIJ1E45Vea+PbjZqFoLx+I5UfPrSN3bp1/XnjNE0rYV8wuaErLE4lgzLY0cDS58zkGyiMp03d1bUM7E1sv2h8WcAK5jBJXsE9gjD9/bDjXKWhqOPdAjd0TtrzmtzJCq2pqo4CnqoLXtIkzK6WBaDsWG9kOK1BBkN2gu6CehNPs3eCbrd28AXpPLFudtFCkfsNi06KOoS4BDcocG/5W1cpIUrsoV/1sVKUUhWZarZGQ/gRi/btZTN8OrM1WXFewKNgwBJUzmCvDRDz5TNyKP4wt+HuOneuLY4kmFLLpIXnftvLjqUCZSyILpH1JghbIiYvPxhAWbnfpbXWUY7yxQQCla93vCFsjFjcOWIPifDq6JdpodhTyVxMVQgT+8qxu1XqaUJCv6SXF6dM1HCXrqsjmIX1VKMeymTv9yWldRjNuVJjsuv2NY/sHhfMNktj8JyH4s0gKJ6lnxvbjXqHhC8U5n48My2UC6K9fp66GZfaR7QMQrY3/L7DsXQdQ22HTtdgcKcywiyk7tEEmA4LR8r3aklkY9z5nwZrUGFeDCvDH/GUSrsGFoQkEXWdsjj/hDmJ0QjxZwj3HNgbmtSsB48th92mz7BcBBiE+PIC4q0062gVkIcnu0IV+bPjFIz1ONlqeBJUDRoiGk5k4C4EXQEfgU9wcTrCoxJSc/9vLW2vNPGTx0Lh7tN3iXyje4O0xh5qx/ScIIcit8GWQWC3mjihv7o7Z3OXsFW5rPUViOEkF41rhtAX1m3wVdtLCdWDob5SbSOk4hJ3jFK74IVCCMDrqXTo2Dy/o4bq4f1/kzv8w0UTeF1fVxyAoJrasl7+mrsuWXOp1QM/F6Cqe5oyoteIbuWXUrThgSIz+1mzOarHC/bX1isNrR8uoAq5r/eauyNDHPDgO2Ji+FJ5+VxnIm1Jwh0R7sSJN7/yId90OTQrUfFCCmDBA+2p+5KELg6zlkTzSqA+et/EU/ulefXWSSsIQvzeHjo4ljCDuUiO9iHnYDT0GVuEHfdjWkY2fsiDw97sgTlxS96pKMt1ZY1SJ8bbFKj7AkE+SRMc8wpbbItw8hvWzQfYcN0GeKydpq7/+WcTN8D2FeGXNwVtIGme7/jQS1NWum/zm2FF3uUXka51+478iy1Qbf1QFA+ypnKiHUdh6FCZdY0ezfMl7JVSZV7FSBUThsDCf3VWPqtstFhdTNooH3PalQmTGX//ouJ4oHYvf5eREHMDPDHbtsyrte2uVsf6tmMFyek8I2xPZE023uz0sAK2UvI3tMoyfOq5SnkmwvvjuRyi3ZmXEKbrx8WKj8NmatOs8ZxoMRq1XCCIdyxlqmeGgecuZypmiS67U3sjHW1V6+8Ylj2V/p2j7zHVfQk93PaRpDvzb40btRqjoXcrt2P2I6zECV4VFZ6+SHkWVdpiSEOBgtGaYFmySYo11ihxn2cerKfQkdEIiZF3mrH1qGMHxyl/1KoGKC8HwmcGsN69r+2fmgPwfIaIESb3yDAoxeRGyHWF3MOJK71Vnap9K2zVSfat0NNIhKcG8VqEFsC0GadB8Inw/EgWdWqFyQElWuacfQnqHxXu9kk2dRapu4ytKqVkuUp/iHyEe5G+XCuqgvas6GyFpOFfac2FHdKZzri/LHRNm1DlqjQsn0G6V3oRcRVCds4YGWMCDychPBW9sPK7bmtPnlJjSNLMhgM6W6frmjbVXJ+qx3rqbv30t8BwULKZvM7A61gB1oyum+bAGamOypz+nMpTu6Mezu3+mCxI7ttZ27dCZa80WKrEss+x11qtIz2/VIvJ1YI+XdPxO73+0QdrXvLcX2VreqSQ5H8a8l+/WB81xRvUii9e9skoOCudi8aE+w8cV04W7rc/NdIjRCibZDzSdmiF8Fw6DYjnaRspsXwhnPK9F8+XjnVCzg9uOhypNqmAOF7HjycVjaF/cEVajqfmWtK+TrAdHoP3smVtypBhuAHwjDN6jINj1N4c5rS7utYgvhELo6dDi8Ecu2y60c3QtUqtFM+NyQRBTeU5UqrhC4I+orPGXkS4yKpF+YC9Oa15d1Wz9hYgsNEiPfWJ3J3lweVO2S0hRolXCgFzIvKklYNYUQkwU+V6/aq1e/JcH3ixFegh5pZeKeeRqX+U8ha3qKjKyItXaR8aJdvcsT637OPud7RD5bhCeX9vfVOAUWg+m7tG4PDKxwJyVxDHWHVnwREwEIgKPzDpIKexXJEwGl3iF1NCBM4Sim1DIQO9UxWsvDoPduBDORcC6VHFOPZ++6MMBMMjc3+pEVqAcQ6qRcwX/dVsahnmSc3d37sNiFhZ6N5H3Me48nrk+edgOF+FTjrdaiR9XHy3H0oYSsNELZLN5PRfR6z6rw/rYDn2D08FGFnws9lh3PFAukm3ORbOsZ/VhZltyGL8REausX/R27B+71AihXXVM4zijE5qNh4qztz3weHCrYbyU3m3kmKIjiUsaPGqgdsHuzbyQFfNwiFvhFasZrxuQnofl5FeK1sBI7nbLkgVhNTqlKamcD6V4lYG3vSNWQTt7SkOGCwSfJQwWJQuiMavedJ46Sqt35UBt/EbUkZlM3JXjjcJ3fSDTqB4U9ASbInULsBUYRoHKZRi/7K3pnpMlsf0ZtMRncqBOYbM1cF9AVGMTjdTUWB7sRYhIwsbt8dHojkK941V7I6m5hTmPl+mL1iM7sQXq1a2irMDHFBRZa83drLJBXn7aJlsQ/h8r+Z+h9/nlAnPQJ+Q46OHJusoHr6FCeD+d23+kE6xOqnLfeeNl+KrwYXAuw4SgbyWSdQiC+G+ihyHbP6XsfTXUqMH1t3mQwkVpXfFqIkefoASdEIXtg/VHo1w9RIK609cLcNZckqEzivOBclyDe5GZCKpEh1pRB3GLmgUOE7NfSFvJXmKDBGim7Rd9/vVXR+f4allIl2vwW8DoYLXneBZ+QsWAfz35ws3jsfNwgUi5CtoZreZ5/G+nSoZsYPLap75+SlxNg/R2bRPXokWidCq/SqavZ9pJDAmSo9p5rzJCUIDbaEER6djRIB+LIuqzqgz7/Ro//54sNJk3gaqYqjRzNl2g7kEytdjYd45U3tR4IXqRimaGoWnf3+b7bFyIYkGFOcCIX3rbkQAElR+dqTc0cAt5h3D6sWB7CNIhwaoJXq6CNQkd3f0TFjqeCiqxm579oDpTmRTqcp5tbt6QnlHsRlC8WNqIcWGBRSjalQa4AZi/91XsZu/9vWyMRFiFQpfDjhzIEYWfIO3c58dv+JtDnQjm0oTRRiVEFZntJjsJjHGifFotpIxidIlSOpIFWi+zA0iOES0utTIiuk30UBYuME1AALLlNV+ZTB5MPY6WquWGabDUDspOtsbq03Gwj6U2n2wL53ExnvvZci//WeRFUdTDX+HAhQZEVAuWHGGZTK2u+ZC378upX/fmfRYT1AI70Q9Ks5SkKHOh+7k5arZfYKgQcdelXrvx0DorC4K3DR80nYHRqdbFyJSR2zE3W+egikBeXVUv2gqs6qxW4qw9c5XTeTAloKlOpL6XtQ+kD9VBLu8pca/yfYSUVV1uiSXyKFmSI0Xc0YPCm771IJwk+1YApr0QJPiR1yN9r+/IfFgo0Cl2p/cWdQpgBWY9NnohHbc4DqIfIAgL6NeW+TxvZR2ghmawghtyL23TvKkAwKKrCISx7UyBO5KaMwoZY7crvoToExLbgqg6x4UGTNX0sQjF4vYEm7H7IwhDFxu8a9XB26vosijcUaHmQk19nOiws6yOveduHUYqvQolcaCRg7HkzKZuN0q0Odju3htsgwPpB0WTC1At1FZSTtfEZk295A7fVFBq+xAbo6vPzq9BJmGCKYbidNKFFxEmJkcH8yK+0LuqzCVtg53jTy6KPvnA1g0PEmhih4L2dSX6nn/fd8qaN7y8NIJbZm1gRGyapdFAFj3YHrUQ2L2DanVMmQBjy7aPh+MNueKyVQbpeVa1jALiNJ2jMD2uFhIC8mEwypWND+bPOIV/9oxJACp1IL5YZQn6fqhEs9qC64GLF9JVomaMUmFaEbhiUQ3y/Mi26PBfXZLRYAYtJmFnwGEb+gSDsp6qgOB1Fx/XwqB60zG5VbJz1aLA/khSo9Qe0ut276UvKYw9pzYyE4SrxTBO/HLoY9h6BoKGakIrtyr6kP1SW7Vx8YWpo0CWF0rYEZit1d3VHAsVoVZ75nRzOjD00WF4m6AE5vBufELJEgBvT+XN/nonVqY9ebPryu0tZai8d3ybGEAVxsyot2oz4OyMXkjUqUsEP+P6oufS8QOes+X6DKPmqgmzoBWw5ovcH2wftUdjCJ4REA+4uJ0epNjYjrtA4U+qk7+//bQxQ52O4XTWHuDN5W4zFFk6lqSd7HLg92zQq+JRyNc5+y1KJ7LP+Hp1M+VlpjGlYFYsQFtrO/70i8fth6+/+XqHlFBiwIPU+ksWJYM+shDk8V/jMOJzuaLtbET6OECgeDfBtNwSXGDCwEOqBvBXgMHqPwaS5q+TT/pjINJcK8tHUMBNFc5DfnBQ9pLsb09ADC9R+uQyjHPyL69vAINxA+PGnUj/2LDulzLzy+1Rg3g4s4+BTt5LyfemKm9mpo5d6/AkviPofpO46eQBVoS9fZ8DmbasZE+PMzBl8zHuLKALlIIkHzQjTXXd4a9m0ayBObDxT6gBRkE2cEZ56S3OgtEu//7L4MQX9xbobt7j6S6/3vHFJ+iWfcXkPi2XNKxujcThnTUrIKppXZQ+vBbGJfRA8LWKK7v2l3aC9E8hC+9nVZVzoe9XoAcTiS5D2zirBh4jjoRoF0jwMdTe0PXTgvq51MISjs3suLuE3yg+d8f0P9x1NHbNxaStnA/SmZk/1KqDZpcNF4/vRAjG11ZVZWjzWR7iynP3e0FacWsC8ctyovya6HoA5/fINKy6F6Ae3UtcPJ+wArm9tNlwITdwoU/EGapf5MT7zJ5A398mGC7V4poATcwLo3l50TCM08z+U8RAlYEsF7mWSwNsF8fxBAyYgBE2E7e3kmwQq0GCHeohdGAd0DthfeC/t7BiprJjCS3DwS85Zz6KQeQREXQGrcodqpY9IQLOmu3x0j5e+AzfiWxyTz9VzyPLAaik+BGH2cksaRREkyLyV9lSz8EUp1NLKJF3YgLwSwr2P2Jw/95r+xAmXOfWdFjOqIcKkI/ESyUielJPaKmofG353pnMsHLMXuBKp4m2SHVJYWoNmK8Or13QAc6Dgef8lCVO+MCFu5CmfCYE7rMFSpjVJuzOk7VA1AYTWIwmO9JHCcy2aySPH3s3FKtcRTENGeZq5um9o6k+Wt6kGdCKmPTTc9cihQvMHQq2IKzdx37i0TOJBZ0me/rzIgUXMaqGCp7gsg2igvJmSUj5oilGM0Z6ZJFciM3MAJ0vgyWpu7w6x1YEaIzpZgPcYcGRSm4KnvVlvFFNsrSI4vUm3UG2u9DNf1o0F9SwNfjoVKkqPJeXP2/D7aZfsb/UnDsf0TxnRnlA1m0s5fQe2LT0ysy2zY45rRdPhrkmZpI9a7GHAjpze2kuYmFyvIwfT6kJxmYpoXXzqbfxWqFM3g7t+0lWlcxQCY+aQxrTcQdnfSvTxLae/bUAtWTT0i5FCqJfK8QYdwct8oqKGzLyDYl3WSY1TwdtK2EfBBJvtgaokJUsWiu07wmnCVWrxGi2W0LkQke4zRPafR4NcOCWGRcFbpY7ArMEvgSgGrpVQ6lJTy6UqdrQcUPkK7zRFLKMCTSuu83gYGrWW1nFO+90r9fV/Rc4RgxIQ9rR1i1CvfhDl0DPmy5IQTKC943LYg3xvhdRNT/sBJct33erte5edkmDy/6HPXbpZZHCIhLPjHunGv889TQpu61pXypuj1DnMzvwN0MWnJV2rbBSSPCwv8pNAIMLPxM+z7G9sMYDKZrnRznt/cz++/HhvS5SAM2EvEhexJg+SOSCwL95SUjQTbTk3emnpXGdA1cyNtQO+4ILUg2b0hP7jR+A+MrL+g0vF+9U5Ws//rkpGujvgNC9NeApDauim5XVlzig/FWl83eZfg5lZzhTy7bz1/8GMRSFi4B6IRzY8ZkTftMA9Iv1Ljr0IpxgX16pW5fXZLFrTeJGzTZexsKDLToEGtgUAv2fwl1ZBNalLuZDN9Yzrb8Y2qQvfVZh/H1SFQAT9EqgqI6qBo8kMXHwXBuat54CXVw2YdKQ0oBypDAnhzj76LPLbcCLy+0+yNs0TGGnu9YPMDk4Ei9RMno1beqI90kAKCj4L+Vzdw8JCF003v5LghzXoyMT/DtZ/Y+vRV0MmYmlRI1X5qukk5dE8Ga8oB2YQuFCGTgwrUm73nW5wc8oToQ9K+Ors5epWLY0cuLDpDTG/1lIeweZqAAvpIq7HdBEi9aP9eUpaqtRI4urUKkOwCkAvbovk6wsKanOsHaBF8M7JohR84PEZYL7PQK9n/h9HfUaf0EUsxZev9Mk1UdNvTvxbFWsqrLceHeDofyfwK6xQXZxvLJZa7KEHNrBR8NyuollFM7j6J6yEVDk5HcKma9OIBEibf/DzlBoal+mJp69KJ36WhhruNOQlRwSlsBWEMTBV3Gvi/d1aNUZ+PCy+ivx/lwOGEgeXH/yEH+CZY1Sga3DdOgBi52DI7YEcto9regvQfhZAK3yHOCdO83H8Sr9+k3Jb2Y6sNTA3Pc91EljnZ25jY1QxRwAV+ltp4tdutEnAov5sjVB8+fw+h3G5iI/fYqY7XpMLLqOSc7N9lWpixJcS3XNSV9Y1+i9JWLXbPUh840/Id3cPAhbB053OD69vZQGZRIhM7v0jQfpUD4gHbZkEOskon7qfJyWEzMswgtkcqJ0BC5JklqBB2JNwP5BRJEPRtSRrA+dNAX8QIfZPVRpbYplsR/SLJlN4tkr/4s7/M2n4LYhNz0Jute5a1YT5k4UX13BlZCCYzKsKoJJ8VmQVepVEpOlqUrS8Tmd8UOmMvKeU/jQ5Pfd+yptGbQyBzx65BnCPRCjpZkdofZLvLbDs5TtO8Ubff0VW+FBVUWG7oCwScJlUsVtXK5rPGBXcRa/hlUwLGwnMZ9zdkWGlNZCsmu52SOvHyqTKiTdIql4FWuwpxaRdLUbA6tNj/niNzPVgGWsI/iCxMYsamtEUyp3qUpq15w9HUO8FqoX9+jt0WZnlaj9KRQxJg0kMCIY+QXNwDmG8XL5/Wc6S8BNwu4SBbd8CtyEzf+j4bRK0s5u8x+H3EBuGP6eVGLRnN5pHpjUx6YTwAq4yMzvnem158/etI230jfE+9Cj/rIYJa3IswsLZRDvxap89KJCwf1c41fsz/pVjKT4+vLO0eWpxhldHgiz5sZb4OZgINH1ZVIfMPqQfBDtH+BCZ4Dqwl/FOUeB2tWYoWiL4qUbmp9aTD6Q0K76cqAzv5Qgu2fRM+BbdfEjUBKtSFcCdu5seTPFE4N6eP+/7N1lef3ZP39pJcMhyhmWXV/jwgZ2qYoFKEe34tE5jw30CghgjkzmVKoCDTAdp4VRbYCzqNHg/X8rCfGO1JtgoMBnA8M6uXX+8ohzm0D2jAXdQoD0hykoVz4L9/0mDtieAF2VM/iN2owMW2EMEbLNfLNULyr6UIVd531Z+sMUPXVslHDVW0VviYatm7fcmujr2Kat5h5nUFuakGBJc/FHRpycVWBAwW1xoCuEPf0UqboNTTefvFIcO39+2dGlorRJvoWLtb6B5W9jWkLv9PtOBT1CifB9gZmh5B1cRfESlaS+WQqINOKPax6CELHp66vKdwnZ/YKUwBYk4ZdAnLSmTp22XnY+yd7k0JDztx5Vlc7xd3l7/kqX6fMlfXUt8kmt2XeicguTWOy1bFgWFBOzVxPKZ5DW6UfiqbkJjaxchZrkxTzicCJLqLkfaXGNZzfcmWlAKQu4/qq+H92+06mt58QcBEfgQ+880fOZcJqXpSl1bbVV0GFki2u6wUsMv8y7ncVUTNqDhzKQi7iVepBgU9UuWzdAOz49nASBuHZQXwC81ZvXBAojZtKw/C6Cqlsw7sgJzbvn3vFSEEWspD5EOjQFs7CAjg5XKXF6J4vfKIzj8LtlhgWmXBEFeLkQqswmlCdRF8AE4Slo0GY6QmZ/BCHkT+CLoBKCow7k+N4UK5OkeYabRAYd3g9pfDPDaM145ExX82+uGg8tZ3JG3Hljm4SWvUs5e1eeiJ0n6KVYYAEqkJTS6ZiUqspSyAqb+cdwfizGV9E39SyZJ0CSJL2K9drzsUaaYi7Y3mrY7gjKcohepoiDk7YC8NA0eHJtMR3nnvEJFJXIfY9dYZPesJWsOaKLg6RlaDstsMTK4+yPvTVWB9kYlXcf0jrlslY1aN9KCR/QrsP8ofC+mNTPQz3OlRrAjHYD+LQ/qtdmyq6pJE9CeG5/ExSooYYmozxaUjISufBL0/KHsy0JRJtlXOMfhyZtiLlb1ghEqI3r+5OEA7hNbOElzpzudJ0qGiLt79SFEhD9uvw/+rhQxSLjWKla7iEVmKokGGkDTk+eEetChcxTWzUXwYjBDk7Ck6WM5iykOJM4ZJ7Etej/w0l54ie0Y9PY7oFyWG+O3Q8Yy9W4o128QMw7jdSLeUoDYKWfIR7Xwd25FNEyugyQO3sCASEgR465/eb/cYUNH8vWL5mPR+5uIntBE0lrPVEmf2dbEfwNO32Tr5dvDVE/PuaDl+Q3fYK+Oy2gDrDP/a98I44FSCnQDKDw49NoKs7/yx7UPeU/E2USMs+W08ARB76n70bgedJTPRUGNglxiy+w35oR47DqqaeKlTGczfZs9TCZcz3tC4LN6Zta7vf3NRf3HIFQIOu6ZCGJLPwcw7LoP+nePO/PWwsC3aIHE3F2GISOacssT4h6B8PuRNeMelO82kih+nuI+M2nffNRrJ1OnRyZZb7UKYfW2c1gLTqlQMbnxGQO0x236QTU7ivEO4xktTfyDs0Kgzm0lSNGi4CWVl80EO9zcSERRcDW5VQwaRZUzEllYuo/jnkvVld6lsb2K6SJM1YanyrCPGzlTVGxUGsJP1RKfFh2Xu9weAwMC8k++00dzK5s3tEkKLWqv32BcXZiswQHYR5ZFAS7sdXzdjLPgA19NvNUOlMg3xay8sFpl0JgLByejir/xXikoO+G+JbXdGS6nyYMTT5/ACXTqwgM2dv/lz5zVBVNtnZMt0kKQuKjYaFFFZTbtP7B2zNB9p234yYrOE0nkseK49LqEj+hVPlxVNVULkQAbyBTlXVZVIfAEgSAgNUeUpYWSErps4YoOCZEYQ0IAOxgf4B2QgiGASyilpQ6ZLmeNL/OSYwQsT4JiBM06lmG+jrcaSJlpzl41VP6oE4gvG2uJYtTSdZA5LKXHjTHAeRHPeVWitM287jI5wLnIDHL/QQElOny+u6EWZOSapx/7+RpUa7gloVEjkZmqM9fSJIZz/8fW5+QW2MdY5Z6UlA5Rd0vBVnceudWpqUEEA3aoIO+znm0UR1G98ajhe0JgKJ4wydkuG361MmM6CTt5DgzLMtNT3VahBvlVbu97q5pr4YZwggJ7kr1Yrsf1DESxjRBZthE3z0El0XayM/Gl1QWeY/w3Lm3aNCEv0p5dQ7RB0C3so4dW5/tlnud7YozVXT3Hc11W3AzMbqKPfPDtFnBYp0RzrCQ4or5zv9CqOQ49xcHMB2O+oo9sIveaeQSnzIyFq9iND/Z7ZRhHnyKl858FKYxxRL1JxCmKYs42wfbUI7Vc8lQlCSpdPdzKAF/1Ai/msH4isGdT/g+/MH42TRdV+uirYFiEEBo8vjQlQFCJBpM/ITdANt9zQ4C5m7gbNCcJi7tEeTfrrC2LONgPe76CD5sJYWkI4nOe9ROUZnqMhNSQGodLhywQ61WQkzWseQHHiCOXZHvnGLB4K8vuvLGWy7ErLM/uAmpBg52l+sh4BtYYCoz3JraL0hvoCfsQ9w7pXK/6rR3eK5ECtALFlajtkPk/MVWOSu6x3aNg3CtcSfsqT3gIU0MIvDMEG5KMFraYafmNgx3pw7gkFg9XNxX4aYjthn13GX+PlhS3PHE1kkwSjt9ZJEeZCjCEK0IbLQ/HJPK7KrVPbesG7Rc86wR0xQd5abroHL4JAEGNx9X+QWrI4YKhJtb22OLt+HSh790EHK98kpjOFuDs1HRayD89IW1hNvt2wDIYPT3RMcRadqDFblNrm5IxXUyAgw/AtDfdDekPA8G9A1YVBl0Q3D4GaDLrsZnrMki0ddSWtQ2wiZXnY7/xw2W1UA+Wu60kwwo8vEGT2KJ+1beH8iCzAEqvVdOZfxB7iw+tlSmkweBr6ng/bg3cUfGd6EDtjODjSgu8Wt3FJoUNp9N5/3BZ5xiqz3kKccYtKbyH1FJLVRoTFkaD5UDKvih9nnz10H7iHg+FNvtrFlSd2oU+es27WBbUHQPZscqzWRjT3d01SlUR+U/5ZpSrw55U7TWpMK/4zJvKQgLF1QzrX8xDzqKmOJ2quxgxMPhJcM2vTHIZj+B1xuog6aVRuWpjIZW3wC9mMPrQZeQr4i6C4Yw0e2n30znx63iP1n2CiCWHyFiGxNyIM2BSYhpvpcISKw/8JhkwxUttknyFOO6QqwOT8uEcMYtn29gLM+K8IlL/+pugO757IaeNBKD5ecObFlbWYE3aJ3Kho64VGUQGw2uqm7XCXxP1GcDNMiM2dVeE9JHut1If2f1l6QMs4bhLd41KaJVxKAT8SjBJL4IHWLKu3ltKiPyojydEg8IeNpWw0GkE3lcDVjHwQj89ZSD5sJ9Cgh4RESnmNpcdLHCwu2aBp40cTTsypQlHGIuGf2E4yAuDrXbnHsGrj0t4wusXl0ErdmQIuNc6yytpbiOEUB369TgaudcWXiqcJNXzIpJ6ElZEGI4Jx9HVnED8/27gIAuDxSDM73Z24jX8aD+lkG7IjeAvfwjV8h4skmRmz98aN1qkmt0R8CBKpo6MLv4Ugoe92RN44HNtbfkk/1Mt2SCzMGDUrf5o80Hlzu6qfVwf3jR4TOmjevjMcjiX86YKX/J4rnk5pjGgYJRglnLeKZumTMfIVVvD33cftD37PM2aKOM0SnEP8fGbVOG7ppKfPLSyMy/a1J/p8jCBePMJsa+7NwaUziietvk1JKkvb7EAp62r/zTFFNi7PFW0AT/Cd6DHsCawsjNbzXIABp+hZP5FXk4SBpeS30M+VAH6LmjjTlcAz2zme3gmQ6ol0MbXSoUIZyRUBK5WJupQSFH7mFDBH1m3DaJpmM6D+yfxjcGqO9MhWw/zxxlmVpjNjG9f7LDS6WRjOV/FRhZ2kk4QHVppeTzcb3avocFIvyNYnEWLHNUHTpUdTrFdwoXXgA6G+biyEv5jyVbQMtGlrTmNOLryGWn2n0i0PNL98PifP5f2XGkvU6DRdKEx8+UJfa/sp+vZCifOd4rNDc2d2fvKN/PI8xmHKed7cPGoce9n0413hS58Bnd75IUEpX513bDNwAhRbymN1BWUnshdwMy00ZzytZ4svnnACZxnZYPTuFfFhO/x2pGibhSWWsM5ryNjK2zmOfzmmIQzsNozW6bz7U88bookFdkEBCIqAJ9wWE3YuwZi2ecmbMy8LHjOfT/ev4ioDFEdlDMjETGOGht+P/0FXMCb9SEoIoPPXFyP8sWc0zQ2P9g2x9CW19Tte420SblRyWVR3pJpFOq2ZM46pZlFSbgmOY9xx7noLJ+5v+GrTRQfvOv1xGM7UZNOusnRMZGxjdcE+bIf4zyXU95bqDwXAoPO419Oh5sL8K3ja4BJvPtElOayW3GpAYPT93CxukWkaPsFvWkqVxIPEg5ac8x8szV8O1tZOTRvyxO5Zh+NBJLnbJmMUqJEWvQOP6sVZCGwfUUKoUKTPFM7vlcPmvRQXPRN6AiySNdUsMOrZjnbIxSirfbhNv867bh/HCyRFEJs6FVNcnF2AYx+TyzOvTK1pAkHPQGjR50JMaYSdEHfJQhzCvddk8oJa85u5JJmHVei4vfKw0oco7ctIcIHSkNf5AzCPqdFZAPZk4+OcfT6XgDHSIC4vGK/nOGmKY1eO/rCFUV7xAzZkJg/PCvMupnsjrJ5w9ZTk+eFwIJGdw6NvQBza3GeW3aipMW2JxT/9YGF1oklphSf/znbbm4sLCNAtkwMvaOdoP4JAVc9KkZhM1/PEjibL6IHehQb/OVL/uoMC1MejUt4M1h9Dr6z1ESGj1RuprJkEvtNG6pjj95ZT1aA0Mi4DWavCSVb5HfDsySug5LRk1xaxPL2VOHc5koZzQKb0U+43d+XfM3WGWPKx9nRuZHuXQ+ldJaHTEvrhuZ+QibCh/MvlSf0bsXBkFH2qOpmJ1PTbKgvsiEejfuRmWrDkAygQNDHYgs7VxV+tqVk4uIoxAY5akyGAu6TK7C/t0Wc4eXvv7qaqvfA/2IeuJANZ0uXoPd8NhHtUIllZisA1hxAcb99nBe4nVGpvHnrnrYbG/3JhDFzveCRsZPF9vuzjKzAg5a4rXmDSdHtn0Tw896Sq4zh3/VSgbH5CZSjkyIfZDa9cMNAJTHuP5NWfM+TxRC7i4VyL+PwNudEQqIHei3kEdK9aqgGleHl/YxTUVafdamf18VGMy7is5Lt1s4sajF7PKgJYUJCT5BM4KIv83QalPFG7ahMNox2b7hv0yHIW8t/jSmkwLhr71AoeNnRn4o5AzXt/pHEDzxOLIaDL6OkHmjMYTl7wqhkWls7qtCMA1TsunL569Ek1lpViabJ4hxcOi6IkZ4K54hx3NiS1eKykAQs7OyJP0SG2DkM31CZC+uaYlMG3qv3EB4yd5vRAsEjgWyboF6sBWYp6sT5BLT6bIU3RpMKCnn1hnzSfZy4uAttW04alXzErwAHMY3k0IX1xoqqFeiPa5IWzcjsAdFmko79b1/1yyzE40pcrTX39EPyRAk38kt8vBjNJ6mzye03ic0omEJJSL0xv4nJKoNi9u3suL8fcEeP6jDC5NVFwSp/iieg3r2ST6Y7cMVitd3pM6oIYJL41OdPGa7JkU7vw2rv6m3OrDvIRhPwKe+zxVh/PNRe2cLy+MT9ILuFFt6G5whHp4SzPrCEJRWf5kSx3Fx3P2Edw9LSlrJcgGgngQI7Y3VipBrpDWh/IYj79SKnDH54THMShR97kSFWTQ3X6YisdE0YEAoqDzGDN8HZryU15MEh3HdyTjNFMnhoPMGz8qFLT+RHezroFnx1j5Fcv+/mwhrd/tGKrwECuLeBz7iLfRy9fKuCLdFc7iKfU+Vng/VHOyJ2ZVga50f/vwwhzoiZX3apXwc4W+085yKpvNGs4X0cJVx7atNqT5G9vuZC7S4GU2jFJSo/f5GG1qKgnDMd8t9kN55Wlk32ay316sEUXlNxhqr/OKB01IJTRKJVkxXn/G38zmKpv9+OFzPAXzL+7DJ3BhDxDvgT99r0wJ0lEmY09BAwIidOkWau8scvg18YKyr55upZg049OQNqlPTrfurXAILxsBsAnYamDtbgwoiQIYQkHyMyZl8a/X8sWa9ATxM3NsHaH7Mwv6p6bbIlVDhpZEwJfe+ZIlYduWEsTZ7LRPjPHRu7PgTpzBq81U/f0ossbpS+MgYMQ9ACH4QQf0FzsAux2hABfiH7pALixHxLjeGUs8YCexTljfzRLeq1vZLQOCYepC9I/0BQ1Vk/OfLp2ilqhAMTESK3IMVAIHMRiolZEiboS2AXPp2qXEGYKaoaXVs9mLiMdragp6mAGDGrr++wPmlKlQrlWxH/q00yfueDpADa1fwQw4Ou00r5YFVxvqQG8yBWPk+rLShwN0vgUhqP3sbi/GI6k9owTrnBoAdNVQPoQ3vI7IUpKjkvnwsn7bv7uzlDJsTTcE7RPdjonVca3Hg5mwyLEGRAHwr2ljBzcklNdVrc67nujH7nAsXo5kP45xdnEAV/h7hxAhdWfba55dgPsEYqA7jRS89Tm5hlYjA1qhvFPTY01Id5LQcNnq1lYXjIrj64lhBTpgJVgPCgiPLPv5BCUEXqIWhfft6Iclbg9u5VPtLyvGGUZIiWGUmHgQPMQgP8L3rIWxX9PiZW360M6DVBAmU5em7msV+TgBceS1/akjcM2NW29Bpno3lW2yRiCicqAQbfAqxOFeBaLOmVrDMlhWa7l7kKqdfhjlQyA/nfEUXLHqQr9PovIpGTpYE6yoJR5QxyyEcg29eF0bzHcchjEMNOnOvbaeSN1Dk9+hPt2JEg5jiCrYrvrJepJ9HqqA9/sHvV3wUETfULec7fPqbS/sr8pN6Q7/ii/dRb1qxqEH0jZ3vNNJ5al6H20Nov4gw21zarZH0PWuFYjIFdH3Yzeg2AktKs5T7qc7AA7dkPf676vZTBox0Wcw/707wZ6kg4GkMTh9pw4MTnywVa96Klw9itZSF6A/7piu2oMpzvzU+JZGTjZCSJwFMM7Y1v/uiHt1oMCjk7imqTZhWYE6wjOnDQJjRf5xNuAyI5+F1A+t0L+IHrrwCM9Kjkq9wxpN5f/UMXxtpw+x9tLbPQ6Of+j8Aao41JbVuPyk3VUMTpW/xj6mKxnza7F2HICo1MJaN78mAqwMNmxPe8iJYWzyXeJYJ3qVANAQq6609PUhDWmCpDLtzJrqz7lTqAR6NAZG1muPNynbHn1pe7KeMSoOtRJH5rQmLl5IYrZfxUuVqo5YeXSJPTzFvoxKiftTu6QtnitRE6pD0xOZ7xurxDOSNzqEakHbgwBeHdHvdpcecar8Q9mZgp/wOOqxxM8evDwsJJI0k23WoPpanUvEKSCdiZB79cmHX2Q/0/n5ZNNErCYrp8rBmiPm2ea0yfdz8pMwx4OeiTM+Vk1UcODHS1Joouc42tmgEYE217IZbd35sjc6MheWPmbMgEQj2Tf1V9/Sb5ZBRnbvfktNhdgCbYjDwbGJlGWHDekGbVe+Zw9Wi/Kk0hCC0qpW2pQTGU95tpyhQeabBfD95NjKP5ZZA19cWcWxh1N7heIoGm95pn3w6r4mdcRgz4X8Vy+XW9sRJR6NPMh+rpauaKfFtwjKuEPQkq6XlvBZOZO9FbiwvBfH0jTH+9ajzNyBOW8q8YAz1ZlCVTH7Y/XRxDDGN7+ea10AJoZzL7zaIXgmX+XAfOLF+Ik3i9DpXpccUUMFm+Grl+nsi+yOdAJjWf1SUlusFPQPyNLJuTcXPKuuTQtwFIdVYjDIliRawN8B4/WZv6RqjlIODxwQOhy3aGDQxbsb2ttPN3lrhNJV0V1Q658pW3sKnCfrf5HReHBoqH+4gj6MeJOu3IrqO5BR1fZcY4foT/c/xjVbg47vxm82MpkeBWKsh5gJYi+LrH9uUuL+MBiaEaaKLa3mf9chmE7aBVRSQsjEs4cksOlPM6o6cpAvZPEFaob3sAGLwbb9Z/ZrUBVIHXqYxuF+gJ0TRMvs6A8otV2khvsWf5P2P5X1ExbQCI1wc1BYgmvaIcWj9DnXMdF3egKrM6Fs0diU5UQQpq6KrO+KveHObZoC2B+7XtNxuu91c630dPL50bWwXxsBCAk8El4y27ZnV1j1FNV48K9NwuChow17lk6M8WCGFEVpYK/8KS24XvvQnbElprkoKRwxK27P8cx7cviqu4NRby33cT/xH+TAikkIH1uHdCapQbvxNYoGaAqngbVG2xqT6Wfy1W11/kba8YCWv26z1OkLYC+n97rBxRTwmHWskrztjZKKv9Le4E/LpPeleuawxUA5f86YqWzyqH/QQdDDW3c7M8Mw2BfExEkInjkYVSrcLV28+B+sjrDz8P2MHBZS7vHlYvTpb9mkhE6dcBCn8vna/5+PWUk3OyS5pWRHTi/Knk9ZZ39LBS3UtMmmutkwH7SJDDbjuPuLklj1IcS7j/ifOWcU2/6E5tCFWHcy3piJtGXHhEu5CXS3wuPEK5K2jjcwHI64mAGDA6s7DA2vjwSUat+QN84pa6ux317s5d3obp8gpctc39l1ibDOAgAyyaS6kxoLTX9drwI0ZTEPT0fOQgYCkLTiV4DQ5ZC/C1QVmCO+n/J18wLAR6Jby32ndGwKadevEouo0WsxVn2RRsOYbo/Wd7wZ5rPKFn5EM1vFwkvgwkQuQwMvjAXibfKX+GYOxsE1nRUpUGXGLHgQIJ/5HYzjX3RMeLBtV0CPXPtGbDaeWpjbMQZRZTkssFT7rpK7Ag4KXvF+e7GUmlCHYVuIhzH5Pm8aq1KnPT8aO3iaBc8kz9HUb43fQNMqbFl4LpACiWPImWjEZIJLo8qjrDWGwtNcJJe/KZi+VNHELcJZHsYjlXvkm/BM8sDbgVIgfUEI6E4J7FqtRkDm7Zloj4ubZ1WIUD/gn0PwDiQlyEihvdS0KPqA4/jwSZ60nM/9ixUvx4pA+LUlhwbWEbIojq1pCG53VnA69gI+GhxG4CZMOvIkca4UtvVzXh9HTMljVa90CayKt5LTUpcpvjOb2iHjwJAIgdvWySE28a4h+HtIFeHZU+dJibTHFdfukRv7x+sja0kaMoBTMu15ir/G11Vnc8us/5/lzArnQ2YolmW8bLvZxN9G7UEdOajzKnJ0gC7vpVEy8uGBzJYjYIHZoqNQUcxqVllQHzArmQ1OLhlz1OuaoDIkU6Dxk4RZqJPshRbIqvXeUOMSQrS6VDj6QXbZINu/x1dIiGLk7zP76QTdnvUQ+xXChHdO7mM/gUvG//SFUiROHquS0oSRiM51ZajzNF7Pj6yJlWrjdYVG8Zd4PPsb1EG0aq+By5uGpc9xruJ6mLSb5TiUYSKVu3R18NUHJ/60xO2sKGN5KouiD6g96wXtPV/igiTRDTLcmll5FH8jN8r9YzorYxS7dOhTCTDmtxp8jHvFGbG/7eTjCjsk7GCazHHujbE4A0RgfxOADdU1zy4Ly7PKaAgYZanoV6pXSmYDfErJv8Zk9b5s/yoWuK7N1pI6Sk6faqqIPizYlAaOfvGnpzjWjYPiL6N6u6uW0Uo4la3bEh0rRx/c33jecFaHcDvGf1CdQueSKUYNTNIY7ucwB+dAvA3qK0pyTs85gDcii+Jhv0YN3VLwmnkyxKA1and0tBcBsDO9Drf1YAXO0kUPRefoKDNLX76/SK2iNOni7lDe3aCQ7qkMDGUl24+4nt3BAQOhdxRPDqPilAEu5gMdP/9G/fqkEIR/N8CopHdVE8Txi3GUU3c16EfHP+3vCXDz0Sc1lADoIBTemGulGLC4w0kT6ey8y6iOfYphrWTlxbstaHCHJQ95ZjRt28+fg0UnfWqWoYLve3j664uVqoH8pD1J3bpL3sAvBw1Hn0ukYx1awOw0C3eUWAdNnJDh9xsGp//Egxiqwh+Q5Ba4+dpK7Z2dzAkPsnqT1JCyeocVj0/rVCqm/Ytc/laa1n7FsDS2k31K4J9DpYECic/32LszgkpEjegNMYgDkAT4T0KyL6l0Nw/vOQa710QnqqDZNq6X81X7PmmkF2lDMes2j5ir2JJfG9NpE32AnTDEJixVUXzZuy2/M1mQeuFor2PtqeAqlJ2bMpoepW0FSQ9FQjCTJTHHXjDyN47JTHaihTKToT6fAStOwPPvgaKDeyqFkjOcltcNIev7A0y/Wu3oUt6L958q6WkP3a/2/Pvs1WWDDumAmo5sA9OO/JOfMOWPgNepXE4/S4anI6pxvT+Rf9f6cwjPvbRPCp6fIcU+LyZ7/ExkyX0KVvJsC9X+mZOc6hlm+/ZAaVcsHh7aF65/lrQK7tQpiUU4RaTAyzKsD++vVMt4HufZvOdaguSDUAEJWzRNTOsmoUa7jmwzvIiBrWXyeW/7NND1kmLpuRrAyva0C5ZZSLg6DNqzHnc+CMBlr60ZKQv1OeJxMn9Nasb627u5FVt7Ldxoey9MAUCXUyndwGROqabw2dRq3eBmazU3SeRT4G3tDxxHzn2XtT90EosR5k83nnZxcux9hD/Bx+iYcyOHqlP1ymgSBwNlkUHv212gCwLbKW1sxMn5jGamlnfOWQ1AkR4EcDY9FsFBH0J+70dFe6qm7kQ/7NO7C8a70YSIEA7SuJEKw0NaDXZB2kqE5p7Xg7ILVwBewXdBP7snwyWim7hcYdk2CHT/aBPGo03hgpL/d2tYhmuJBfSVhjca5yk4VsEAZb5gFeo6haV5XDscI7UCSLz5abmoxtPwuLRQocZ/h8Ptk2iPNGLmM5l0bKQ+3kHru0+tC9mzigcYLHD23vrRpuX4bcwvgyTOAKIOrANuI2Xc59gdDNZ7zHqYYrc0p0bnmFujlid9Vwn4N7HhOL2swVbkgwl3mlYzIsuq3AA2+w0fUO1MYINVMXoh7Waba+OMt2QQFW1Cnpkp5SyxVuCGNDU4C7aHQFG531RL39l5SsrTq37W/ciaijla84888tqk1QsbVGENFKaWsEkpUW/X6QNF4znXGSZpzY+YSh2FmVBG//MVOGDqfGD8DmG698ts74vt4XWdOXWeb0Y/g2A4NJwvVrXKhxbOBk1batp+NoSsDi0vtacJ3pbs/KN8+z+midw7vF0/HWsJIdZKIIolfTny/Ccd9rPUbvJvK4BbOMSkcAjQXB9x3DdahqpCBeEudZ/IY9SPDWRK1w1/NI45lOOV1d1xxj+tZhIGbJKfCBfqbjfeRzeOOTso2m4cpeXBBV0D3Ioi+UuEN2y1CS259DJCFnDa8izjL93uSsgkEPt0JWIiFYXj+shS4slAsUNmIOjheI10cHkQyO1UFbhhqaaFDyFGaFgG3+kH9l/HA5GXp7jao8AAh7iW1iMRXXA/Ni5vQMKEwuuXwUofnU+gVcnE0gMFtrBFx/bP3bwRalJeQUnJW61lnwXUt4XjjbRxrPEdxaETzOZ1nm+rp5M8IUKQsDFFlw4B3/nCKjkYfGZQ/0Zh4KlxvqvsagGj/53/8bgC+vXf+afCjfOb7nP8uNAXjgal4/xUnSamlaj8vO6nEMPdfmbgpPdklNVca/jt4+fPlOhMvv/76gXfyM238ATwQaGWLm0WHeRbEsu2QH2rm5pZ8updDsYwhzeGnMSiIWdRWEh+mCeQTsJcG4z3Ttwqpr27x/d5yZJmsZQaFGqMWgolEZiRDn5tDl9DV7B9DOWztrKCvVNroMsxWkXh9sNrHHZ5v9prul0xiEDDj4R6rdi6cW+S2IFwzeoocH58EEbaooM5cGMjxmjsoDmUWK14fsjMHbBEfN0PqhzUxntWdMrw8Q5SyqZWIfwr/Io+C40BOMIOy/sNGsnK+nA8GSn1jgsq5N4bODEwO8fM1y7Lftoa8PaQ7pU/MjYYFdw7Oxyz6dHhJ5W7Jixm0vaf9QEtZo4xjwrJJ/G6MziS0dyP4m/yGZuchQrlkQZFEBYJDETtYxbd6W4VWvVvyHgoloniov38jbGqeWOmCoBmY6ayxvx+pi/Cx9fS5nIdM7IDlo1ZcMmRJsTwdI0ACx31qvxoRarK+qamdjHFUpZK+4iGYEvFk7yZbQn5HiRSoSAeAzkMUQXzlzbRqtSVNw9RmuDu962fr03tTVr65cgEfsEIQIohz6ld2NpUSBdUnr4rhF+wSFtPR9ndCHWkBXFYHoIBz0ohwhJ+kNikkguOzXdQqDi7KcqwfjI6DSkAxmL3B4tzmIZGpofQFsFBICNbrc2zs5bTVllq+4VtAKzRc+Vr8+OsGIQ+lpGfYXWt1YbOdEHP8RC54405K2tpo20kJA7HKOa62FAek/qbB2whILjGLvr3tpf7mXqQwkuB3hFbSUWMn2nVycv6GuF2fq0fgV32z+TUFk9lztIuPQQSbp6fY+lPQWWxu3gByRmCabYVHNZccZS058a9lJu5NrtlTstLEAjuIOcNjWviMrPzNtYbwYisfEdpR+yS4bOR1PAUZoXIYqDF9i11wEznpcrsAox5Kqy3xG7WPGH/j+2nvRH1YFk5yNHhiw9InmLhtLmBvZA+3VFRGFDZHnpeHqwP5kXMzqS3toByL4n1gzacVpnSnhRjGloH+j9intVNRE+8v0x/Ipmfwggr7mG3DguyHkaY1ivyTfMIGyRN4PuJ0rzdBmKicfu3jhj7YOM3xhodFwk5HP9TdJBMt8X3c75eTU8B7WXr0Qu/j6bZArm1WTVzaHz2PR9krq3dSwPNArHepkIV3FLI9OLAEGqHiOJ3VyJplfhnnwtKldnJrZCBwmiMJ2qT53MUA6EZN8Quynh0/BXm6TvrItVsUKEntOyTXbssHPKgcd8PnO7FsQD4betz6vYOP0KCRs98Q5cT7YJr6kEk6DRxgFvoXlfSYXj5ek6OOYzYUY4bzTRCl+vQC2BGWGGHB6Itq+6bBEvpLVXJDDJm6bAbyF9507avwMBnv9orWnaajTZcHWG17jHGRtfoLuY2e+roHkxrDzUG67vIeHLJTCOtBQ7SgZSWDJoVOCmCKMrCurp53XrOtd/+Vik+4bNf1TpJm34O6lI2sF/ltMb4PRZK+qbmWTrmxtC7gpqA8UAJp6wg6G7rMPumcGl8lHHyDiv5uw6+U1F+v5/Hs2bGlEkqGpVKXQfqjEraOq/vz72105KghpZr/MJd684oTa5MbU2oWbG8slsUYEEiShCLQkctwFN4OK/H++MXc6itq6yO+zhW6O6Z+8IkF77XlvCKyIIRrVnvH+yc38lVEclEXzSLjA2jjUZVWefa2uqDluJrPSGcjRjA9aiWPaon2FZN+q+zTxRXVeUbObEjeE8ED3z8PPU8kzTNrL2WEuJlgC8/4FbQluVOSkRBTnVz8FGeMkbseEZpfV/JL3vQoEMxZezy53BO/FdayfKV9yfAVEQ/PT9/rgpDSfF1Q3IBJtQDsHDuVZYr6rENPL3sPtYpoftg+6lTPk9bh+yWmtq8JwaQLe19RLbQLXyXIajjjtm4y0GMumDFTgzO/aurOC4Z1uN5imBW3jCRUNEyImDo8iySSTH5QW4xNILvgqVWXvVhRH2pwIYuBx2uNoLW1iFjxz7ezEuYqm1sOBepE5hmri5F3ebdSI1B0WxwxtIzJwkSRwcCe8VPZtm2bQY1CimhFhgFOxg5UE6+4XoKPo6Lvxi5yBT8JF01Y8XXZNGQCa8dT0kskJ+KYsnA/7KZhvs4U1eTi40Ood1Oy649QusjWMvOHefRF1nyT9Gyn6iy1qmcw/8YQAUxVyurHDHqdNMJx1lR2Kxg/6/H4J2gsYSaiEfakLw9Ofhuqn9KC1BXvxGFOZHotL7TWqdsJjEcPXQXGQhjTrW8YZb2anRJ8K+sE53KlCxj9rlnJKYhvan2uTsHKZl7+iEFfffHmy81Dw2Lv7HVojl+GDvR+m11ZO5JtU+0D7ZQw6a7/00JhfvJdVkofotG1XWSvCNXOHmdNpp3OHFYTEmNtB8pXK9zbLzUfEl6G2XAhc4oQB2uUgCY9c3FDgFAuVe0UG0JgMQ2kc6R7kRuhyMedxP45XdNQpmUepGypMPvJCPBbg4XoONSOrWtFw/8lV7+u5SAb+xcvW3ktKnmSWPYkWXJspiavSAqB8BKhEVUQIxlFePmu8wwkLPBtV1VJjnv+npgGID0uJ0w8WjF2neiGh47LNK77MsX5Jcy8pvjV90zP8RF73RfYtYjc7Z3Qfo18Te954WwXG9gpclXPHbrXXrfnETSaS9p4fPerDR7zklTb1K8NnFqVqpubi8F4Yp5wOAEau4QCzjz1ePu5foOxIdpubbEDVq/f1+eOGpfUPoUSR3v0IRsFyXaQ/3lwFjFUutFzeiy9yc+Qway4D6qw2vWl1lNZXvobm30YFg4wRhRRaJiVQq11MFbksCrLNGqCXTd632ucwvHlKXVaU7bHPC4IZawanm9LTlcMSZICXMwEwXSi625p7a7y2DIl+ybKSWRtSBx6LAFYBLuY4SWYlH463IPl8/d7l6kaMmDMY7lC+djrfJS9Ls+kw31572pRnlcKq4niLEQPEoiyiL7QAwMxs3MN2PY+Yje4x23lrwYBeApndNL5o3dQN5q7W85HZQ0Ut9HF2zGGWKcIgXJpK/3rGd5eCkf9emqo/G/dhCDYmhd+0bzDGlDc7NenTUadzlWFA8IT7KF3hX1jxnma+cYTmRIR7ApEJdbxC2OYAGgeE5mysZufS1+7TEU0y2hsi3Kwg4f37m3pblbeXp6jNE6qXOT89QfQnhUO1Jv2xee7cUFI3Ri79BLrYf5smDWR6a61lCOnovN3areO6KJhY95f7hmaq6MsI/XE3do410OJR/FeaaXSiOk0SAQP4QsgkhQ1qe65LrKwTvRY0DnNXMKyzafyShQy+7u+DkhY55MMGbm1keYwF3eCFg+Isv1l5uh3pYyjIE97bxSJIm8DJXu+gTKGmf+F00rir972uNBgJE8dbFpfVHg9tEQMa5Ibe2yKXG89OSIKbemsPhKd75++57CqMYcdqbltBKEQQlWlJ+YIuDduU5wODxhX8f4HT1wvW9K+Ml4PIWG3wUe9LTrsciXXWKF4lgR4AMmFnblyI85t25bkmYXPEFzWRC2sTbojNzhzcCEKgcAPys8s/wLUtF6UM93D/p39IeSnbPvLysdhv9rTyGlII1aTfSrJR9xqhgP6GOCJ6swfMG0BvL4IWCPSS6CVV67mXjOmLRte2EN8nxO+AE5PDVpp32zYu0EE7ZzWV/f0U3fU7vr1AJezxzapIpeIsqPmUGdtrBhelRHfeDXvFUNnd2iuhS4+nxeGJwkaWh+dyceCMQChUhahFhrq+1/4gh/3FJfEQ5cwgjPljaUwnIUlchMwmDEvGXV8wcrfo6dxzEjj5oODXG9LjjRO7r+EnTmNVJp20lzbeb3pzWfQOJA18v01Ms7J4PuYd1VEoC2qp907AoPRKNPE+KM4+jkDmhg0KwcQ/ePe1GlmFgOWvtBD9XIJKeMIMlDdL5fF6uygP4rnkudfyPRTDsHvqMxm7w4p9Mti4JdS8PUkj4Ro4H7z7kjdUF26YpyKTt6Y9dduytlDfxzGRFc6FSOaRhINFDIm2g3MMKu5PwFTPxjWyrM4jyA3bfUcoXnwnYO5m+g4bvC/NsrgNduPlZuYt1rXNgGaehlU9EIpIH2f2uSJ8k+nEjw4YwQ4puwxiRCrSUV6vIB6HA7tvmde+Jk2iFmEL1Fll6zkMD+evxW15xXDz4twKp0IO343HoSeenegOyHCBS1sYK7aut+pnXDZqebHwTWqQ75GP8rumws6LMzDW3+04Mff3DdUy/quuPX4/uSmVv8lxBCEo/aNN9z5AOhaMeGaDV0dX2pNBGpB2iNc5QckYwxs5h1JLCr6AsFpyO5zWDHD6e3fB808OILg6rTOfdWMcPPihO5vyN1w3YaBFl6xVqehwpLnf/uHWzYK//NaGg3uPZkJoYXsfuRMLVCt20DcqcNWim7D8PBFUfYx7VRo97L7Ic51oxfqtRmKoxUxGnvPUnMSI7CwOqXY1GDTdNSxNkewjgkc1ApnXsMvU9wo4O9zgAm3E4Lv+IIzW9AgoxmwbJCavxPvqEuypvLmS9Ha9TD2dtlV5T8Uayhf316aDDzEMUCwVmjsKNWj9wj9uCzaRhZ15e5/BNDIE6nLd2P+bMaxQHEUONrGp8e0rdnAkHtu51QOud+hf79EgTOd63AKN0fkLbt+DdMtetA+f97SrnzTIk04lb2K+xGCVJoTiynoFOzxh0uavdSycrjk4z3vPJNgrIJT4SjG7ABX3bvFQjUsnyvoLe91/nxANwWZ1C0uMI/ymI7uojvulJHYSDMa93Bcicb/uVrJEzwQACSylfUn6YdDzllB6gGkL/jD91S9iorDVdxopLQ7mG1xvhJQx94IYQ0+iitmmzvz4V1Bw1fU3pWyhzia91WHFrc9yqYazqktKQkbSp068xh2HtueSiVdGbBSQ4RziWLq+Q5gaYYHx9jDCxMszyhXwxf6MmMu/u4oNWFhOcJWwqjoJ3tqcarP35PStXwgC8G8ioyJibxPz+0J4E5DhH2osYq8aP2oMOL4jmuQI9h3pIL7Pgh7WHPS3cTWF7Fwe6h7A0598ustES2fnETuXBARqqCW5pzPLPZOTza+rS7ApAy4/iZrR7NwcZYBEHB6wnsCtNbm7U0WzQ4Tr1l4Xl8gfl+o2AAjopGl+AWm/W5HoJJ4Yaghczzk8e8LPfHC6jAZdy866Rw2YYgOtV5g+P5HhBYVnxb/ZESWylOhaiilzfV49aAsY+IUw8+I2R+6RleOyzku2fehb41nrtsAHcpA45RDXVqUvQV7Um0b6H2VHjHRzH8Nd/d4r8ffQWa4TnvuEwHWYuAjhqGY2Z8Iwz+lSjxCS84LuSUqVLQoNdDGTLQcqOsXe1eanxUpEBQ2MB1qzZCWK+NmSQG96pVc9B2pOHFxoACQLV9OQVacCIJ13sXJxvxpiTqMCzyIzhy4FRQOqCWc7jLBOr34RE1WDPsPlxfCAbST+nQklepi0OSmOdTOgCu2/4cI1DrXEPC5vdpcH8mCjlSwgw1Cd0Gib3zIypEM1VcHw64MiObCg78Ec/7IMvCXRCpcBEfvDAI3Ia59s5gWYO8W4feEU4Ah1GQjJt0yuit+LRJ0MVsSo3u5osv/aW7+x2GFizp3Qn7wHZcBEIwIIGO3EAt5HAi9ZSYcK9LGQlGxChM3ilUDmp5cGNW0ApSib1WdEQ0NgcTrV6JszM+Ej/CA/p5w7cGvF+CbuWD2EmszNnSVo5FockT5DHjrkQijF+NMcrwyeX9nPU37/og6jrISaA78FKEOWZJBYqWkhOgzc8G5Iffz7gyAABtB91kc3LuxjAzNYXaiu85ljw4tS99E6P1itLrnQLozyvT+oqxAX2iY9JDeKZhKbLYRzF0hfSgGuejCgWW495TpQANRVSiug4lHg3tB6MFYcJbY7rBRl2ITqRX9NIz8OgZbpcVXDkmJnIncGoIsxCwlqbYz/uhgWub2i41lTeJH4RT+Ofd2iYyEIJSeHr2ywSH8BwkrlJEWKgQRD6c7DCwxkF8lLe4dVVE7NnflV0D1IoSmZbYxQ2thwKP6mWRG38t8LTwsU7wupxNBUTBZ49J49zmPXlsO5anwyFKZN+bO1sUTOVOgNlfLEdMCsCdpBYIGt74XrJHQvLX6muJrcHhDMRY4Axsbd6q5qNJQ+096Ag+pTJNFWF5PSrhcbozML7W2vY7snpTZtHC0wKVTwjgf0JyC3TOvZvs8AwlHPKzBkdCphd3tTBMlv2YLCR1c/HAl9i1A1LU2d89ZScZJBawO93Zfx3Ltjm6g4md9164K8mxqnHYuoTlmiNcap4MKH7umfWEagDi+teTBr9UFlCob6OK4hldSM5A1uOUtTHgrucjbrSwV2/3wziwIcL+Z2dTDKk00S5TIWI+t34c4GkX3J+XQA9ScpNInuZO9loP2uwKJEE6QKNWz552XpzJWLemFVssdu3/HyTAXLUROVMvwU030/BIrS9DWoTYKpEctlUAdU2gnPVEnXiSwWobRraGJUuy5u3/fvMBppg6tiU1mTH/2uJKpIRMoaWWg5qsIxnpgLVoYic8768UO3LUku5phcgFg9jb/thUrAu/+QQebds3ZE8LdX/MJOvdE0Sr6dw2CVk7WZngcRuu9PPFLfT5xjj0Rec4sBvFhX+E8QgX756BERB4bxUqH2nckn/igDFxLlY4OWN6BW5zOtwa9wI8lOm1ZVQKzTOOqNrjLnHhRnix29Poo1gbzYKlEEGD2gixQr56Jukkv05yYTGV+ZmFxhB+h5NMS+P53UABdlMc/idieeoxLJV0mHDo9CBE7EeNjCkWDEDJOxz/6esfuqcIVxwv8o2bn97hwYIJDfgX3LZGdKU/ezq5M5gNmhx/akeXyGbybm3DLMVVK7oiarvzV30d2b9seCMId/8eCKiZHKrknd4exJd/VCJZV0Lkj5f0PYqwYmo4dxFVX/+Ex2cvcsuaFoXmBoQfShwJYLBYHu20uzVhqjMmT5p/JO5RGQR8TD4SoxGzuOw0JxI5OWy4nCq/uPcHotI3JpryJnLaa57j2FiTzKafGtwQ2IZRbmc6JIq272dEqIZoNxmMG18oUbeaLKa639DK4pHTRzTa360Kyj6vuB4PAJVLNHa4TtDjzUe++bJY0eFXK5X9+5AH7tH++taz0fqfMqF5k/0e2yGVybC5S41zhMedJqyl4q85pvxysCKXC4HRfmguK7+T2O6yYzWwWhZ80DcfHItcVkW+q+E9A5MWh3v3M2YiaX5mNxnDhvB4yrSNnQDnvYzfRmVjRwsxyDCcMO+f1ti9YqD67n6CW4ijSKyke2ExjlxiOj6he2CskRX55nCM6pfJAb9QA0ge0TWPbRU0fZ0YQLPy1H+xNW+I9yekTkJtci3BviycvIy7q3zPPrC5JvabwdSmgRQSxNI3UxABj6tGtdD0CvBdlpMRP1T2TeO+0AVtHZu8M3LldyXFjcA9kBgS+Njo1c9LI9O9s53xbe47KPKlPsMhphtZah1QS29vS/qnjTKUoJ/R532HePZPPkx6WsXU8VCcwcUeZml+vp32MqnY8BaMG5q+P60/F72UVk1Bj8E1p5Ge+42CItcKUGaI7Vq/Vlg2IDphYFf/uQLXoFd5t7Ppw3CtIHP6Ushsb8ACizcWVcLYpFv8oq/Y8lvIJoonnTrI34bNntTcrcQ63quP9lFlgRxmjinGRFm/It9os9N4u3lUNt5lUepP+UmWXW83NuOLzhtIP0oMiRyYZ2usMa+gMOpDGZRHuNpRPOY8LAyIj/X3xiL7QmWbwQ3ghZrvvvBusSiOirzez+OY4XVy+g0RSET7BiFpgHkaGRN5QMg+CgBoOoAv7cn784a5AArMza2NwYT0GSdAT80F8ZBmA7JkJ/58Bp3o1TYp/ngtqp/uhov6KVTlE1alVmmn96mjoitFJfk41wXoZXD0t6OZuPXvQlDzMLQrOxPc1x+MNujKBj0gDKK4mTGL79Voi8o9HLLM9uaZK6ompsfRrJBkwXw8ra0jurV2gHrGM+IfcLO6xLKpbjc+3JtexJbx7JrOv1/TUAoH4Lwewib3GRp8Vq75SE4VnK7pj0hhB9ZSr/YxotdWckTp9nNYaHMN9s6RG6r2EiFnrb90eJFoTWyxIcSwIik9NUHTL75lX+1GyFK5CTL/X+yrNHbC1rVl8t19hZ8zwoIoq0qlBiCLwQXRvLEMzg6HcL9uIfc7Dgpgf0XwKgxoRot/nl5DSpQFNqrXiKqg/h8rBflxsytNV5QuZxr2JN07XRl41FE33S9Y1aMEpqq5sG0+4SWTS5o9Jj1Rf7eueXHSJWhPKdAsK/dCnlRl8Yakowy2cUfddbG6AKMRwx/pafbu5qTUW8W5wXvU+Q/OiN0QPAXVlAVzBH8lQ+DZ3xzDbleaEdz3h8xXe6zhNvkeju6yoxm6V9hlsbjhlLuQlMI//Tsjab05B25L3niioWME+rwIM0f7oRniUYUmHbOmooggjdQ7Y4pDfsrOVxM1yr3Mph82gXM7stJ1gKWyLKHZH62P8CKoz94MlC2JYjAHbdPZpbzQj0JXtLwTkXz0iESJSLfgpBB+w68VIK+dL105MZ2FlxJD3ZwSyTU6ikfU1zGzYQaY6zYP27tsvXnlfMZyB/nvbJDRoVOg5aJo/cg6DSVavI4x5ht+VswIgZipRNZmNxU6zTVvqulp4mVFbKs7c8IkZSjoxaZJBoa2Ueh4GI3b8itaduwZpLaw9I/P6G7JaM85cjRuaGcZ33EsNz7xPZHqgqTMK/Gz+hsKKcQZ1H/+HnKo6ZS4d7+OSnch/gGNH8f0V4iMuev1TLe8lUCdbGDtK7aGUFcDuhSZd2SFu79R92SHeKb1ropj3GEUX/Go6saXKHtIFyWfb+SvYgqJmF5iaEjK+Z3sGFQYwpLG0m7CrrcOSGQQPhsoCKQ1FsausWA4oDiymk9xClfDoBKu9omovAbHx3mvdQ+Q6H3lfSLaqblRLTNxFtcKJ/qiCliNZIG/WInI050QfmrTThj8ZAyblHhEuB9fW8/VPIP4bAX8JliEzSKwd9n2xCwBaWUEM76NyoVJSeREUeG4yWRLE96rFNZ4syN+NALDiSmOCcn+xcwHkd6IHT/T+CqNX1ty4HEfuMi7OWJQ1x6wwLXuc2FN+RC3xs1YeoSs3/ZJq2jDkJGteMgFgb7gQczxCdk8tAjd/4VNNf7Ya3OR8EyFZYEilQ2c3w5fjOD/iSxvUvkplHJl/BiezTnzzRbW+4G6t1YVui+ISVrWLSiuy6SL7FaO22etAgRoHMm4YCF7XqwPnNji0roLX4ddeLerUT1TkpZNAwnXeyNDgAgDZj6qqcWvwxyOtugJLpCnDCCDsnYA1d4VAK7WPet6+jkD3EiGBBhiDVeTw7F/bWvAwJkOiFkFZdhJT2iDAaMOeaN9XkZ+5hwWrKzr5Fx+9EiWkEVNe1OtoXBmgw5dx+CrI9GA2IzIuGz5KBJTvJvzXSIUVFdAWrYkUq4EHccfX0gogchbJZwgSV1l2xw5WAUWfue6AcE0m5SLF6RIbE49v25VcX9UYtFx27DOTYFULhhNk+5uQHO2Wmv3UPLRJ8NUA04kV4ResWFneK6bm4KgcLBsGfe0Yb3PQxwURmGKlxWNZCjEsx4QylLBv9O7hJG6wHnEMtWeMzlpyTpuawJAnQv/jMcDC1MO4vQ4XhR5pdajzxCo/QjoCsLah/OxxxJ6SAsRjR8O3D4cpKdWOmKXxSUgOvPOavlJC790RzNAnbxTXkfKfGAhZ20pE9CDG1gPvImpLJp3IisUpKiwHaGaX4ppVKWWaQ0qgF97OyNpDwVOUsdP4Lt7+/pRLa41p9dcBokpyfkqiEos4Ysvw7bAdnQXa1zrRzx2zmQ87FWyvFnACG39EPIH4vFEKt6wyfUOjdn0lbaVSfAi05oEcQATeuKzjTxxo4LL8BPUOcK5cGz05wl/ukRWXhw2+d5tota1NTFmrsE+FR/dk4Wj7lYH4a0gl8ZGoG6a86e8Yina8zpDi1nNTuQjP6ogJsiHzO/DPIIp6v37tnYLXlzdfwQqj6tP6v+ZRTL2j0BIlw/Psoq3Cb+Kw7HuCtEmHPpuRVaPg7fk8e0v5HggQjC3gD0gFOgCI38ZTx60IZSNBgTI+P5qhqh6qZOIoB75ZVWIw0hL7rcxRLglXufyOHktlqccnSdKTpTsyL0sZ1BcB+l609hiUZZ0/+4MzZ97qDWPIUTEBTn9Qba2hvFDGnUew427DuktXaCgyXNsKCU0jnFM/+OuODbscoiBKeVXACS/yzKA9IlVzMyPkYnBlVyrRzwsN6r8FzSPn3vt66xXTDHxD2yx+dwyet+X2k0UlwFm53sVvcppDcToUiaT2tb8tdCV2ARxoFFWrIKKZMfPYaBXyZu/3Aq10qa6C3GM+lLKOgSCWIrQW3NbFw1sy+8KVdVsrn6KFZpo440SdlY5vqjmBCyaE4RUy6WGKXhcqICWt37EuuRCit1x2D39x33YTCVaYaNKzqyW1+vejbeJYck9V25llQuDa1fA5Fom9YX7yILTVjM03ziPy1sfVzsDfqB0T7ipIH2DLtoNtxBAI7Md+iRpd+y2JT2CfryLdz+kLEnzkEPG4z92oAXIDWYYIrHql9gY7G9V54pwbWQ40Znx54yH2XlMHUDm73SZRXDGdbQbUUhOsXc7EYflgKoUB+opBGFyQr0vFvfHexbDD5Hlf9YnQueSUwBLRUmp2UWTSYa01FOFyYFw9fhF2l2jn5pO3dxpCJ7b6b8J6mPflM14LUuO4C2xPHIMoozAa/qKZ/ePSGXJ3uG5fEcejUUT4JGqn9EsCZccqjBJWAJ+3eL9Fwo/QHj5SHfLglmHWExM87jUrVcuGd3e3SBAryM8zehrs1Dia3BFVEljKQ5z1AwtjxP8JZkMLvxKjEz35IjTqchihetSIkN5wYWJVuZkRChkJkWllnPDmZGNvoiT8Qa2oRe2zc2jbqFcw2MNx3WwtceOZ/7Ysyk5ZNprccw1SSmeW1hD5T0yuCv7zYb0hMCLNCD4QxtAezwLaaqLQDe5atlZnwrqBC8Bs2s5jUOOm3k/phRDlbzThRzxey58Xut8fp3GU7lhNOKiUzq2mdjg7x/BFlgHab+YgJUJAcIpECuBpYx8zQspbiJACt2OLiDbKWnD8XuugHJtJch+PKaGZ1IUanFcsHcTRGRtNFOIzKHdri0vkdL8sn/k7aaQdubgR31jAPUDaDMGUTKyuy2z8WkpptIqiOLljUgS/Ar3DvPYMVV/2+gQ8MZeTNoA6p/sVdH8ULEajSeiHT8DMwG0F8P5YwdnMFQvei10EyTu+9MFVNcISnFAdvnQQz9Du+GDny03i/tT/H2Oz4VNiTuctQsVPY54XZmPhr1ntCo+jGQabFp57YuVngqbTxHhke+iubv/NgiZtN6tiYF7OB+j+2NgLJxad9q2ZHKJB9iA79OxxPQdNI/Ifr8B7oEtrVIutF/3WFrctbcQNteDm898VDHnlvw6yBEFTBw0eQSGpTWxbrKXB/Ft+OwVXlw9va4ap4J1O8E6qxfUwmRtGE9MefyotPcwBcoMfHoqv3mK8dWhm5bcpaFbd02BMPgNVdErnx49GH56AzuYn49xnNcfa5gVw2WnJIb0rX2qQuTfHmLWFg4VwXJSNWok4jkE8lttrIDSeNjMNj4xpmatAHJ0veod+X3En+S1zO9Z52DxrM23OvuG4kKcT2YIR4QyP+4QzSM1Pu6xCN2pDsA1A1GLnK/mVI1tk97JMKmaNQ77cNTetbxp8mW67BjxbZ4xpBKQuGQCM70sETOcN9eAUWYxWWA0XVyh88GzmT9V/acdUd7FfZ6uynYDPZkCCGpYypjcYofW/M1UY6xYsih0qhKNdL/f1d0eqLG+cp6yc61i9enDWDjXwZVurAMYBYRMJr+dVXEOcaEc37XZi4St2c8fmQoHQ/7NwWC9PKY4S5HkGaJs5sOohX1ZfLfhe16P2Th7GwlpqunaWZ83UrKq/cvOHiGLBnNImMmuGJaMqOGLxWJMNgv8mVlzbG6V2JqBFWWreK2uWywgtxZpxSykqnXaImsmV/HTCNMAw0THl+CpoomswF3e2HKS4lAPiaPv0JPAdLD3baWhPFAN3+rU1gVvLsEfhQ99WL9ZPmeigOmst1azhg1gkIeZDa2srlsosSAmL3R7gGkGDW9JSad/GvB9VicCwiTW6qTTliHP7MeuNdOeYsnW9QOD6vMUrjN8/Z98mxuXeHquEKOrHQSQQwC6dQhGYJAl8uExKfs25JjJvbJvGAUMGv1RBmfqEYKvJHmVTCyREp+RZ3BKEgbaZyaPKRbqOL4rOqzQlbzhkvFIjJFcSFyD1Yn84a22feN0pv2NDJ6W9/+m7C5rOq5aPlcVvgQS4Xmfh/Ih8C5b4OJ+YmDpvfAvDYfITAyyEBtSnLK+T4gMJLvgao6oAq/up+yE5yxKAfi0nMtiKWHZS9rY3ROMRuz90MXDlt9ggbkAxY6url8vBf1nsbxyMXGG9wmiSWm2LiZpjnoYlZg4NBPQMmsuNGBZsif2BNc0iVI65lJEESPPsBw0IJmGJ8qxx+kmTopVXlklFtTa7WjLhn6pIkM0AZpaWUnXt5tLpl0twIw5xzrygfh8HUWOHoQ+AcvL7RgwL3FyixOxVr+dqFOH7DHoTQYe317o+2AF6RX/kP5btWbetdeaMhZk+Idi0RqgQVxLEtZrUJzETpNIWlUmdNF0Q02XWVsd7tvP1M9tN3P4yCLn7JWUykXGzgx4gpm0ixrAJ+/DV+3kXuxXtUH6UAgaFCcpfA5Ewsy2Fc890uo36uAtT3KQEzVntI7knL+26ZIAvVOpYgjF54Pi+fn+BDBazB6SFOqR+0jI1lFaTCh5C1onrayakogQazWRUoBNPtn7p8WuZxN8sL5ctO/vIDeAbjIulSr9H4OuL2Ae6XMCy2Mwc+aIXX+iiKiZvLFApiCKFzrbe2c1YZZCJPGxR/Ex2zJ3MRsWcnh8u1GK8VeA6PXL8wkVYAbrUQii43lwbRi1s2/qcelOJmMd7BIvjy/kT+NL4TgiW5BAdjaeD4p6jpvT57ptxQELBMc8SyTc4iq+4mJHgQwM+XbNPSmq/HL4FY1SSpaR7F1pvskceNJyD87fpBmXbL9wB/uOu5PI6XArfUa5yaGqZcMbGCyvl+N561gq/GCdGblCMGiQ3CB1+UEahrTNtca1Eza1/PlpTBpKkJcKm1aq589f3gY8C9HtJH6XoKm6fb7pVdpwg6z8koBT2dn6P6Uk/PaLC65IIrrYvzvgtf+PmzqURXljBUBDT+/CT9x6Typk3O0p5XlWio1l5R8c9G0rQHO7qeWmwSYM0ghKmDriWpUggm+J9ia+fOENsxJzk3PxVT0eZRQY+Vr2SZ0DxXUNt/fAAuYNVyz3C/PNLaPm/dm3hRdx+TA8BPbVU9fQABaYwQ2oRjAg2V6fT4gDXmyPOwPulJN/yWhKXtu+FhxozxN/c5NOnovL3/sPX/rJGi6OT4w97QkNauax9s7IWL6sqJ/W/QtJ0ij6D11fcouDg7+/MK1hCOzlfvVdtbpLTUgHsw8SBPSh0VHb0Z3VYcaKJ8rqTQKFyrKTPcS9RDTUYPylquWLS1/po0LliC495o0qdW3st6ScnB2UnDb0QiiLu69u05vX2op7l191waL3WAP03n15vr3H89ioYzIRzw4/kkbJUEvciS8a2F6Kf0IIt/Z2Q7POH42U2F7LGX7EbUlGII4voxMGtLEXOC8u2x2EQRnSeFVhpU1aiqvq1n9GjN5SZ2P5EJ11v9vCpLLlSqOSJQaR/7/vu7FrLqpE9GNQPFoYwWmN55q49eJhgB2YkVuD4RwGsP5nH5Gy5kDUgLeMDBnp+cGqgyjQFz8HhTxieSN6kV1G7wduK3exn28fvHqaJV+hIVKWIYOcfD7u5C5Njb762tE8t5d1q1D3cA1pyk/SRNagqJFd49/24NzRmpKa5PQcNcPqLSQOyHnzA4B1NfmohKyA39VfCNKKPT995BmlQkPTKFLEnsDqKqHMEGLWSR3u5ckcwRdnJatVgqsflLk1d0wroIC/toJe62quIULdi/svsPYgz9VV6K1Tqp7imqwd2kiEd9sRzDN0dL+vhYDvQjjLnVUGtl0nOHM/PHRbnfJkQpff0q1hMMux+grzjfVmwKB+MlWLLRfObN91mSYCVY2VPkQLqLrp+7AKIxHb15kd20dfqX0BUuMV+dIVvor/fBFMJwhWaGxwh1jIgURmnrZp9JUm35umR8IIV27K3fIgQ3hiaQLUAJwQ9fsTR0c6MjmnEtDjDwkq2T6YOmsOjXyh5WqWDJ6ojs3E5pwOJUixV+Q1P/KI4Qs3G7DJV4/XDOjhpFlo7en2vlSLV+eLUypoL1PpEyYYtz6Fisfqec7ocmklGc/KO39QtXHt96/0qlaB7rcicNF4NKCUfkfNVbOstKQULqLWI1OP1Ell5V/g8LLpHHgqpXZ/ifjKjCEC+V81Fk0nQR1Iz4MiL8QoqtGu8Pq3eonEzzZxOq8ax0/IQpgcPN2Va92k0BbwBjWXrTh23bDfCyaEbRdVwHwNWwsp0kCQ0jMs+CsIfWvNS6kR+SlDmg7rhY5S9+ksxSgkGzxaUWfPmf5WKjPVO5LVKt51DO8qDuKOQccrDIohuA02w4DXl9e0K824uiaLOu5Hr5iA08NhjfXMjGDhXj2ufDn5xzcbOcdpT3BdHbSK0ibawTEElYZLE3V9uCzL2Yxrr72A9Hb3OxreL0A4j2/u8GUpbkMi8jWAFzey8pEMla43MWLIuwGF/Os49PSnr8PIIGJ7K6Kwl8XmtbQfEkP4/G10YhVuzu2V0u2es8ucbOQbJmGUBGYKdsYvqRFVu1HEFyXZZ1ZvvWRXHWGPdH2MNxajmNuLglF134266baLNxs8fNVBUec21Vyj8zsp8zr6U/jLoaOzUFHHtbwuCqySzl3LSsLkjU8bD1CPk31jpf2+CB0IXNIJVcrarwF9PyRweC3BRxKuRt+GYtBPkJEljl1lwOvXMe3gHwu37STRvlgQalyLmFbe1sJxrKc7T8Asuo3g4TN4h/s3Sm2L6rA5fjO9Q5G3RCcyP2q0EmNXlzgaMwfw1VAg2GEtXLvZ9vNRDdpL7efSWEyALeRKakOaIg+roBO1a3XnJ5kuCgEJwjgQXjp9pLwaqoHIu5HxBbb7jnb+JpRLZhEZSKWgtwMAe+QGCXmGuL0Ks0McNXfW8YlU8dxhsTdb9wPVG8S/mg1SNVFYgj4kVaLeOJuSGybvADhO1N0u3uIbB2Zx1Bf/bhYdvTw17iKhQ1cfgOcQ1YkqwWaY6LNThU/0W41hQhP3vq0CC1tob9fxAGbiXJv6FrWcZZOow/qpVLcjZQAWtJjGCSSpd1SozkrR25i136W4800StGXlj1OgUV4T7gCZj23evx0zx+Re1pUAMhitW7FmBQbY5VnTlT6dzHP/kWnOIOcOEIBY+xwR0vsaSX9/WXm1LDMH6OcDDbyl+LEc8mvBD2ZjfyGcso62nglk0OPu1O0AbPRPN5K6fgwJ1ILQJu0D0rfel5GsXB/AlVQrdBpwC8fbfEFYdhaAoZfQqS6LdGHFgZnxDX6Cfh/ynRr7y4aP0T3HohcnkuBu2bG7DVkygyzWT31Zjnt+zzf0xnXSTZ/26DWgqXL2GpyORbsUeaAFN1VX2X1LU0mFnYv6a9muvdJarIqgBJvty2s0oQxGHHh8biaOPjfP/aUJDokwUZ05KMcf57yJH2KIqDYwPsxwXE4aQuky32D8bTTEdjBW6Gw4oGnnerJvo3BwxpjlT1/yLcE6C/s7XXY07SCVazpOrEV6HI5n2S0CuIu1hwqZnBOc9X2lViCh1AcAPTC/AehPMcd9c4Ayrp5sqrIkBvhAkvzgZxARWBXdgkdSJ7PdwZUJGf+buII+VhwC6vsSG2jmH1GTcQcQc5g5UYPpnSM+z6rYOAbMpBJqLN6/RJQFU+8WrhUu6TtDeG2ZAWvXZ55GPUjVt6XmzRpSQIhnnPxJUzO/rWd0RbwqnuF+j+gzgUWU508/dRWqMFyJ+B+nGqlJ2m1w50NBQnjeSyyWqh4aJv6fiXqlPZkOAtCsf8cBVhJUJB4IlhdOb5xCuQi8eC0KusV2nOrGgRp9NgVR0UyGxZWMinrkTirz6S6GjeFNji/fwVStM1fFAa1e5leYzsx/VlFNLwy6msVJZQEj3epjLxrULWj49cFQalasQFepDSUhQ7BNDPFbLZY4+oRhbrnyGAohoeegC+Tt9i/og+8w8p+A9iRF2L8lmCsj9aAZ3NaZ5HmSdCiGlOw/yw6Q3/kjhTPFysgxMTfYOoW+Qe5Z91dUE1UWJxBSu3eizLZNJf8s6JnF6gOI40sTJDc8KZqHeQ8uT9+TDJ97X35AOC6FmYDGxr9elk/imbHG2kTk888LVBhmFCTpXXOsmm2Dmph6Ivr8hZclsPldSQqQTGPtibVOhUxY2kaGxGH7nO2Fum3ZFyyoffeTh9jQKq7ziWq1eXYx9b3ofuJ8WDzLP9dmScdk8CQUQzBu0HPOvDcSyPwcq3rD8e9CncxCCbzwU3FPl+edzoDCW8WK25JYCDE/15d5Z9ZLBqeXndA/kscpYw9vnmQrWwR9zm3CEfYC5fzKIsjd13/NlnI4qrtMgUqcyYFm3jQ9hDcaE06rZUAOdPdY5/6XAnU0d6+Oo07WhvThT75VDJjf1L8dD6yJoZ/4Vi6rjG301RtBHqmZ9DBbvQqvwekzHiwF6PwB2ga6uf65NXcCoyC9Lnx/4aeWWRcZQEFowXdwOorzwOGHEveVFBEJcUBDPylTly9sVEf9jL0DB3HhGhDlUuYk0VggPqd9mkktZeR3SauIxCBuE2szbgA1epFyIQWNrl5WiVVaduNzpmY5XzDaNaDJ+GXppOYWujAA+RqyXAzDtW/KF7dMHAAuuEIdtP3J2vMThI5HhtrEiEkPM5LQqmyiUcx7nONarhRHByQvsxAz0/5wwyJU6zhH9XF6g6onbfuVzLP/IZsZZLz5lXDVrGQW2OFOS7IZ0K7WzpP72T0mkxKtdcjLRhMJffbPhVUCUFpuWO9M6IBiauUQnXUYeHf9as+ZbAyOvgLlrPYwBmITl6bbYj0PEDAr0dKwx18iwk9o+OPBc1sy/Dci7XL+JLfzxmhlpc/YbCQrHNiVGmMuITwFWFRhahbkck8LMuyYaUSR0K2FWZkhMk8OI6/jMCiRyNoTLsqzmBBo1pf7D/U9DP33q9fMUpP4ftCDNEQSBukw2/niiLCZ+gXWZXuzhaqH5Yvc0dsw21u1oKcVT3vgPtaRZL2zqBg9vf4REii4aPxwQhc99l2fPF4IyJmxrYHE8MuAZ3j0K/WDmww5gqgNTV2nGG8NRDtUSQ4L5Xhj9P+gTRinzJ8AnZIhbEWNeiM3GgCLUyA1DuzJZYiaCQnYG2nhR7z7hgu1Gf57mUksVOV3FksNImdP/ZgWzBHYOOu2l2uQPc79BTw0EDS4gjdtQTvWPWsT5HI/QLPrN+88f0ENNIqs9g3+SIQ4clkosrG3TSQRQ9NnlK2926pdD1tFO3xRquOxRPWx1cBlCOZyGHXcafNNMry3WrZ6xt8Q9hmgjX76TTzG3+zUZ4xW0LK1z+5VoMQylgoDWM0BQip/PQZgvNUvtuDvany96zS8SCI0cppMTZhCUjf/79/pRY+nFfZfuNqcn3RvQAXZpjVkZMbogUZsS5/aDwKU3auwooz/H67p8KEc7PqFY5UDiBE1ZmM/C+BPJopsQH2SRP4AEexHyUdF47Qj55ZbuheHzdhudvdYkxKRcyeN2eaIp+rx+UIaTCQ4VRDvfMwrvxW3zckIqS0JNJEeWzCK8vs0lZPTD78wD9i3ZBRq8BjOJYmf9ZUcqEgBOSwf1LsW2KWflwh6OV7IFU670XyHdjSrESq3BgkIvQfuEJ8mX//eH3llGcBsL34RgdcAnUBDeqGvGpoNeuJaQvGqrIfJNRYNXOh6mhmUgymBqnwX07OdrcM7GUFV860kn+lclf75VdvRv91Rl+4FtL2PlCQhL/q7sNjUWF36EpowQeL6FqLt3frXyTVL9o49QgHwd8u7TKAIcM0A4rzHjcrowiNhAzyzVi0E7zFvTMA54HJVtE4Ez8H0aXms0oqtesBavnpCYIqOdbVvNYUzy0VFKi6GksdLVR+cbJSrvrJRh9l54F3lxLJblXgZ2GIDKphqvUpkO27lPTjBEFhuXGdveQve+h0qMGMS77A0P16S/yjOIVZorqZCMHiBI3NaUR1Uqpeyt0ZUHxf7ukKKIi7zYzO6zb/T7TmIw4XgdzCA8Yjmht9zGCV8cUnvZbcJFq6VyBUot3CHH44HR7jxTRqSExnX6cIgWHzgbx3iqvTvaDSecruh+d/KpJhECsYHR4zM6liSaYg6/XY/8PDBVys8GUf92psD6c+tH2mNIzuyeqLz+a6/r88uXXbiIRfV1u4oiHXWgYqkg3EmQ+e0JAc3gA3V+eaIXwJRiH2eZbZs0MLtAWErog7esvSS0Fdu1bwxlK94vPEfc2ssAZWlOzaVucB4J73tHfOGY9ojKKPFTRuksGo6WjGIyvi+qw/wOM8O/a6ypbTa3dqE3/f6rFSSHYlBKEi0i+kS6DUnV6nkA1bb4zmHg8RnHyz+u91pR7NPiiexun65RlbB1nBZb9JeH1jU2gGu9nFkebhgW2TfqS6pANQUxbf6bJNbWgsiSnZ1Vu/usUgJVC4sPfJzOcl9ij/j6c8uZrQ+nIQY8VIKmEQXnlmrD2ieRFA4XRkOmV5yY9AlBUhZJ7xH0Au1TtqRDs3C2w4Mdu1jODKQljQDGCv3t9GRnFRton3hfGJhFArzlr0pWrztnh6lY1LjxUjpwIFI0R5vT241FvPaRVjD1kqRgXtmVAEngyjsCSLMokXOWLmXK7AsV/OG5qKXYSjNjM+ZZb5vlbWeLWyBmMsbu1YVPtS/7+NG7H8QuAdRxDc4WVpjrdRaq8uK0yKikxOYOQL7BunB5WE8MWfuxxDPFGzKiUZeEQU3NRsP9kCtCcGgjWPQ1yU58V4mbvOMg1gTydaaxPb8eqzPLnhC8UPPqqWmoQOE1tmbYTs3T7JPhXQLH7QCrQrE0S82lY7sJdiEb13banwl692yEz3qjM+yQ7EhGr0dUEQP5ajoe1EtecypQbD2iIdsfYTs2FAcXJKRFzKJ6iHktWojhFSYR0Qrdas2rWPzoVAgrySyH3MDoZZRk6fP4QhB0JaYf7Zya84pxyRvWMiCGmJuM8DZhpGGt30RKxclyS1dUVsxTorhElaHmPZm7YXCl/LZ3BbB6eKGRbFblM1LwJwYJkZ9tRjH0kr611BK8Y6JePqKpPN6jt+jsL3/be2KCePCjIhUo7yN1M6vQRZXlS89KB/ECTgcuNyo9e41t+cw9oMHIph/Dl0bwmAYHXPGf5AHskFnGzD9gfFDWu5CYWgmqJa6VFuPoLfaYtaSCWMUHOnMf9vi8+sSEuCUue7d7/Bwkssb9gcCSk+QHlia1qMLt9O8Pb9ZpHVdCLL04YlVKhbZ6Lj7cn5lizxTnKSlTS/YVderwos2E00S+wnStuAbRJ/0OIxLpcRmhr48HlhJZeMUWygRUJgVhpWG1EuUVMj+njn5hYkkZtcLB/yLnSbRFnzy7x2tWun7Gfl2r9nLtV3zBRbiDVgI6/mvZFcKt+bF3Ov1aX9AHk3HvgNGvVfrG/8fS0kAPcXu9IszdC2YttgS93TTLu5yGqVB1pYJQmsgEMjwqVZR5nmtyypCmyy3gmeT5QAeg6bjAsPwLHNU6/R60oDNXCHbxxuLuG9QpdiXus08eYset5695fFQqI3nt6xzNGLS9aWQHa5cqLsPhi0382/9j1Z5yeNVmwGjfL291SNHpAAi18AAK6SmZU99BuyWr5Uyjp8x7YwkRvBLgnA0yiXRmKAHoANGu4sck101dUQCdxMghR2XN0O1vZ1NDDvemKaBiiBX4FbDdRHD5jRYA9Br6Qu8/MUz91Giz2kSjgHJ0yAuSP0tGh4viWqAajfHLciLMWfzwrSmrzqbDf7QQyuJIs4XY2ukkWfDrMyEaM/FEVafZuZYsxm0QVJ6nHr9JmLuIRm0mxj+7MOjKRPqAc/1b/GyM5NtHrTHxkpVN7T388JEjFPHlcgFlDnpW2661dYQQGuDK8SFxijdVwqGEYbEUI+P44qnR+yas+CyvuSIQAa1vncLiBiwUd5KhJbSgCxMZ0+g1JkBDPeDeUqfhvhK98uZlO9gSQ3waV4R3IEmid3Lqewlzsf88dqZSH/JzbP8rab+mq7RIYjfBOwhCD3Ooxbr8iPw98Bisr1qhPDqVXeaIdKNHFXIxxiCTBdShjS+57cvADSLSwvbCwqM+sSgKCf9FcPYuhQftWLO50TZCaxOJ99Yss59cc9T978N+h7qEPsDYpwvldq1h5qlByhgbuO6rBfdqd0CC+gK8wze0D2Rdn/tt9ZCyNCpf9BYVUO02GCZdQtbR6jG/xMgBfUE/9OJe9hcyR+CruUvL9CkK+E/e3vUdst0hgs3WnG0efmqrX4WTKPZLJSso6GlKmHSSBTDibAsSVw139tMjyPN0GnB8DSyRsBuP+EWmV5ofmwzgfojFA4JLmUSEfHd8Cz13TjhJPRGU1fphU3MmE9kmN7LipqAD/lhusEehq34IMFPR9NWfYfZRbcScTqbKj5X3m9qw3nasHDeoQQpefJWMLRP3jTj9PO5hHTLxcv5RCsFh/WBdI2+ThrcNpzYHZm5lq6Xsov40cRz0MDYhC9c4zYbRG48wt0yiOICV2pmfNoJrI5rLlWcND1uIVqH0G0yQ9IsTMrHhoeleI+UbkzAF45tDLi7s8M4vvv/ToHd4FobTAoZBi0dML4bjkAbMg/y+yz4VI70RqVhN2UGCKx9iciR3NXpY0bl9p5XkRnsrf5pZqJJoSDzWMqVJbiCH+CrNDydj96YvyPJhN93Cs3pLM784Piwh+zTHmZR+uxilEp1DbEyAU9l/iIcd8vBKRxiHL+1TDfWodty7Nc7XbXinlQuOydsiUtmVYNn7rwMdZn7WCy00lpuCjtz96CIKL/OCle6sy7OIcdGjjbYQYVlbz/xLsUC1kjbI++BTb9WXzherRw/+9iWgh2JhgW/8UvqVfe34vMntS7fkZK/mvJ/aT/YQaLAB5Rt20UocvZ8EvqF91O9Oc1rIZL1/lHkWdohFOkJT5Ic9HMWhGhnNVWIrEvtFIjOX+ZskcVklEQARQhLXp2VX0GgZblY/OzSUUh4VM0+YhH50TQQrxDz8tp0hh3cM9yM2/gTvjRmQg5NAIKWgNzcJLJRctFvA058lLVPv4QN5AdqtBnC8i5vJW2dDpqaaChL5sUsefomJjFQDKGpWcPLrlJHuUAxjCo9BI68jskh8NafcIR5KlFFkhT7yEVEkYcsd/NCzDFHyMbWtHn6jzJikka25AmmNRVUMFNLsddwx+bp5QGf4GIH5FM85oUVi7aTH37Tm5dixC1OOOHU726QTNNQTEo6s3CxsIrsokcAEebDjPRUYH5zpwoXEEc5/JaHsZIDA0LguHTQZWaR2nHGnajYcxILpRVA6qbDwXpZxn0frwakQgvU5cOTtxRgQ43MC8Wm0+4lBhvqd+XvKj3NI9b8lVIL9InfjPo7XSC22qXLWQaKLjLryDUwpDi2+dMr3qirspjdyWbqVPsgD2ceDX39pYptEstSYei50DQbbnm/a0UoFOqQGtlrGvU8UXf8Ag3Av3yRg3kaqtNeWfD9ZyozeL10AdK2pZdublV3M1/krusATuOKH40Fot9QH5gUN4tclnrczXzaVybS7Fb1j0QDH3986o4yYRH5v3iKP66oYvXGJ3k2avGXFd1YMoh/3JfZPZnOj4vVLSULyskRACxoyFV6zavMwxFJ9tRyJ6JZZmDGKgyBjsI7ruTT0WGGX+MQ+1torQBhllJ3PjZRw6dQxO4AdUH8v/+q28qsm6G9HxqKCeqBq2WcBhjqX0WQdAXYMccmPj9SREKESeujrP9jnxzEFXz/ydIojGU5iOEg0iEmAm3WBuWGswyZu97B6Fmnjju3qI+1Ik0ypGiY9ynqoB/3wBZRo4n6OtArzCrE6d9YsuarRGISyXEQcIoN+VEr/963vyFEdNDyfrxFLG94EDjlT+aGJuJr5rNJukGaUy+H9ZVtw1MuON2A7Ecd4syEWdP76tIYAG0k0qRbYSLtG6gtGYpPctL1S6wAgHvtjpmp+QZw+eACTiGqy8p8piPMH0dSjm3XgX9wbIfPmSkIpmr99IWXwy4cpftZampPEGiA3NGPxGf/2/GbbQHoNU5l+ByJIA64gI/nDRkCO4vrFR0/HoE7I2t74U8gSQRjLHCQs13hsY1BBfcisWbAQEqWmkcziIqNi5asVfn/rQmrjgc2fP5C/H/Wyq+jyrf0fqN9m4gK9jgs5bsVMWpjUOp5NMYXNm1AUBsj7d5f5ShIrI/k7TFq4mY8BIwKxwI3k1ysr7k/T1q5OTUQgXwSv5TDRmPUrHdKpM0Nw+TMHzuNNxHNzjjl0P8Hz6O0rQOcnKMyknVMv0DUF0i/3UPFig8jRa5wiazmJrv+Q7vji84WraVvWMu9MaKHxhDfIdSrXvKvWBY8it8DwvVXBMdmvWdgpH23sQzU+Dm04bf2ZhziEwzm2pbNtKE11sK3nZvL71t/Tbejnno4mxmo3WPy/2eV78qBQvDJBik5uqKfnvEriSYSj9wamPZdxiSes3K+QWD2THlPNDfBg3uTutqeMtNC4rQYaVmu8S760PFMwFXuebtPRjXHCRzF1/NUlBLiMoxYSKb7c5rlAmXGIYmZhjnmHwZiZc9swhqFpeBqnCFEnhLkxZ3hfIrgw3N5S41jX5NA5YRFJd91YlyttDMYEZWBdY+bLZhxNE3PjaHbj3r0rEYPiVpCrF+WNjzmFHD1d1ypZ76Haj3qlf1rmuva2iqOtyMa8ZXAk5OGJA2jOnb0e0bx2Ffi/RkveM8Uuy+HDoFwCE6NVs4fu5/2WBHboVDOV4VHLa3aChIHPssH++rLqvsyFrdrhUmoHmaAdzgraVWjKyWp9JkfeDEtfwArm9YScrsB0s65hWF6cJJb3Lk5UhgUYtD7LrO9QffdwRMpHEboquaQm5LdMXK/3Ozb6mqdA00HmrX4DC+RAsaFJyLOzqxhhi3+FhMQhOVzB2LJy5p/4Heif+d1oefwCOKmYhy5w6zngFY8Y/LSlGyl2xAcHuizuZuiq9VM4TFMNvWArOuMzygmDiPSxUsViGv39AqS3zpSUk4ioj/a5TU4BY0Aph6XloeTKCdBWJqjSA2XEblk304W3M15fvsGAJ3iF6yqfnamGRTBNYvxB8njP63YxL+jg288YvE6gVCPRugmNnvHIhKFfYYQT72PSqCpw6C9lOK4B6CrgERD9y4oFh6L58S4FP22iuuyyxIpFw/eie43EbPcLzMqI5dCcQnDw9pS9OA1R26rMGJwMr1OzUVfQy+mtDDaqGuYOnYRxGipqQd32dO9jyaPSPUS67splP37z/ofH+oP2i6EeHTx96AFWkH2KHMHG2yaF7V+fmCRv3WRSZDn4DJf78UYM2OhJKfo5Jj0ooiUQL4nYtZmOHVzV2CfIVVip+Exb9ONMnFdeISun8pS3Ceui0ygLrEEYghW082aUxYLZTA58pH2eTW85/T5ZxGa85+4aG733ARUX1F3/+JYwbUy+mzpy2D+CKFVC8PaW6T1z4NX3jYtFPhfq3YB287ccPSHf7w5rRGhraOKIO1zBKkoxIDqjGNP2A77V8I7Bmadq9poNWPQ4s/7JaeDo8PuX/A6S+ayu04sTcfHcBCVzoEFjPxWKVR3lnP9dSviHa3igIC6ES9UIIHoVItQldaekyoXXn3aGglggxjCuw4q5i3mr/2YZPaZAkox0835856BGC4qEe6/Xqop/z/0mkn2Qse5LMgg2z0unEUaR1+Lsq5WD/KQbzhz2LDJAoRIYKX/gE5nxQ3/LiFVwhfviBPHwD4CssNiGZRlfyNXccAtTHnjQWJUBFbxNy9EdHdlkNSbqNJXXfWN+wlRYW11/yk1stDR7ctd2j0rSzL3iFSS4FmZOs7nI8PjWcDBRK4O3KfZ6yoOmZigtKi2f0H/+GlN14apm1RLoemVN7QtKLq5Mlw82DzFWDxGUW14hNK31BYD9T2SE+X1OkSzhISxUYySm9MGIE1r8fw6y30u2pkSnrqITY3h53MzezOa14UOp4Qo3qi6PYuMcmvx4MzGx3BgkgqBLb077bPwVLuRbRU7ovF4Tgpx7XSeW4cm/qjUkhiNfYjXnE3jtMYNIw+ui+BpVEU+O0D9l51KScn9MJTZh/3jzuLrCFObyPvn0ePJj0SGxU78mU9U069PJeqFeoGcDGMAP2gN+bm19oSYuH9aO+V7TFIyr8VObQqzqMEtiz28cFSvI4+Sd8nwpeTd2PB8SjQ2VJ37A1mzlln1SZStQETPjt0lu3Msjvy5W2b2z3QE8TihmCjfPC+yw8BhXwJbvhT79yn05IxJfwDd5/dt86QbsOdCz7Ec0HQsVU7fiikEG4QRsaOR91EamiCmWFDWZu7W6a/0SWw6uqd4XyxP9oh4PAlC1b0TQX1+aQPwk0iEICm2DmfDgi6RznjWTJbmlSF/qFsvnAprvnAXwX3esGM9eL8Zhg+35u+qsEIRK1Xf/ASBSrFt/CfqDVEzbFctOkjuFvFfNglgMmGLWHvut9JD324v4y5mcBxXmXM721+4SGIeFEfVHnOj6va+2G23GQn0101cQCfA58m5vPM1fq7TvOUE3lN5YqpikjVBN8ZWoXgFTZcviIG5IY9pPlvUatFNQeBmQVbZG3pTx6QRh42fjJRE1ETmuRf2VfDjcNsZLiBcPf+VhU1gjSerQQLPLb/Xfiu4OWl0ZB1uNegST0hE4fVZzi2UFSUQkabYZtSUMRPqC0aiRSfVNCeMz0rRYbpzfJe+RcI6bhUdpZ73NuDnY/7m+lRopoxiRhs9Ge9WLvGFU+n9VtJpiLT+tYKvj9ZFxEkWBQiiwu2DYFp8u1YlGqSvSngRTVhjrRj9PR+rVY4jrlUPo6tAyfnrkUX6YpD78FB8x+KFMav2sMO+PZ3R/MgIyiSa4DrWqgWhPtYBSRuTvc8S94s7a2Z+1ec3oJ5w4AkQpOn97hJJqMP87joNTkszfa+Z4mXhVY/gqGiwIH988V9RJP2DReR9orFRoVZBTSwaqWqwlUy4dBb7gNyrPm21m+JCWlcwpTPRYxbhszDZEa8GkSEgxYr65Z2+Auie+qOMvAOQDoB0Un6GOO6wc+sPWyq23GqyUWLAYUVBxZtjRoKJykFxf8DfhlQUgccw5E5K8HD4FpzYE/u9nCeAXoR6gGExYJc51X/q2GMSqtr2HiX0M826INynQi54QtiRgBp4e3TWU3bsOvOWAZrzEvUwoBEQIq+8FbANMlXTb/0XfDiT1Jb2ZetNzXCrAUmXl9zxz/YKCNLHXjxVji3h+2KxMkqtDfTTvi1ibBosODa7e+At9PlxLMLEvsjuLbsG+pvWY9sEoAF4yStHT3B1GrXvcNWpN8KFMCIDo81Pmbov9JrRfDZymKikQ+d3wQJ9unGzC6EDVscR92bLUwXcHHH0mguTOUPKOox+YAY/qj6tt6PgM4V+zAYMYltkkWVJMe6b1gdRUG3F68VMTawI9VVOjNWMfxZgX0oZFLXZcY9lKFxlZ7EBibSA19uZIbS8nrv0OgDKYObXYHDCrth741/QwIelAMUvZe/mpjnLHF+K4oakHld0KW5I/nZTiESYpExpuPyfWrWG8MXjYvo7OcxltnBCMqT5aQjOb8eM0WShcnRdTwyWRrwWbZWggLEP4HSUh93uY4G7OIUfmIgWEHQlbtkyoVtNydCjGVhiNOxx5+tz1dmuF6usKoznIBbnza3nR8XhXi2TxxxdF2atzBak8mnHriPD3WzOliepOxv/XiXjdGwXaD6oYM2g9RBNFFX0qjWrJTO5E2dy+aIHSXzrZ4if/4P0CY6n+u/95/VBw7cgOX5YPPlhzRuX1L1GBYh8dAo0xDpSe4gS66+PaBZ9uWCfacAMcpOgcv2Y/ec60KLRqkuTJMzXpYwBJEouGiulqDWXhz+AKfw7nRihh7KF2f460HaoxZ98pTI0XsQhcoSmsD5SRyOmhxDjyPYh6nqyDU64GWdn7ZZ2mcqizQ3Wqt4esoSC/line1DKArt4XGlImZZSc3duhqooHX6Dl5awY3GmQd9eFwBE0iKodKY6PSP0qMSn/cIdbhdt6Lf+7+YPzUKf8tRxEjADXqi4gZW6huL+PlergRA4/XBeSm/0PZM2dF1VXxkNvzR3YYLvky1ScARghiDq5GUxff+gFc9Nfj6bJNg4pW5GgcE+q/r69BmaKscWyLp5OK550HbXQcxuEej+TGAOApBxfvffV8uCAy9D16aoNUZxviUyieXKT/Rz9Yr4+61cFqB2HcYwtLZYaa7F0BTaH16yZXYSj2UyJ0I3fHJ3lbqEKRuKBlHHpP8NMAOYS+3UFA9Qx3sKZeqM7T6oQeNNUdyYzYqVGVsd5Dyd+eftR280ZJ0Er+yq0zI+pK15ho3qqypoZrEjtbQ0l8gZ2uCeSv0t3bLokP67JhtKifISoOdlTnIfAS4TsbfSAVqrJXhGGv+keO3R6740zYNuvyc5fBSJyoAIJtqSyGUsTynq8W6u26cX/MGszV1omCusBZF6qNdfcCD230HWxmvb93qpd9LVCFMCiceN8RD1Q5eQcZK/wTkvTJX4P/N9saeLFc0l8DKiqRulpO3cWypTtDj+wXQClE0EDi3fqYsMD98SL9VGRGcpaJpuRSJhvdcOm0EJ7IUD2MvbjvMS4EASYkbJc9dUlObC2iHPtj8IVl/h+QzNnGbXA10XQWhLuYvrl6DyrfBjHlmgbrT2kktNoCiUid1M55xJeHVVZnFQ/aaF9FzroN16jeOrdwO4mNfQowyaDe/yL7JeVRRJKO2pDt/ZK7bcyR9qAQ5GI2JPn+lsqk70NZ23JYK1a0wnibOm506IbbPkWqDlBIowSEtIunQJJ2GJVneWHkFhxI1qPtjrMxC4iBvkhDl4SJ35e3KX0K4U9V35RntPTRtxydjgF/YzHobIdbQTJuDtHWEeYT36EluGU+aUMUjiZtMz9Lsxl8jPoAjJ0XmaZAQNgimKpWZtDUCecmnsz5HbQeb0ec9Q0/YE7a6cJtVRcB+yMPflU63pxoWoSCYl1Cra6lLmKLZ/EH3JoAmzHh0LjSae+NFky2lR7hyMBs/m+jN0FzILx0hF6QKO76mNHYHKbwYH4KfAK8XlM1ufiKNONU/QyFaax+5J/cpE2tHbQWrk5Qd1dQLYKyfZfbPlglt0CsPFoTKDft6NhbVB6ARixI7Sup9SWkh+EmqhibxxC+ibeO3N1LCvHDUR3O4kgGghvkORhfgY7RAHzraXTtvOAFzgo+vlQOiLDgWYg+0TlarDVUc7CVk0mf1SjVRZaYy86O+3GHBN1qr3gAwaSqWWRDiPPxBENTa4L6DVUzzTND6RJfsvz+bk4DEQ/avzKqjrWbjli1SHAfl06q0ixToP5Gipo1lY3BkjXUH9ud8tCmN2IxMtOu6fXUWpvNhUqplirU80PCi6BvdMXgP5efgORD81T8sbe7Pdw0Z9J9NtERex+tIxpf7vLKieEqeAbQ7OfaC4tky7BghAcQBdKKYk84CF5EUvdxNSMulntWKi8SsZlx+CJaRRb88injhrOpuv9ZIVUqMOs5IzQGTpY1YVATkwAHYskxnMvJ/TJYVVU2lcQ60aWJjg6i1GLpJ+BSTmJ2OBKVMny44+qdbjcJdQtg0hRuZYqQorNH+8hXLN1owbWRcFHy0v8Odzzj4dpIv9i3ds7FZTMklfllzKXl+gKKfbTuxYhCdjXAtJbfbyypbSCPQBz7GSASJ9o0+c9c1ypOYr0KtbSYwLQRro5lObrhpDklgnmzObuU/TgxLNeb7e2xrAiVpukay+pbE6l8980WCOb3YsL0ZGrvJYVY7EJIY91P4xNc9TLAwjKFmayz2Yz6Z0i69GtphBMzsgrPDMwU8evLXR5t4+e16/2WW+5xgn9LUN+O1FE0yaMbPJQWjta0fHClDYXXDJsj3OvZTjuk6hOV9/abG2vbgfvjXJpR4PjpkAios/UKm0wO/mRL6pPU2mV8eXWDftXEdDkrxsONoeOL/wJJC4YKt59fJwDGOQMYpTIBKBXTROqAPMw7ziyMYzwpzMJuNkqEX2MPkje1WVStTLsjzdAfGOrVXxRoGQd7+aGRNfexduvsfwY3SGGOxEcnvOWbb9oiRCfoxEaUkSDYyfrggV49pprBRJ4HZVgFx3mJXHtV11Is+HRczD/BAFMbysbFGvKHBxCGqGU2mCEGA+B2NS7OC+wHuoYWRF9XXO2efl4Rn6AoosXyYA1i7+MtkaXVt5axi563Rvljn2Gt8fr/j4gp+he2MtOoYttLcS/u5ekcjEjO/MhQ7fTs2OqBAZIgAgz2w5AVgHbtXWpw9wqAVmXfW+tNCkxbZ6RGjmAdJ7Z+NKYkTVSP2g7KyoHlj4TTxwqSn59ZEiJ77jqdMfxEfbF51UVpJQvSc7b24ncjU9wYy6iYC0AvPa2rkg3K2KoqsXi7uXpE3ridK09YSk5vwTicWD17LWbZEcL8wU9U+5Xg32ya6j+W3IyZ3H6UDPj86CbC1ga+PhMOC6iaeFVgm2/+G5p2KCkkm6UXjbJl4u7WI3h8TkhKZSBpqmcbIgDiMQ9uUZJBd/1hx/8AMFULFA7mkXfRfiBDPNUQmOP8rk77VpzGhxeOLvEXArt0dDxvD9zcoD5+MzbKZNAh//0lRDhRd6xdqDdw/BIo6ZBt4jULY40DyL0fZzfJ3bV1So3GvkHAU1R/ErFeJhkvYBXZ0UXZXmrTgPxktu6TG0Lc+nfq2QCkWitK1xmDCor8+WOPOSL3kLUKysUlv8t/kP2uaxgXk50cehXp/6gaSDB43YVvLJqDAaFPV8RqoNA5LMLCShVJhUsdyGShqTWwcvEhNHR6exiuUBo7jh413kIK6CMqmUAPxByFYsveHTtP8jTYqbQYNP4q61dh1EBdvCtOQhIbsjUr3vk+hCVpE4syJ4pMHQ3tAZPAI2ouMiEEeXX85cLNCNa/5ur5YZ9VQrVeCzAnBBRZ+cFKTkqUmp6RuLPoCtBs2+lHWEyhw+XK2OJyos2qanExb2sjAwbZzOJVKH+ItDujYNhszG2D1XVSoroYUoz5McGYKlxoeOOubtui46k+je14mBnmlqEVFmQ/xwjXSCXITXv4gdl7ov2oPvjgOFYSRIpyA0Z5i1nRoAOaudQMMUqXA6NdhWlLQNHIhpgdIFTXxvlqOSLThEd7EtqvHEvGILhfAZpFl+t5qBZ22o5AgwpgGACC0VRTdJuNxGTJmducytDPRLoKq1cnR0H+mTOSUE+VA1dyTkEGQgE0YRU+nQV068UXVEx9j32duwYrqFrXdr87yqQbJ+AYdOU8n8baCkjcPpxnOi7qQ7pvMUZox3WsjjClpf0ok6rJf3MxW3FutSowtpaKjJnv4FLEcJk7gDE2xIB8O1A4rEfb8iYSw9g+0cZKYthSWxmvxDh8X8jiTfb3c8Nl/2+yrOberoliTdqFku4cWkfoCvMMKKdK/QpczjkSlVfCgz7y61dUUZQVM4DLeXLJi0ovqMjlsDNUDdhIDuk6VX2nFG5f5CrM6iKVeKb/AnaF+xMJ2MckV/RDe+chzyL/BRdKtbBTsPGC/HygM1knxPzuj+eZ8uMdSV0uE+qU7Wa1puDc9OErVaeI1vwJM4a70aAqkkDMoDcvYd+PmUBgVxa1up9F6/R4N8kaBC+r22JCHvzpgsK1sNs+u+xOEUflYRAdc0Q3iyoehNAfaYJQhOEN6qAaY5DfCmybK83jtS/uCBaIa62qn/cTzVegbM+KbOwhYQPOhsZX8vDK7HCiIdOh1uwdIwpD5mxGIHjT+nvE5u5xbogfzvvybfaDbAjktHPLyoNUocC+qERnSQUykyBsa0qmr05fknY8NOhlh99HqrKlXiRI76akeM5FZdJbaxCJOeDDH+JuXZLZDC7qWpKt9JtEx+cauQIlvkWUkt/rl9JGs/R1TjRl1XBF19dPRaXE1PUtIoqnNzA+Mc49AJeY/Uy8VVGFC1R1VF1k1stew1V6kq1+ozYcFnUo9Hr3esfAjBvkeipdd40f5Uv33btot+LhzAfvaJnnWi8SV7BeQqlZK8FEDQp6ckH9atj0RE1nMHQodH1tCY/HW6vapbFheo1lhfc0y3NaGOHD7wf8+vuS6OHKQYCPWMdE+bgXAXrPfQ4F7EI5nJ4G4cFXS7GcCh6iHjuT7UD/CABIrLUidIHJ+D4QLT7J07OgHchLq1zZv60sgBJq2TS9o09GiaXkTUQBt8uwgKFzj1xUgkQvARo34NDoqHe/059S6npthqJq0cg3zNtfqbgLf9UL9eF74J3/A4mr8BdZUsKjNuFKdlQ4XZyd/hJuCvZwWHSHEtvn2aJ3hyhP7vq9I1VJ1zqx0Vfj4Ab4Wry/X4VzbWL4DN9mUt1p7VIP8xVYt9t6llWd+PaZdonN4pYPbN1Wi9qiFoeKBk511Y4k1axnXnWy+lXLeXVqHvNAZdDXSNMm8oynCoFRPFKUd5Ib4NNIRYtNzEllsaMjmdDKhUHp/fpRi+yeS0+gjfcg+X46xglzqXC4iI8JPNLSBTbXgF25NeLnG1bVGlC6IAPp+s92HjAwzOJiWT/6TJfW2ZfbJ/ooDcWGgBynZ+YA6d61AVwuS42jI7zEn2vxMMJNpiv0Wa4LkVCTOji0ZRfbq2lUSKsGyftTKHHxLIweJgnMID1k+YfT2DTShPt1Z8+myfF6PAt2YKfEvpHEycGZr707qhV4XJHALxaAFMQdp3ZsounmdQJnH1ziwpDPUJdv6da0ApCZ7XY+t/Ok/rOEJo5Sm7jeIZFbtyQQD7xTUU5BZkyOdPkGmRvQARSJr8bexvhx7JCmkEntHjDuIKKM6pdd/wXROE1ZBMMtmWC9piiAIWA7StqM94JU1A6NHt5T5AsZOhFYz1yLSH8yZ9sLu0F77yVBX59KMgWoTM+v5mI4ZRipC16iiSwgQfdvAFuvBhTgipm89n+ctwRtx7eTXVjNHNE4p4RH+BuvQLSe+W/VUkayD/2YZUWYU3pmf6mxsn8r3o7v8g8K1M2/UynPkJvFCB+FCMU3+BMjX+mheNS/9k2mSVy7gLoyOobEQNlmSEZl3F1mmP8rLgbCWoFPZ1XlDnvsekoJ9brp4KOyC3+Oya2JMY0X58myvw2rKn2whoxRH3kTZGR5X5/Wdaq/xEeBKtKaEoNySfu/Nm04bBJmf3rEiBOd7F5pbHkmgsZ7+IT7H5LtnVzUVsVn3oBJAyquqxfKKOvpJoIRgSz4W5L3XudP8XdYcV3gsZoopWConorrL+9g1h8jycJXTSPAHS22MV6GrY7YjmjQRly2awiI3EnmwGjhc8IZrD2qCqSDPn9LDn1rMz7QjSj7pAJD0YqCy48r8pkqxLgMYsQRDxEWyFWLxrPm06OJ4C+p1WqjEudAaMAqdfw6VM1muqkIMDdiUB3tY0NnSLGqnCQjp6gTqDQaBEjQyHRBs7fXI+fry6cm2xzMPO3wHuxfzU31lHCcGNrY9TU9zgTZIoIwwgnhRiqw/A4tiu7+kThtpRr957JOl+bz8pM3nwgT9wzluTKXat/m7cXAvUTaHipXY2YcawaPWO22imGUuPBEbvIanrmS32gMSVLG1Wby28/SzMd/ka8gUamgPn+a7sk7XAIrsyjhdHIPQdnKJrs7GwqQM6RKdvUR2qxLpRUh1lZMxVFBlTT7u3yBCVriOETZMOcYg5AZG9lWsuhBjqyANkNjd1SIR9X7YWn1CYI1gdAZKjnWPsca1KzgrihQ1QvWYTPNueQv9G89wLFsZMrDstFcstUWFxUo0PAd01hY241EgX9yLDvc0vkd2BG47qUJP39unEF7ajBotDZXQlPjF6eWu/veIFoyrkwgO241N7i7VC5MTSkftR3/8v1U+jEEH0WgU33iTdVjzBoNSn3eqoYQcbmkskQSEAsiW/Db6oB6HYJQsy7wi5pMHiOq8PbNoc1mb3nSEJGWHoNngqvX9b1EENSvFDf6mdHP1FxHLHI8T0wCtG5yrs+fSozs7pOx8+GLwqdV79tiqnCctdN3EFhqjlZpDWi6fYUhN7Qpw4CZxzMrriK/cIl/eA42hUwbzfnfmWkkuDfko0lcOq/pZXKl5kdgDKZ3DUSW1t4yWFU2bO/FeJJL2xEReH10YASHVJpe3CgxZ7IGURFyTWzfNu/+/547DTRPvVAVMrL//P6OT8Q7dWD7HW54rbF6q/nM92VUXxd4rkR3ZrPuEAjEx8wVB04NRqldbWt5EiGw4EOrxTH/RrTuWO3c6M3YPvvt/VC07Eoz0PL8ou/1J7Jih0XveYJNSQCaR/CbYSnXwi1pt0eA78wKaCpJ5oEz4BygFqwcbQKiGAgfVdXSsy8gmZoCut1x4Jew9Ip5vVAqevswNSpXEREfOJal5Kb+PQsVx1DtVkGUVhBMBPjboIGqWbiHGA+sMIiKl9kWyAu+t7D8kSxh0D/D/3+6Bwe0UWyA5eVZDiIo6UhRJOoxe2ZNUoANvMBMf9EL+YNule1+118MvyrFX8onf4gHgsaqj/IzMX+PUm9KLYacyvHVoZdm0Q9a6VJrXoeIH5VvvyZ9q//RVtC9ZILjl3OCh5nENjRlU87bLhHWZPHbTJnS+1gZEQaAhSaG6fGD/fl9CKvaWDJhBKm43NbkNOCRftLfAdpWAw2vc7jcRvR101lU93no095ZZ18Yt1g3NnetuH/FTiLCHlJ+pAe4jRNi97hmLgpjorgk4h1E357OYuWHPYqk4UxWriUeGc6jwc3B14A3rLKWDLDHQOzVZDGBPenZAZk/JIth78I1izrvSXX+srOp01EyNLSC4Ff8HPIK6ih55xurLHdQlMD7ZcYyIEecoz/3x29EcAxPjU7v/MQGNw7CVqEeagUNCn1zIWzuqT5nA8qX5/aVqbUv2v9nuPn2jGkCjr0yL9MaRVHNTRWuHPw4HLlCyRjKdELlECRJZORr5i11Sfm2pUt0Dm73MyuvSWvppNETgpPyrRu7SRcysHRE1AMCcEfvQ9WmMkj+qtM6h0mDCI1jR/WqB/UapidEo6MaMJowzvRyGNwL/pXsAopK6LqIl3rhMs3RE+cdbZg5Kja33+1c5sY1Nf+UUyw9DwB/lTRhrW58JXMUgeWJkWX/Oxw5wuo88gFY/HgKWq9Zc3cGhpxCdLxkngRWzpryv6e83/Zu82NoAqyCSJ31wvpup01KHdBY2OxFheM5FxSWENAiWHiYrLfy4WLVaHfK3ZwUPCySOzDg495lvSpsHQA7nEAtEDPeAu2Bhfkqbk94KjQK+9Uj0AlTX5crjOFrz9rFWCoAlimX3YmjUoH6bpifjCxzps35gKU93vURqgnACBvswADQEAvdJr2sOLjyBH9wEnfr7E8mgm0pAuVMPmF3JhXdEPaVEtRmlqAODJvpk/QJ/TxKbL+dYWG+PpAohyzFr4vFBpbj7FZwJv4QS354FQcrMUhVbpSDkO6qqhm23MnhQkEdT7+oEJNtPtwESHRJeiSRhXErwC+Ca9efI/W8yf3Ga+BBKfR3m8M8TZQkrz2tq3vuM8g1W+itmhwrH7JHZlk0xLIL/bib9iDIv41L6EGKZx2teLSU0x9NrWK90rTSDHCtrDN0tXmHoo9OX+nNc4pbx7ZH2jXgDliNifkP9JcwMF2Srw3oyrnMjzkwjrrj5zN7/8CVsPznuqhZx53oSskGvtBknuLgaPOEYAhHapO4MKpTKbTXp2wo+teZ4Nq1Niv9kRdJzU/X/fhjVpI4lFRyylcx8rNG6hPGM4XeXqenU/00vLYUwRlmoeDKWD3rhnaHxIkce1q/7WWg2SDHR1517D4MYDArnZbWHOQ1Vu+UJciEQEk4P+2Ep/3HL0+ciEzrPrZfYslAyHhp89ImhEMU8AJQGcTKeZVC73XRcoe4BvwbjCJG24R3SLXr1QGcv2tZqp3EO/3fWfR1qunMsE7aKX7B4GzhHTLrtFgcOnMWAqefXLzSVaWGQjA8gTvb0ukIMCFM08CXpBNaqejfQm/M74EPYkm4N71vwUk/6SOgxGBY+YFqSh3jalvBtK6DVXSBm7ITnogC43z4gTcGb4zv8HZ0jikSVgtlf/vSyV+zXkiXidnOAmVlFUpC97YjcVzE99jLbC1CJTPfDwYfbPX7+V8z9mHcZTrGOSY0nh7V9Mx8ZG8K5PhrPelm56EBSetJjZl2WDksTyNOMhsSl/GSLnW31UByTqWSISfo9MT0b3xpCazwxT8zalgLPZtWOmOnDecrS3J4fr0ZRLWdWicVa/h+UQhl0amSxxp4ntp2L/q3C02fTGMF6giWz0HypXyKSUwa8QQO5owiLZryxo2BwRnITi7yVMS62ZLCB+L92zzpcDMWsYqSc6GV+9MLSzHOrp/JdH/vxrGRP3u9zlZstNKRtvvvNHincIdVfhDm0meXvfyzXol17lFA3Tw1siCXGDkctq0tcqY7pWpcOqt85qo5pd8+v+M6FVGi+6Kz0hmJEuub8dbcUU/8X039aNR5DeONtVMIOHYUmvZxHLPyjpkrUJ7wq08lEua3DYyJZWmolUF88eI8kpQCRPTYUo6sxKCdnMSip5iJP7Ytk+XHMXBRL9+J34944b5Ai0Y4LSXN9DaefnUcCD1mBeUMKwu1IVccMVNiCIj9vxWE66uB9gkbRKLz4EIkdkYZDymgnNi9PzcsIUUUfZZvAfufAvGlAzaYc9e9j+OBu90zUiTmGObcuhahJuyzuN8+o6d64HwfR5wTMu0/wdBfc6n2vfjW+zEWdf/5CgMnY6jQU5bInzGHPU/ge8bGmVdkL4zFTuO0qXBUyHLz1QSYpOa/8qwxLls7irCT+d0KK2QYV9gx9ijsNVNAA61o3ePlYnbLHbyHvCW7/9PcTWm1w7lshpgvM5XQvlj/CkADY3fVfW3sImMFmVj0CuhfkRWBWuylKqyBlNVbbsIr5vR2yoPXxzcy4x/v9XvOHXdOBLT6YljY5mJrp3+uzyvseq3VYM68bObHVmu+cD8dXA9v+s3icFvmem8P7oDfA+M8LRjm3XIfiY7KS+GRexhAANmCT8oPOlQBa0i0wPf8Ic+njSyJvzqCfKGGQaq0gdHPSgCTxoUHi9h0lSpS+JoewoTqeMoODnt7xskRivJNZxg73J5EGxNY+OUSJnZRiMEyrsLQte4PR6fda3MlV2Q5Goh8QGfB0eCoee7Lz126yFtocdIjlrqFThYvbY/JQmdW8x2L1fkJmz8gSvtCvhIrjm/K+nDMreH0/q+0AyH8kED5sWLDLYJnBh0Im/F8spdnW7dw+7wYcmEKoifux4MSnLwbKfy5eJcEJgqSCd/rt4tYgRIQ8WaoBTra5uDWPOv95uDGcUfHPQZkK9Dgx7f5KFoiXsHnZN7mxIwIXdQLgrdjhMaILHt6zi5X281Sn2rUrMWY+2Oindhn/eWIGiyM3zPYHn+74NMrH5Xg+m93WUKF8TggJPWS/SStgVSzCqlNEoFZjGeRA17a7EUBwJpLUT7goa36k+SU1yzS2TpR9BTo6DY0Za9tPjWMAPHolDokxUwgrtxgB+EPFSAoyDmExLaStd7iN9mNsQb4ryxf4D+pt3vlm+NTQQdaY3skkoald1hRilwCLEsEK7ITl/oI+x2NRnpl4Z7bZRAMMmuUrW2HbITFiYUWlRZm7c88AoRjb7aEwgV20IO/q5HbEe/SPzin/CNhsog8XVuuBantPhRIi2XrC1CTH72ftMVSPmVz8hxWWWwLPfdkx3EtdQBVANxC6NiLhRqmc00cTO7m0O7Rg8+e0FV4c2g62lxeq5V67xL1PqquA4y1meeKKNkLCyKeYbCiklwS8J1ijCf9dwdeKmiuCvbpyNC3Kdcqp/JbUH+pn7FmMDO9da65xRl368ipB7jFrIgZZGHlDnkaE6d6UntqKdQ4GZUSHb0vjOjRRD8mO/7rCx5u+0eHhasaedp80l3CRUIyW/6PeYCNvGhK4tdRiv9eKSyvzPytIaD6ZBTTF5ib2w7Ff+zs+8ilkNxPGhiPZMCV/H6fNK0n05VfcHKdszHjaNaNxVGBjJklGsN0EjEYD2JW706qrYXVFgOOxYx7dLmmQcLiNYaNO/zMKeTsVTmhHCmr9xOENkJgmuA63hDTWTd2UWbHMkil2PxJpz0eq7mn8VffTQ/zWK5YGyGQeKn18ItniccLN5jQq4XPGGGgXXLPVYXsk6DTPNBxZguKVP/EpeYiSCXZMmJQHYm0g4pZ2aSEhTCCI33PIUKfwwiWkW4JUjkLUYa7SJ7RHcBROPmTcQOTsTAMcfi3g67KvIyZTuiZ2F61zUFr5HAnnnf91zHpR2f4RRcxc7NABhu2Lmb/xtf4hWaNdFm5ZfKhMd/rxfbpFt4mD4mSCEwAcYpnOd4vsX7bo0hNrFAFQEU7GH6VFA2RzjOuBWOjPtsj/DBR+7V+jbEiANJMDc4pc0Hxp8SJgFf1zFf2EWecTSXNLGwUDFKQx379PwJ1RDgj9EbwRPhbocmXqwRvpUvoqd+hYgEjuPYjyRcY13s0B7Eka2KT0buYlGbpfSvb2ADgwDR0J0pQngpKM+aHULPOh0zPYhSuPqaMynURTHoFo3VwGIEuFlTVIH85E0avasKjgwiT2/eGKh6Rh1sgUzLMBGyBn7etKIT7ASA0TEnxhWdn5HgIny8ZzIem8lYokgqHkdM8DTrBdfKco532Aazg0pzSqjtW3d8nVdnFh/KnFv2/3ZhQEWx+xV+r+s9wLwc9ZLgGo1xqc/pgy/6b+a+m0zojp/5FNUCnqUiXGW9r4IN8CGQS8c4UwMBZDsuS0qM285z9RL1zu54FwfD6p5dyQpWSybTBtnCCJ/E7ic+j/Ly/fRAGzGAs19zv2ZCMQZdpHrg5AuM5XcCvdYeom2IkOb8YKxRgPgAOW6kcLa9xyS7sVfJJa3XBCKveXdWXLDFFSHvIGe6/O9F36p1Sksgkp2qXnd89sDhgHdN0cVezkj7AYWQoWLWxiS/UNQJCmoP6onYg3NwbGT0r/Frvqoa1+cvUyYJ5S0WNhUjGAKKk1Nj9FK5DbhQzZADK1CN+VmAYYjHk1BW6y9wsxFCe11ZHLwSPpqpC8uD9Dw61j7AWbXi7XmXKjveR+MuxJE7BDvSrPaMnqPO8kYmf6U8CFIoVLQTeR3II7oTAqeuE/nanTQO5WxTDTXXvMan3lt+la4kaGLypxOqOXMH4wKGQsErVonSYUXhRAnPFVAryh1nAmTWLvYQ2T40NPEzj84EQEaO3exol0hdIOzyg090pD6XJdKQef+CM8AFizg68ONQHtgrG7eVvbyvpZvTrTg2ZV5e1c9gqVretIwYj8hLHuMPDKv+boeo4k+FqJIviRtTZiPVi7ljt/YPI2snM0V/ZQon/Dy/raOK8aW489aIDukiGdK6EoINDiZyoMbY5t2T7U1DYeVXdlpzQa5zdw2BkVflU6DG0FMZ6SwA9XF3RHF+FsHbbRASmME4Ap5fXpMZgfBtrXNtfAk4wMZepv5F0fj39SIXYqzuwrR8h0L8f6qXB6rEkNndd8HtVI76NJv+/k9LjVLGE1ivHiRg1KbZgUT4xIJa5KxhDeyMmB3+QDlM369iCrrxgL8tYw+Y/9uyc9Uf5eOb7tAE9p2jWC/MF9Mz6oq6HxpP5a9aOJzhLiK7noULNy/I/PFqAEC7dvlDzk8Xy593dyWkX0wRm669JAWLpm5SySoIaRz4t2YSdExAPk4tCZuRvrF7iSjKc22loFm8I7XfmAbxqjZaIfi7vD9aKgRT6R8SLwuhuKj1l3BSipsRw04uX3eFGDlChEp8MbaMmK80skAgwGyXlIr73apKLTPvRCvOEagaFa1QasMmQnYI9g4ZQwbOzJqicPg/9EUJT8AMv1FQ5IBYtno5EcgRNp8SX5Zf/KzdjGAfPySWjCY4uJI3q/tfKy9JLP+GaadCMxm80P7bQKGy/Baoui2mvjGkH3UYIww+Gr8Z/ycl3lehARmxiLcE+L7DBVcxlv6igl9EebawCQPvm0S/EaVtQSMzC+BxeHCLTf6LzN3i/6wTMqqwHurr9xv7y3AjccnuS+Tzs1vKRL4IaKtxbn8HSPAs6mgzbejMw0yjW+xApvrhgkgAmBG2PIVXf3jzAECrMDrO3Vtl/FK43RsoxhCn03ojsm/ZhwEAGga1ylUkEEc0P3wPW2h78qn7zPbT3eVN0ciimYpM5IhHKv8T7d9tH1+Qif6gf0DKsQaZQJ6EMyPZcGOTfit5CKrXYDi0mw3RHkfavBR6S7cAR/PrgtFtZ7kfa9f+YNqF1yadgg6/ld1RUrPvRrMXmSIXIcLwyDqeGDHL0s5A9q2gtxUfmnGOw2eB1rIssb4hRv2mIWFGbqVzL5Cct7jE2cl850wED5ATgJS360nzppREljTjp+vOQjwH/HZGPMWHjet5eZD6OaVkeP7bB2sFVMtVVZYZjOzIaYQXElVbP7DVnWmBL0gVThwS3VdSpt5EXdhREw6F5QxkRN4/8tdxAmrzn3NAnDMrxhZHIXNofVYqaT+ruQ0qCS4y2f/GW9V53Ee/0b/ml43sn7RvbmsU4YzgvdR+ZDII+oyDc/StGMbhHidRFsYoXzjwa+28/oNeN1C6Px88R/VjTE8Eu+xZco8mL4JXxdvG+etCKpCsw+InL93iuOAaixHhSMYR1TlbOWggIu5zdW5wCm27qD+KAtZFko0jZC8JsZ/4aD+EOROPNkmrjPyfU3GqiHEs111nHyrpdpsTEkBqMzDuAbpOXsqLKUFuETAxoirZyu+N/XGshM+iDbJhumXQV0eqN+oXEz6aFpnZfnJ88DEbPkfDyGkgD9Oe7mbNBWJnGIpYq30NFHj+/+hf7vOc5A9xj9NYmtLBBu5FRI4maXgJtDtEIM+I3xaAGjKQH+5p91JmfjoQ+FhsFYDPCeAZ5+791Uquz6/XTT5t9yeyIpnhp2zIMCVTj9HUUktMXPjRU4iI/RABQeUqtE5+p9reO6sFByKJW790H6WUVDK+yFMSdbxlfow3dh2LlywgyyAwfqUvEThL8/8L0ArUTByBLVxr7ayT51XeFQ4OiWe5dc4uTK5uAEnuj8jdPjiJbEizQR2RGDXJ/PbBnEukbX0rdE0n3HzeO2aLGi2ve5CmcmQKCmlIW4HpZzCdAvQDVa4zmhj1tv4R2s3Kroa0WCfAWgNs3g08Q8+Tkq/viRhqmvGCTW69DAgssmlS4uf/qsUQBwwA4dsGgqZtmFWHDYabn1akuxGPfY7/2Xcwpx383Bl5tQ2WvaCzJGvkMdczMcFkz6/ocvIdR6lvlIA0ro4PNvRWDT8re3FybQ9wK09j4dOA0VWdP7kEJJhj12+n7ga4KTQ98AtoS5qlFpMYF0W+M5Z2eH65OsXEkJ0sXBZZrVpu+nA+IXgVp1f4/ZoUxj+bTCS9U8wp2LoSHFi2SQbuITVU475eOF/h+5kvIH14w1rb+h+gBC4J8v3bqaMgvhvBAy1lu9AFiEgPnwEUrb2+DHGtqCs/oa/eYGwBz3MbSr3N9UrXgNqPKWKKre31tE7Fk4QJmZl7HP6F+Ep5sIl9JL0fczQ1VcYxFwsaqaBRSqGVIiKR8lAJGko1rUkDXmu3Fx47YKuJc9vSx1hy8DBO7hu73v9Ss1a2lzJ5XkE/3DLd8sNu+MIglimEFHRwZc7niB7HCH6IDlVGsdlQN/uOeZdee54bPMx9zjo8xcwlINjvdAe2smL0i6/mKayYjiHC2WVvmS/K6y4adCMvOy0+l416U7rNQnd2eVpGhXBa8cBJmiHozdcsTwcAc1QaX+VhMdDRmrY57R9i8hMs0ANTSkxANw5aFx+ExiJD+ab4HFZg6AeoC3O51Q8jjJ1o064kCyUbu3bOROIgJw9Ywg1+CE6UGtZJqKJa1+MD0MwkkvZqslNZazqzo9XrP/42EPYkWE0IvawX2GHrkmDfp+7CR2npJaSPxQSYCvzzHRT0YmeX4jdJcfv2Ds6fDkwmRZRUR6LYMqVvP9cHVpZG2VF1xZsgh27xSQIKaV3EcunE8AvB5UbLg0as68WC+Zu+nWGz9N5WOKUN7qdcmR1sk1Q3N1CppDez0555g62cZIETjki39gmqCRR+ECZKo/B4VjQAb+y09dY8A/QFytGQYK66f2xQWDDJjqxhtiBQCvB/St5w322OTIKK/Y7NPCC9dW+evT2GLQofsXm5PAjfYap4TqLcLdkYB91ZbTQ0Kfdm4GrN7JbvPQweWjjtbFB8TKw7EG2ichc8tjGpqSadCNGi4djtKY3H4ks1VAIvWDA1OWlDvGjHGfr0Ir+5l5AM3GoSUqCcz7UTmtwWqXD43uO5Z27vL4HyoFvBNenA24hGe7QPoFer16YzphatdGuO5+xIzhkyaNmaucsyhJmTIfF94fJL/z6Ipv9FKV6D9/Mfh1MviZb6tLr3XHSTUUf0HeGbyaT/J3JQOjerX+2M8Sc9okredq8AH0v+jCz9GMcm9gtpAsuAkaveGyErclMyoBtX0imYMZ+J7Qwq+kbj9pnqsYgdh2Ai0jNaQNAOVTRcs+FJIzArc+VifngjycbsruJHjZj75gQ6Lcce5cCSKp0AHtIe7NjfdQQ4Zp8UWWD4JgJ2//GMykS1ceiBHC2vK4TaJCXZprx+b5oMNJkq0P5Uxio7hvhibeUNV3xuMgIg5t9/byp3cHuyywX8i6VOVlJHfc3UzammGxb/+JqwjzdWNCOAC4HL7UFXZP3uwVNQ3IWOzjaDjBjgvQH/QgCcdcGjFNRatYzdJJGuJVfigXwWUrexW4xU1Da33mQPLMQ+9KAZybMLGUs8Gmqk68rI8MLEX+Q21/BAinsZs5M732nVNuux0buyPQvtPtDg6gd7W90fxWx2e60kcs8zl51IekfYN2Bj/lIt35hv7pgonFnl4RZ/AvzVdzz+YHOtuNpt4xGFYMey2WKZ1IhTSPY4ck7Y8O1RynXZNfmA00oPs7k9qJOASg7ThMs1OcCQppo0L8n+xcmLfByriPlGWXmuT1e9IOmtknaIBENsy7PcckAudFCxBkxxqcXCDMC/P7W416NVm49pOoJqgWCMyk+70AaQ7cr7vfiD3N+aREAKAs0P16xHr383AnjJdSPkay8L4PXlJAkOYjbxg7FguI8XYTMpNzKu6zJ3/lTuzlSLzrqV8Atf6bHzuby6ksf5FVNulrCA2X/kEUcIJ7PfG2dbDm8hX519MAsi5wH8kffiS2Vtd+czb/H/54w/I36Cnm6hODHIoSznsU5XrXCNQxG8rQjomdLtSupLv+Bdhb4JbEIMqpfzXOpkXhalKg49Ccuc7N57pLx2YFo5IBQTpnHj2OSYrCsAauVF/af70H1dmNaI6gYJB9ADQylBkKzVkduBbSb03hx6UP1TTXSpSuUAb7LXCiJniqrgj1JkPY41S7Jx1it7Tkpto9C1aaMWnngqhf/2mxAhqEx4k9jmCNo9nlEavaZ5K9C/EcBe6AMShTccYfs6Frkx1r/ifWcowO/4270sSzWfMn0yw/VMnVf5wnK17XVw6ctS/GKQRArR2sNZyqiVH1zNWtyhMGw1xFMOcM/BD+LoMgVgBB6R8I8MlYnzEhPRYMDj9xCkhMCjZ8dggI09RptMTV6eSWKpu/+vqn2gnLXay2eVkAfjQJjqC4HMH2xP6GFiqXKYnimfsRxnmpbfMDMaGcSET/TD5O9lbZJszkRpUQHmazT6v2dRZujoeo1PVvhcT4PIvWog2btLaVrB+UCAK59Q+rdY7sOJla68uiGcJ5Fpk1jPzumotq4RmU1a1p2p7cXQB646g3ELFnx5TmuqRcSqW8YftEwEvsw6j2wbWLGPk/3GMT8froRUX2OsbF1JCZEfzVr3hpr6ZQ8ePHo/rOZuwM8OHO02qeIF3uBU+AbyevLuIeZ3A9md6n3eepCpd3CJJOzvcFiuZ9jKw1vvhTl5FT7kojsME27nRigRRoNUqGoqVsArz9wDX/TMhV1eeNH55g5xGndyDr1xf0nBxPjaeIQRxErLGyl5VXgBV4hExBnGOk3NG4i31BlcDu3REJhB7PGF5Z1NYB4DWf8ssDE54QpZnryeUbcXEKqoSY9gaOE7pykUUB2ACcwMoWPILMz7IeY3wLUVvgdluYjqMUV3eDGxqq1xtpEvEWt4MhWNpK9XO8usT/l5LT6Y/wtPmKzluaLgH1ndp+vRiKYruyJp0I1iDSQSrVLDSJZhjX8f+XVXwNV8nj7ugaRdd/XCzzkyAvuia9ncpYuelgunJI5qRRZHPUOBkKn3bV93FRQMj7m7mxokJLgLBlpD8/AGwLfiuyZMIEo840iT2TdsJ0z87ovygYfTEk3Eh6hn6PZO/wyXhyBBvl13L67j34EuBO6XzaTMurgK3Wz/tvQx5ZexiPqoQ7GX6Fi9n04OxFFsMoIPa3hYEt5FBYjfXATzXKYLRnc1UZiuxEcB5RQVUlB4Fl54N4UyKPGtYd+0YUq95V/VOTfH/JqIGnr1SN6LrpDw3CVfEcZkin5EpGrXOkKLPym22dBydJ2qDCKIoKuv0CLKZbwH/n8t7nubVK9ThwHtomJDOqIG7UCl6wHVLppWybGCc2+zc9Yv4s/uGdNipF5X5KRW70pYza5pP8bg4iGwhGMEGgJb0sCRGEzHQ/7voWdw8uypkbXRaXSc/VrF08N8mr/PFrKONnNInnUB55Uf6Igo9SPQWLDS5uBvzCZSubr55z2i5WcL23m0iHGt8wMUKWW6Qqjph/iaCsCFr4e6C0fIiwdDP7F0xJpuOrxe7OsayQenT0MTsVAVDhvpACwKqB06pkZKJCItKrZmDlUGDrLKZyTOuMIUGmeXmzm9Hn7qhgmN02q3rrmby7ZXqZY3yjI2osdbD2aB6/+bnzXoNnya2YfjQhYObaba7a32zjiOybaoWeRgq66wusmA/KeqNG8trb2rei7UJ+crbUHdySUsiDbobXeTWDbN5CD+ZzD8WjtcaPgd4KHu5Kh7cN/huXZyi2GkWJT62JWcv97FNESHdyS7ShhK4pek6wun29goAFUVqVgoedoYniaQiLPAqbjgpVGANZgRkOiRzNnDKUxMZi0X+bG40T0HuLGM4/Y8MF49m9sVGLLU/JRjiehI+8wYhmh5CqXvpmJc6EEsi3GTFzNHLy+3GQtLcVd5MgibQsND43byZfABznOR/rblF5oeYKCQnvq1hdsZZabVeHUShLCXSFa5lthjulqoAcfnMjb+Lc4aCNvsRHeSEw+XA520IXIsDFidjBV24dqRFmKS3qgaEROvQB6F58e7cQCnrueiZR/xvt3E3yVW6oAelgcTtYrMrWBgEq25FEigZ/RrdCFaS+MBdXbLIwnQTsxyL6mdAD7XYxqHKIThJQ3DOAgQKzL2/qWKW8b5pMQPneR8q495TCdIFNOJR3/6VOKTDqm6flbls9p8BsX3yE0aNwF/wNL8js0+LvXo9wrBLTH8xaQjzoZLBYbwRgrzBbp63oz5rXA3JUHuOtzD5U8ynd/KcY/WAleLmjvdHuexOUd28aZCB76b2nsvvbcNAAQd/axqQfJKneTN9Fb27oMNDjppo+GfRRaOf/sa2y3IGXDp2aGWbiOOvDqOXAdHvxGchFFObRoz1vBhtIzLgyqJiOvKYIkPXXN5wmTj9Cq2PBPOUM5sg8P681b1CjZsdXQdPGS+Euw1MhqSWh3JFSidlVQh78TBlpyGsLaBdQjdo8Fp0F4NgByB09YzqxuYVXQBCyJDpnh6rTXUlLedOHiBgTplJIUk3tSE+fdrmIYt8+u0UWlGkOjBdQMg8zkjamQ6hSz9G0Jq4qEWfnGx16UcpD8Tas+vnHR5T4UVFdDgVDUqBP9aLujdxAWf8kXvVDFczCcXHh/+391fICIlmTXDxt7pmzzBaphJoSObt5ONnG/c4mMt4Y8Oe0JZ9euj0F7njZOeofrrkuCtXlE70xZ///Fi0un8jEzHu7eaSw2nh0UGMZtv+u6snyGYEnhCCH57e0LCy4khqrA5SjH4BUchCx5DWh4xOypVwJxoBRbq6CiM6qxnYX/HMleTVE3KYALsqXwWEe976zzScHokmss+tuYAvUMP5B/BPzhxK431OYr+izSTvFyA3KA9S3r+tv7rsT5zijy/Kt1OmoVpRrsRAemrOM497WjYLEAKtRQiKaWPTiwwb/1206AZix9ds1CXMfqpj9qaVdz9h3M7zplIivGnpsGEIiU6Al7r4QYl4e+AtyBr8eDnulxbGGaaDfYkgEP8G6SRXz4Pt6bLyyQ6exRD7ak4aDeygTvVZfG9iHGTnBK1AwF1Uni4E0XVlCjfMZs9YPEXpZKlYPk+nMYf3V70p5wBpB+/jn9EpaPZUYUuO9UN9Hi0U1xE7sWbqcEJ9DREbyffkGj3XvXMKUlfZdZwrYHYkMxaR72Z6JklpVXTvmXdfbIeI5KlFQ+VOVRi+Eugv+WhyaFHU7RE1TOC5ZHgq8uLigWonMJKgnDjO6hwKuE80DgEVZt8R1klFeyb1bYC3e36x+ZlBsGweb1gkuolizYUgMmTyweN8kXoeCX4IHvaDgm9xNk9YMws8rwNndRGiC46Ja5GR2bDlr4NKxsFupsItvwF+ZsLawmC92qzPzqUUwhb9mv5lNZnlDZGK7/hYDCsK/vsninsNz3PWiqSc82qsxTa+KkbLVszBK2fwWGGzNTqklXtzq34adEoFlMTj0VYq1WTyWMvZilcrR3jVb0QTuDQuX4FsQeDYV1In5Pap0+POM/pbV+sUuDEl3mS2SWjkUpQKFr4CkKWSsR7GQTnjYwRJAEIXH0Q208aZFM1SAveOREGp375qlfMKOycJTZZ9wv6OyWC64jNEkk/GfU3nIE61D9sieiDuK5mdRgEvWiz+buDEs0G+eWwVF2l383vI1lbXOPuK4OG9Mlh25AgfF3jRluoN/8GhIkzMBmOpHNDi8NVm2dUjD8DkvvFoPGd+AyTrqedJODFRcA6QVRbZhjwTGoETs/MZE1kVjZz5Epi/mFY6AXRLuF1D+0tka6xP55lB1/FwSZVo4zXXTubA1s36ghXvR+Q+lYXwkltLuSj1XbjDQKA9vk8dJB9hyqb/c6ZIvTV2NKNHnWMNjdzwTORrtUhKOAn8BLG9x9Fc6esCC/yh+0kOU+K1PUYidWqpHoX8kq+QzsONm9EPJt+RnQMweAe29ztnogTx0XS8MHCgloPlNIAvnurNcWwQjd0lsUmWkQc9OXCkIz7XXpDnSthrsbXK8Fn9rRDlaLLBSWKm9ju8KWVuTg3aEONmbj5+rCH7z1IKdkI5ADh6jsf84epJZnFbp4gDpsC0wnX7jVadRADSuyqgm1fVAVgwOHWnfptkrKcgf1fLHz3VpZyZ5n8HZjpXfkgvnBirmTBcv5xSAGvsb1tMCUonduOy92LSdV7y/oAOLo9NyRusSP52Qi0QFCyJ4uL59EayyFIn7R0RFB0ZbJb+61of9uye1hbb7QrtZs+ItkqgxciXPp7xnBIDmq1lC81isYqliAXzC9iN0YGT+B4D2qV3kuMmIwAWJjoKW7CFcA5hWxQkIU8jc+Kd3cIniqmkgTtd1sJlHaBcVjf4OBqG17QMWG2/oivEBCfvMSMXaTa3+KnGjuuwzgV0IbZXnlGvNjnM+I2PeKOhu43y1ZaelvPEQXL33UAolOuNTEH8wuuGM943BkzCeF6hBIIDXN/qoGMLyvKB/tLjaLaMVhGS3XH8ap3CRmkxkRrY+iweiBsM3XERsPLRab0IGnOPrSskcOhI4BngQ+A0hDDiMHRT5qI9U/WGgHOe38LOdq4WyRDfR7S4upyfCjdWSEwGfD4qICBJ3HTBESD1YGvsQGTSz3PmToklQvrBYKEZmG93R5v254g4N0RtHo5SkU21ljAuxayQop+eNgjnLkLIfZ+MYJBKUqyB1DzfF2gIBQMFwzijeh3VqV0VKdrdGrYOYo1QvOk5liknTiTVHGbhHL5a6ZwoJ6BDmG4ruck9lTB1JhfpKGXCtcqKr1ZIPAOnbZZSWyQGb8xgqbV+R/aKvLYQsmJQYJiOWTzPA+MNYaoGYmNBKPLrvff3wKealwazZL4AdRV5Z8pfmsoKmlRvV/+nSnEKyHSqhXC1b2nUprltf2oUqlaySkEaYsMRJ23K/fUBjdtPz4B44WbmsbbvmvHTppaK6QeOzQzb+fIplZBNO6XLiZvvT9Ll8Ouzx1gIN3oxbD0Tc69pyTOia7eQjycrf0v2xNHyfpL7UNpfDfqQyXq8RzWBB4t0oNDNAQu7uvYcZCQzezpi9oBeGhJ9Gwl4cyUmme12pMo7WljkNlyAyqfZw0ApjJJcOqWUlaB1KfMPBpIgF4lMuMB2L7YIhj/lNu215UBU7Z6FiFeCCoYJaiCmSN56irCht6lkyQgGBpNj0dc3cOFuARzWH/1QRF7PoYww9t9fPFVuDQRcAuB+pUTbRjOA1e/4JzVLKdqYaBJ525bHgjDHKFRf+3/Bvpf85GwLCauHmqwxEgvzitk9lG0DU3+iDRQhDwW6etxTF8/au4Fv7VwNIlNfr2lOSMS7X3EDxutvRdTPVvGaY+8KmaUJdoZ/tMFRmkgTxYHuGokU9tT8gdnHX/5BenGTJ5tlS050WcJgeXFGXjK2IKFoyXTmA7HzK2EyK1hgPoZBVAHRxTAJoWph6fDuWH29H9eCY+2zBxqG9BeU5a5Mg5Lxn+cM5R4KP6vHYTSQ+CBQ7BquXWYl4R0WQmCumLVMeDg8uk3JTUyy4y3U/+sSZumy/4s0szb8qz4xZEoKcXaE/T5J5KD7ijT7nlQGVq+/jBcF6FcB/fVYf2H97zNvJESxOTPxNe+RKenv/quw+YIc1GlFsdUjKvTLIVCqVPzY+7UgXphqNE3EGsGd7b0IPjA8TMcQ8zyHEhKz8LKjuRdJwUQw/P2Ojghh8dourwgesn250ikuFm9aVwsCZg2zJDjcUiSUgtdQncvG1nmwonIgc4yjqAPCzA8IEZyMdM/enRNzE5L0LBBNqK2BFdyhBHXCJNEutCzzc5Ox9bnC/1Z4Rc4qN+YAcLkGtCv0hRO120lN6DhvUvtY5EqRYchzErkiXMUTAoSM4S4Lj1oGuqBc7RJALAPsppT0dKohGeHJfsXwDojYzmeKh+UK62WY2ZRJ0JdsFoWmyPQkNP91gz6yBG7anEzYZzh7hol20XRiNLLzwbcK6XVRws+aKuAsr/n8u7PSCVvOL5mwSDNEVRact/F4S3PW7CJsX3kju7wR6++WXfDK9zkqVQvFQmzzJAyTiv11FIf70vvL1Fk0Uef5hjDVwtpFe0fuXc1x88Uu6Gm0wHieHS2jm20HhzchFYk4urg1+TMFg513rIU4IojPqMHwYT9B70cRxT2B37EbBDD55rf4koZMg92u65UdLrxOhPPWcUV8adJwq323ecsyXPmbOi36YzDlny+bAAe4hrCBUSP0OGCsyI4TOSb0hF16e9BouIvpUbKVBcWuf72r4MRAMOpzQXal0UnuF0ppdblQPL9zATa6lUmnyquJmUvND0UlYdWtAz0/2wK18HNb/JTRpJrWG1fb7tX8Ge+8ACH1kxVe65wnfH9DLZonRTgJEYTJnr2dPIl9ljIcQu+QATtAQz0kE/XjtiZgdfpB4wTD2XjEWNTpRk+vlezweFF+00EBgIW985z+L6XFYVv+S2QwZFu/Wtn2wR20BnV+++oaBNxEh/Ew7s1E4DQutXq+SyencSMnFCCbuviunO6PiHLly2K6HU2IcDhH7Bixji849236YHOweUsi7gPteFOn7niV+DH1mw+IZb0BPhWh1Oqu+u70XT0EmCNutLE1RyM39kgFcjHzRv4doMFZPqmiQne/pwqPMfkBGwqyez8N6xTW7ozoaXbMKQQTNS67XG6rn+AR0mtSGuwtEj4A1CvkS1ZKIFR835oLkm16p18o668fSgB063LQMLyCmdtOMxC7fsrpV7L/wvAaZymrVtZ0Oak7CwXXp1dEzHMIcymZWiDaD97aaegFQV2DmZnl61kGDoeiSOjAz54rDamCLmw7GeEaZ4ZQmtoueQDm6KlXARXONXSfE4dS6hIuKJR1oTN1hyjiAEA7uAyLQGUI+h0fzOlim++jqCqgCdIgirC0YrPzf5eOqCtzQcoW6R6BFlpwWTZkiWcUqTyJ+Pea9MQPKjgBqi7M789N5DTMmYiP1FDjgCvjdUw5HvIT0B/P4XOE2qlamx9wKoFu1j5Ct2F6ieBrLP2qiWh9ZJ4bG5IiVZ8ZbHFIb4ozv0SB97aFw/89eETBSRJOXqJA05IkQyCtEg1nqQ+fAmolkWSDYi1MpZOy6RZdKPqNaonoZ2DLvMRKhfMS4xCMDV1M2xJQnlqg6qDulny/rdJimYh7bamK8QrnqtIzWi3o74geyw6iBdX8aBDWKwbBgsKllQCTQI/c1pCjkQd9j8Ag7y+D6h3z97eKZyYsz4KwH2J1F7KTpVENJIlFSdM4C1Fov2onnHWulwVcaqAiIw9YQRpXeekeIMkOl06cOVh4BRMuhfUnuv+TwJZEFyGsL//HTgyWOyAs2b/4oIxCBz7Nix7TuWpjw2bx28sdHZMHdb/SA01Cs5f/47C1ttI8XYOtdPPwN6fWEXc3BehHBZidRrwNfhj6emC31m+5BVzphcWzwbgZWHVJtX+PBBQ8Awstm+91sNqlSWNpkAF/Hz8UGJdvywIHBsYWP9fabwAmj6wm9nANtSQTNlYpk3gIYBGXEsdjs5dHrDJIWzEYQheUtutfllvoWexVfzSBJ4hn/bSnSb3XKwWn/FB+5gt+phXkDqCLZxyW5saWWtrH3PCZmagPNKw5XmeSwS0rmL5Ba6D0AJ3feodoUWp7SzhSZTc7etNb3VTSAXENk8Fu8GYzI6bdASzzFoBYDm9XPZPX0rZrDeaKhtNTYACcn61jHGtctyGdLqRBTkWqqabglC72uF47t8XjEc7BbCtMx1XlUK3yqBpNvKPt0nWz9BaDTv6DuMoK+R4hmXI9hRpPxzjx+jJAJoaYvfTu1sYWzC4e6Zw1DnsxxkmUNa7D3NNqoeFl/CxRMxDP+ziZzFv6iQ0ly8OYKU/HpWEIQ0x3Luk+5lWBdviZz+skt3XtC18HZkzYUNi+YZF8em4dD1DpXgO6UttkbHqSDgZyIO9+KzUMAkZjfEbsr+xOtD++AZxuJC6d3lSGZbpmlTMmS3ICWq66Q5Wej3d2J/IGc/dcxw9XGR4j2wc3nlrJxsl/8kBLwk5qYq4S6x+Aahfp2d62jRImKAP7XKkLVaJGg5zyr3M6DCwzP5lLloxlVPSXBxw/Ln8mkhL4kbf9mixog6TUT/ivPP7IoYVLmgZC4+5wKGEApYmyQjeEfkXBg5+C/pq17OUSebxToIYDGZ1OI9E17R0EAPo/cTd1L1H5nbZeh+HbQuHwYyLx/M11NtL7fMknbW7A/IPnzXo57tNwhKzmIt+UQg8FKO+YJSLY9gOV2LxTpZNTS7/iWKyVTqUhbqND87l1YDgtPJHNaZLhLmUTX9yKXwyC9OlWE1BnvrJEQuwW4MDhLu4R19AFRHOIKdJh/8rQFnFQukTRailEPb6yskqVZmyBsfxEwGO6SQnwfbIVJzs2AZxzG5spmEEgL55VUTV8n7PuzaBqAaS3ni4j3CxBsm28+e3P+SC8rHQy7AnbvwDO/iCvYZngR+nSJchpYniR1e+7u13IFHk7X14IwlQ5C+qI4ekYu5dDLt0nEmNoZmUT3P17dkpPSb4t9n0gAk+nS8ehI+svilw2AYVigvjidnl5GE3XPpvjLuDSuKTksu52Pf8aCBD3o7kxTayhXsObTxv7+I5/dS3/Lk+rrH9ZDygm+S568EVUIaMWTDNiamHshTR3pVk5+GJ2eaKlp6HIzc/mf+U6KKgiCN0WQEcyL/LDPnaMG1WBoBBXUpJVAm0hshPXaQBaqEAhpU9tpLEXUichml7ZcX8NB/QF7iW+9fy/+8qtRj0NgBB/lzuIzqYONI5U2JBTOgIrzMZ9nyOlyw/7SeQYaHtzgs7tHcOcvMJnO763rRfsmHO9INscpm8w9WsDn5ohraQmScks3TdmFXbRqgfoUin0VWHyMlV/eqoB3dpHGcJ/nJRycmc0zwvZb8P5xjs7Luf0EKTA+pLty1P7bvwdXDIyU48IPk5CsAB4ZG3Z0w8RWu42Ds6R9SUm56CWXQhPYIYO96E7EVfOUjUB8SlIcQh0we+awlRGT+tJl+85WPXHS84/Iz5X7z1Z+a1VaITDvpV/hSsHZ3U9oOPKR1TWIM46wNJr9HzVS/45ZjH4BBfzW/jutN2je87rS/U23gCUSKWe41wzqX5VcApha7snW8YCarazn4JRGABzBJhOHimiQrtsq2Z5m9SNF/pFb9WcYYyyWz2Ebs6bvyzsaNVU1c5p5RS9HbqulnWyyZzybqnssmc+zhjA3DL1nvcIeukfEB+/gFqageKuQjwOhH3Wd1HxrzFa5SD4Dcj1vgmzax3bwQ1J2w3sOiKkk4k6L0fYo5lQ6wSePQj7HwVYbkhqFScjG3sAgJlUMWE06t7grsqENs3Uf+Bv3k+QgY5EORDp4T0/l+eAZWveDDOBwuR0NQaFNQlMfo5Q1AQ+WqhdyMNCsOQwrj6DcSxcqa4JO/HWtzOBE4JQA9vplCc8sYgWxDeiRgpXvGwA0VNlbSodt1ozQjpwgGllmbPkb15Z5+tq+tao7xz7KJEZ5YMFIS9MAZN0vggU0abfFO4CjUrAN9TC+mJrwb2dS+8eG/OcDeiMUzPIReDI2jDp5Tc0HPd76GtiRfqJ70p0E1YcYGc036eKEnU7RhcVZ1SFw0pCkNs+jg88YGwKHudLYrnwQmvgXKw4B5QXnextgcHckcZ7uVwracgkfLZgaNT5/O4o0r6ImivlKSFHrN9FYzUah388R753RihK98HGFIbtZNjQgNO0/e+W4rfZRt3EBNPSRErr2K3uQcSKJgVvznq/NvxDYjgWKPNByfyxvsmF/H/eLzMzLx+8p5Xk9je66bX5GikL6v6WyIpZSgv8Vpi8wQaf+FiX8APp+w3+SIrdavL8SBLv+3WEmFPqDWtc1hFFzsIiulTaeY/oP4QQHAUXQ25NpaynZwXjf6V4EXRZg/f4NjavBGNUFT0MeuRMpnXf2O2zfuYMAJ0/mRhxBcf4ZZAp+pZZhNGKpKuBatj2InuqEihq1znlb3vDE096YjcJzgj+RwFdavFyou31Bh1NiYNSxpZqFLRbnDzYTjxSVAy0zH08Z7D9iSb/XWXngItgnCFrX70bZAmoINQH1Vblp3nxz85ecYuJOE2HJvYe6IpI/2g8IID6m4HQs+ki4NvUFQrP1Uv6uCePBA2md5IWZh7gqFk2ErvAfcPvXNvWoiBFH/e9yI0G9BMOmjsLLNgS4UCNq7cizZWKgN5M3F+neo7WyrbUOef+EklvndhQ7OuewhZc1/55QdAOV4rQX0GYzG7ZJMCocfqAlADmPX2+V15Y5qRbMaQlMzFP2Gcsmd0E3GT2oKrQxxq4X+003xV0rgum86Q46ZRYcEAovqHGszYg9WbCAW8pyOeHcrq/8kOOyU+3sQu2/F73vNq4lN3eRizqTRs10HyCdH3CvnXjG/9YXpCLvIKj5Hcrci1ktllSEXp0i3D4kKBBMPB5D1aijfEYABQ4t29KFvgvylolTBD26t0QvuPtH0Tm4Y2/p0CNvEH+onIM14OS6bSCoY02LkmAaoy1l7+nkvbhFIHX8KZeyaGGjo7b6FEYfQUyECsFcwQJ3hdavjicw1IYuw3wIorYm02rZOUwqF9LSKZyzQqdIG2fg36/iCwDVpx+4XqpD5/7jj9reuaFbJj+1TC6rejrdA/vrsetwaHgVraKkcZzybwYSbj8BHUe1qaffomx1oCn28azqnkAz+0ey3tAB/PnR1GKGcnJp1WbDAPK8Ciuy+iwTVI2Jp1GsStT0lH4NgK220O6Z2SoI85dRnjsvmsw5P5kGbPBRCUsmMxPuvf1SWYtFiRqQ9h4oXOBn+uGn0N02peGU4kJ8TTZ+UNJYhRaJHHNn+i6T2tuWAei6Lf6DVsvNpa1QePYf/gznUFvznT7Wk9FsUQXR6eC1KQpWgBL1K+YdqJMX9mT2yu/2rjNVfEYcAhXo0/ibf4VeAP+3/iYot4odWkfhLSeeWba7mo/cHRLpAbZKROQl47urhLm6LmiS+IDktsCcFZLUxl4oQcmZCw8mldpMWTdFT0A7G/4StHk0RGqU5e54/z1grpLAeZPWg2K4S4cJtKtt+Bijkdh++bJtCBsGTJxNT40cnTg9DPvbA0usfSIMwYjPefeDVpkWhCTqP9fbSlOnrCAd1Qrcg5nd+za0z2D+WicegNdcblcvzOd4QJjF0O9h8qeo6NHh/NdX2jWS3cAaj0L5I8Av3ApTwnKN/OpLBGctW1veBGWKFSNYw7J+7inOWstuKE280jzVWajhZAriaLF7idk66V7wxo1h0CkR1NqJIzbhndCHKs48dhETZ4N0eEfYndZqkBn8bAU98mbcpXq36EhVab/ZdhVh91SQGfzp9kRtqr5oEleYAGj79oBUO4ekWRKVQIPbdjY5X6x2FrRSip0ApNE1HxG7xLRFvBceqsSibt6vHjp1sx8jGabRSp5rlDY44OVbyQ1iG4qKlpJJ+Y9YOaXFb1qcm86iCIYK/3IJpgYF4034jOMuU38sOjqw9XDTQt3ABmZkQGtmiD+7mSsntMdmHjAr8I9hfM7XHKCzVBKhQ2xDB0iB2uyk3yGsCl9bDkPrZjmLFd6UiadqjFHiyXMicVvn8ufpx701mQlAhM9x35NISgaKRDYpnRcXNIVFSS0XCVO661hPWSsGYeiRMbBa36tvrYhuE65FF7nx4WSSR7wnRZedhk6PyVYMQAFVgQ8ZPlY/MCfPptsSWL2NeS9eGN38YUToUDHuDEYXvTtTW36Tk28Cs2cvcVNFw5gKWOgYbBSb3AJmX5xkjAiTr9tyOjhDqEGphZsjpr0ZKyfl7GVFobsR+VhlPBz8+zlMU7NDbG4ewvTnQ+ncPqT+/JTNq0dulGIAa3oAOE0nXnzwCIhq2feuslkAoD4OrO9oMEL/aGHOnTrOOsfIB/Es6Hb3sjvWXHxQ8wXM4wJk6lqugs3O2pDDtOebkQJdWeyxFlL2Q4TIf2ICEzEH2uQqBkMtF4Or158OEA1+ls+gu3BD5CTMQjipQAEC2wNDM3BfPYoSFx5r9J1ANxEeLHcc9hwSl8O5Db042MLqgGWjEaiHMriSP0I+LNpnb78Uwl7aH6vBWpqvOu6Hs94O9DlYtBAOaXkgY10dty0gTxmUVGw7Y4zZZy0nOxQlf3/TjNsQzhasd5soqERSg79aMBcSWrWIIJMlKr0NmqUmsYbldMUMF1Oeb1phQO4WfSYjbOTAKLqzT9rZI8suQ2JTCoCHeiC7AGhOj88TrZjNfas/50fx8kY8Bk6YXc1vyNMf3dbi+Ubr0NWoRmX0/8q0RjN/Not7gaPH/EacGM2W03Jw3NJtr+lMoDnKYoH1acdbDCYUYVbunGKjSJfF4n8Uhj9bKb51ZFSGDXKVIGtMbzouH8apt7GdM7/+GiVRCxVyUwffikkIWKd1jeUC8qHc6jzu5Oi9sA9VRS+5/6/ONBD1lw4a7B8bA01YNmARe5IHi5vTRPHELG18xIZCt6k74gWkqbAyDpICC8I0gTge9lP96cuVv00UyC4WvI4ussGgPxxOnCGHwWwFCcaXw7kbXe1U6BXrJZxaor2a/pXhUzBjOxVmFcWFr0dRZ4oTDs5s44wR1YrzbjyJXqJl7vwMpcKe5zb796dIFeCZaQfGRzkHOoW/LAuiHaSGMoM93dlwBB0iHlA8MZX+hzduSJjdP+qYknbGrTRF8UIgT4+WGhh3kqzJSJ+qHD6BflrmVo/cWije4MtcfolxD7zBnfQEnCJNGuqGNC75Iha2bNGU4VMkySWTP1fNuT42RevXlwVcuYlf5xCOkHL1sReQdDeG+fy3no+BLyy2cBlU8th0syOmp6n9WVb/FqxjtXt8aevDfarLH6tbeFq5DxSuvM8lefhAuGJ7+sAi3TQWQiD+QcU5LRJGwpGx0BwIVDfFIWoAagCCe24VZEN4cm3UT+nq797Ft70MILeCGFNfUiDFnxZUbSHGGi/GKg24krvPaWlP5K71069l9mE9Yvzekp3B94+IETFFrIsklUHzBrT3vKc9TbsNaSliFQYrbV3rAtTZ296ZRGFYexpHdVF0+O4waAmBdMdMhfAtuSFxAUE0+JgkCFBR+QBQ4SEluRJnkl0jF6nnCobHflPTd1nVQ4+/+bD2OZD0dWiQQ7migbYQz8cWgDJ1yAWz37gHvYDTBIcQYZH7JopKfqlwv3XgBxjMZziKSAeStfLbyvireeFY0lskGk+TpSI8VhtRpVVF4yf67dT1d4Z/56K2gCFsSRMPB/WgTS3JWboqh9ijLUa9oLfjfyye7y+h9BrFtUFMdeV7h9zMKOUvbUOXBPqfLtgAq9r3n+CEzBVC8oGXD+MJ89Q4qv2SiQl71fcRNteNh/HlMnaHAQ9lOd3A4oNoBhd9dxcP41fhPYOwYHYu1lMovb6o47CavUaU6VlvRZ3gw8uIoWUNeyVGbynmWE3L7Xt93fodzEm3F4MAcacQCQbPXWV64S7XZo1V/hSLzgc+3gWdemDIDQA2TTkWqw2wWkqsn0+Ya4yEqR3rR4q2+oejrpcwqiKsmMrN1+YJC6cs5DqQT1UcP6qpG+n6jnJMlX5VRmVmG/7nQFxr0SdghiU0/gJmrW2fUCzXAbKDZPx1L4vwPV+uUODAktjS1Q9vl2QKd9CTKjus3eKHy50SZSiT9Wlsa+kEi/2pnZwu2BUj8pA0YDPpFnwcWuWhVO/TLnddxikfCX65YDVBY0mDbwIAhQH4prEgjIYVhdvwCAv9OAhrWH05253wC1YnaKQFvJOq1/io2fZEJ1mVC+95wX3fXnBFLfR491H1IhlnL1agB7u7s8ZdeCMDszUXmb7qZGQhsfYLhvymgvlhbTK3yEqHm5HL887aUK/hBOGtb8VRk0AYePkRq52riewOhsDWSrH8JjpzvnLQcikG1fn6TVlL1EW88+wQ8LZkbvmERceTrZW9oddHE1q2kgvHeYbb+MhW+Gdcl/vR/uy1R1E1g0PqIddYoBi9NHIei4kUAptOOwFGEwn7hApgZ5Dp/vQmbqcuwfT0lNn2oL6q6hb422jSFnzP+vUX3GdeAg3HbAY/3HRE8npfZWrirr73jTu9FatzEOv3w8NdVthm+OcR2T2DLNUNDMz3DfmsYCyebHi5WKDIOyp8gOTwY2F2F7rmTAu3qD6MsgKqett86UefeiH8w1WSy1pojufmsjynTN96pQjT52UJYo9e0H7F5dby3SDbNAAE9Umlcc8RidUWOoNCKjpSRY+Jm7bR5apOYtlQX26NAynaHpuLBpRivynQpSxMZ9uXXcnS/91haAsZ1KWylBN8K8HwJoeuOGRAT+S5MqlFIFpWv80AOi2tQqQOBxLPMuQr204aZtjCi1aBu+KgrxuEJHiKv36Hj6OmBrXS5t9FslZN3BQdv8HGGMlpmNvtc8OABhR5I35GsTKBG9f34lMpWzoXxYZcU8Vc9QAC3sLkXluzSrsoOcv9j1D/bZBin7KvR1Mz2V8klTlAnXsdhJ8ZxD6ltdF6IyeNZZXd53Ot7kd+uRd4tuqOpTeMBmtSwcbmxzUYnShaLpu8RwdtRY9QCUUvm0HsSBuS6QKL5eayWW2KJOx+nX6dgFXINIXIqYaNUgvlBACIAOn3Gjb5Xe3jTCuxK7lcQvbqKwo+du6dFs2WhglD3usb8Xg/hJf2K0nKNJf/vlREDJz7/NtDLGZv2ToMWLXow2pk0F9WacKKGl98R7bJR/xhUTD06sCXU3iIap1G3EuY+PCy8w7/qj5ghXUE8LDwLaTBDrdM4lTQNrXmWLFsx6TVktxmW0uCfPlOMMydnvD8q8FB9x0nfk+bXpmXzSzkBxfzdsTKdcpvZ/X0kWjxLhB1LoX14Q9pkbc+HAeRuCOHB6+mqkuU2f7/sS1Gmgf5wMEB4gZVgMbKExLlXhMrgOQBnqiVOF0a0BGkMri3HTsLOFa2RTmGmrp9D4tPKJNUT3RWmfjPsXc7yEVPO1lJ9iMPMclCg6TWEeScU+yFGmBDuRiTf06i7KR3aRieS43oom8m41Z8OcI6VoaVcwDu9NC6Dhe6vqGbFlpHHk+oynKnYe9gn+eZuCYK3Zyd6w+dYlJv0vs8EYZCq5QsXw49bDcvP6mFePhlu9G7ZkFJl6wWwxt0m/a4qXbeUQC210OCZ2skqAeeZYjgHuP1qAUdGlSM1J3Oc0bjvGuTx+DE6aQPVqgongbl4yW6hdUErlNrXhmFR0P8I+ZgSUzYxjuWRNAAwlaJw4ZK/8JigKJPC8NRO0GWa4iNjUOmso10dZeKuP6O91ahVQClLxqxSyH1Gfp1JEdMQYyW2w/zskaJTpaWS5ojn+FHDzh17fpOdx/KMQQPO5OCCHgVnJEJc/wT++8jP3sFSOal3BaqzdPvTI/rvR8JBaUlnaEZvtsvG1fzzUIovDyOvyv2rLDAr1ePMq/mLAQEKm7jxmRu7pggMWIx5jvtaw8mY9fxT+TRqhWKnVJ4jr5glo9745+V1UwHgxHPxzzME8G/cV+JpqgShKwVusdlvE0iYiUG7B+n5gcvA0Vbh+Na3kLFm6twnAyjIGmxb73oGquRKz6QdR0Jq5mgOyc9Fz9pRRGPUG5iNyHU0vktNj5lncAUrl8BWXfjoco/GGzK9l57UY8nd9vwM/v1Zkh9CJSrIlGw4YZ8dSHw18F9b7dynbEI/tkM7Bfza+ahN1mPqaqLxpNQy8Tw9wZXtWyQd8zeKp15v9Ijp0qMx+8WQo5s/ihZJcUux1L+z+g6F/ZEOqz/ueHemSsx6w57t9Qxh3BxlxRhDRCOQ17wC9ubCUFQoJtDfZPXm9byvcCNBTyZ5yru9MlfVnXK6i6O8l3EL4urlkMgNq8PGGMB8fCxkCJ3iTBuAAGW8/UC0DRqYlKo3bbttiH3qFoX/sM1opqCi1xmz22plMNQ+GijVolw+BwkZSz3bLdNpO21p748gxQmORLgXw3QlJXIQPG9VBN3MofH2Isjgia4ec0uu4w0AFbspHZ4joc9oPxa+9I85SYFUifJSIF5RIvFYsWS+YMKRk9L67FGU3nwUuMhHXDhxBIuYyjvKX/upCtcgKjEKw1iqFAMjxrv3ZSmrg0YmdQFr4lVk1+XHPhnVyTzLXnS0T5qJ1HIhilfY57viGMa3ZmtHaDsfx7HLR4D08pSCfAWkMc+TOH3qaylECX6yAM8DtWXY/L4Cr078WaeuX71+XXNoHvznzb7mJLg5DoSM20uUGCOtkeoHT6iKAz5yVh9rLeTblYiplUsCzaDqJwU7AkZrEfzv0ifrqYlxeJtRwLD/ObHDsm5FBVpblxSkK08DJ+D7n7iKB+KBry96YbXOvaMaQhLa2m8aTAUuS+PRrJJ4ptEh+a7NOod4sXDD3jHtORhnqZXnGdlmytX6XrChfzsJoa7UD0gUT3zpA5oOqnOcAV6cX/J1AFHhlTTztfZZhbapc2M7TXN0f6Bl/N21ESY6DcU0b/HjgYzuAE7abj3sksWh+KtU7Ckwhvy/Nkxq7Nx/7c9W1UQNtbmci/7pC174XO9V/JJTVD3MLG7QSCCxHcvtAP2p3O72z2+Yg/JAkbxBE2psBuss8RpQ1U7Z0H2nR/UfsqtdJrOaRawtmsIyokXghkBX+WQ8szWHwPZ3BlUcHRc5F2/umhJlGa+2lWLAteZUy55Oau/kdEgLnGtHCI6J8WxcPPlETk/7VtTYCDPFU4g51tEP27JowmFJHKcbLFujQHXrZysRnT/9ruqOMCPZbHyHdsqQGNqa1HrrGEOw8Jt0W4BpZdTmQXnCyX2ecUnj3b0YP3uuYSuqSwnKvHiSmN2zdUqv8KxDpUjkkZkegQ3y2/j5LBp9B+BMeSfc+kcqGl8GeKd3GZ2QuQNAtzUkFJNzFnLcuqVrUfHkL1UjJEsCeGze14iQeZTpFmPgUc/HYn7pIb6V6H1/QWZLpUtsMQwXvIle0dadTRWcx97YlYZrJlosC0TtQvfxpKxyqhNZVe2r5ldr+sWMPDc8xysCRfJaerDraGcPE3dfA+TarjzRJVLAzVVRZAi3jcfb2i30nULGljRjCNfBYPG8bqfLCSv9IR2AntDDSoX7druqqIF6iOLCzkVbl/9MEhYuG2JWOOri930RDC1YlUBKm4JXQIFM952XJlP5VhLaq4e/0cIZJZ+917zkO7ZX62HrjeL5NjPMbitj/1A3puI1zZLw6cKp9N0AV0YynKf99T5rCakqGA9nX5o1ruAfKDFwAAAQSqk9zqnsWvi3OM/fvsyCM+u6KKijEuq5eeFYHrC2hQGxz8X8JJvh9DskjgW29qVxHuNk9aAnhzO6jTQCuhIlesHw0hXTOm0H1SgOrCTZyZZFI54m+apjrgq1Vlr4K75xjf1HWIIyUEx4Ij9YFpD3+9/jtMR1cvpwvHBRCazxV0DjltZ/Or3V9zA4zeQXMeF4kK7IW3mqAaZq0I5ks5Z4btAct7rvsdw9+SP+H0ChE5mCnq3qCmOAINeDATYsBuNXcvb6cHR3ybVrvP7uH/E+Hnyc8RVDRHguLoFJwdlnsA9rhL/Y9MkDcHdxW/aC9Vj/g4JjviknJbX3NnMii3pCcfFe3nm1pRv1QIaV3Zl+Z9sXEe+xn3nmFTt/8VXomZ0YD3e8NuSMh77NcTCiq/pIzD4dXcWiAb7p7DHh/pYPxjY6DqshfuDL1BL+IJx6h84DivGVNWS0twzV3avmht1jjBGSmk3xcQ0Movm4KjiF3RswgkjJkNe/4o2dECJnfNyxdwgtz5r6bG5DTUd942fgIS8YiCxr0LzcVZyQiXnOLNfxiXBppJbZbPMc7P/x6EQBODd5rVRel4sg9zyOpx5C4YjoPAuNDoz5bVJrrSZuOIkJPCqVyUnNbLRVGEbnES0e/7KTA7jfR+nUes4iBw5mvcRxk9Tu03F7RdUjec/GikkuBEP7eS9Gd10Dx4kDadScStWfwjK52QdDL967XO0Qb14wjGVpJozFYBFO+062OI4AGQmTFlM+xz/aGb0cK/GQ1T/WS7llFqb+a4t0o/VbMppGI/SWJ/3vJD+/pSZK60KZNZV4DBdFDISd8RJq61ZXBLmZYSIt3g864cj47IYqdYo8HfP9+CVT/HWUVMx+rl1o3uDQwtX2C08jQyoq1y7sZam0/gvJiniKVFoLH6+b6DRSPBFHN1pWhQ7GsWrhBmwj6XvTgJoHXDI+6aefczbJUR7ghMKPJCCBB1tFy167X+RZ976yl9ENLiuzcQqk4CiKsJGHZIbJO/6aPlsM3xcV2Lv4EkrtYEcCdnX3ryah3zJBGWRvHQI3583Uzcpi7rumsiG0arYHRo5XrM4P1RMOLkK23dwB51J+pN97HoBlKJ8AM98usvCxFeDOHcJwLaRDkNIjCxYyyVG/MkiyV91LTKw4JH4MCNg3Yo5cFj4pxm4pUvg3PgOKLoEV0xX6V2HHRHahOUOftOxNFNDovvtx0HYH/cqRQBJ78hTH9t5mvWw7ndMuIErBKu/tLYSxu+KuDiQE1lEG2UCUkJJIQ6UPbZUIt37O2yJVQ3RcfzphP0oz0+RlulxSpbUqDsfxtUw7+O3Z1k+dWeN3IAJKl01SwKfSqW8cnyS7lePklibLpXrHW8MAXHGDVLQMRLphJ6S8iLx1Xp0m69KF5B2oDGLhJltF3gZUePpKF3eO/54fauxCQ6n5D0nIx83lBFHb48XyZZh2bDV1mop4oGBIWGYntq474DQ3R0fLA8EF4FDYAwcEhloVKBFvUhKNVDNqlqWwGOikM4Smd4EOSapgU9STe1tE6wfqvah8RH1Vo8i+FmPfyvTqzzIICy3lw0hoyAFBLf5fkbY2YzvFfLUGRZaoFD+BMyizCgRHYSVfvWZc83sSFUM4oEFHteMzm8k4ouxYr+6wq76X+1CH5sv/MsrDfpQ7+5z0qW25AaeI5lruXzskVMTgr+hB0PEZt3jxbOVEFaXB3+pqtkFcOV2QQgY74iplE2SAPikyHhIUOwLUgKxgBUuQFS6N4/kV7Ikr+di/H6m0o6ji+Hza0dtQQMLb1OuB2hav/YLgxbicMUmkD+6zcGj7tXgfT+leTKANXv3oxUC4bPGFP4CQ8M7Qy9sCmWrTvjgnLh+S4cInE6K9PhV5QBrsWbd1epbImBH9yZHaUUjtv/F3isnmYsOHttQbSvsfn7l6ZNTzJyCmR0XxGsF48T7l2Oeps+01nSFxtieeLeH2ovR+9+/1AYWIDtFuDNv4CDmsx51SzoxEDr1DTlxMqLbst0rlT0ipSvkkQKpaIOW1IJqmY3dKkSGyTxaeVqA5bGvcKMkeEt4av+XpF2J3DFr61Xo6FRw49JlPFZ1/YE7GNpAtI+al2689pmX9G6G0uBDmxo+S5Nr1OevxO++/YyndKc9Dt4tSycaaG7kQtMWl+EN88+fHf8NDVKMx5Oejzq+i+KsdK+g9kq3OwKE4gxGBPQKfLYa1tWZTWkX9f3t9ghveXOY7zThuBUz+6Bgrg6Xk/ZvxsBSXV3DsPxd3tEmu0a9MJqOGaFrKysJOC7+hSVp84cnuEmdyizIVL/mG0xkX7+6zKDTdPTieqSpkEtlWSXTbpEoWOTghFVQstAKyhZqcdhXNTP5TYvw4kKCy6saKbCqvOIi5dXfRknvcsfKcgJ1g3hP+CKYEvK+igrBsRikfqFFi4485ufwqLdhRwp1Oexe/OJ0AOh8Cah5oW6L/X+K9EzvnNDi7gT+BzugQao4/MjRO5yFPB7pfsrmZCWnnFTQft83IXb1na1mWfjBSXE1J2+ljtmLrWGUjuyChR4Hkp4t4yF4VIPOHkc7PcvZ7e0AcehFsG4305t8xTod01qHXQEKugIaulY8hfGrFZKIwIVdMB3I0+C2kwmG4PzJgl3et26xWD2uXYu5I6zhmEjn2i6hxvXTb2OCL1Gx1yMaXRCl9mi7x7Z5V/by+qz0fJPpEX5Dfpy5shq3Tp5NbQ7Xuntt5VgMaTVAXxVh/vWqSi9tJnCYC61ib1zO60Upy5JjRi5gcTiZz+IAATBuDlMCX7ER0NicEDBqBXm0oMsoivBSLn3crzCu0XiyeNa5AnlUtRngyFcAKDQtP4V2nqpfms/sl/Rckhm9v1s6hQCJz3jjuXjJcECnwLJL1qQ7Xp1QnM3LEqexxV3N0HK/kaBfcAB+v3m1ODqXNuE0IrA7qFBCLBmQ2TltU6Y+2OF5w0Vj9l0IvK9cp4LpFtsVHYIceE92AdoJcxJ5R3hMX5r9/kaT5Mfk8yFLS7bwjZ3R8SnTuroWrORFr06V4DMnZ1ndIvpZGRJW6XRVXd56BsFLcvcD2na6GrxPCF1tL/OHFHMOmLdFUiqBznh3AAx5nYYyQnfElugYUTTv5ERbCv9ujE5zVO7OsfaBEQLZf0lRxSu4NDqUnEphBczQGcBz6llhzORGSsoCFOqjbl3u9Snhb/PQ994btkTVRjcPX2bHdlulFQvb/rJ3YR3/hQYNfUPYr0WfajweT73DHhWe37ZQOWyVkCeFSpEAXUKwJLRVo1wAgoPHYatetkZ2fHpmfE3iZgBtDeZTnO0wABhKL7OpXL7DT6gPEhdyawCYgM19JrZ5T0oQHooTsscTzxVM+BMfip7uIsfwslAPs7+FsyfUFxoAh60dG66GSMpCH4970s6Jg4JmOg0AxvnBC+VajmHvdFPSfvoKDjMULLeDge+9hd6LaVJXkd/oBhuVF6RPr84PaN4hZB3QTy7lJ2jD7222MDV7PfPGbBqdsDTm92LJZkNZ68IfWu7x2cFLzvAR+803dMXyAagNHuYjOCEriKMLAoTG3qEfqPgQfwXYWf1MyY9n6yE27kizpfN/xHvUb4VT/wK24+qn1iOWkeisF8CsbOuMS7HmdeKVh+V80lMSKM16lIZSmpKgiMydWsgMJPHqkdtYnRgPs5Os8v4T+GQ0diR5uUZrHXNT/g9TabEpBYbTT24M08st4DTnZiHWLPofI85w2Acl9vf22CGYcNdn3kcC79yXj6tRx2v+ExMtDY4J1iRwWpnt4eU3YRBJYxq6OMbdaCmhZGWRSQwNssG7t+iU49XSLWHfgE9JbhfnGNMxrs75IyCBAml3Z2bZ2yUCNYX5rwx4dYt9XRrv3C8BWDi8PFusNQjPjKJ4pORDBarGcu1XLhBXRpJae+8fNHRbCNE/VeaqqqRez7cvIe49+DCaPPYORUR3Br0OBKvSzcM2CfT7KH2lpwr+E/4DxpjJuqD/lANGLjb1Y626rsSexU7zv0+yhRnHorBZ1wnchCLC4Z7jTr9/sl/R3S64j7OVZAcqQwwdGIivK57jlkg0uELmF9yQkqscILDpxZcDXBshuToQyCcm3lPSea/aUT6Qw98NoLUniruNBK28pPfYQjMvub9axAgbca1CjGXjm33SyBiRtUxGHDHE9EUrjkIGAOaad+ch0vvmpXlr1Hph3T/JtBnHEiCq+VuPH+xalYj/L1H/LIsNIndaVWfmhTeedxbug63PrQvRAMbvRY0nXSsqTKC4O4GQ+0v9U7zwpqOh8Ml7vl3GeBtd7jEq0qMwbuuSRecDNNPP9KeagVNxBw6+uAmvUmcYeg61BfnTnibiWabo0eEo5uSxvBmFq8+70D6xexPL2D22Fu1XHoSHEhFpQMrEr2WkFhZmTMF29kjIo7dknzS1nOPoNdPEBx9CbDOJI8tgBj0yCg7b8tsCjZtJ84+YVoOt5jf/pbWa95k4heMYprxaExtBS7FFX//33dA6xCi9qvSsCf6KJs7C8QeuoZJtOgLqUEW4jem+hlCF6sHd7UScXSHXgE7bGcYZo+LfcPnis065WUy5N1elidJ+dy0AilXoDQKlPx6nUy3pViU+idJnbEzLPLeDCVavyoKr7+oEKDrYPFFUFUk2o9pyc+Yxn3V0C7n5daInmO5ruc2/JHLX2zpg5e+51n60ZANEYJjum56VQJuBKDP44nzfLUldOhrAxIozK8B0t0zy9UZ2bYwoee3mpCWfDZYWDki0fhmcDwok5oK4LxD5KJxxOw0soiXAYK6j5cBDD5apySwf3C0spy5nGmCwMYPsNo7wFHCY6J9pNkLmSPs9wVo73tbu3mxejCFel/jxuS8UIVO17ywHOU5V/HbNjfyYXlerP4J4BEnqSx2y+oycu0rSttWl0zE8d4O1kPmcu4GaMgs+2eUkhlttmnjMm/WfENejy8akXej8NMIjYSNSZjlNHTNNh5Pk//3HFnj8L11KmoRXFVtbFkM6Pm/u1OGfcLtyce6mklpd4ebCgVuk3DeNZvvJj3IyelUs7IBKK2FfAEDKKVZQm2zK6tb9yzfeEUGBefNVOLnAMWD8FI0kSELoeWt7EMA6o9OjjHoaA/2r6ad4zLeedpL1VeYQDX4mRU7VBHb9UsPdwXixmg/fFhAXxiHz/X0LB2OzWEsd4SqHoq5xdUCtz9YYlbLECZoaEryJZcIeRHiKEr91ftjjkgPtTbYwKF51xKAZ9mCKOwtPATsFkF/029UwDkXo0wzbkpSqRQ9LDVmr9LyeSF4GP2XnOwVWKX2h1en2X1EPyG0FuMhseX6N0mGpRdXROmKgPpYp0E2W0hSXr73ag+e429WLFrmY6p2FgpkxVXHEPywk5ROc/fzZX7sEwo73Wo2epr0QoApSi0/lGBa1Mi079qo7j3f6wob0Kl/OoDtuv3wljO/0984qj5FuVjF9WHlYwYjja/Ck3WpFN9aUDBDNFGSQw0uP4oTloo4TZB9PMQxo9o+VUumc6GoUlSbL8My2WV7fwJqSvZDEWx2T1+m2J4gjetCI8yRzgLCDMN30eaoKTw+UXnw2c4MLeQu3tEXGJsVFpG8GGac39ta3rRwMiZeOXt64Xpuvq/ITvD+MzZOhAyUvJ30MVEq/gH4EGk0O3e9TfpxuCFXWQbgVBWzih+RUEPV0/Cy56glhXibtaXMtmAvYsGG25xvaqcBQRZJyFnRWzGgfptnnuCU7ejIguODeJ9CzZyXJNDNBmCXDH4k8eaAC+unt9GJMchDHaviALVrqNaICjA+lMNHIWf5FmGhOXFenlfPryck7szpxqC1qF7PERwJqAN0lM5h1am3duu94tK93WpmL0h3AFmb6y+Hd+A0z3jzMRQD4Ymh4NGZC+CssQfDWPXoOfV6cFJST/EX8hgQXlwE0zvOGxRNXkZexrjhIx5FjoGEgF7Cb6c5NnwBFCkIcJacAmsrWWLFvx2qWlarHNsJc0B8l/J0FmfnE9qQ0l/zGK/cuoWIwOff6FNq1oMHRcP3VIUWCGGr6gm6o5mnL+6xvkvBXMvhKHnq8MGmsCOaGCh4H45X1CUIQBzJI91b6j1CIKI/GbkYgTyY8G4VQforKvhB2IDN9DffneBwM2YiRBWyzfOkU2ILSSlngvImbXz6UVetyFwfLGzEOfxvNVNkO10Bb1KHprRbOr+dLWhrhOfDzHXpS94Tryw1tcXmDk2by4BLeTqz7PTBlb8jVYOakJfAhgpVWXYxjsnsat6uTXqGyOAher0fZP9Cgvee0HZRAERdwKPeagkvVaBn2dPnKdSZKVK8ze4eaAdTzd5dV15Wo591A/nV4FxebaHE5BQCHUovC1E6d0LkhTF584Hzjs1HvcR72s0F+UVTt5qW0njCitbCgelBWYdzCaalgpuIWLjgy+QwpHYfYWK71XOGsKFHr2rmrBqpLQWttblQdMMEP1AL6ua6Q3O9de69CtC+ttZXukx7el5jHmM9G0OGRWxehMIqXCnZm9oeBlTJTcm6WEhd2NyYu8rRcI8wrjbOkX0h//St/lnP8zY0Alnn27BzHwxrnQPO869AJmmkJ614Lo2d/PtuJVpLTNySZB4ISRAaMvUXXdAl4s2xdbUn7m4OH6M697/z8ge4jxIrdn/LRWI6GdECoi8X5Qx5pff0d1w4u6yndkbGy0bAdH6jeDdTWjqL1iRlV8PLYn4OtNMzvWeLAIwiUhnbqGD41OxRb/jBUJ+KRdaeoJgODS7ZDXrBO29018W2QVmXwvdQEhqkuKaNnQ8KdXMlnySq5YBon1ng7qth3Fr6vI7XOCqINtL7tEglk5sPLkzbR+Qrk3Yd09FK2huOLwk5XEBF5m53R5o7v0tWH2oVp3CKO4fuXXKbRySGmHrlgMOBbKZ5GkaQKLLVqIS/IOwuQ3fHuNbIthhLhGhZ8dJ5mfVHwEcOq8a4SwWtzbi8FKt6J1fL3Ow5Nuh1+NbkO/JtEAYNvzW/Ob0wy+x4AX4pi3bUcG963U6fwEutEH7Lf0AJcH2ZRnaFbN+UGg6xH8vQfvwzJQCVIULyiTWAFk18QJAWH2nVwt+tcpCk9petbYF1xKLYLkLKYQOrM4GlKXNvDtu/QS7RiN6lDphk2ByMJMD92kECrC7LO40UDEaQmCwZZapfCole+DpKZFIPZHqPp//D0cpitvL1/+tVvkkFLp12tlRqvqQq/xDB0fgPGYHZA8fHLP6wYYXAKP+GvL+5LwMyogHfTuK1trTjHpmjdcd8f81xSkdPeE3WmOULxIkmsePDlI2hFhj+bWLjSPLfdSE3tjduyfNaD3u7ndrO4Yfvw44tkeF77Gb4+iqFxXbIjeBk+eN/ItkoJLYVlWEs49O4i5flOc6uc6mTrvPsFmI0N0R6iEdU/DxvQ2Lq/iTTvTh94t2iPpjWs7eySgGHGUjMu4F6bEJUqhPRXn5d+gpwFnqsJl9HSJUh5U1AJluz6ZVeBB2jbywhtOPgqgD9PZLJu2WxGwAlkOZuW63ZxcpELIKGmzZUlx855u6sSGv0o77nmBupAvf+ojiI1cH3Qvx68Ari85yKI/HGzDbhAspQeDOHqZ/m2U8qNVLaruZyb4hGWpLU/PHsofV/TyzSjDAFk79t+Y9ixL7hxKr21PCfK7RcKF9eenFGMh9ev846IHGPWCPwESPtSGiknGCL8sCSB3bDfQpAxVTBVQ9tFEVU0c8tWrz7WujyV3p6gV4P1qv7IDOOSNlg7sLxGOqBe3Y0F7KNL8TyCOi5uxPUr8ih08Js03U8SA/6uXjuQceJbpPFXKjaQFTwIg+HhpSQoTDCC/kM+WscQVzfluAWJEMV3EsfoeHuQuwhggWA7wHDBhgmiLqn+KIBrZPBS78vkvucUITCgn31k9W+l/XXbUE5xtkwdLFWujhB/rl3eXAgqJkG6FtuN8QgULh4VZvaEWLQVFlRQmHZjl8h9VcQhsWJF4BlQ9AjbUM3pUgq9v2lBRiSvm7PfDjN5wGH6y2HMGGYSEClB3yprKEZ8dr6wGXfpR9aOYSSxBhRYPv+rRJJg6X2eoVnSnLGlfZ3QONRZpztCm0c+W+cZQqnuIFJu10oHAFUap5NyyqqXHZBFCGv+F1J2V551aqJk3XXxO9KW2Oe8S/1DWkeJiV1to0KMDj8jzvrastAIcYQ8y4U18RukVYslr+BMtByNjgptpp6giNIETwFXSTY2S9ymgwgagRrc4IV9DN0YZmzrsqGLH2j0upwk5OnQ9CR2SwlJ6LPXtXLKhJ1FwDPJoLlxXT88zrv37iCfP6Hi0hJ+hI8zjH0dGs1Gw9J5WE8TVHZnxfD4nSmOqghD+bo3vVMCMv1+2gxnqQiQeR9x+uYPQ8ZVVdIQqCRdybqeKx6tW4iFbnGQQDC2KVZgl/lbcjCBQkqOdgOSoUTdqq/J+G8vnyOmWrX9EfRxcKRHbMuBHLGj1MvS5k7V9h5loaGCfIFB1rjGPpsUSSjBnf4HFnsgKpsPUQljbIAOEhtIIRP2Ea+lxMP0MSB0h5KbF1Msi/I7UtwdwpgDd43//1bS8aCe62EiqaqNf6i/rWDT3RPoKjDHLuzJ8bCwGlXTlcvdirKuwVV4ObOENY/dH127RI9pamDhAssA9gvSoYhupgi/PH8CtrUhXJF64P4w45MqGYMLHs7sTqzWMgDk98cnjhJCxx60n0q+/ugQ7TrQzpv+YKP+EpPglmz1/D2vBDMIn34xVOJxraKZ3C4um7pmPtkGniqMLC6kbFaiWEo2Gz6XKYrCrncT/klfChFHHp4cn3RvuR8klLcJdR9R3jZffZyi7dPK4wOOgnKuGHmAKB8Tkk0PrxezNrpza+8n58vw/VnOcrghJFnRDKRL9V2LLy+ySjK+EIPsoeoEDVYJ8rZ8jycgYoSGCiuyxeH6FNyY6SwCkoTzftsw+LbEENDV/jU+MPT9wFmerdBb210TNweO03It2lVqW76aX3NwXQ3ZvPzm0sv/xSy6xPq1J+KpkESR68/UaZQVRDHOVp3Z3WSR6pr2eTmaPvJvPhA+HhijQGScp4UADZz2KoR6+7ULWFrFqvRFN2iujIZv4m1tOrlgI0kL25Pozu4greJPI01vsQSBKdeH8ThD8KvtmIckQVJKJhoONxDu4ijnBtirtAXsb+kuFdxVrdZGBMHy5BM3gAOp9GUNpvcXdwd8upStPoiZ9dYwl2CYNQmReUYS6CNeBTd8C+TXy+qKLKNpRg4+ts2qN3pr7Rbv2YUuBH5KyA9JFEWud+6uTGKX9f05o9mvSxX8tkr9otL08STJnDS5DbNWfb5tm0DbVdRGRhR7ALfy3XBqAsb+6jISKL22+OX3ZEe+7jw9BcJQt7vkfzuKshrJ7ikjUihy+pXV14P5EPCCJuyHbQ3LNA9u94ylrRuG5i0S8UOPgwOGzc2LcI6gr8BBZYu5Bx/iEL363h+IU+n3oSHozD0/Hcu0troG8cfXCUer7kl4+wpFEaI0c7DJRXddq0woXOb3wXp+tE8YjUyGYGVomfE/Cdprdy4TsjvqbSDLlLW23bOXE3CFZCdOn22IankG2stx4vuTXJMQwdZagnV8pGK9tNRyoa3v21o42etUgl5/Z5wYIoYQo4OGcaB9gTCsN8GHvA70tv68f5zYqU5eSaLSQ4+eqr12SS4Di7wabVH4W6crwVgJOeWUOEgWvWkBKPqCs6QjWRMp6ypXwg4aZ0Po5VCMa0Mgwn72B9GMBf5ukww7MTCjKNBp33kybFN8/AnbhilBhO2KOOnx3Xo0sBfXd7EX//zZxvSSXzzFmZ9oYLHjpl6WNWa4tRoVaJ3iguARMU683MLl8Aj6XuR/UW40OpwOdZ68YM+IQuv7LXsKAO4BTd4R/uotyGo9iImJwCp+H1DhIKXhZHzVhVc3HS2K88pIR1FjDwLOgIxMzNanZy5JQa/a4VYdX5Y/VU1LJcDGyMlHFcah8s33tiRRWbp1eLeTzi0xAJuqXpn8Q+O/CNNHtkJjI9L0hoFSiA6rJJyWXk0ijzFbS0KwJpm3H+dbbfZQKul2VQQIng/12M0Cvq226zgCoONebva8tECu7B2XGDtNftjUF9mZBiF0vDjjLIFuHNosW2ssZdPa7x0OuYDbuym4FUMQYHsUM0oWwdMqrDmwRY1y1J2FddatkMiao7D0LEb9bH7uO3KdOybbfCh6nSUiWgNCCDe4mfQ6kdiWSWZQmE1x1G6KcTsf03vw4wizs95bIxS2OGAzuI/Bwaau5rJM+Ed1eTiPOiKHLG7dFgDbodV2GphaH9sVdGxQ5iKDjjjWSKWnAD/PCjXVfKngz5/PNT7mRcM0O9WXveee2WdVIIaElb7iKR1sdJod1Y+iNv5XFYfxD1znvRHm/d3NT8HT66h16ZmQopijBWKW08GJ6dBtDx+DwCB9hCZgJPTJ7OBW4slLvIxVjfz4ciK43ZWOIxZpnmks5RJAytkdXmTl9yCzoM58L16w3jjbTjg2RH2ESVKPvDQhsJPGaYht157Ouvon5kgO9KI7uHqD0vHwuGCr2chs2gbs1jYbCIx6KRVAueuwE8JtwS46KQWPfLs6orDs+REExL76sTGlnppLZOn09uEd3jcPXEYOZ+I3WikY6dvJRaI+GbsAq9Hv0AxuAGIOQMkPT3qYn5RZmxA28kpEXimzMp5NGTEwyloFabKfHi6KSb6NA6GArMrar36DhAE9zQz3aDOD3ubivUS+9FpGJgIw4LT4Nfx+Lsu10HXFeB67LnWmR4uB+UTFbehdG1ccQWDquJAcY2i2R5o8e9JpciCaf6o/BZkr5H7+qu1YkEtIGctg50nH+onf8WZPsb4R9Lnnq8myWR9H7bJDX2B8FdJA/kdea//DqyPVOFtMOcBpzHohx21v7EFepyzI25IqKlvW4U4KejG3iDi2n2g/Qt9bEgaLmAPJ8JwTfgWkZJ+lUCICXB6QjZ51bivgULWkOVPcVcr2HjxpqSLe8NxIkeHIiChkEaHy7xThusvDEAY6CB7HtAd4CAHQI2+b75uiIzt+cwYO6e3ZcD6V6UKWUAJBj/JJPzDBPRIp4vrXA5b45eJ4A2qI4Vnq1HT8XN5kFv1B2cosQMGFWy2CxHlSln2GFkNBde3q0w7U02HOLALDgbphW3J4hCgOnMWkZ21uOd1Juz2zRJEwmQ8D1TVEg9wdIxHROQNzKgxoYLCkBEEP+89xXOD3mArYEgQ/3rn3D+A3lSoLWwkZ1CPTxkf4bmvIIDgcYgaJ9vBcuXkpuZ8/KCTIvjJE0wUvlaogg/Gx8ZmQhTO1p5DbihSc5gHzVjZsUfCnAf18EEwqdhT1C1v51j8Pl15njWBKuBNjADykiZvztCgaDG676c0DrQZe+5ePAltEy/minXltYEJIKgR2QbYH0huLb2mfBBB3WC2rp3gzN/dvZUhEmg7wqBIxZqYDkdb2qaomV96fkiFj2w2dFgoIgbLqVkTPXTU/ivQbc/CTyNA7tK1osRyJQaDo9+U1+IsrddZAXm3dHj11lRPvb1zKRvotjnj4nr/pl6T6wZOP5vL5rCsX/D5ZzqRWxk7Wh4CEsgs52lOZinAJzE30oH4gpatj0tm8vaxVYHzGNYcxsuYKEj+orL8aNSH07GmZkKdD+zei6HjSXswmH4NUfN2OcYjBfHYUaSDOHaBm/QBH0vlaxXow7Vxl8C8YTySs+9gQ5xsoSy3u+4OSSAvRRyoFYominGmTiPfRbENoKI5tplwfXEpSl3iCg7m5q6R3I1oHJk/n/4fww9JQe/9+TcqkKOYOXosrFgj583737A4HZpH4WXtu8dKPKgDVSknDpbJV97didYrvBcFWSRfutIXgFFjr3RRh2rR9nzvgMigxNK65KcZ8aMhiqo4zb+KkWnjQU8ftf9aQk+EfZgvCO+EV3m9EB9+t7q6HdaYLzlGv2vfqKGWYN//s5TbiX3JW4ecK42Fv5kMOE9s5608bEwwMygHgc29uGdM7fmFll2k8So2DDlpzUEzBDGwlUdeotiPRLE4o+RruvsLsMWNvG8NEj2MgEqIMx4dnZnaObJkr3lsNMqcLFifeiU3vJEk+kbQtE81hCRrJmtTnHZGQpw86lWWEbhWS/1Qjkzne5aqVALDtbGFGdjEEcRH1vgZgt5zr5ifQVhlCzUnwqiAS9P83NR3QuLS/KJFLYd82DLiWFSFYFko/x+srHjBh+StFAv33rw0Z50T15xhMHEKY8ww1aQ/tdAz5dugHbPxPWPeHrRgorr+4D3XmEGdlrR81g4VwoJvy9OvV0MnvDnXRg/epQxGQAte+ypyRaRKwG42/3WhlWbSdGzyPI4qFaP20RcBIbY97me+gL0deSfXZGfl2GWFzmy6zv9uZTa6M0CO7SMEkcTTJ5i6jqwFW9HFJgiiu6prXunx1WKL8Gca6Jf/R5LrHwBkd51EvD8y3txSGsSl5SjX9cNvlpKYPS2m9UTWtHLOKsZhc66h4s4G8e+rqP9RARoH33oS0/2EUklJ+/wnoiZ/zm9+/sgXrEVoVB47OrikmVqbYWTqVfJQo2H0hX5UDYGiHVRS/RzKXYC2BC97EmFT5H52id8zkrgz1kF4kso6GABh+9WNMcSu6Fy9onaVj00+Jf8FQ7NzCz+C99i9kUNtBzF3f8BMgZpimf4lVz5pUYszAIcDxf88OXm9CtMLDRvXhEOVmbGJ5yCsqX2PKWljMK91Uzj32TTT2tcVE6kmNPfyVnv8fVQ3e5g81EAnFYMKsBuCCz5hqZzK5pisJGBqIXJrQvRXO8iz82zJMPudHmKyDazObg40wdeo7ETQL5kjuIHxa5atqq6CIxGY9d4NRm8SwIn2R3/G4Ud9kchyA1Ckzc/nmRrya4SOzWh6iinOs+gZxnLXY/6KyxYPIkuNMdeC0fnBFcT2ZgEjoFOCJsim/4F+/6camEGv5sfh+Qcgqa4DvGPAC4PiIAA7nJIIHURmci2/z015ezpo17sGqbe1NgLivieZAWbC0KAvcvU7XIAO4u7Zsj+3lGh7rY7h5VwNRC+bsMThPT6eI2Tz/gzwdyvOYXbsLEn63v3lq1DOhg5DIlAmklXc33bjIv4HtjOdizH0K3fGE/T7dqv0hM6L8w+tuVM9FsP9XmImd+HiRQeKr8QBpKA7tMU8yspQqTZsz9VZfZgTlEif9iUzDT/2/xYiYzTwMaEA/a0+79CT5BZRms3d4dUH6WJ70aRzzoTGix27MhuWBdbNoRNLmweA/PcWpn8d1DjvsZX3bn0dFP3AsZs/XtYPe+fbtpG5AoPFX2aX56zZ1TNAtg2TuzdPnQLqV0y05WJ7dFJU9t0+9eC+UA69BGja25KRSkEzBZso7J1IN9kAhwEMWWHNVrZ17MRkn37dYuBiydHZq+BCDTSnnmpIODddgO0mwVfiq5ESPvV6GuUtEcts+SC8g24naYUsdauV9/GJJNhJJK9TzAsPsm8oBkpHnEPrW9oCQOkNnULEBaK1swI0SiC+kUtobxC9EuD26i/wRptrSfYar8rjeQAwlYu8UPphsNvSUGXGJnghXXyxizHENbfYW38AzR6tnJc9mz8AkibSvUemvlRNvwHgwOpZ9oHyDUwXIGdzTh0e7rQw7OF+77Jht4X/esA/xFlP/wTZqdWmiiMT9IzHnWQ2bh3HniwvLjrH1lyp7cHBfqHTkv6qz6yrUHwfikah3lWTpQdizhUikCVX9sFZJoBm8+F6FIHwvT5oN1LEeD72+dER4277rE5KbYpDVmLXX+g/7WhYCL0+SfxgtjqcJhj3LhijDJlbNESF4tBowam49aDMkycHmeBmKGlC3SAowh+tiVYaD7BQZ2kzUdU7PIY5JB5kpepBuo2iU1+lSeJwQ3WTffeIc3UksEXuzgu3NOEUqq1XylH4p6HJQ7ifPINaqPUSC6o/oV3ro8Qrgx2MvLmRO6bf8BiKgJlPkQGm2SLjqic3lIqqlj7Pg9Fzk6VCZG8ZCVDirYhG0Gyv9SjVy8Qzjp6NzOhFqfKR/EtGIGWmFA3hYUTq7y2ZfmrKbE4upG4webNq1BXsXOhKeD3WdHrFmWOSXKZ5m2p9T9qKgOVJ/S57ENDD6ljnR4sEPQ+ePFvEpR7Ei6sCS7luRRKLMh6zhugYuG0Jk3gRiNcf8kmcWTOHflSDYKOY9KeKHrRB4XSe5a2ZtbgXX8Xa6ZB//wBeXdns8P+5DY1L+mg7v42t0Yv57t3Z9rdwb7s2gdDNC6Z12JAmuAHRpDHlwHZOTOPum2QXyG7d9CcaE/eZM2AMUMM6X0YDgdX77RSdvztpY17qOLNytqzoL63hK0P6pnoM9a6cemudqHoyj8V+KZ1DEVppgEJZB2zqidxt83rPKOmK92loH4HZH/+WZKTHFK+4Uc8Xc6mObVsZof+LwmM++iCkzSdrOxEmrwf8RtUtpprPUPK5qrodcFxUhHfyci9s1fz3U6eD3WnrIQjRS6TPe2Jy2jpMzjMGz5JeKTALL0eLOMRMzxCmg8JMGjl+vbkNuQkNk6buZyZTepQELNFc9qY7WxE1gofAg1foz3BqBcYx95GxVXMXLx8M/0Ma3vkS0zhJ0Lt9ufifLIL8dXx2+d9XLcPF0nfU+DD3B2r4IlhkiQBQxhUE3onS3fv7ssBiPC1NJNCLADu0bazU+fDJNFLaQNUSkev8l29vTcWwoRtjeq/M+Rwor2BdLq70bjAyhYxRBoX3lojgIXd+8eZaBPF15RHg9x0jhilZVppXYRxs398z24SBzNbYUIw1P0Bf2UEqwLk114H1eV2buy/5ScAkCvoFUQvIKaI9y/LwJYdHxoShiMIKnCH0xY90fVJ8riJDEi0dRmJwtyvFqQvJa0Vypq01Ono9K997BTlZyfHC+LPiLJtrOqYXX9UjiVNLM0gqLMAAkwIbassVIKropioU4AemrJq50+JDS8TxKzYLDKk9p5640iNDumZ0grtj5HMl0f5IcrHBxhLyLXRIT2ZrniZ9S4x/z64xUK19GmqOrevSkabYMW35VOlglLCJrEXjoo7a+Vn0GGSMcE4htF1VYfsqvX9aCxCsGi48wHCKtAQt9+aVAGwL2brVes2Gku1oNSFP1LeeV5WQUdHDTQMn6wsXI5OeooNQtHKQNsSwdyEAsi66cawM6NL2LJfNds//AZop9zZf1zesLVcHp7o/xfdVuNdL2+iZu2Y23EcpohoTgX3o7OonEx8cfO2oSGn7mOA1TtfsqhUHHjXEEw2dhCeuRIRsuPzhKR3KnEcTEmTWsp4yVETQ7KXAIiLtOjx5NHUsy3kpR9z3vu6Q4vCaYL8BgDkYSowlfwg6aHbLJTCFCRPUnv1FCZIWQksJ2Gq1nuTIACDq/rA3BoZHbAC3HfFtvEpVKkFEig6qIuCxfZGc6/hqy/gv7oPKMnRhW/j5c4XAEp7k1zyEFFOY7EonsZKWYnkKLbtbi7JLD6/Xz9pk+jSlE3hCNAcbJNgN6pr/53E2+oR2938Ir7acqWLAyJPn9yo2KMfaNHExoaJGtOCwG0nyaLxfDiwSFjVaQp7msL4rvW4O2jlQIGgCTqRp902GN8lPtwvEMyHrUFK3i2cnXqz6N5iV+hOH5PC5EAJkI2+2lvDJjWJ6o4uaikKnKRFTfYvDjl4xt8HUT2gnFCvIjPwfoI8bgk4xjeI5xhxFzBXRmThe6JosGfoLTRy/9alkCvIZxIS0ApqKJZ8VB1MmICYoO94uPvBxuQ7Yi3EBH+Lv9gGmKxcrWevJ7OUTUoJCMReM/A9gCZY+VznxlHYn/sBEicV6IKKSLczmQ8aPwYk5WIW1UApXIN/ETCMDkp37mxvDDMYKY44pGU275fo5TVHoJp3lI6/r9xIEFpBGdTMke8UYM8fcw3m99e2UhIBNkWj3EXaezOET79s6oA+ViaK/wpr7WeV1HkZArVDlThv8S0T8Z6Q+HuVVi3w2HWUehqhfk5NjoN2cqErF0BLaWVL7zIwCqHXd1z9TqtlhnmXmJMJIkp4X9lfsHU2PuCW4dXh4lhyOLNxltHIuVMTdxiNhovaecSHnurf5rsfnk67NwQu5dqEVmvm7Ne/eyEZS7ljneT2HDMNow9AlJ4CBEjUR1AB6KsTfPXwGvK9ydeVlNoheaCyY2GBHvzeERihNm72+kjXgbjTtobWAnN4CxUr7HWj6nxMSCbfX6otG6HvzZCllhmcjMa8RfACPpf/rqHi2UrwHebon8Pn6pfOXD3j8dk0hQOzkdhynxpPnROTLg2gyixAyl0RDEa3exBNS9rcTJnZJBOjb2Eqk7AS22Junn43dVxR9llCQfHwf2a3/OCMb3Z6m6XZfUWm4xVTcUv7qRYqk4J/cczd0SpLGs1trfcRYUon9SmZDzi5+qqJZvMvlciPMMfwRlAJe2wrml7A5K7WU1botCQRwmSNu5Vt8IlxwLvuUIMbBDwdwS4kOxYbYrNyudTNFdWqbyzLjEIIOrB9CsSTm9eQTvACZiIRlLVl6nL7CwdXkl4kPzn5o1IQ3nk0lggdmQucXEcNty4m3tHXorHuE2zxGS1yZ6FQaLj6kfeA/pRJpYNsv1M+v3EyGmtEMISBb4Y85VPGXKCz5sKpi9YCUElHvbqUFPp80lDSar0wD6EerqmZs7AsSsQBiSTpLTPKtvG84wV7v29hmUWI7sqqJAv/y8xbnJQ/LT4AB0LPJVkEu6a0ARBhK+7H0DAUQW26vHMEUs5rbFGlaE3UOLVKwGsddsk30v7UE2hGmFAgjitZJPfbGykip0EPagHINJ5a3OnZboopz74IWYR2XrBrj1nU8Lxzkz2BcF52swRaponfexdmK/iJXhjMFLnWgzqlpwtC6RdkKtFzOwY5+Mb4p5Gdnfvt4LnOax3CgqX+Fj5C4afMduOiqgNq1f4b+8ZfbpQNh1vcaOqz0sdY3tNCk4vJTGPEJ7Lye4t/vFGjg+3jojlibYZI50sVS8PZumbZzbwIeDBSqOIYUPjP7RuKdjBWw/8HtR3cetmVfZP436UpEEYOPFVdiz9y5rTjHLPpxJLTMYiVUzdFTxygyDoUuU3uYkkv0z7vx75j9XxChH7wtdZINV3qXU2Qp3F9IXm+o/uonatLltQqKN83U5xlrbWdjrkSEI+dmQw1nkTJfvO9SZULpFU+JjQYmCHq9BsqoljrdVZCOgZ7qdhAjXmKb1OFTZBXSNxwaeWKwVibdXdzLVPGsl9SYDtcziZikCD6Bo2Um1FqrG32nUX48fwL+FUGTibNCuiIspY0v2Nu/GdlBU5F4c1IiJZbMoRDNVEvx7Ued/RSxitxwBqc3Iy6KY9ADMLDdVfxRolYwcde9WgTemPMb5Nkx9orUBFXKnnUQFg6dykWDgrxnYJiedy/gtXWiy/IyHJ8e2U+UWzjtEhrkeZXGLSvpGrptOIDr9ZbzyxkJ4F7RzeAtJk4JX9IYmvcwuNb88q/wW6Hw/49Jdz24CNOtTBfVKStO4qUh13hHW5rhBO5CPpm6hLTH9q4967v9xaN3bYIsW+V673kIMVOAZpINWh3Cf5kK8zFFXBg/llV1mqyQxaoP+j03R9amdwfPrTNjipVTyqDjr/u+RRQEC3Ky7d7x/81pFQrRyU8ypkJj9QHRI+9EeZvgNAgdgnniOhyXX9ETXNay6LrV0pZjq4oQAWlpjijIv0YyUyefKth6C4hzV8wUxroMQY8rBpEoMVnOQ3tMeANHCOCCtLfNBbhxT1/HX4ZFLR45zAEgZ1PpfApceyEJP+puIKUsNyyu1/Dx+B4NiYiZFgIeMMJP9yw7MfE/9NkmXZ6cw5zZpeb9z3sc0D68ViO7J2N6Q4E0CwzIA72voa6QbEodkTH47qJWhr0RgXt6dIDFtlNgdGCyyAr8tPZIA1h/yaRt6w36b6tkUgj9mxv3py8Yz3XPoUSN7Zcp+8NcwWZmgcIl3ijr535u9xEB9X0L2yHTRquc0+OEE+WPd8qaUVcEmnAUPYcIriniQ49CpNEqSIyWAqhVAmNFpXACKdrcLxHhs6HGIUYvyD96oH+f+gxT/G0B/AutQqAZMlEbf4z5eq1yFNZTrS39Didc2pGRMr1+PEqrFrFp0cN/RslmpdwEVWHcmOPBtaaykXKIRlUFIEENjPDwIykbvNW5p2X1VLABsbE0q2S9qpEXLzXrf2GAQfIN4H+w4HLR+cjViT0iYR+vNXcgxNsZ6dEwpR1XAy51l7csrTKrXugydL9Irokw/GEdkOwhdrg5DfgXeGQ9hNUJ4/XG53UnfgR+ih8XfL+aZiypefm++UdF3ohVHMGN+BljSR+rtEp2DczL8gV7yXNWUt5N39aCIhsuaJ1uD3Z4bGpqD4BfUKso8eMOIA/R3IRtM2ZDNDZh3z/KiGKjhRGNoez8/q0tfVLAu1OqK7317C3+m+ArNZb1iH2x3S5E0Sn5pD/ccmInjPGYv7DgRqaMYrIsFNiDivE6uXwVmzI6622ffXV2V+31KrrZjdM1Bf6gWZF54ejipDkYMjGWg55KmaIPrjibnPsOFZz15RUCIKbzzrWPjZU7vTQDo/fkMXKKEwe2I+Vc7QTE3phs3dBkHeJttX8g8sVtuxcp9eE0fq4aNWoo4RJINIg967rkVzSmOI/vxqdaGjp5KDGV0IcnEdb1dWHRh5cGWWYNP3zvn2xm+95ORPzeeScWilnhhwXNK419ko6orAk8RtCe30wv1/hxRAzlVXxI71ZIsVSaeKNtBS2Ol+c0Mne/9TBbEdfchQZLFzXFlqIRC7KiD/S/gcTFRtllgU7lq1JBpKR1Ck4m8caX20MJmVllyAC/vHULxtSzUmRc0tjm9ErDu/VMmWt2GIwMRyJfGpibHLVBeenzG/h7Bx83cowzf2fE0C4x7MYwNcE7VWnO2Tz58g14OPbiE2NDbrJoYlMwiPWMYXD6ZZJC8Yh7PU7fYi3ppWjZ/g9/XqFUcFzQU/DLtBX2Zza//LsxG6qYML/bdTFvBE78RHm9LXXME5qASsZhe1HuRBDssUrXGjvpjd1df/oDzAATyc3e/Ne8gNf57OZwXoku6su5uymEEVYFqDgunkT04AK7ShoNv/ve12UB/rmaRXWuxbpaT+h5TGmFFfb0KEtMfWtsDkP6unW8zU2yNG+VgLoDuKt6ESjhkddzN3NdLuNq6S7yX3DFAqrxob9wD8TkzX6XRe8NwL3FhHCGUdI1+BWH1n8k9gjoTIAeQpDODoHLpDwlU++18vX3+CxN6+Ir4fb1XV6rAb4mxhvdGyWFzg5T/H1/eM21YyTh1FG0HWddws56wfXvy4oet0omV/ZlAZ/lSm4waioLzsUZcUFR149fgbpz/MZPpl4wy+8FLmtetg5e/KDuIXVD6SipgkK6tefhdcQpHzz0JCVu+lRkaVS2eBfQEwL+UEp+5jadWfOtIDcr32XZpHeWVY+gdqoWVfDq5awyS4MKtOZRK1J+hJ3qLyx32V3W0hbX5cA5pGAXP/8hE32dy7zKagIUZGTf7OfAAednFHAl8D2PZYiAKNUsmkPlIGPXsB4OEG7RjdaKHAqAi8YcgpQGGJuq8Ujbi344UOE2QDucG1/4/S/ChGhNdqRv9I0MpY2JLKTNJ/xbeZBLy4sjD1UlU5gqIX/mJM93ukH07WJ0XSoGJIhnd2f14GPAMQfZ7LdQZQoZ9jfRkx+HJt83K9ay1lyrf/EQvxQDOZC96Q8F55urh8plSv/+Zh7cDJG68piTHQUeObL/KWKAwgKxuN6R7ByYVd55rgejVHo4LAydVLjRR+grkdEfmtXguhH3LCLPZWT5raV1U+WYTWHe7kPpRbVWf8RPLMgz0/UwYzJL6tpaxznniow3gCBJOmm0quJ8PYVp4IFbL8MRnKxxxSaSO1/FNx9qmsI98w4qeZASfEnRfknWoUYthIc5HIyXtw8VAfGq17ITTZhmnndX2Jvuzf6HJNsJxu25PlDiv7v1oB4WR4yndCbApSoJ+VHEgrpfvHubkLAwYHrxre6SCn6wKwXcNOjtWoclC9/KFsGAYZRvzz9uzgQT6oMH1BsOEm4ofsm3/v965YX5MV0mvxBjzsvAhMrdoVAlrHXUJ1QdZmkmiWQrnwj8mgsArb+HkTsIBlnzAMIBwzYsIt/MWOcqllL+VVRaQlng9Ch2Oyj+fYtu22UUW86ydljXvmZfptNsNbJL1tWInZkKZd/6JXwrThc+j4sOz382/Mjehpy87VdSzzL2FYbxg1PG+323ah6I9SZ66ZTRmLI7lvAoxfaqTM8tNy9o6+HCA72UUdbkafnlMV37kC2PLZVxaUG9YKktxabtllro2BzRSZ6Rxjhf0oi5mSgreUtdoDseEZ5D5Ii8uASgpaVq+cwklRPx6tVDrLrMuk/9BgLizTOfOxtjx8sS8WMwHDFlZ9QcyZcZPfVl/b4XaXIux28T3E2k83esTnGzW6j3vMdxEuErcAfB5VghOZzeGLBY0spAaHNVoUqa5Sd2xm4rm6mj8PqWCCaOAXFZXS9+MijnCloIeU4CO9qFfg6QfAbUmZqKIglO8rlNAau1PK5/VesVn3MkGrTImT/KlUDWLoY+jytSOVKh9sOY5QPRCP7yNV3Gs2fGNZmQQMQpVWYrrG0iZE6va+IZomZAKpb1F232Ecl3WcntIwQPPehluA9hrLIUQyMnhPUjqzstEENnw0zc4MdG7xbdrMqZX+p+dUgqbJJk8XuOmid1sbx+DxpMbUR+OhcSkZBzyJ5SHREHKao8s23auQE2kdpeQZPEECL8imTwhDs1Np22IXh5rEoYbZ0znpqZv4U9dMUqVgrvHSsywBP29RnXmF9pKB5bCqBJQgDvNhRE+CdoVxIMKahAN9FnX3Wi2ho0OSeNxRWcfZ3+0Ilcrke+DwBdUxiUO83h2I0p9U7ep0X0Bh60abNISJ/C+nu6ysKXNqTbRbltuFI0G75HhUN16var1QN0pYUcgQf1HjhPOQmmjXs7xHleNXwstTsMTlBYmJp4QZuuPaYHHy1QyuWc9ED9Ltqdc1hNUf+G+Xq/pF8yLJMQtbEi69lW43RBtQCc7wlNwvxd4dIlpN+9O8py9B5911UaY52Y9xDPIOPo0V06ZyuAW4cj33+4aLK0eCM2ZdGySWEnwwRqVubnxNX8Yur74KQ+TzGg/SvrzsAq80EPJfhxMDWQ0himmuoleQz5M0TcDkEmpSM0QvefCQMo6L6y2aY45PjCea/4CpBzdLlWDfZLsLdsdX45AEvsRXPI4U64ZyrxiT2/dgNNjsaknOgSrbBdsm3kg9f22BlKkD0AvXX87dNbLRRPzXGzWPEPX9rhpvH311Hr9kV2mVzv/z0THbFnEv/zXcF9a2OAPuXhgBLSEk5ygkEN6tEeIKmWDoPyI2iR463PMnWt2gaWN1+9+bDAz3vpV7dudFr6ny9wNTJpfB4SBGJ0t7hq+AGBWZEpI5VhpMcDk34hu27Lrn3kNJMxlOBA1XG4azk74CTfUciRD5hbKS43IOeFKs+mIjmUjYyOmbsZKUKqvxVkxBT+V79AZQ+3GR5STyBO2bn3Qnu6oQr2fFAtQFqgUG0+dl9pD2l2n+bs55Gw/XBHYeyXzJTAQXphhOPzRvrHCCByayn+fVcN6pHaQzicZNLPFoxL4Dtwl2+MecGjQT9K0ENLpgaEYWVZ8CqN5tyOJmtueCdlWCZZugoIYHcBYvLLfhbsz7FevJUW27yyKebVrd/h3NulPVB+mwI8NUsEueZtrmFCOgoBJuS1Mi+lygqgyu2FnUJkbV9TfFDBhkUgpbwFy5A8t+1iigQ8B3YJKRItdnLWETzivfpTl30QdKzC2hMeb1/WGypgP3syP7rbnZrSzbLww9X6wSD0uqFYPWqZn6GQlLCQIw42QtdKZZvCo+zkksfERZbanVYqXA2nV56ltV4sjK2w0BQT0D9PyRABqhwEqrfkYQ94mCJNVXAp5CnJdDTyyCllTwNzkcqI68Hsb7qE9WfSpzITOZTQqYCA1CUe1e1vWXg3a+s8yv300hkInJlxEVPFFkjZiwvV9oqrkdzNFts4w0rYlOfPn/quz+e6qeVfQWdngXS8iWx+PGtQdahwSG81T3sL7tI8i1tdLowr6W40EX5QinHiEHP4ZuyePEV/xJE1RGL6nub0+vUl/q+Z+1AeiFCcuOhZf05Bfqzy1EBoq6cqESu0HPrHz8A/NGAZc4uGhTS7oPDvOUuqU4AWNOuc676FLcLCvlJjmo66qFH/DZkLgslv6CZqplIig/5sD/iil1pj/x1ZFlMxwUMFsDyZlzt8qSC2VE8coOqvUY8kN/00U3GlIkGavkP58NVpvKmvY5RD/VIKyhusTOZKnhgyZl9LyJ2Pt2iaFJuLDzu/farmbd7MnqNQZJU5liTXw7EqWKbXDpeuplkAZVHd6AUogCzHXvYjiGQq0AyQq0/82aZQcMDjzNAhzXtM9KJyKMoMO9o80C0UIjKi7kCByZ9mYYYJNrU79LSi70AdZT86oFJam1TeL9ylMCLWv5jPG1eh2tCbtENlqYaoGX88mseF1HRNdt6qBaNu/Nh674HUxuIQEEIRamP6/FSMm0prRndYM45Gh7VjHBk7cdXk5l00kT/JTlw2TBAn3xdodd7Vg978oCfrpudMGDvAbq/ipXCt0FC6//qgvlImGWRLR77V3F+zGy8rQAJl2YLJLtOOc7GeekYmFx2ct9mEuIUrlIqFqTeQVBnpbp9j6eYxTnMfa66Ak+BtX0FY1N+prjAaZ1twoO4P8xBj2UMYLEUAwVBEyWp1nR8HSCnNFrtxgw8NvvJSLySmKBZibA18//luemIPR+m8LGU+gffmgB7VqyehUoa8h6M6lUoaUjYZzChGgfe5WdKdV7WzZvq3AovnLuO+gusV22hM9IUaVewGRHUyz2pcmt/AehylgxdzvIJzIRzr9NJ4TXRpPxr8arNPH5hL3+vpwxhvUV9bMfpjSiYA+PnqhPZStVsVnnu9WRDkmsG5jnUhtOekLvSiFeMBuvgStdcYGz3h3cm3hss+uzUHFRZeudY4LRXarUzEh74XMqjQlo+qRzTBS7+OlmvFBHqdM5nPmX3GPBNfYovbJmbOs2iW4NAno42szQu8BqMsM+ENnXg5Hf+rigmaTQPXl3+6yACwJBzY9EK9WfpnNWIIaOdXCSkXS2QJT/5nWvBE4Wex1TLCnXObRmpUqRe9srvWSxIXPk7nZqarz0/e0JIZ55frRq9+CQTem27LA7hxSAzH/dQkkw1lu8R2fZL8pvMVCTO3buK04hQDxPne96ca/O/FU9su9m9Ovx122hUzAnkDRLxFGWljTF+EY5JUcYpxiWMI2Yg/UKQ1S5LXUojgs68BFVglW8SVbiJJmP3+W8V3mxqcr6hUvTccvZ+lDs1U3dLwypkv8fEuzcKfYvxYcS3wDchX5FXRJg3MzWAMQRdnVanAlQ2CBECTZZESw34ii8tthPchtrqPSUl8U55VGoYJkJzn16d7rAOULkXMqGzcTSythlwShINfp2h7qPDZHsaMfQxgiAIV2pLwYS7EE7nQIhcBMkfa2xoOEV7W3IduTq1e8aOuxe0GQEY+vy8wMnyDPBXZ92fAXKIFq0RI+rUXmVxiY1TJhEpv2Scy7dc8y3cirjZtpe0ywmmxw3uaJGs3BPhVf5M2SoVcIZs/PGrvM3UbNBuBJtXt1HE+Zl/QrlxJGflwKJSk69Mhublvnk2SshaxQGPz1P+Q3/x0wNwtMCCqbsIij9WClAlJOA4SbVjYk8Up52lCTX3iuTVvvZg016r9IiraPQyUbZqyb3w0pcR643T0ehCuWEUGNdKT6c2AxsE+kR+PPXPfy7VQTd4lZuUcIeyXPZH1ra/Y5p2otwGlMmzqF9eeK0pD8Q8YncDpd0AXtYc+rF97SENLuLKNv0XHGgb+M5aq8oGabu3yiO+oeg+c6LicljreAvImRuKzQbdz0J1iF5MMeECmVwIPFG59Cx6cX+C/8Gf188ryGohEPrroYFXvgEZHFobJFbJi5NOcbvcW+f9waTDGR8Jy2rIGX8guoZ7w0qP4LJTJ0MucHsFOy23++Y7faHcpvYs6uirgvAzGffQ2yvr2/JmBr5PIgdHuQwDZlVzUKklnBtzum6G1mxGMu4YEGPF8DEmGou/zSyQaHJe9r6Ydbk0eiaEM9Ceq3sRQQf9iPhl4rvF2tAuMU2ouh+cBVp5gZJh11cwoazjcmkRiuB85YziUqfQX/1p44iaoxTbbHR/tjajggdNSn9ro77y9swFThyTew5UPuncCfQsCiErrT0BXPJvk0iXhNYzGOKLJjqId1ENtKhrdYYKP+dYpS+kpHkuV5mNT7Ny8mjt3N+6sNHzhzpEQrv1JkuYYCr4pSMbsmn2wAIIz2GNm54FvShrbmEiize20FaSiMhREF12vRvotj6RkV9Rvk2mEeNzE0bh5h8I6ATGkji3zznWEefuUpVuLVKwM59VGTpQdvdQFup8vOmyXVoP8bH16MmxyRVPMabyJIkKY6eQVpWzlcx+X5iZjr5X6Yzgrgnr2Ut/PBzIY4TDiuh8gK016EQMd6tu+AxzftnP7PAGbAUTGcf+R1jN85yCOS2hcGUeHADDbR3G0XRB4U3z3IoEzQKz9+mOqDwnMT/EVftbp+nKmb8+yczR5XwzTVZ0Zi7CdV2WdTRDd8PSpxPZB06Cz/1hhPHq5yt/TQ5+l3EQMwjuxDITLutzmadYGbzHSjxV0DpyTN74+Xm2NJvnwsIzJAOnyJWoDJq+KDiWaZ5uXZbprEtDvTbxzXieDgLsNBTX/F5aRceZjYLwvQiWHSum9NUh8/LZ5xYnBj9hjTuCkyV2YPeucNl8x4XIPs2EyV3tyRqLD/UhJGVlRjCLY8V0uZNanBEluPvj1797tFjn53bvMBMA5otcwXM1l05JkkNFqGjxbXBohnMSbwVdqq7g+ZfrAeoH5dCFoOus4tvcvIFzsPczwzchRtkBsJudwq8CWLvgaRNiOlRK3welysuTnlRIyRAaBjyyZHHOkIVzVXxUlvWL8KpcQn4subA7pm0QxAwpQizJaDCa3DsrAFRZ0dzqDE6UWCBE85oqa4lrDta+7iK5IDQkEt9AIJ75cm0PrXkTr0RLmxwykPK6OvO0EepNAG3M0T6sBLjaSE0H0bi6An9RnGY9YCYSnjo082xq7PkvnwpjwoHUZqoEhd1AC4VGajnKKGk+tFfphjh3V1pU6znQOLcK3vkUVBF5xUcv+xN1tkPjzr4Bozsz5mcB3R7e9vxAg6HSRK/z/QOIPBM3jmcjna0ioIAynanxm7jXw6dnCbOCW5RW6uQkmtYuJ0kQhfavHqVRzQ0rnZ8WK9gTYoeXGo1fYWcT+ZsraPbWT9LxHqeTCDxER65avPw5mbTnsWrrO/tUEzbfOyFcTmh9k3U8B/tBWy4tT1R/uUcUtzcH/pY6+NIX4hKn/ytxvbeXBbeGbEiMbrk6IqNIZoSaQEdavkaM7qCEQjuo2UTj48rdje11dMgBmF34OmX2FDMPhUeJfg8BGPvf6djcb2cIo1NbT6ZPERHoavwXeYcydS0v2/E8ry1a1OzJN0XqPS/E64B9TxjGwl0XezCIO+3cVBOS7gf4iLx4v6YwVwjLiKXUJVmVlledBD2Br5V3UDBwuLFFXYgK0eRBbSkLkPlMIH6cRv7wqnJ0HWYT5HUoGYmtH8n+z8UltD4zChL9+GuNWoc5I7Dn3p7nZDqHwlGZ9ieOFluViqPW5/7tW3evjzDDKjeZCc0cgokpDnbv78PJkdgW3s47yVdk29ykwLQ6j/2IvwtLJuKT7rVnsKWbS9x+wBpax0/e4WOTwk2NvhYHv/iW0sXE/25TFsRiRLnd/0UqnsF1v1r6bCya+gSJm5ep3mpcSPVjrwSktntGEy4zlbksVNZFq1QkfXjXltqtg+vk3gvatgo/XLlYl7wL5YRRGlQzdiaX177jA7H6lvwxcUTO/b6CsDTfNwsXI4N1UQ5rxMfNilwz2QLoVYkQbAf0o1HQbBkghUgSmMbKQQoZ49RXKn7DFmHIdX+dw0ok7JAdgm78fEyxfW9KP9hi5wi1F92U/pYjcSeHq0TBBCWUqrxiTogQWAt4KIekpTOVwHfAOh8cIjA6sQLOdkM8Fm76dwoaXcIHvXkZrKiZG5oGgK9EIRaw2DNUKJOz45FNKc8M7c617HdBYkTVc63R0vb5TuRqOA17gCxFj49iCnJJnjR5bWD/fFx/a8wnDAIVYwbpfRSMY7ski8sQcxBOlgevi9K9r6D+uXhoVm9qKZ7rDL6ESy7BO8gXFiO76lt3mPBEjyZvoaCwlfauiUYuu1Hiux/cfEuew3mXeZox+qC7Z7MWKStJfmdD847FRl5cZVi4Qg1/8ptIIGmzki7LbZ/fkt17Bmsf+P81u8y2mHWRmmFBpNuE3EpbHZYRNrdl7CGsbXwG3G+VgHPgFAwh+LYFWiW/zIJ+qCmpGuO6QjxzbSFTn4Zlz+WbAj03GrQxWkjdrBt35VKDy63Vqw+CgpyHG/DO/UlyynwzM5mmlRpYRfwmXVXTEZk2dFU9vSbqdk4qv8HwInbQ55POLb78WtDO4QhDQY0PRzFvk7HrxdSz1+1vD/GKdNaw0T7PdF7bA575rujjjpJI+dHeSvIOKYVPLRuSN9jtt0+XIxaEuqk6kpUUi3aCZBNfUAH4JxTxf/LXYErk+xFCdtoUcM/RZb613PaC5XsyIM3okZXsDzfCLHDz2MfKtwTFaBCJLCiunp8/LfDk3/7vt5bVWzzsLX6H4sAXH3o/FzKmVxOm4iGiX28wMP/i19qKUaa9hoj9edg4mmMGUvXfhYmk1J29FekBGdBLMLWSbvpxoq9aMTJLV8y2T01jnFuQux1cO+Qgd3Wmcv3QwzKJ5NzFaRUZMckeYzkYZGfIdbmOP2KMjjHmgHGIqJuqR/VJEvpLFOzyjHVTLSc2nDxKTGXFJ2jGfgoZLh1nUWHpZ6XmLAdnT7shh7eRQdjrMrKjKigfk3SxhKhKIxkyhCyJWjzO5n75NMaHZceknUprE5jyqmEzGAVzvCcTi0d4nKFtG9GatlI/SpajQqSX0OhgWmNuw1GKSMA7ejVGB+CtcnhQ0efReCs2rEkAm6MAgEARVxRBlGpHm+QSK4EsyoBIVIM6MaGEgLkJ20pubiqAkS+icC9JNgU1ZsQfD147+ZMrMm6ouPoWZKNBsJSSyjCuuod9+V+JOM32tmIv6Oj06/vP01TqfzMtF2bQcbFAzH0xTbKirVwtM6ZCefoB+UqhPvR8y0XN4rfErRZvtrlpOajgFgEdEgNZ3zJBGXU+OqcY+DLHcTpD2jhjOHPWs7cX4yqDIECmizjGdKKZcBP8ILK/8Hb2AuI171Zv6UW4DnqFdEnJriVjiQvN4IZnFZbzBrdbqwdpQle2Otrsu4TCcjmQhDmdQPJlMbwd3pAIZ0wQTu5SJ5AHZpjcU5VTGrc6ryeTPjXaszxrIurQWHlcVkTj5ncxIAvq8DHrvjzjFYFcmT7K0GcIdPctdHavQMXZTmzNtywK0y6pFvxLsB3yoDR65z3oCCf/WtrONev4KWTDltdMv+joHB52o9p+2R1oMEMOiH8uzGeLqEtSgaKwUb+itWF8VXBIQUVQDR9gsA8NftkGxuypC5VXpxS1vcbl2EGKAxn81HQ1BCq4YzkdEEwV8dd5k2UyW7Y+pao9E8mJIOl5VDrJXcRsIbW4e8zuGYdKqh//rRe+ckuw9G22LrfeorY60RvUDkNf8dMZNvN+ezTc7hrQIVepJ9ci3OvRWHxun0fIFo7bv5b/MbDKUhFVNYn7i4+Sb80gR5r2oEGaKoLhRAuJ40fVlvHiuBJQ5nZ+Dc5J9ranZqXcjEXbhpd9tEF8nsKf23jBouDfXsPJhmv7kZ374VkoD59c5sUITTyfONS0JenaOGZ/TqdBsrqkzoSfusvw12cRmUl4klWMSUFZe3nyv9A20vjI2R0NfsaqayVj8PzyeLhvU8x+bQ5MVe9SIcAzOFzmQ0Cx4Y/3uthLRs02O7+OXSuwJwHRB9kTrAuLD6Z/tImCNQOBZ/1oHO2i6YB+fS8zQMdUxqd286h7NaYe94Pomilzm5gzZ3G+7GFoykUPj0SFfYLppeNm7y27G4e/NFxNlLjcToTAj/xHZq0pY6KWG9ehiFFRLYeqSbw81qmOUlEFN3z1a0DDV2NE0xiWeux3XlfXOEzsoso59cm2ePBwRnZZfKsMtzi+o4cz473zDWWyjK0Gf4QeGv/E+9XT/Fk+8TkiR1h0Yz2Bg0FQCfLlsJsQNEcan3k3ZRclvMI4a+o90iokhwpdTMlrOq+x+AYfkOC4k7hng5rHOOb0/euvBTgXyvGhsgMepsS5/ah+A91SNNfSavZlcGEL3/Q6HCWkSAw/3pVerfApzmYgLKPLVUkPGIqCWAn8N+4W0/QCedB4FvY9J/p3LZIqwiQ8kqOne8zcB7HQWaiOx+lN+/IH/+2GbW1phuh65v/AvzTg5xjwmAGkKrP3bnB5QRGH+tw5NzbiJoXAgl7VHwDO+Fq/QnrGxOJypBVudnM3fccTsN/t7i+8L/9iI/9xjuyvVySO0y4t0kndsLkj6BG9EkPpWFthlcF2opuMlLEBT1sBc7m1e7EN0GSW4Jhqu/caoa6WE0u6tB8Dwm35P7vaL+LjbQN3J+/krK385V/+7mnFl8fHsEoGzgtQ243gjbW9Ta7tgS25h1BZDnWc4Y781eC/BAxPKCIvFpountWPgu7JQ/Fm+FGVZys6ScgpBhz3mXsZItBKK8dWrGTJd2fhAjQlQdlX6HUkjm/Q//x681q4ohJ6xt64cmAoPAxBHGM+r0D/A0Da6ZYt/v+cpuja8raIFvQDVIV5rIwSDyYsrckEXMKb6NlSRqzN205KW/trHcDysg91HKp4DKfiTMTI60NodfLCSz9txg+nZyP9jrR3g9Wb0aU+xrd5fzK8/SgyfLQluIJrMBvzSOIwY29uxBQS4Pm8yYT2WM7imAZxrrwYddTzyaPNB1dbLuM3lSMtIe5Y3PALrvYfnbXdKRSq58uoOuM/AK9nVOMYSbZwxdvicm2mIyg0SIMAkaGB5GZEUzimNIyMF7/Y/rniTb8Z3zAF9+QqSnwCwh4/Y0G4E3sugI0bx8BZg9UvKdAu2uXzhK3wV5CFrXp5YwEt5jB/zPLTawVpDNIBPiCpbmt4q937yeF+IcHZkJr7l3nnulI/n0zTAAWjiAg2PYHDdF/VqQiRjmxAHJpkI72J+w15u/Q8SAQ7z4+sGVkLCPdfxrKPFybXk42YMGIiWYDB1NHONHb27WThE0dcz3F6f42xX/BS5xZKPpLBYtdp7GPBugZZkNncruTq02bvJFSSI9uw44y7XgOtlF859l20e+Q16qYrIwaCgE/4Ysfb0mZhFDnuTonXsqyy0L52faMTbqJgd7/hNQrQJlJQ1n1A1oDZzQ3Z8RL9tE/XUVqcizWPOc+01kR1mhUAfKrUZvZvU4+0cDiy6c6wCV5dSwldfsMjFk/yBMBl4vJhi0GF7LaQjQbQVKsDQFWo/BFauR8ZpXIS5Pqr7Y1nGXAbOHa4PFf4/MLd+1zPJLKTcwAbMVakTCwx36YH4OO3aWGCnGqj9OrbasROrsfXx1n+nvj3anOG7k753RA2mxwt22/JWKF8opbSyv/HaWmBMTJc0UV/3+20eVpyrWNKGqrQndgA4g2oyKe7t8FDnpI37jMd6C+g0zy7/q0Blq4Zc5m8z+fgmO0/iujumAknyb2K1szQ7pm0zVzq9UsDYPUxHB1ydtmjFfeOYlOkPZU8pN3VCdspWLNNn3kvZBRJI4ycTn0LaaiaTCiNyQ6gM6HsdJ8DI3bu7PuxU7QlbIQH2DvTcdic0qXNjnL2PemB/Br3/esVX98wplM30GgGNCMSA5LKz92ANpTzgPmfSeSXgui8fW5oGwuV3ZIN7UvYhFOQxsyRikBK6JHB5nMWjLjXvXiHVul61Ul6VEg6F4DZPhVcxvBAeCzFHvtcJZyuT3q/M0qeKi3CFZ5JYTvOGZOTJLKkFXoNiFoOR/edmEWjEEEjvWhrph0HuTxJf6YI7RskUxkDIjVp4RMivpiRwrbCeBAnI37CLket6aEGI0vCr58/V4lonAlq5P703oWzOwYotz31lrnuhIhb/JCPbPo9h44Bu8ejmvDSF+ADkjMmMd/6dvNsejYXSH0QlGFPwY8q4o3zsAA5I4YfLZpB64EhwQrkpUImFqHeUa1zVpCsNYvZrbVBFQlDc4nTlO97rJh8gjPiVxxP7rcAgzpxEgtExASb+D2qsyFM3az339e2BC/V1vnNnCd2cQhC4p+BobwAvBHRGPFOz3pw2GJAqm4Te6Fekts49uTJ1ss9cnGYwMXOB6xC6FfbJXUGvMob5r0QDvYhpbS7z0ko6SR/uu3AoOv071uvcX5+xVZpoqz+290vcusJGrIURH3wB/vdz8oEvT4GCbKYNnnGcBAnZTFBJ1LRFbv23diYq2ag/tiVpEQHC6rd/WLjKbzSDMndReefWw1m1WruMTF16JDo69VfKhyoHFkB4UftrwLvGgOhWBTXMkQmE7206lA7/fplSOlq6XHNv+TL9szQpshvGj8W+a2x6NElpjK7umL0a23orjC1D6oBcdjkMUM9hn50dxWqVPC5YRufpcskDYKSGYW4suvqsRkUxVJLBtI6PLt78m6SWwgFMDCIOW61THWOUh7sjoM4uvkp7V5IUvTZP1WG++u0dgiyzUmrsZJhk+Irot8xGCcwjn1KuN6MRNpVxltvHGXULymbAxOzKlf0Ad2SF7NObW9klvJ1HvjXyhfkRm0ee19Z9Av3rPX8xOLcZSfVvJkApMnGJmIFgBUx7D2zg0La2tl6FxXijaULH8/OrtbnGD0/QboX8ofC4CMXjYRpngeM2Bj+PcL2KxPx2EQVi2bG8Oo7TbpBMxcJzWe+IHX6xb0zGBu9A7Y3PdXIizneGPrtsW9WOhzllaJAxZuwgscW+SqRu/gf2JZZWsJc5sUVu0983RFsx+/v6NffqV7EJoua+EHcREft4EdBj4Jb5DzWIZvljuzzJyvLJbfBbBuLOqzMD2Eu4rsXu3exPGEb3r7X55YpioSlTl7Ef8c1iMjejEAFWRN+/22hl7okp/yXg4nZCSDC5sx64Uf0cEwF2gVqYAdMAuJb63lUqVcmXiL4gZzeMQXaW6QMs48kOLqR1sNGcXuig+xIq1PG/sH+/RlKVTRJ3MnEG8+SeTdwlMTDAdV4z/6TG+OiF00Z7TxTp1SfWe7yVUhbLa+XPy84HSdntCEQx4pTSogo3748u0/a0z1CzsavPMPPJnnSiHLCVzHsHgT94q9vpa8R8RXZdOj2+0d70Wo5ijvfp3vFojkAYB3+xj53jpYAtOUgiA7CAiOx4CcJjk7wtkZhRWOxCFAPSQWM/TDfH5sCX0xwtgvrTqwlUMBJ1T2JjXAR46KExqzQJXsLeY5MhpnVVRSvT4h9q78ROijXbQARSfpz9sMANXPu8QixFMeu2cdsX9hr2u/cPZzSnJqh6L+/SyVODVaTnnj2nz/AAYjQxigbW6S7hr068npO8+Vgr32ZWzza2dQJK+zNx5XZ+0YRHRRZcLLdte8LG7STYZWw4MTdbxXmreGE3JPC0IrgD2glsFp9vStJS4fCvowc2s257uVR64tnwbn5pJPMDI1FCME3kfsFvYZiDoyaDkBbGooLPuqvpJa7UalHgXlKxPSHchbGCcfp35agDXa1dBgNwdjVHtGheD60whS56q5frWV0kXh04x7B6oY2DjWMNjJxj8pIUZ3/cE7DjLw+bgLJRajweH/jHonDU8hm8+tJISYvUV1Y0jT6HDPHdXcutcue+12Z+oGSDjLb6XVDa/yn4U2xs6g8TchtBkih7wpb6itX4FiJzRknuMI0wqDAiqH6QZu4qdLZMJJKwl4ty7xPlODI9hRBwPS2hAT9hAk4MvNfpZd/yFvEpDWBLV0pKMLg8QkOcTR+7l5fMgSJKOwtsxlmcuVaW7Yqeh3uANiZmrVqVw7pVZUbogegWNCS73h49+3cGewonQi04VOpgX9oUuxAQd6+lQQ/Hv8Rx8S63AYCzm1VCOx4PD+aR2VXmYHzV2aUXRXTNlzEK/DGbq0Wm/pXKus4j6FuiioYUu06JtHxAYw29q876DPgLRPrzVu7azkLn59dCeFbUNTH2asdsra/KmadzLXvP6dP+g/9o/mfSnse/wkKnOAFDZoBWsKUq3pRxD/y4pmazsnRS+kdgMXhhecsnfpb1mIhdw6k82HAWfl4m8IWWDuwobbuZHLjfERZ74SZMCEwgaJMSjTcBzhCylY0pyOXhcQ9z2tQEnl7XXf+XJmrPpv0WGWWSsD/3KRNCZLwr6QNNgzgk6pS9L/ST0gEcHHU5g3rTHu/RNHNCHedYgXJjOsyRZXuvLToqmBvJ/IFrPbe1NMofazNQFKsJN7JNJhPADyvW9Tiepg49sOsVzoYa9IUCdES3fTnZwHrNJ3JEksJD3M6YID8xf7IRMlPMMZRwb6EAfcQ+snQpnLsrJ/S8svmr5mG1P3LX9JfMS2yLs2zsFOY9s+Tj9pOxQZws8zdFfQMY2S/bLvsc8kOZyF4n/Kg0H/ytYjPPk6MpS42e1/vZ9bSv8Ld/BUWcZwN+alF1sx5g+bohaIu5PgdZDbuKcPwuBHz/w+8VQIPKyDqJwtC/fo5xyeT7wNLRMTh9syEmN2uPSlXXdmEQwSbCwIFzqTPyWKrPfv1uaqLZO/sNNvF3iutp0zjmL8J8Iw3KNkY2tC2kP/JAfUFYDTGyWr8gfZRMLhAt24RQ6oMW2xS5CnTayGhyZSmuD8XjSJYoSbx3v0hjzh63e8sn90aR8CL+0MvErxD7o8xyNAItSj5DcVnhxD2NC9+0b9VxGpBGUkjecEGOoYTwC7LrAW50X86i48JUmeZi8KQ8ERuAyWROlYXyWHBtYpSiMx+kZ91CXAOA9pEQS8sAMX/cApBev/hwtJzDR03WsEAxxGdtqI0eq+jcnprwPKR5O3VUy9T1SOjIncp7dPvy8hpl0+6HkPC18wTS4RKH9YVL5s/rNAShffvEZv4P32/DqRfP7kXnUKM/2Ua6F6v2In8pQxOwt4KxOrHTS0hZi9O2LylnExpqcgGYdI/FZlLytBd2GVY4eRyDty/X9KxXWvWQ0WZffZ3GKD3daYzhn2LJXjKMoJcrkhVUahI3pDJayeS3VADuw7PQaI5mjZFoRaRI/BUt2EGYfdvKFhyj7I5zOmiM6amYUUo3E+8kXsRTJRDy/LzpgD6vw7xPD7vVRoY6TxB4GpYCYVHyDDQdsBHCQAo9mKPffNQ61NPxemexW71GqgC4BDvqyaq1+xzsE8QB8bdBY/QyKoNXHEch2Fah5bxOb9OZwXCpTH7NEqxEhBmadNz0H4msNVxnqZlvnLHCCwHdv8Bm2ifS9DbHIP1ofshQvdO+oKQQBsxX7R0bdqf1BNWv+QPeztEogvhRm21VDkNVRnIJUHN2oARorCoa3nXQUzbiNnI7lcwg0lC1OGMze13Y4P8kVoGua4SUW8Ul8/hAkA17CQLAuJcFl4jhL42SzPSCqWA1DM0I3Ce45qgMhL03Sk3aylw8asFRdinLvSHYZrb/DtRgcArG9FGHgKPn8Gp4aPYA8UU+fwX2+Nd48zSn/lsZa0A7TXTePes+EVmUFNsx8d2F7tUeBqHqGxuWa5ex7w4LDYNV0qgT2KOkw16mhdiYGqwAKDszjb4J9TVjoNoOEtSZVPdMq95tTWy8S0azv3iKfO1uBOQ2xd5EwtBRkYSb8OtEz1K2sEbpvDWmHsCth5auhhKNHND2JvUBsemhNEBLjKZYga1xe8vR4mtZr9Urr+4D8V6bPm9jBI/jaN1n3dWjO2zMSDN+LVut3UI9J7EYtja5AySnsr8zQoUAIIbpb27Zse2p9drVz5ina0ad453cNP3h1HDLMg5gO3bxFa2Ni+Q7CHlLjUFdRkgLdenRVreeAoaAURYqyt955JHqiQGUg/P5cI6uhYO0VZ2KxWFpjTsNJ1HNFtFVLZcQ9clmVGiNmhysbTG22lo9yNJV/gows7TtN7OHoAWVhGEUYjDEJV50ISF8WOdM/yBl5Oro0RtBd99I7yOUiW6T+u9zulMBNerymk3pvS5gm3PX040NFWbk3DbkPlEulZyToNF/ov6y/Wi4XCkEeJsZed7NV8WNeH6U5JWNSLUiySE0tOEtxsrz3//6mMpXloVDCMy39C+a9gmsji/o9Sk7zVeGil9LboKUNK8OW2oJvVyarq/bqA9VzBkOzBeTJsDSTkfPpwQj8ZZdf53upLcFXyjBLwG88yvZ0CRe3sF1ja4QBLGbI/iMAd9YSIjfHuh7l+2V1/8m3JUqaS6cooRhbbZJ7EGZkdH8fBysBvTdcb5KX9CnpMp4KlonaFWUpzlYfoAFP8u9paolzBA7t9xqLe0mFwnNp9Yg0tIl1C9HYSuqcju0zcF2d+tOZIxmuMvXKrIzYVWnINWorVu9ONlWt84un3dlpg8NmDE9/78LWn3Ch+ZAYd3AhXnMUos/s4zKo+oNg+MzJZwSJHSu0ps7qpUJSnAg5VkFWy0/7WWBWpFmBPnvRXiRuw7O0IFVlLTZHm0eswlBk6ZRaBeS7NjwG+Cxsw9OYxdeMcyRUedDSiVcgOS0PvbYVqnzatvUefssmpJJGxEcYVGTrSSCs4jCXZDtY5yniJnBiNCB3pCVJEaAL6CktXdBNEau2uUfJc9XB3oiHOyGsQQe8NAtXfvIHD8R/rx3zzoaDs1dFDFur8QCmgIdvs0IwKAxAGwCv6Ict3vD0x/3g8GyZrQVdyr4NDO8nDyVCKCzSX+oWtMg04Mlfy98CgJ5G4YABWOLP0HvTRz6Rcg5T516+qbUuMb41TvV0VDl5DXO42DihKdTfFaJN3NSKGZbQE3o17iRfCMxOj2au/InHCGTep8MOYYzmOLPFtKgZG4OZhIpoyyAUTGyWq3v5cyDCIqYxA958cHmiZWMJh/kMN9f9K+Dex2EGHDQGNjLGwJTG87FVrmkaLuvPmVMIJp7BHw8qGo5whsij0Q4RLN5EqjzeFeL/3+qbNQzspJ+XtQLLb+jLMvmax0XI7uAiZN/AAX3cQ3awTLBFqsJC11IAt2rBAhCB38Doi3pmvLg0MOFi2qugOspFrkbPxJGWTmitiNSBkcY1qd2CF71OllwnBHNGZpgEFGnZHJ8K0ouWR10mh+PEKkvWUFmzECQN/3j3Ks18vbidzAnnuSBDJ6PRdSvL6WMuwFZ0OFJXHHPrdtLfIn/wEsbIFBchn/Hq3H6IkjNDpQfLe1//lSQqSdzXSp0kDcpQQ+ZJACrGlXtaXn+bRXffQQStkFUW2S8DagGEbZhUBQsj18TROUy/rMfPfEbBQFDOjm5pNd18qy3g6V1fK/VhIqfuzcYqUWL4CIcmc9Dhx6pM/FtG12RjghJUbSH0ZKxbFrmAgmMvX/sHQTeBUgn0ORNCsp7lKLINueZzQ+X+NS6+zBNCea2wueKw4Jr7N3fF21FMeMbsqE3BiOPn5WFmEmKRdLp502X3RGr6Rad57monNLjjHCLWMC6F/wJr4JVG9HqzQmsFjapFVdbTJPd9CYmEC+EkEYhfzbWvt2kL3a54K2e/FNdLrHSpGRfcmOzESSIVB9kr0sFdWapSC7Q1ITApbfPDtH7ay6l+J2tkXeSi4roJobGI7dAHD0NngkwqowTx841GUx4AGXJ/NTMt4NhKo209TchoXeBYqlq59lbb5pqOPozWbZzQnScikWiFWfNuDc4MK8KSgbLQDzanvxjA1oqextCgeRcurV/Qkc+noGtLgWcgsklbc6KVkJNJR7757km9931XljZGOHuov0/IF3JI4YnpI8x8u1/Uz7VOo2RHW3B/sik3XFt/cb9ZZtEn/qTK52lGuvUdAVpY/LcODzJC6uhMuyMXQrTCOXezP80YKqlAD8J5yRQf2s8A4eZJCNjjf93CaJQlquAMR1H8MtNeHAjwcJJ42NigRNs96nuyVF4bwj23AK66Mypn4hZ8ma8IrntQL1eW9HeDp4v8RjCS3OCOqOQ4/Q/6u01FqtyXeUJDuxycRWkq0LnJiptvtZMba/zvpEtHdJJOt1VVRIzOmODaZS2srLqNipDSc1CjmB4mEOxgkMX/60DZkcJlegboSzsnh6bU0nMYO1C2XVF7Eix3WjesqdKAaXZ+ZSR/aZYGXIfxWa/8cYVp7wy7D9viAQy7wFH8JM3hHKBOtZ4qmwJGx6ml2HbFecLsg2v4nMLcS4D36XDfWhaM+D3l+ZH8gfWVaEKlxxNlZnmZkj6h6lGQqH8tweVaNWXQnHF6PJS9FbngSkcxb5oqxtTChDcPUm089i85TL3IjdhLFRqrPa8MN7yYE4tuRYdtFDmMriEJ9kj3AqvvZ72//512rQEay91fGK5zdjRLO+coayL2J+GR9nMFTpItvVsI3beWED7zfWUDQExiXEqbFQTs34cSxdRyBcjvFiFZIPYQHbWMTXl1C0TzCvyBfqxEPrqbMbahGdx7WEkFtVxnC9eX6iVrQj0ntcWMoR1Qna7ljDT3EUUzu+VKSiPVGSygppMnmn6VXduS9jHgDOTO2uEQrzL9VZi6PzcKBpSW3GPAjUZFjBeEx0hjCyyvnHrnIqQu4gUXWveNlJswceFoMpLjKBvGJ+rWuS+VhS4vkMhjB+5l0NwMkAUipCI5eFvLnfZcMRNVM6UZYQCdG6cVQGk0xNO/fv0XeimjnTxZo9cVUFjADnXFykat30y03FLo0S+80Ksispa3P7G1h14zGZmLbiKCrf8PeAgYZC/V9DvtDmc/FE0U8H/4vEC1hEn+AsM6X7T5dEPFiwn2ebHFmtiVMmJXTAid6OWTnX0AK8FyNqFWBRW6w8dev5UZJbg9x4xmARjXnEp5jT27PE1HeGeE6xuGYLNdF1D3OSP/iXu0HKUK8KCjzUTti5+PHRL5pXPdm/4msd78vJoRGox3L11ewJOBAsRChEK8iEh5MU8QLnQ4BPb8Jq94WCuBJOK/6L3rmVRSt42dZVxU44VhDL5KHhV6XcyFu6fd2xWryRqXEKLjcWyfHayOOuOD6yA+huHFDVHu9dzqifd4zOlZlTkxWP2FEMFBtM7Nktl7YmPOi3A159/yDMumZY5NdhV3229LbnNRRcFaFDcb7OyYdI9aMlM+Fhu/T9CEBOMxHDIMWHGlpspI72bi+CSEkYEswz1VVZDI7krSM46Ep9lzP/Jtr6zQI+QbNawEEe28FGQkuNx7evTnxojCLQlIIKn1XhbhJ8zppx2qeSzQwkH6xr8+Y9z/Qhh8rw/AKAIFpeIdZdfQfgIV3sns54Byh6oiD3lU1NPXRHGauurkXY/kPhsrlR++Y3mne1/qtl5Rjdv9Qe/UE1heKfxbpUKlWLUWBTGnA1fah06yyBkVunEvTSNe8DufhN6uhHx/05j0YBTkh79r8w9AQaLCDx0M+Y/oVPb/5b4j+5pcRCQHnp7BEL8YxlxXBrkhRkTqiddwcOXO6y8D4eBHCx7fpxLbLJX8vqMd6MHM+YZKmBK27GM7F3Ebx6Bl7EEfeKhGhWyJLDMVd+9Fj4zpX/I5HlaJH3nlqpKLTXpolxR1eY0UT1vnEkky4M22Lo4poejVWEXV8Gj5nTVAzYr1YYR3Ol1ijwIELOGZO8FNjwrXxxEjWWshYgIovKDZPwsJt3+xUTLSbCL4vGRTXl6AvKLd8UmL+Afo8PQWI2btEYISbX8brAkcJ9bYtTlCdU/lQPj7W3eUjE6sLpHpddbFR4kn9yk9uRGuARp6nwaC+XSU48mZ42Ln6PNrXtZ5NCCBOBDtjqe/ZzNjSVVFpcKp25DCVLVnn5NMElqxZ5jMxqQ4XAtr2LwjJMAMSF5cpYrZaakDKFyrxlByHbE1ug8lxsLV7M+90vbspTMTxL0asGRnqxN/GgMTGwEoukiatB6G/ADNhPXpoSWD5rvInDrJ8daUENrM4/eD6wFcNmA3FvCZPXafU4bk9qiUXpuz7nuhkqB06wW8xJ5nu5+GPyBq4uGDmEJmANEojsVjzCWfh9e7WZZ8su92kpsw7XhG9zfS2XS8feHoCbUjKhXfWv3LJUlWRPZDph6FHlV9jOILHCxw/vjmGUdYIWXN73Wzk3LshN/UszlBivb1iqxvmYZvALa+JUA5iFMN/g2qvsNTHSKqipEpWL8udicDCaYbBe4ZqW9sS5dHJaAh8AKFeSLPUKXrWstEEPDGv+vJViF2N0XVA9oxvBL89urVRH3i2b/4PjcNUBvuCK5lMzs+r5pyLv+Xd7M6nLLIvEAQqLYsXO9ChWI2NYfUCrrkX32IuSAuxBkCDNQMk7fGnMmK7gW4Grd34432iAaxr6a64Hl/HKlbSBJdXiAma+qHjLDvQjzaoxr7AGunw8FFmVz3WKi8CQiFknGol5QZCfg3D28fm8rYGjdenbtXEtUkXTYbH2VWL/fxMZYcX0L/VvYbSizjk/AnDtBMFekcUxkgnnr4l1ZaTMkDz75HF6iuhEvX9XE2rzmG6ois6WhYdtiAXUy6YEeqyViHSuGySegdoyDNDvJwciH1oBPQ/AaO3RFnCBoibTW+PBqBdhm5ztiT6AaF1HnCpQZUuL2+EVUE/Hgn+mYgrPDbXY0dKD3PYJGvw5a1pzIu1mk2PNAZRFBGG5GkgaIBAo3dBJpe4mcyUogKNVG6UK+MeJq1gNCOv7gEsLRexZxEonLRrrRQLUFARy74MUjI1Sj6SQFUvM6YBpdo8UJ+GFS6WZ5vMMwry8x3fxl9ENtlU5zvUr9l++BHPM3xEffgRWJ50AcnzfPvPglAU9tKJFT6G2k/NBGHLNk9HrBHAnp+bW58UuZdiJHo2NyU3kVwgYdr2lIJyjVUAkLK4NcHxJwMqUmLDRWpRL1OY/1S+ZPn6gbNDTL7XBbHsjItbKOqZxV9g3i+jWStNiXme4qNh45HONcpLHJ57+g/bRT8JOt2Tu8YrjrPPvMMnLY2+hH0jROoeN2qeluuezoEwmIqQfFt30yCDFpzYadURPh5G+t6Dbr1vBn7p986lQpvoxpkD3B0vS40faIOrw5Le+78mQSqzAGemW82KWca56ZfOvQgmWFb1yNNReze9CaNXdtfuJI9jzL9a9ffe7qWfVftcXoNJIJ01GZC5UfEMIPs1LiyviCQabOB/90GKGLGgJZ8KRu/vfzf7+E2P0lz5MOBuTwAo/tnpbsQEH0ylFUStfU/QJ0bs0drWImFDTH0iN4gxA4eFVw9IA4yM3BgXtBn7Ye2J9wGHte8dRXpEsA//vyDNRJ3c+fxNdzDlkcblgDpInuVj9NwQ2G//Pu0reuwZiFsLAkdSyyytd9fWmpIRY6RamQSbjf8d1A3pMdhP6SNmQbe2fZ7y1RZ2OZ38o8fqTJJ3lEjEQgO3ezGrnZursXpHVpOC+C6d1NlEAF3QkQ9pWUsRpDgWcMFbw4UV02eZI7mvDtfEwsimEYy9mv+Ayeo6o403GfGcTBjdM82D+X4bXQOOKmiP1XXuF1t4ACLgmGBlJ+XC4o3BzlQ7az4Bd4hq9n3ioEZvM4JVQN5ouQ9SoSAJRainx0A+VBv4MT1TVxp/zy/0Mdx+Uslv4JOyvCXZB6y8h2Lwv7fvaBZngMtXRTNogkikw3HVgotmBQD7QHCyqB/hZ3V1lqCQ6XzEWALBd68zZxcNcJysnpAJncN1l3v7Q9G8+Rf8KqOkcbK+lTFW+SL4yvIQ/J9fyPTaTiLEGOZDh48x1JccHn9P+vBw/EFE27KWAxUrR+ix2DJ/j5hcBv1n5aGDlStxbKXzf8FcNe1qnkqx4Gs+NGom/4EjM92i3Tso6jpsr3sce1nQloNTaSROl0Ev1+jvJb3Wo1kxXgDomjHDFSSZUhvttLe5zt20sa4jK3CksMRssdBWCXeonKwDT4ryrrfWah+Xwzga/+uU77U0rTcEmRxLHilD/Yo4NZwcIuCdzVjuvDqT0V5kiv4rCMQMj0OTvCkrIEmpOvf6gKI2QcLVgQPKiN61n3azQfOdSC17Q19mIw1pBq8tHfcNi8svxz8jWjT+MSmyE0sNfUBoC3skNU88GDUcAjyC7TD2OmGG9jxdqyvb4EyHik1iSiSQtMFzsezJ0eztmkAMXYYgB2ZiayooZufuyXNv0JXBOayYdwmlqLhspzGyV/NgxuoPFxoDSBQ4vHz8h4QsfYoRTIdp/e3UatTZ3XgkKv+KshOnII/EM9bjifPcOg223/6a7EfZ1e/hpEhy8Ltt9Q2Ze5kajUkBtpASMB1rCMtCmuOoE1L61//gqTFSlSq7uXdD40tHqK9HBwthJOkcDz5AuLNgxIXaZ+XuLC3OfmVWrT0SgyK1eXo8q4PSUtmtv/PyQ31Sa3lfCva1gwYZFAYE3N8+4HjfY41B6a/6ErelcsoL4qGlW9yHTDFwl9GolpARrzk94KIHT7CQ/k+XRXPo0AgKAUkFiPgz40YIs4Bq3SugrACvS0dBPf1kogxIJIPHGgyKlsHiTsH1Z2hYiYCq1Rzd4r8vR0YtxlTe7/4mYfFUZVn49ugysSvwtbfY+H1etUl92bclS/44I7swWtiT9JHXnmO+xmfx8a6YJLbOekXADREUUZqebX5lB/55EJB1Zgm2XMQ3f/RMbFHQAyQlR8pWpo57fpL5Qk0Wvx9YA5BGEs8HpWxWt/b0qgxoM0TauS5F0H8OaJwW3AzDgEilVUUCGEBT5it+iDuxxh2PPugM4MaV59S7+PKn1umqE+nWU+m3r9bfIivzHzWaVXhWijUNDvmRBgxDH118lhWGegnbm7PXYPTZecsV+dBdwAABBxflVLstEQM3QeeH+HPag9H2i9XahJzk/flzu/ismb8xWXrddJZ9fcqMy+RJKu7WOGRCkoSFaCBO7kv06/4L8+wkC6CNUmUgx0wKUhut6KNKCcEEIoXYsoxpsLxzpONDC7cPymnHQOxAOs2Q+y2eBmQHV9yVAu9NiKmcySBwu8/HR5n6wEPCF6nvhp2JyCUEn/1AXfG2tlzu/xRQoAc+Zu2Uxf55Xuhea2qrpOhvpn6YRQ3OfG+e/bdG1l0htmihom9Ar95s1FfceSCA8Nxz0OBXjqrmL6b3qMmIONgFE8ul2PpJt+7sngC9vnAmOqVEVdv/dSbXa++U+kMWT8jNfpy4G/giuo9AHFcVlpk8dP0v+5cbSEXzeqpDof46umOXkW/rh1GGnCKhIMYNfZQ59R/jLkTa+KQNTsqRTxdtxmpFTU9RcTX6h+THxEgT7T2vN2I+lZPyuusrDKkAdkBYxQSMzQCy1wo2QveKXlzapTuv9MR1PSNTtL0iytcYw2Hc+o0Q/BVRjklndesSOkXPQuu7vGHQHxwFWaPglHnGoBo+IqCNqk3nMDX5zrsFujmnMfnrqEG+/xbUclCVBsJ16EaYM+XpDxxGlth4m+jFcB8TuauYF5asaw9ui9NZqV52xUXcc6KUtN++UCPaLshD3Vg6M8XbWW1jbKZ1yIeiI3pzbU4IueK59IPbWq9pvufDh8zrV33WLQuExy3QH+l4535t6xZ9KtdMR0JErPVyrkxQ3FaUuAUSMatrMRdlpYyKk/je/Z42xo67Jlh+iBqmA/dey+jhzFHu41hJAPhGTCHqiXXEkKIyohksP7ku9BGgKV+L6UuZPsziQcJqVk6qfp2p9s9XP86wgBX2MXNNm4eL1zMp/43IRdSndcZS18MYLrWiTplBNoDmSd/36eKKb7TAThMs5unXijCIf2372McUAqr2XaQC1yFm+Ese7XMwf0CzlygxYXqbD1Ce3N4ZJIX6hg/K9Jkrn9b47MUji9wrOWggh7pW3FLTnNDaVQ9dfZbMWonix2IrzgmlYYCjSVjFMUAceczgXHOZXS6rH0Q/xxbHs5/KFI9V8IrOc7eCLuW/wTK5+jW2b4jjxjdDV2p7+h3TpFYpUgXMbkI6m0Csp4UbPtOv4KPSNpgedE4vkVGCW+re1zLP2nKqUDSgeebwjUP7ffzqUBgEsOiQhQ6ri8qslRpSJ+w7NTd8MjHxJ5LnCkzfPp9XarNkuerjMicOZrT3WICI8zz18olKJuv64AtaWOK8GXMqiIUql4PDSIsJyvGIjp31widrsex+QwsQ+8w66xDoKFZfH22VNXO2T3zXX2o1fD8AQ+GoqBKl3Vv3JMRc1iUL6gVt7gNWCgVKXSTq5aYL0FYjgfsSlb76QQiAKpRn8GU4oOf0CvbvVl+QOgBpbDhclA40Agbl5GgsUBGwjq26yTbqNmAkq/ZH8P6W22A7sgnJZJNi0GREE9mrnhxqvsTg8QlQie791e6fz3+0KIiinsf/o4CI6FmX6amKNfKuyiSROiJKUJkkXOMpwmBIOUlw5qs5/C6jrUMkA5xb50pQo78AG5QBdj8V6tN0WCXUZHjTZx99HP9FnCnBrudjtQhoAI40Ms+HseUXT0OROutsY4unKzzuWZz74qHk+EuYGXZ7tW1qUou3upLrV+wDD2FOuGASW29kwSPWqhPgsUZLT5djAl3/U/uXcedAlM5XyjWe+5J0mrVqzaKuAr9LmjVywJPkpjiJq9FzIRs5X73L2PJrX0joSnD+KJ/AWkFnOxU3hb5UonY7g8uHltJBSFtWt3NBoId6kzshK0RDL6tizIGsDhkrONG08Tp5a+ucUcn+AMR8V/GvKEOonl8BBYwE+T/WH8C80UWcIcRUxR1v1TP0Roxeu5wKGIYxWdBBSvOkbDnObZ3GgeuAv9O84jDdZoLatgeaz9ygUwhlZQgYK1DEad4NQGjz/qCNwzkYov7J93ocYo6r7X+8NtWpWHSB08E9BxBb1QxcgOao3Tn7dlI/K5Igsd9dLf7R/fxpPLRw3lgfJz8iGDp4PdXPhwDxlsGIR5EnCUZLyMgT3+f4czCrhh5k6s0IN28yd1uYnqwIrfZSdw4uYQBd9XIMg8k70FrWEESqIi3UeAYC54YKKZBHTayKyNrOODZ1CvwKr68ztnNAHQ4RE9qsUAfYTiyCXQ2SQvJoaB9W7nfXlLt/tTaaIOLfvtatIHb1ZvLD1YTp5PjDR+shmFLJ7XEkjR7LYiBADYjmSB2Llp1TZ1hKPn4N8PuQpIyXy2HhhKFJ5qXtZ9PR3+7GJnCsKl/tYBKlaPox4ji0hBOciPQDvjooMG3519MKdXxtZGbe4CA3LsbOeTxms6IR38OZZCay3VTmisSRb3kWwbNJufrTaPMhTSGrr6V4zYz2NiyUSF6UChEZcpJ97HE9Q6ziD+g/nE1eN9BHb/1v0AcDBdTSzS8aURNUqBulEp3lS7G3uojTxIF6LVkBKHgHvIwq/c2sMh0q9IM3Bzz9N/nEK3ZCf/XGF0UQDWw+y6J7odxk7nrrpnwfK7NTgvPEotJUXb2t4mU7iP+GczyzfbmYSY19lrSPeH0oS1cQvpTpGV/OirKp2aYy+zNataVIVWUK68Z/kLbYEND0+UIPhGkoPNkTXuS7w1vFMmxsstu8F0uvE7myzOFazKPawT7xaXwwT2vsoYzfp10cEinFgSYzQC6bfHasd8j+F7YNtzf1sBgIEDoAzHMXT8mQZKopilaapySpi1GSklOTvXEeAA8RbeCu3AgVaqpDvRiyzfI/zDffjaE1E121k13uPiYeuj/Y0iB/Kol4eAQGTLzq503irrIXDJlq+LaG5Ei0XcK7fHeqilBWi6mTKFdEeIr1BWo2jZjcfP5VocMBqAYM/5W3tcD4j0quUsgKzAZHIQQhWmV1sWY1sjetFCh140XZyUCrbrEqQl4IeWjjASGDuuSgHFsPjT9HzSEnG88zzYDlT40EgOL+EiRT03w1bOPkelCl2rq0TmGfIVbEplGFlHzF2umPjfrl2nCOWgoKz/gAie7dw24y8C81aa96yw/5NVN0etKv9xD6QGMIUEOQZ2DT3k0RKJO946iOUNIYMyaBAozXebM30LmNvaaulzmTWVr3kAybPAnH96pImX63/kurVl55RdSLibdk+aQSif9m+3Ox6quI4bCl9KCGttUvBFRIazQfKCsglgnfDZO+jiWq/raNvTdGA5ZjXytfGkCFxdEEKJVrqfGv+S/6l17d76k7Hyi4Pqn5Cq2Q92gfoqg4XKw9OCwyu0eXhcDzBKrKWhdMVLOsOtkzLKt/6meI+4gNHeYGB9o1I1YXTMtBD7Y5U0gNXuRKNC4OCaIPOqk2bvEqTRnYd9een2RqRCUqbov+78yYs5ke5tjYm/gtx/NwqwqEPyvKrzHK0EUQqV8V7fbCVD1JhLzFP4hnveBBFKxpUDyEbShsgKHsD0L2jZlFDSDuRhVPNA7pxPyL3A/dF8t7J4jLIWpbF4OS2Z6gegaiv/ukjfLr6NtgRNkyfOqc12ybcxtJCDsHUtjdFItHeBRkSnQEhFGqO1SatJyMkn54ezoU7Pb5pwidCP1S/LSKDIwk0BIlUsbWxRaCHIFpKPegu5YNTMudJ1A9tzME+8fYvxqfK68Db/4SHTu5uLwFXlyhkXaP/oCD8GmAka22P8cWl6UWNBKvJ+jPVo1uKX6kEYcPf1xqD2IHrO1Ux6koGH5yzchjW90/hS8SRhVf1rOkf5HGQjaaqqoGOd7+LVNwpcsrbzeCMiRfzEgT6k9EynR5GlKdAo32joci2n/dgk/pMh5UUt+pVQBjuHUtLklqc+x5tHIDBxAIjQBGo5L7NPmxlQGJFeky1QIAvbeurR46DWb+GLTscxiyft30jZx0YYRMemydDiHcFqiQD9OrRD0T8bNSASLz8zs/9qtmg9EANR6CUAhcHd5G9e+ojdCGcrNkCliU9P5R98jsil9PX4PvklGDPErgoYIzuSFCTM8nKw4RhJubdt2ssRMow3HfD1eKytWiPtUpsxK/ImHF5FkVBgW46Wq1+kJMkYjiA6j9Jiw4kipEVbfNO41zUhYYwvd9Kiyk2tTkKV5bVPV8Un/5Vs7pd9EfsVuFcQaTJ9dp9Ca7oxjliFBOaBGgNek26CQw2tbq79kD9x6Glmo3EWVcmVy40CWH0S5mqmBBnJLWuBvOzbLQUe9yZ4QW3DaGli46n7clQQewaFrDZHA/QnvkxlQ7xBYNA1Tv0tr4/jSGQy0BYbbOPZnEDsFl0FRGP1XGS7hhWP24WjOiRA5GkJT85vpzbap0bkcJPLUg4KPLY2nQDgz5Z+N5aK37LFeFqftq9TkQiP3CzBNN+TuzF8m9CdnPLxE1QUQ07wXbuabPcj007VAdQonGPwX4hd8TXIRErMicLnsiBq3u6h1ihL4uXgv9hY/k4+UD7a9yB91VNtoBjbx0o+4yi5V1E2NBGyJ0R79CzIdP4Uyda5afTmK3MHfHhnTh94NIOGiiKcoZ4OWz89/LH4gqHin3LFMMSz2bY2yhJsus/Z+fBliZPS+tGU+LXgIzf/tRDGOX1PaY9pDEYFKpa1Scpb8RnQWgTv1SU25+rd1Jxujp0pMxwoo5YonxgXaBMaOUZ9zS4YvonnJPIjotCZCdbkyK0eRTP5mO6BaSTQ+b69GJGc4Tosl1GWN91SsOHx43wCVyZIsWPlpapOJXCJuOZi6YPlQzXyPUajMSf3TLWLsINBFuiEiOpkvQGeI8n+hAomHceBHOcV5WaVtUopyrlo3AbP0Rr95UH+jLEtVpGQms4RUISWtG8ku9xzy0gELVtFqlK0oyRYrGVZGEOoyjZNr644HtS32ZOakDpiWLFkMO7Ik9AkJLCGEMCox5ig2ly/ZBncsUePcPgw4tW8aGOJQUYIYnXGCYIZxUV58Y6Ilj132ZB+Fcoqf+mbcveI5IP9KszyjE9vU+HxDcOC7vVx0CksX+yTLMtYW3zCryj3aofR7E8u15jdt/eivU7LNIyVeaVUsVNVi3OQ5wV8VMvvIxGOItrPaVfGHyHEWz66z2rRGl8B1P7H7XHyxzIYApnGSZEaQR4EZVwnqVqkq6CNm4fdGvPbyZHzkUM1m5wsQjHr58ScCbYJhQBc/Rta/88KLqC4uEZdQfM/R6WTDU97J/jWSHx99hGScKsADp+2pIhmjyJQxZwHezomdJPbbewF3HiwLe0tyC+7g437wvPFNZEAsvHNqewCblABvohOjCSfLuTi989+hhFXsWdM3Jca4El78KfaqcNbZEldZT1In17aVMn+nYtJaSIdr9r+6yyoBuBrRxQ+UUGyTL8vtVTfTe51BWfZNtEf5zzLCSf8pBMFsV9H57QxnEDY9MBBmM67T2gt/vZxc0AETRSJlRxRLLniAKoIPBgUUuL560zIfbDBsKBfJSvFpA6viOiAw40x4jqzeb7OeO3khul3q1e7vXjoH5oM6eOiGpRfnf3AYNTEmy9YzaUnGAgvZSZDoTbV82TlBIgOtRD7XJdxtXYAICWEk6BA4417mfuqYgtG0YUwXbbLU874EdTddmJ3kJUbn8kZ+GZ+jspF7K+F8fDL2l+HS0PNWzNFNcJFNgYrCIusCvcQP30qa1u6P+rxuii8DiFsP7M5Lw9zp/recuFluYsybW5WdEB/26Z9H37AX/o+2f6EuCYrVNsr2o4KkufL4W84dEX2IdwvCJiLVCjJD4hir1Yki3Q/o1XlK/DfUxHL+bWcqTUiazE+SZOGTTVpGjAkQ8js7l0tIMttUc/JDyNLKG5IEjw17iuryKYPkjB+eMkJztOn8iayy/ZUaPyelG/LkjVMIfR3AD8fqGHsNA3LqLzej3SompTTIkZhCJjTeQN6ZQEeRCWBcwczE9ah/lfWSCf88JhTcSilQhO55G7nA0KNJbwA3VvFAfAMGq8u5xQex8fJX0kzmjqwauE/PZT5RF/xAzTYhMBRkF5FSIEoqT6Zx5P69a4Yy3awdH9QC6mV7mp5aTfTzRJcElvrJ2Us3QuL8osjP8YhRhuwa/3m6cxVspHrRvMoxJrJqHdGyRx+35MU+nMKUGaxkvtKp1GyUPWY5nIs3HBl8vaSrQJlL3mAMvkZxYru6hGeQ1VNCJfjN9lNviAEq5HutxKrvrL/KVmORbt5RaaJxVJBZxDpuVvxjtVWC1Mx9tP6YnwZb/uoVKzXzijk9H4+E0QnPyCSQNAtPQAht+V/hFcqM6fN7QX2o0WjvD6rh2esLRiN3j5q+bERZRXJ4gBfSUvnN9eQ9DRkxCGaN49jG2+kro3ld54T/vWAaPgxkHheYbYSL1Y1kxCHcQPuvt5IUkm+NpbYr2PNPmNLwlUbUHOn4p/6oJhVzS1kG/jU0un4a+eeiQvYOqEbBcAAiSCSPt9Mk2EgJPDq+JvRbb03F6BGnhdVjfRBSNxHC5lBvz0IkQ+Yw0wbpsNegs0mH1WHBFQcOG3r0VLQDF1D0ShLZCXJg4QUbQiUwE8EPZwFDzdjYVtkRIBcdQqoEYqKBXtk7yap7STKF5ir5CLyXdY7JZYEmJDdRFZk9aEv+Mac3yuqPTQQKAoPGOJdZBdQ4ljEeQUKRLXFKHEKD9CU3g2cm45pSPzl5Pbim3AG9zyArl8/3xjw1nkajLzgEWhd2UYSepUgErMHj6bK98BnsjkHdTY2W73ICESvFQZqynojc8FUYqJZ669dF5XoRyKzerznfdyX7wEusTVL+B7/V5N0RMoUnE2ZjkB7G6mJh2y7BaTZlOqotj+E0ozKFG07cyyAYd8HEmP0b4c+BbeIgP6kufWqIA5k+zafX76lO7l1X9BnKJHTEnH1krmgz2nquU7oYccRsoAaSfn8o+y/rdcTOx/ca5ERBmaOFKgVZhXm3HZ29gFIFNciWvJTdILcTau/2KBLlbXztr5YPRzAJckCtP2FUOtjPTHee10k4IlnshDnNwNH4gT2awx6GlUOJ6PypZbodZCkW9IoO5Rpe6uLmNAlcR07EBjejVcWZ6LEkmO33kcradSApT6xE7RWWK/ouLACTDdihDjujrT8FKJAFri9t5YuCalmH1pLCReeFfCqefkyqgAysrxNf7DFlRAtnyCcpD36StR99239c1JjTO0uCBwI0gBGoHSUhfzcm+dUas6zlZ6Sr5TioHQKUDRho6o5lU2Fm1qAeACjM00tswm6vtu6Gl7cG/4FJLGnlkQg/2fcSgJQXEogl0Qy40jCscsev432R/0gyJrsgLUtVrMxvAxWUjaLIUhH2bqUh4teRnoXEYEUm3BDMJK+47pzvgqLneW9Umnx95R1cfapt6KtJ9dkd5QPr/NoIkvqyJLytVnZzXYAWKH9R5z/igEcQHgDvXAmMBZjAw1rzBwan4zJV0UAByWakD6HckBzG8PmKffNi7WFbJiBTEgJ/S+OG6pnkBwdlYQJ6dJRKVf5RdQwQJ+pI0L/qW5omlOIlWTaRN4bVQmUUpzZQdzNQqCiJu3fgD1Q95ZE9/8dPf0jWMfUhV6Kk7pvfOTO2dCEzaFbdoqUp3Sb2jfO9uXGvvG3zJODSrnu8trk23cxXNwa2GyR4m7B1QLxeiEEdwEekdGkxTCykQJp4xe5NCLMsA7jsY711q/2wLq457+32EK+wcZCXRgX9YZzGT1G5VCNzvciFplUm35TsBOOvNSRlnrfZs9zv8h3PzSaXGfxPiDrXvY1HrkjhIl3GkiS3QoM0NMhMvQeXnuG3q5QDpz4izhUKZK7oJ5chpyUkVfcoRR8XhWYTWFEj+GpIUzkxWzA40DA7qdKQQA7Y1vuaVeRJpfPjJi114ffzkPG3snMzU3kCrlJ4IXCOnEL9Mh38oBQ1SxLuFRRslg4Y+h8grAGYMUNZKpqrzzU35ACB370mneLp4Nqbu1wlg3wczNkddTopQ7XbLOrOg/lcKPjJCZrTef9bZmMr8QqLka0OTXwvhy2eERM8Eb6FFkMDAy97a+ac1VfUB1QLU8iXh1zlnt6qGxUiZuOufVKJt5ptWviQlZXRdHAcxdxspACgu5oazIOOk9IxeJBhLLDN4gAq+1W0n340MLfOqGd0OGIy7Cgd9XjoOpJl6HBIwNvn1ac05xPYvYCNhVd5ovECZ2dXwhph1WMHMT+Iog2aMfy7bMjAm5gXmG3ETnGKcREdN4qRqy5MTtYGyTdHYin9B0f9NoJeqW1DloeqvR61mqS4FnYavzOwaC/M8Wzq/UOuPOFHauIpfZ8W7f8hnzyOLxzqrhUVDWSDZYU6IiPHLztPeCBKzja1JzPRAFabjhqmQ+vQEUcj0DoNqXy4mMpK1uZ5a3vwXFAcauVyiMCw0Yxlc+KE2LgK1IxW9NjWcI2aL3zJ4ilsaGtB+75S2tlaPiTtyyKvdhSvutOWUFhR418xz4+iTlCy09Akt4O6KZUkTqGFNa73zu+rU7u9q+wkOUH9tZmGs0t3YSy7r97FSWu/kmDyukHVcLpUD83DR3oaV2vjAmkNi23TPOHeG7CZQ3gYoFTF7PWLJSq+xQ7/0rdMIvgoLjQh2SDrfC3D5PDs/AD71OGK3o9KBHY84LVGb0GAS398N+YFrurZpJWSkmy0CidO9/kCK+WwjQOxvGjJ+54sFz9B0yQORK1zsppWO/fKRp/FDgHOWOuDERaL6KVyQNKfnQxCAtgPMxQc7rfw86udUSFa5gVMx/Op9Ez/0LbnOiTVTpfBub+MCo8JHTpJlKs7IYKbDJd9sosNd+eWchMfRr2RZQnRMXpZSp5vLWzhHBoyf7+7BB+2krKspkUjR32PxzBS8VBCVe8TdjUqJy3dtk2kcCoATJcIBvwfnb+N+9nBDFaeT08am+yZfoOepehIPSxb52y+HTHT0bc+1SDR1qy+Y7YWaCBNIEr9FJu5CClOhiZ7pOy0B9ozOQFad4WYJpUxsPfVnn2bxhfQpSkywTDysw9pYKUl8qkOTBnZt7Eah+br1+FszK7lLf8blG8KNPgJ+3uTs8XXkmRdwe2PU2no2fyoczAIU5vh6Xyqd/jHHuCNwwChMu/NguaTBPgJ+/WMJH0R6qEhxx2hrLjDacRkshsyB1I4oD4XLuygtmDjjx24sIEWXPrhTNQbKUuJ6C6SY5AsL11d0gKvVTJ6/++Tw4YsUF3Jdo/9uUI2TXwUzLNjZ1UL48UjZAMUxAMkCg6voEMgAloR4OUTUtrEv7xU02G5Zd0+aEklf0IqJEur+xLfKGsceGTfrVqnoBE+9yOxMi+0sIKd5Et54wHyD8KvGXPOh/X1shHk/aAg2phuvxC9dfkGD2qkwxPDjqj20cWPOfmLiIWR43pE1roITCzO7PfojBajZ3gtzPijG3odnpC3s6noS1fjeduApL9ZM+UhkDTOCoCseZvDkbvNdK6zP/Uuzc0NojTfYIhqYCca0ZnVJfYdX7O7x/n0/DrAv4N6wWJ6F/rb6OyI4bI2FZhq4orcG4U+7cwNluAfkjafU1pYnAwy150AMmwNMNppxJ9Hw4ih/CGEgdIaCjdojAhVsjm/gvWF3UFGIaudG3OZiLJOgpuCnIPxr8VTPQtILYzOhhICLjprJRL3LKNaVy44Mve4Y4NhHjh245RiRfZN9uuzPsNvpSrZ463igJRwMCxuzXB+Im0syIEAkXIwEcsSG/gbgsHFI0nsTEm1PsxwiN1JbQPVVhdngZCAvKdzppVa1uLcguFqEcKZ4mq0YAZD2O3EcClCPndxzkZW7K3i4uA9ogpkHfd01zBokCh0TGq5HBeMmqFlhzaX0ycJikitumSEdOPOtLuhE/PjQe7MZjDvBPeey/LP05GKkaWUpUT/RferqEVXrTzPoJzbkdP5cvZdyYNTOP27TwkwXLqsBgbZv893l+wFbyIcTKyz5YgCSvv/Apxq9DofImEWFajnCY613WnBRVJ/ahWhs7mYyl3imVGVTStfMomsw9DK4eSMPh1ongCGQPqhujpoVg/QDqvxAEiNKcgn9bKY98BKahlL4KAfDokUS3aPJ/H4f4cwWMP+evnriWoYjw7JkojTXvfWPuv69LC+UO9WErb4tp2ghyOW1GWvBxG9TWNjnPu48hDoTKY5A1dnkGT8KwhqTLIY9rBd9CJ0MD5NWkBXkVvBhWYfiw4GbLk6EBz0NfZyFAMSOPy7NQVe907sUQWnLTkEllXOEs5GZ+mZT9zL7jFvSb8HfUeOwS3kf2+BOOUNDnatQxLnQmiT1YluUeoAOtvnjDsr9eG1BBPzF+TREuK1vQ1Di+w4jUF5XRYLTBjLK/Tk5T7LO9LL9hMWvMdWEhETeBNzG2V4IQgjYYAlzVRY2JDw7tOtiXtZEnFW4U8MlW1Dgwrplaa1qoTIlGVICwn6szMrbaSYrelFMDYpTxrOIz/e+ZjHfxdvgmHWGh3mHmzMUA3Rg4b3H1eGc6NqT750h40AzGp7mv+IXEBdlR1Smt+ckWq2eLLRAS8BQ/6RPGJKhFmQX7tAiMoRhIqtFb1ZI5G13yb+aEIrWnjZngeWe5d0kjEEwUXb83F/7sBt3AFGaHhFx/vnP7/lia/VzwneBHeToaJ6lyUwLu/e/QBsPxk+WEGg4Tvw2jlF03ytcM6SOZFkYC983KOofyVcobbp4W8JPDaHImqvHQNfiyQ3nRo/vBYm7z9S8h8/+CbaZPJOSaCQ2cE3n0eB+gyvLQ0tKiav+Fn/EZ10LhgiPCMb1SEVg+SoLfMjbxNQgkqxATbkFwzXYul/BoDIqRaB7mwqZ5ErPcmdT0BhUGPE77sjnlwrN+WTDay0YDL7KpmjeVVkMJnJGihPoRJMdWMWdtljZokO5wOd4xF2s7vwAuHlDrsl9csAIZHkvdHuhO9NWW0dYmMquu86+Jeun84Y2TbCBFYg4X8aIZCdMSN9Txuy7f+bVr2XFgJxtC8+oOcoqBPWVHk9m0Pxc1QK3yavOHOBpHuOVKIh4Lrws3DqXjRXwmAS93/+WRCkMAlLp5mwVvVN/DnOe/feJ8R4yFZdD//fm13MqJlkfzCsHsROHA8nTzAPbpxKtHQAOY+EOMo3jJo2kvOWuMnp+jTKMJ2sIalEwMIRwOJOBeefWwmOpHekvqbbNUyZX3xOMq6msD+u4pNNRKB9EQQ3ZFF1JiYQY1EBkcLYn60qx7TnVMeLLRR0OO8d7d/wO0g4SrY/AtsfQx4zw7nFM9Aak9HJIfoDN0vsHiRNNQer2MAhqlYv/VRw4wZyHNx63QUdqnXuFM6RAK4aiAeiujfft/Xc5oPGf+bgsI4KLovX7fatrUppivngVDLdXa4b0x9WY1d0IXRt42LQqumeKUGNL8LT1gDYyAhMdZP1lbaayPV4r/Ua90a5nQoV/7XTtX3kFJn5Jjit6EMd1fdXxfl/9t0Ut4f4C0uvmG88FB4Pve6snWk0W4N7SJs+Hw3pufqSJaVTJo78O989a3n7RcOXnPsL6Vt3aD42ujU1Un3zSS92T/4zUnfRskKWlSNzKMRN5jRV2tY83s6Krjp2jCkJRY1CE3w9vvYQgIyFFUpaedr2ygNJnwNxN7WtdwwTWqw/F6CZCwOc3JDVkJfJs9LD55tCJKP1YIkWV6nob6ZHTRWsLu2+KPPqDWr5lvPkAJM5PXdBHycu4lqmaLFUJjn6uRh7hV8oHuXtopZojJ9EkQbMK+4lCq24aBWH4tAfmv0E/PuZ0DRIS9KG/piQirMh3TZ+iHvCfN6mZTz3uK+nE8YMW9t0rZv+ToAJH4xs/gZj80OKA01JjnLcuGj+AN+eRqMULc4yV5gNshJ/Bi1vWXwUuPHgUhKvMaGJRx3AQcOXxwgxf1O3ntPPXNZv1wkiLCs0MQZJ8IIo+jbKEXSWWhQAZv05HSifn/F7clZbuLadWOaXCYc3C1wLmOF4h7kyaapUQIbYZx8vVIhzEzlZ+tuX+L2fReMH+Mhwzho5TFCK6nWUDoTB3K1em2SmQJW+4RijDNFH4OwFLxk8jo5UY92oa3u1fCbl0nfDARI7KaHMqLYIdrvDLrn0xBjVH0+FG4zLdK/1xJWqwAK3Sfb1J58YJW7/Ws8czUGMrh3gpuL2TIlxpjKYxM9SYZba7XOzqHd9S61N1s78AiD+4u9+eQm2CbcUVQXsKU8l0+LCmzvT2lQdpjHB83mVTun/db2DjXDclNMC/rZmObhN9b2G3CXFe6MZlQTbbrwKDBZd0Ls1oyZRGGzD/DTfSdXhd8hyGla9Da9xq56+24Kms6ynyE8PnZLVBf8lGq6wd3Z0r5qWVe/5R+hmMOY2Ptn7hjTfqYoivtRZ4xqWlNifMxiZrryEQub2UuNc29n+00Cf5kTqkVs4yeLU72K28e37vgCA1px4NqEP7kolH9UhTGl4nj55GEQesyzMkcp2iszzS246BXfk5CNl2RPfjudBiVioIFoNYFRw3Tq+ImSKoIp/jpjsoS2Wux83mwh3cgHHIzmBRQx0fbsf+B46q+ZWiszZsiLjSCBvWYgOHsKU+eJ0SVMesgfC8DhZd0uHJhxPYNsFLjPC0XFTcR+1WQaWqjCGalM0tiI9TeBKjQy3fxabWbeps8BGL7ZhIlYZCmms4/4vA5jyOvq0l9kamnD7/yET1+5qH6mzgVcWkmycFZWemUcsDH6tHe2WtZpr94sQJv9Z1Qto6ioNVrB5sSCddtoBKpAnJEGJVZ1sSK+quFMCSjfOEfK8r2WEcRRlQw8rQ1yfCu3do6ft0Q4D7qCBrLgzZvPUo+ZSaLLJfb9HoBLkUkrBPBzlttGRszdT7p/otHHf6mFO67gJbpdQQGFsNejoYx3wgl6UXW67WkIf6zbV8stGYjKQPAYah36Y8qc2qN+R9zi+c0y7a+DD1AFY+ENamtiO5gcfTr/p7Dqz25vLFQThObKQUtNIkbrDpHTs17bcSnb5aQYrhd6M/ryrqwDwzVbddIvCbXQsWpdjbV8JK0O0YeZz0RYbZbfvAQIusgjivYGYx45D1XPFv4mFFjb+P/KOAoZUEH1CaXePjSyw2CXDVoVcSTAGkw3Xox0FsIx8P06+KUYxZRJd29ZJlRogqN5OPlhpxpgZpWCAwNmbYDFvMxJjGjmdVTcJRucJmc96J0E7SdFdcXWv9bzZnPv0a3l80f4c12yzNTAW0i5us80kKwkkJ87uEjCzGqlagLYCUA3OQVNEM+/Kt6b/7oj55aEsZIEiZrNhqwkMYywa4xV+XhDDjCZhy6sHBk+MHJWofOYh4GuoQQmEMUgO6CwzRfhLf2vAjwZgPikhj/QVX7x19iMpoVAIcDlvv2OB6ixn8Sknbkr7eC13Pd2mHQhfjzIsxZ5Ollf4GTVTe0gPMEIFBclqrgBzC60n+5aT41D7pQc9AozCOM8CIkVWkRPqtbt/HZbAV+9ixWyEUk27nCK6mCpLdhjJmneY5OdRf+fXIknSFSd56tydoUPSp2urLUDParbenDTdQ2lAxN5wSh8+xZ5HihUo/2iKRrGEoVC99PU5v2WVUH8BHDWsfVsEcR74l3P/Zy52y10PxRAwfBvI3jX2CL1DEJXIw+0pyYjthChYuHA3gyjQiDzoULFt2YYT/7xF3MQRTyjmqynXJntw5BUKKRb8ctt1yVzThDSjjEYw9bCE+yuuT3nGyrN0YjktjEd7T2Plw6pcwHdpJF/GnjblCX3m7GKA/TmF30FKN20ksQ37gEITYt4tj6iXPoktrSfSWJPQ8slxVDKRKeKWZbiZfSWc94IQLUzvUqBiZkxNtoNCzcHG+TcDgBqWIWnoDKvguT1WG3F/jDl+IJ2DgYXhAJcA3WrwlNSKQ1V0Z9UaN46aWoEXyzMqcCmlivRBH/KC544UfYjHrm8mRIP50qQePw0P2l7RjUJIwFvCsGTV4BQEwZatkj6lcXTN1Jn5AS4tljgwCgnbyk6wUNmrqOn5WB7kNc7YrUraKZJxd6RujlJU1xj9vFPzeKZHGz850nU8T/NpIOyX0kRpthuA4qSpc844Dz6VLk45a0HtOPMzMAgzjbyb7SJpiY12UHxD/3ePRHFkvwlMUxFZTqhMrRHqitgRbR0laIacOChmQP8kxJFUdhzIGbjrj+B0SmfsQ3Xxdsthk7eonBw+6wXsbO1oY/4P/1Iuvte/MKPutejGL/EMoWOmwsKm13SXA6cKXTTmvNGa6FZBvhEwYSJ+C2f8irDPyEffAJc/nHu55QNVRBPEj55cqCcA9rt3ZopfxnkDHwk0seY/oSJ6EpiWOZPr6QKQbeiNO8vgT0E46w50SFr/8r5B8SG7KJNIhbw30YsLq6wVwUiRQwcudOakeVb1zgJtP1hnI5XxImBfFjDh38/4Qmil8dOOsCsOSWlDqIN7ed3J65gHQQeY4UAB2+S4dvZoy1cPQ70Shc3MyDgGhY/oAs2LcAxyM6wY5nFBkhNzkaFRH8q8hgvwuToFxWRs1bByix3diUKX4gY190UTJjM9Jml9cyNNG1JTgGCah0lW9pavPA/xGHvrm+Wt/uBuqkLcpMbGgNp6OgESCt/YB0Zs+8mMK9jR/mqHJ/czzcSnZ4kWrJvjFFiqA0NXYHcMXdGb7U1cFQtFfaD7AW1Whwx6zJAGmX6fdwPoAax++7Sb/KV0k76H5rc3+z4FU89G5+P6FzYU0E6HsS4CFqyM5o6mKTfQ+Rkyug0n+pU1g2guJBY9C5U9/QvuAJ5yiTnVD5GRx1H4i9P56chGKm+0I45vyuCsjLS7ADZD5MiFn+kx7+lnO/LWNdjzSleuIKh/tXNLvA1CfRe0JZ+9PRjiDyU6nmM15UUKzco7L8YJFeRZvWqF/RkIRDD4girC4DXPBg46zpDlqwNaE2CbT3ZwhMngwIWVfGf47n6zxA769UcMPGUreDjFHG9fkf/6TosvwjkEXD/wkC7xZP8/ZyUumlZ1+4UAx4rhgZhol++uoWX4vg/ZzvlacBxEj4viLCPqAIQ16Bzyv7oxWjbh91nWFqd9jdQfgSDGDDXn27Qx/19kOhMHdS+fdftARkCnRcYwhrzTISdKSi8vBQMwL4So2aNmwT5hf4mzb5ELCiexIr2Wxd/0Gau20NvE+xiyo72tlD9o3uE96AFO/fAJKlr7df+kpRgZr80itaxQCCytyhw/+ZPnkCvpPEWeM9u3YQPjCRGWN81ehuUCKwznGqpdus3373pa4hva3f6eMXR2wKzIzy3ZNLfTIQys0nBc1yttBS+bD/tSIQdPY9VoTjFNwv3l6fg8UDCHSUi+3gGqWYPZ4XjQFVFJjIV6uBp4tu8peYlaq3x0qZY9pdwrH3f1pef8XBZsOxCIaaiVHHH5tZ+HOhpd7zF1qhUxBG0mT7BcWUFRWiJHqx54Zl8kRzOO6dY54YbO3eA7ps/U/ziORG+nn6O3wtC9zrDZ6ovixdYZLDOMakx4ukIHoRKepQ+JvOSbymWGqwjRA9wiFiFAgMZZ/8deKQNm3M/kd69smaehzoJFzU8B7LiB4q/eSM49eGrn+neHXbTg5UTRbuEqawwv1LOlmurF97b03+0hv4vIJY/GAmJmiHqHKu+/sSPRufOJikJAXclkw4x9Bk4TBH3Lz4J229Js6l9rTb2HQZw4DkcaubR+KXGzWWLLBbeG76l3nyZDDX46+tjvNoEB6XxxoUsUNUNDyrZ/sCrapCH84fLxTwARy+9b6wNo2bL3R2ZJtF3HBbzUpQqIWcWld1XOA2yk9NBlOGKaa0C4p2nW1cdixIj9WtiwGYixfH69QtHf2O4xlfO/MlRQcQ1mB9fe2k0+GMaAQB0k1YEDtpsodlnnLS3h3z4cGZXAzzDrSOJuM/E/TOZYiOhIbFfR3j1kALEoAmiNQzUtt2EG+i6Dtr8nF3RlnDLDlsVbuQnv5fY1MqYWEyrbq4vozhSfwZQ+ZqyzE7VZ4lskZRMMAv50pDnhMZOeGmpw8JVq5tsPSfCVQSK7n20HjF0y0/F3atoAmwg83+p61awLRRBFM/VdTrASXEcYrzBOfsI4KsY+WLus+1qMEFSvOCxas+OndAYbDHGePyN8ZClofh1tVzLP6FQxyG3PvvvqSpiYBqLuKUkif4D8ucfXY49MHR7+KihU0KDj44YH5JyLoGNJioSdfxzz3AmmXIkUMudpb0/aZZx7PF0v6SOPw5pDH0J3A4KE9dsYwjyeyypJJTnJt1qKpHhM+i+0Ye2DTiJpn0MCGfXrt4/Lf15xdr6c5TzHxDbcVT0QVzLmO2F0dupZNOKvjBV+8UO87k6gNw6o/n9x2yaOLO7rWCJ8TrfUhpqZdJmF3FX5P8KcZpm7Qs7wGiv4fhY3YzvBO5OkwR/5oSi51cq09XIpBTCXd6LcjeE1eNOS5y3ZwXylaVnw+BpQu7e7Y5qC6Ymt/zmdGpk8N4F4Qvte7bgNzRtLtArnSZ5Aat8R4KBImbO71m35VrTfNRE27mGc5uITn0TaMEs7ESU5lrkHVm1JyLRmOFiX/yKd3ORvf/E/0PqZ65z0gWl0hsRyqLkvcVgIPci3f2oeNDDNHgQe0P2bqy94PmDwI6FWdlDlmxF+jOWwrgdqzRW3Od3kVy8+BTqlT7rJFIEw+WvcHOkipjfcxg8Fgt0zfRqbbe4TCmA/wYZoS81ODy7+wsbbIUqCT97juGhoTatnd7TL0nOEUl9RDv0Hx0DWxqpPvFKagvt4smEPQV1m5hjamRuW5on3vvZ+7OJdmB3xNpAgtV9TWmC1mTWTzZDM+sCJPodTl6hirLwHg+fWK7ZMxxZdMgzMb2PYdHPkt71DzfXHM20/5YmnOK4iPjiGrEpjyQS4AJAugPGI+YcIVq9hHdC5im8WwiHIEUKVtRJDUWu1YEhvPKrvRTeS8us+JZfKZHO9MIYtxBmBMldSnW0usxsPNSk87ivbRFiXw3DL09e6nJ8uwZl8fcf6q+ffcM1S7kVAvYF6Vx/Pv2dG/ggrt2yZTNKM7RytD2+1zhNwtbucyLJTKo1W7413LYAQxjo6cX7dLwOn2QrhTOpxS0+UA48QOrTavqB8i16thiwDSzVTX+zBsnt9aPJv+5KGsC/mo9+CKHcGi32P7iZjDBx4sXyI/mR9ilR7FhLQCMcB9SWPx34uE0fErHqRy5jz8+EsG60VBloq0IN85bOc/3RQ2J9iX332mzNyc+mHKWuwGDGaChdAcGDShrRx1Lxc3Uha1onaJxS4W5ogTk3SPgGDpUs7eGtfZaPVqEuw3s+zgHShALeDu1IokNAS+cH4EtHJf208DE71PrD3NP21TdsgBe+3CQrhcGjjZkZVqo5WhE3nzY+xMWHnJtVSuBl0PCTMOZe2ekmSQZP7SnE4SvFBs9vLfsF/OiQxi2J8jvpyP7m7cM9q9eOvBqmYqoARoR1imQfyEKtey18X4qAhgImgtJuykwF1blBAH0GU2n6D26RdZC4izXYcZia7jip2ZaczQc43+CgeVTNNTbZFshJAzBAOh3io0qPPmCp32OwMWggmxqBJ2rfYZFy/EgXlvzZeaLeF5GgpIcLQk3+dRXlRk5b7Fsu4oplUa8sTr6WPCbEqW0FZHMj0uNLPLr9BTcjg2WXa/NMJv7zAVvCBDI+EMaorF3S4i3Xmzh2vNMRcCweidC1/+oxwfoJ0+ACH3wQdObyGjlFHDCKOxUp4XxHKHm66JvhyC/HhWFWVXrelqSAJw0VgP4WH9GyAkM/sufelN/Ou+sDhwAr8KlYvqvvIiFW0HUP7fr57qX8qQ6il+OhuWX1dFrntgxYSsKaavPIfLjI23FiFmxkSR84nwYmjsNYWOmjQXBj5Je9nRNBho0El6UNB8sBrRYWCBiP/USEWY8xlk8IPFUE8c3+0mBUTw6vUep4cm+ncR3XG8V2O2PuL3bS5d6+k/daZAxLsbyk9sAfyloBW6a1tkHshK2sthvK23FGnTG6EIeQi2gBAte8pmGc11ldSjjHEx9tezsybTx2CbcK0hyJfI5rM5hBuuFaOToC2KvV9ekiBuRMqy1hAVhM3cp1laI3nsOvQv0BMdeRFBN4OkTq1Qshd9r57Ug5TH07zxjjx5PP8mAXjLS4tnn9oJmIjLqyUhDLLo8CL3ssmfdrfvSfUrEg4MCKD/qmU/C/3N5sTvafB6PMQjSKWa9hIidfY5R2Khg1L+Olq6bmVxP3yjT8d5amNa5XEA7CFjl9sZsMz7PGKoM/i4ngXfGRz3yKN3iss5O7bh2jS9dLv8WX/Qzfa/R6lFVq90GAJVupYNLPAQSmGn8D5Blj1V9MIxpyXRdYUMjVK9KFE+zlRw4yRdjrR+BiduSJMI6BmrkzVQ135w2A9IoBHrPVUM1Kebzyk5PTMVSFH3tt+fKNFbpzmzh00s+ER5FdUwLustiBG8aZ7QGqymdOA76CFex7BmGvS8QkwjrfmrpOKX5a6asFZTaEZvq2CSGo1OuOLB5pODOaYiNWE9Z9GDPsIj0ZL4UwRHvPaYQCkmFIKzmspQBWfY58lSMyU0/8zYfpuxmEEvHRgqVNKMB4sBkNriFFmPnnCsrfU7ZFlSqk3bzWpGtbcuWbDJ5cXw6d4FcE+XzX616Osha05mQx66sTyANaB+GVCAliWDB/t+dZxQJKKS+DREsPhIrYPOa4cPnR8oYKLre8eahLcmZXYLh2KeWrRxHiQFPVdBjJr85I7pFY+xUx+ftj5Dby6+UJ4bo805U5il6fGfO8WNv4Tj/z4cnj9d14lDPQDtQTBIcH8PbZFp9Qx28hwXw0NpWQEXExL2vcZvBVw9+qFeZOm8FDdxxxgNJBkbW0axVaKlJWDX4+cQ3TQuAcL780ZIbmnJcxWh+1zNq7WDx2HpX50EsaEdPkwM/voBaRhf62CEaH28yaHPOrBmE50axwE5a8ZLe3i0HTOGKx98CQzwyN766BqUQk35cEkpvZRp92HSB83366PPqzcY7xoU9REm77spF0c5CCd0tuAfBZznw9/Jc1P6jddnrDvPX7tGF3JNFmRuj4XHhIYP0zEo8Yl+rLY8Hp96DzB/R0ioPApNqhlQHTFC2Z2oKhLkAkuyGZdNy9oXDjHFEY/k858aw85Xf7YR8rnImVsjnjWDMG5mrWBNLfpfHBgo/VnXo7FxaA56hVgG66su/cLFgTOybr9ut45IG8yWkTmMElpWzLd/oLCv7qmjMLPw/8IynPWViuv6NYQA4h4qp6jYL+5X+tLRQiNL0Rb5jTgPxsODkKjxkWRrQbmmsQkM/WsU6/5XUkUHrB0WIO7jBS0SKGC7hgzQ+g9qrDgc3n+GP1d/8K2buKYYWADXaNxvWE4jdWHAmagdAxnyOzOjs3Hzmlrpr7ljO3G3lEfCimdG+J7FmBQzNqXVLQK4++xwekcInsqJqkoOo8cB2hp4bJXK3pCzebWS5debrbDqf4O0TqfPSCa1Z5cO6Pn+pFSnYT8PpmQA6Q5fqNqxGXEr1hq/DYBzQsIprulEQoorRm93V9gg+Lz21RKtk7eJMUgCrgiiMC3wT4PXUoOFwcYEVoIE/2d9Rq/dVsIz6odIBmN9VPpq/dOhKRO7LTvNkBeaE4SeYJ8MVE62tdRhdr3neLfxkaIajZbKP7CQFO1g0EMF3kejJ468sQa6laOOp4b77D0+m+nNcgeeXo+5G2HrTo7IT40j80ROumS9TMoyqpQllLMTCFfeUu6xccesQ5NMpR1SQDPCTuQgt0mkPgHPu1YyCui6PxpgnuGgjlNnj/3enM5Zyo+mDe1+9XbhBwWqOnB0ePPgDeO/uHUD7PZr7iSbiw5Hhbl6FoFlKUPNWPnG1jE2XOHDwi9+wEXZfVy9prG58wYe+yug7psrlOxwgRL6yQ1B8Wc5e8dfd0OdBJXFTFgv7Pmc7XaBNLx1/qi23rYE6K5IDi7oK2FBGT0TD9GU7EM07APHI5yGmOb3ZnAhP6lr6bROOoeM2m7q5uzkHCDyyAaEL+fqNzIFFaA3mf8w0ddBa8R5JPFAsBMhjOIO1BcBjQETs2rtKBP+x4LiCk61OXjKkBTKAb1wxU1BcjhLVgQ2yTrC/3s+uVTQ4hI/CjtKZLC8ACRO/jV5scVoTqJLN103XWSNNePjW+CN3YTSRhvH13XlAfT2VPR9RkFMATh/b3ti63+m1DJyiDjZSq+bC72+md4bb74fPlEJdrr1OMVjxzksK1/XS5KNedKBc5WtJwP4hIaqFD77n5e+N7q69UXvBZWcJuDCbtAAdfokdVSBj6tBnE2oxMIAr409sw/NmSqyahQKT45NNRaRVBcS5CLqebdPQWO/tSntllcuYPF+GVht6v4xqGyH+ybXNIG4KVDhT/8FxTBWBWSSHGdZhpIbf7Kxc08/qcJ3gI/MOxsNGxE7j6fcBKuDHZ4KZmRzom92JPkwmP0d2beYjCMIZ6XpdkFl8Lm6+qnExKo9LgVGL3XKpGiDLX+Hxlm1h3wq6RHU4yFd5tIA2jwCMIQCoSO/74yst0i/Bcz6MzI3chkCwhAXe0CaEzvqLQi0op5Q4b3ecI397n4H47h9DUgxbakZfOKrF67Mut+JRorbE+71gDyRAHsV0hGKXtlKrOIuSXdWccNrB2t+G0pJ6Tb6GGBdR63cSd1jspdyuRgoqNRiNi6RjEbFUrM0o6SQUa5aJ8GuCCb9uolnTNKTQgG4in2OPC4ad/NJr3yNPZvN+CTK7o+VTPDAFUDujZTfoeE25U+LQvWbysr2pHo/o/NMWqjysAJS6FpImvyDWu2QNZQ13zvEKisYWcKsi/EfbG75FTg0qElwMW8aJRsMY0k9DJrEhqRZgWMQlqKPm5CZ3A+tqfnEOMIRFJkLSYz/bru8lt379OvV3R9XzywrlsOCKg4RKJi5rsGjqXr2RwJvaoYv3Bac+e4EZzulHJEqkxiakALqda2V91JUSZVCzprOo9LtcIQ3rmJszFj0lrodzwxfwMoNneQi5hJ5vB/vebVpjhpHEkY/oKRPpmH2G75Qy+7CSepHKB4o0FaYKQAc2L9aYG31DcEB5xMjuNkWHKXGs7DIQXo/jz1FEbWc7dOz8ml066CeEB2GrJADLlqqPnCfnoKE2wEqzuRDMzaAJGxpq7LiYLoO566fy+bYgiYLFJ8tO0rDrhwFmUzRv4SB75QXYsN4DlIGnfFHaZkSfOvaa0rJgKQQcGPiIEiLbybUlT0st6rscDElQ23BXvLVFWfiQFNYFd2yyErl4ca4x1qgTWV/vTgMssDam0gykPvjZNhDHgPjy0HTuI4rp6GqfoL+MNhXoDYy4miNLgQcJYxvlONX7dWxnDrCApryA8pXhVOpGTKkUk6qOfp1AY2O8THQcBOnb6ba02pQnPsbB4XW2CCBk+RhZFhZkHfglxHsYgQ4PuwzO/6dtS9ayHzNDZMsRlXEiUf9UM/HY6Mrc8+K/rK9p7Yfb8pBUlLhBs5uz/llImGxV8BMGEhdajEef7NgiN2yC//ympXnUZy3Euyou/K85MhUTqonPlhuo0Peo21ixCDrd7ufegr9Ty8O+wlH3KW3wJZvOnknFDHkq9MffyQXhRryjP0eKLKljwALD4lI4x0yWSLrdEWscLjAcm6IbNJyLTrxuRpLiLc59g1Tf1nRrRFLU/vNDQgzPJKsnMY1tweQLDnNEziE1ihNC7gue25obMIlIY2GXBu2QjAhT9qK90Os5H1prPmazhez4fEHtwb58/RCQk+oBur+A6g6EbM89+utINlaTdGJ7ReTBBxPvPwSTDD3IOeeiqo3xQj2Z3ZrLsuPrTo/TVKwdy156/stS0Ffl2QH6Yd6iFBcT0GqDuw0oIB3jc2ToI3XFqTIdq1bh07y+N+d9ZEB4N2gWrSENUPQQHP0Fg/wBT4odK5PEXbKPGHBtXv8hnDeZBanrr0jy1K6zC3us9OQl9NP6dIqOHcZChdfL10HECpPl0H+LgSAeAe7PavzLHrunWllZmoMZFUyPhH56Ce37lTBQY+eadUbCy6zMGVPNweRFTb10HrAh3cWYTqCCu6Frlt7yVd81Ex8O8lCVj5wIEuv5U5A2uxS/xz7shcSvPetcDDHugwvdtzKjKgmJgA7l/YUVfJiYz5MzOoGX8bo123dARMUyqa79dNN+uPhIHFg7vgkgZYkkL6xDFNj3cVNKvOSxwgdGRjhDFEqrLxhh8Plp5w8k7l4XRx2Ca/RlLUTxkjG1fT+1h43gXj8Tb7Vh2u4mUuopWTuzAkJf0/NgtV5+1nuzIEiAVxST/v5x3q212PXzFAffVOqHB7UOXv61bnCrIZObHAkqdITJebOS6AZoCcbi8RA4azPh2ycYmutaKSD8imh0Blgnto/fwTrkZlGr21l/55+fmYtde6+FcvAWRNTdCQKYWj9ZTK2NAstdbMbJNbMiJ8haYdtjl7V7/FIweKBnF56RwrHvjEe0iH6Np5O3dXLkuTtBsp7LhG8jZ86v6NUVuz1U1QRQpdRQedg4E+fTHVJOsUxtWZS1rRtoBBomk9gXl60bScclmuVUibJDNFJDuhWiKTFQZRg02yy9+BZbbCPz42+nGf4kIRXLJql5t1FN9lIp4xjhqJcH6mR6oofKEp6hjYngd9hCSkXeLZBAxBi74ZrTkq4bJcGYyFT+X33wuI42ZMiEAzHbOXCn8t5OoRh1Xeq5OQultsPpqfHa0vrV1chyyBtZpk5EgnEFGxxLEv7CXvHYtlRLRAHzmiQsfHFcTScAEXHG7VKEdY2wUV1Svq8pcSpV9HGK/T6iatZt/HYnRO07L4X2Cgx9sopjKVm/Hm5Hq7RJwmwg5nlEjrEzDK+IRzDmzc5JS1y1IfUeLsxU3K5eFNo1quWOylIrVep4mGIZQX4W/AsOpnTaJ8aPCH3u6xSCwKxqaVr5Tj4eJg1BGLpVzGVSg/wWtmf801wqoYjX2VOx3usbYio9k8axP1ftAEWJjKUP5T9EUQy7k2fbZnXL2xth9iULGKX1hMiHIJ2LJdgClRo6bghtJTrMtBf6QSgF6XVsQ4QjHzztdgLNmnFuwxoZw5y8zvRcxgDBd+lNok/mRk8GkVTfsFkSBrfCTgz4CXSqxiTxO15mHaI7SiWIL92YsS1h6FibDeWepwA6p02iqWmzLgU2YiI80Zwub+oIl9hgWRWMEadcHoBefZFP0UdVrNz5LTV+ZSlA0pwS8QMPry52Nc/ZHd/aHgCokzm5M0Ils1+cp6/+yvKxl3WNA9bk02O49VC7FR1GTFJA7WHomQ6XkZ+XYgT1Dav2WnJuZRZuN3434Wj5yJNxU0eldWIus0UUWCorp2iaBth3Q7tsQcZEFdbbCXNz8DYFqYgcbvZ9+d3zhXf/3Err5aeOZGVQ3XSC9DQD86r6ixWXC1WK2rQbnzqWTf9FXbMityopF8SxPeKi9PT6ETVISJHAsB3AR5uvu34Fua2xFKi96tfpWUFx7Jg+msI2wY5XKWu/cVnAMVT7IuC1COYDe3LZs5zc4dEicf5gO/ijHQBlJATCQNtVJ26yUtzDoScNIlczTn7z4zUlw7sTi9iXJDR/5zlc3clRfGMOHL16Avt/Ms6ibjuGH38fo4NjZF3yQtv3TrmONe45II7hiFPJ+v2hD6S8k3eoCBmm5r8NUWHHXwzMaeshvSrgXVAh708ppri4XzwoWThCabd2AWf6cumaBGEBimP9DZndoZfEUFpbju6y0fmwwQokLe41lC84AqiIbJMmmxd8ZGwm5uXvc7RDO/izmECe9MBIuxNyD2nV4ZR0OzfhBE2jG6cBH1plpn81/gkSb/ljmia9msdN/Rk63hfAUf2+KqcliHNI5LF7q7liaDnCWrYNHGZ1xc8ySIuSH79lsVgsmDkS1c3iSSfYFatDevwHQtbS1unA9HeOW3hnI4hrTPyJ1/er0rdbb4+0xTujgJKFUKKhCT/2/D7IXW0fz6PCM7OYDZO4XSgv//TIz9AepwcaHtFgNs2olVodB960ns0PmpfUpXpqbnVIrCUwZZNtU1O5XNktommyJ+1vejTsUxaAq1EKHwRlyNMImP8hB47mFiQhO5/x106492akLUTFUGLynHaJkJBSq7Y6OOy1/XYfnZviwfEZrC8muasqPiouEz9QaUEI70CIRw/UJyN4fKsnUTOmiu8U/6PK34NL9pNZCAgIa23+w0aqOHOJ55xp7DrOVXaodpf0GK9og1fU7Bby9dwMTWD179Y/dmp9QiLK2MJ6mMvAiVD65F91BGROR98WltpHxQnKGKpIHqtUOCOxOiJNQ1IUUmtq+zNxLRlIaPwHFC1fzesT/K5amfbTQJwSZLtbhit0OVSvXw1k+fs+MRCV3RFba3C0M9Nr59HYWoFsCJGk6QqD02jlhUTaMnFsjPdcuH0OaY+LJONlkr4k48IzoFD1X1ga4xoO+ULStX02xgxlPOXXJnpws4TRfrSrpDDsFIMcLS2GN/l5GEuKUyppRh79gxpOJNVQh+jmqTCK4Poi0MDh5h+HSwmq3z3Lkoll8E+hqGuH1JMxlrn7FaDBHfxEtiJT7a5S5FUJFg9RLIvU1ZOS2Aav3LGuojS3StI0mpei7A2uvEHlZPXI+j74sJ95991Q90Udhux8ZyMxDo4/YNTZllugvvQD7asbeOqbmuBSo9t8sJb9xMd8l+1RWo17vzzD9lyQEyG4e1J/+Gfcjowu6wG9TPCd4NbCIF+vBzBdIcxeLnwYzVecxBVF1W4jrHAI6qi26pJOWaiWT67pQ1HDbauuRnK5K/gD17zw+C8mcsND8D7kxrgdU2a5/3bzSDGiF/2Br0+/lwMxPqaagm8YMskHeOnFEwi3oBqawWhCYH3TNr5aYwAoBq/rQRslVXDGMOHGBYjXr7uugbDuwCSOykjerCcCwgAciN+1Czn59wfFsq9olo7NMmDtDThSEWyHu/YubU3mxVEnMBp8rvM4vSjVpgV8KixCxIwmnv6Wtkd9OQSTFCGiEQHYGI6rcpjWOjX2b/0U24+aWlR2ovvV/9AFIrHlTc8sCgz+QGxduBYH+rUHoKWGhxyfGveKX9zUa5IJMrEA1Hn6V8kdRhWNYeYzqntx1U1dgucTAjVz1A1yxTqgC/FBQY/bFzx2BbA6pwuabARGoZRNf6o7BuM4N1nGi/gnZj3aY+5IRY/ssUUyOGsJmsXLId+YyEdz571fB1qMj5MEcduhGGWJsgV2xuszQh4jwb0vYYiMYfDf90lwjCVIVbfFbkCqxlNP3xcaFUnGGycoAioFmN5H2zgbzp6yc0437Tu3n8gwLANVTzyafPhYd9WPGtQNX4f5B21nigdC30uF8d50EOy33oRuxbMpmNbdfcp3kgUfPRUsVCgK8pk17r36T015tVAWJSwiVeN5Av5y0W4naLr7xrBBALbsneOhRc6zGRPz3vl/uSMey9BBEcwQlpkRzIz0jHMZIFJIFTmj+LUq95zpfddODoHcUySEZ/ZK9horWIveXMyYnQcxVS6L8RwL5/jOR6kUxu7Af1wn9lVaDVg7yuqX+SkbZIM9MgaVolCaDJ4xbvsm4lL7nAkC0k+/ELI4NjuN5cAruuZDLUTDwUPKN+I1vzGmNPZOKujfXFXPbzfcPUpgVFcCUKd3kE1DCUmGI1w50yRHgoidi+sCS26inmlVlW8YGEIkH8sXyE0GzAvI9MVYOLh6NVRCDw1H822loU9Mh10NpUttMdGf0K3k7Gzw3UWYLjLQaVB467xSPePrzkKnD/oGD8sslMJ3GRZc1Ow41LSB2IRvGQRJS/fnEWb8dwxaOVNsAiE2xnAykSWW8RJQ6rfc3AiEMVtNeTvZUSP5RR3fwV1CLHdxpRy7xavYdautnfgqWpIDvrVVVsJ4Hd0/pcasA9tGjCxq50Z+NLVEk3AlaHumpEFonTLKjPWUDY0vlf2T50QZbfKd2MX06XijuN6Sz41aut9jV4lpa0wvznfsmyZRIhVuVvRSOoA6oGnkvX7ObTsWbMnNH7UbW4sOwX8fdDrldr/FU+Xrd8ChWucgMExrMb2FJUSgXmCeCzg4/Y7EgeY8ae3RPpKff7XW2l9NNFxMqslqIxEDXRS+R2XeJcLbMDODU55WeLHTKMqeo4A1GIUQUIxzNeqQRyZm6cJr+K+31kyhXqJH/6ff5r03witPgpTPP17SF9nMUkRKF/zb5vb3pI8BbZpgexSTYMjiDQkqyqrGEmyERTXWMlPJP375kcyafWQzT1LHtDU+9YR6gkKGYqHH43k7VEbrgLDoboVljFxzOVNz+jEnvKz8LTmGc4kByzUEv/sITRsVNQAFWe3skFA2XGsWE77QKgtxNl7HkVpBKP6G5snCrKtmZckITYfU55Nig3N4qK8uUqINZIgEX5uCaFZPtRrTRLNf2y0R3J6DeysUGZBwbsOApweA/fuWo2skc4lEhhCG0WzB9KZZufZkRuMZPEmx98KUIqKZxKL/ctF4iwHPAoRSk5GCvDN5aVv77MKkZAodITwlvaWWwT36UqivfnvUROcHuyXd738wZSFjfshCa0VbGSTkErgkKAsMcUMpA4dBK6juADt6FD24eF/peHxqO8QN7sPrsxRwt7P/WwM5/QfmnFRa7wnmrI3eYt3SMzwSUFCIC+l+ulSNV47JtboXtl2OLzr9ey5lxx1TNn5iGuzCepv3pSFDqps4SlYxUF2ExInsU5c1+ebfETomlhCo2Szk2t9l7DLxSCq3Te5uxBfcsxeTtS+oEI2vmoevq/rcLEQCg0GeE8Vs1lppMb21uN5qW3Du68nDT72QWaCq58Ht/+tUNHO8x2moko1B30zH2No5extTcAQ1QSd1a1xejLHDeFnD8XtCC9kGiCYOTRG/9GEa7hg8olAIl4/jgnm0j5CQaLUa7q9lZxCvTqmTb5FBVWspPJ60M8oQCoZwwGaPgBdrpu70sNpmSyRSemZHbKAD5X4PB2LhTf/moEfQ5gGwmFJj6ytp6P5wFN56RbknSWnAeF5vNDamZk2QdchNUyFeTEcJda6ZEd3hdodXM4XpnvmBUF1LUe+5X8wsiGgpkfbQk+yaqiACiQulRtz/VtVw6uQjqvBYJmPO6AMaqNqPYxRQ9HmPGpYB3NyZKOIia2Vx2FqJmBERr3EK2F4wWGAQ1KQC581FmN+Sv8gyTgIvDsZtkh84LfOUp5ZL2aIG0bE1pNmVYUTkY0iOFzGNeXZyBlk1BZwITVGQjnOn70pLNAIQIKc5oznHo4JPBRB4m3gOdlBaegJKlLO93479Yu/MEWbrgaLadDsbP1U9CzQfRPJwR7+tNNXWKjj/xzhrU8ZZX/Q5XHInMwTv6K9WBI9farQH3/j7TIarMOz98UrViS8U4gcrUFHeS72nFHLEmXpuseRYFxV+p7+F69+9KD2RKjRLf122O8fsk9xtZIlFWv8OBTyY26JEcTbnzDOmEDDgaeWoOlim2DJv5mzVjUox63RA21Q9bb/JTTGohjK/PKTi2WGyqZhR/A9QInC5Msu67mXqMJOSFLgtwSTgv5sLiiBqVDWGi+Tzm+ZBQEQJoAJj9ojy736r7C4DzQ61bqxfMNPFz5lELJNzFp9mApb0HTLyvIf8lscxNhiiVDJJadju5AAXCb/0YSqNdsL8fX1lUUNQzhQVN5QSC0y3564hfnNrT5pGYefU86GWADSb1tm1WMYoJmbh9zDoIavnKDWGHPuLUeqiMsNaaIdZQDOe/4Nsx7X4ggqMorDa/56mlAjq7r43O4TIUiOb834ihA/40xUPZWTIKFDKpIm0lhwDCYh9fMpUtoC65PQg9AWzBUWuIBe9HsxLGV8B+NPewJKHWYSygJF04rPD6Q7FVkLn6ilt4gS/ySlrGGgDvEFBtOODzfOIQRbb6Qnm8rkCTwuH42TXpuXueIsi1l+b0CQCWRIBmYQPB9eJ0SBj34Bb31Tg/RC/YL0C/rnEzulYXGFGQ1BhrbdLLbMyUPkwP6izpToFB6iATdt2MP52KDPckVoKPiW+xKZk7ZaMbB92G8vjkSnCuj3tVY9qXt6DV6CN8Kit5emn6Qe+ezMOrJk75+C4LshNsTTPqAzds8mosQXWz66v9Z3/Si0STUM34cL/zRZquBH3TPLMbSwJuMoMoARGNfKnedsEfbHW2iA6u1haHRsXj/zuc2wxJfLxH3bJqAgM6VudO+cgZEaZYYBTKXXjhxxiLqm/i8pPwYOu3/0iyABzRDOSnXpQ2KB9VvYQMBumgzs82VbuYRAsNEa32AewCgs55cD7AbZg+D3oFNlRFPbwKqzj0xCkyUIpfnd2SZ30446sYzA0W2qrbSwpi+kxhUP2yFkjDy6ASVl9vtqNWnQyboa4WyQG88SnCmB3kxocXpxD8A4fh1E97QdLN0yyuHgnd+eE0wrKJMnFxy323CBNjoW3GgyP1nNrPZH2qfVvnE1kAG0GJMXc8b0hkoYMa0wIAm9chkjt3ZmDtoaMwsGaclA0rLNL1kPHveq8B0c9h9LT3whC+g5bCU2P87PADAR739qA2XH65scBhf9pVb8Bp4Hy7KKsKtV+qe+zlBbSNlbnLkhY4WzvHSJw0s7/tyddPvHBv5VGehpYL7f0yOAbS09cb6eMLOmBFGQeiP1OWyXwTxMRJ9xRTdxgxVYEHfq8UMYlecxNBFISosUstVlnFGQH3zqXVl+zVYyjzISf5iHehzGD9fDEGEcgtlKIl0yFtbftktfhQqnoPaJ0tpYqxPpWZu2DuQX5VdVrDMNBOjvK7t8cWfaiWz6Aay2xZApXA2qyCd7+4HjlC1+FlGnYww3Qer7pqstYkzeuh5erOQFPxlU4lWoZ1Xm/iSBoIUkNIAonsZCsnAbNLKhrmgJVT0t7hrtutNUW7S26mnz0ThV7WZeUkneFhscFsbPGyshTeOeS3YefOFn0jE34E9a7BUCABEbHoleO84jl0lMkUrxx2kBnv6cnXxTfJl0AQLuer7WJsLHnESiyLU7c/SibMKem/RhrU04RGiCq6QVUc5ARAyFcLEwgWFjeXXvhV95IOSEmYFSjN+fwdwQgpcvD2tx8v32u8tw0Xvmu5Kx7SpQC8F6IHkkGkhpCNF9vVii3n/KogRB0FjBLawFYgoJapic1F/F2h7hAH8xI08NeFt4OSLaZHxoXe7orU9/T2I9pdj///Mk1i44OmuY/0Lx+i16Y0eexxKvY5I51RYqPUu8tQdkf2ur8+q5oWRBeDhtFk3lmIoYKX01RhvdGVI/+6kf2dtKUeptld9pXZrgWtLA7FtWsV8sLahqT0Pmf1ayOxg1UQQbEyeR2UUkuvST15CYxJbFlSomagn8pVri1VO4U3/Wl0mJiAXgU5m6BToFosRx41YDpwc8oQdoSxGy/lZ3KO6mT7MujRrE2o0mDKeZ6Zki57cyHOwQRHPevu7AYbNaCtnhYvmX5E33IrbXHV4i6V3SXg5xKXhlhSK6MzojHNLo60kJO2KYpdqQru15fc1WQxF72oOWcK54QnFzWtpHZL44lHKyoRCLnPLWDNAeSDLxIN9gLH1T3cw/LyjPKo91hJsGclnbXveZl/k3tQ3ygliqNsr5pkf/BTDv6vdgFUp3Z7E8480vmRzRZT4OUJ1OXA+owqu0yPUu+ajSlsorYx5t6036DYCY68jPrYFqFMpFzeHa+mn9xFQX4XdMSJq1XYEzIUzmwKIl76ziGIg4sl1QyQ0CKophGPKT6yhe2/Mkrqq6Bj+GUrwpgVNzGvFjoItxRGn5WjkELHF4GGLaz5uNMOKkH0PViq2K31YODUErUufi4Me3HP6B/TqIYRrywpJ3UvsIdII2jSsjkGQU6UipFSiU/fU9cq79FQyIDB+mnwueBKGfXzqNnZXbE9LDoDH8AlX784fBsMBCNhyeQxpKN0SPqtYdIaaThJ4y4GVrUlX895f70xpRIhXuFhUuA4x3681LiCHcXWV8o90maD3vqAZOzWMEEENQ1GopTvL5nBQY3q3OJEMXIOmy5rM+kLgZkwSbLYp4DmIdOODNITU1kiVsfqiZeeByaCUgeulemR3pNaqVRjZl0OWIKW6T4yvht/QUA5xheT9ymQApSj/zJFCEKU+EP5qnFHDqaJvw9NEbA62R35dftCm8xw2LaD/os9U0tedU+7fvRPLAoEtE7zyvuCjaj/9KIN8/7BSW35KDtGIrj/yUAYz7DZqWb0yGNQDypyFSIgWHZgyqx91S/ZMlR9L3I7GlU1JzyA/RWYQ28MF3f5/zsGO+vwhocASiVMJbgmstNAF6MhrzDFgOeaiWhTmtVKa965u27nTBbK6PlOX+hfyMAaqIbBee3oVvChh8h7gL39D3hDes79KefUl2inYghmgrKaZAT7Unt7G1Hh6ohw91k9P7IppF53gBpr5yIRPaOz+qiAMAbUw4IoReKCARph1WgHLdTt9LRSBChErnSwsEqkpidF/6iKT+na/kbBUERg03Jx77x53o3GMjzyje5xIAROA087T202WEjgLNxmbDp1ddUWlsT/jshct1HYBnJzb5EZ4HFDCFlcfWlpMzfObu/KjgbbrYfKP8+6C6m/1bIYJPK6b9vWJTRErIVvR0yx+GRa9/bw3iCvMsn6zQzchbEN5ASdfbVlylR5UfbvF4pPBzc9kBVYHlHrr/FuinmtHIJFnxWmuhy9fIMlSDTdg0IJ9OBFNZ0nkyGAFlCEMcwBmrolONQtx7OHHkOiBBugOrjYICbWZvUjb1lTShm+nVhv78Q5/ZXMx9Wbd0pGw1pdJ7yS0YzXv+Oed3Jm6x/Yuhj6Wk9jA9mrsrWUEuQKQ2boXuNd8vCYVNNj+n9TtPwzPgUE0hL8x2KXEfYheF2WWslcxzsjcPKpvCIY9sJlf90Rpmoo1xt3XsI7JQ2LvOn0PS8KMfs5TOIjij3/PPw9SpnRoPCQFqaweXE5yxlDxjT1lsi8MM4X2lytuGHXhNV7q2BJyxlbZyfssWb6BTLI7MSefpKT6DwjOCcgDBz1ncRrMmC0yEJN43dD5awjrL/PLvWBa8MJCVGDyCzrovjTAYqDmz8QMx0z7cFqzIzCKu9Nlw0+KUbTtRy9dEpPalfwuww/0BFQW2MEapGGiMKnfuM+K9k/Q67x+LTzJVgX3uf5z2AnWIQO9B9Uqgvzsti7yZDMDGy6sddVIAzYFSi/goxS5XqQkME1z9m95/PAkQ9AB8kUISrpDc0V6GNCML/VRFLF/pAf00btTXFy2xQeXtEEPQ5J6dpWwtc9foZG7aEue7NZfrjcyQq4eVwS0i+O+41cGck+W5njWTlujP7JPp+Yc93tMM0dbPVvp26uWMI+lCIN8BcYMjqCJx1uC/jkOLUfV0I/t9z0Ec8QldhL2SjQeSb75wsaFfcNVrWniQUcVJiX5Ei6x0zEwGBlV1F/58wQgHVYQywAE+qKBKmJ4ejL79zRm/wjBqMS9yXkJieXVNQtpLQi3S0GmCqX5UENw4zfOSw4L3MFyP+u4qew7Q8JVxoJjBCvRpfgnhtqazA6LNqJnOW1d6K2GGeC9jQzugFtPE/3+HxSKfy7zzhu6FTtAT2j5UZnk9ISVFIVg3xWFxr2NA+49nIoH5mi+SYu5CqjR3tOjB6cxGybQkP+y0BsWdEqVC/6QOHZoI2P+N/HU7TXbZXQZWEpr8LYYLJopptDmTBDSFnukBwdDn7Nee/Qsh6roLkoISEzSHDyF7aMtE/9HtCGXsl1eJqsaPN7yxMz+HWC5Uuo5/Gd2kvUH4sOQUCE4VgLsypoa20pAi7kp0DuHvdhi2GH0bGaaZyutg+fhkk047yG9ooXFgkwqqaoGyxapWDdPbRcK33VK77WkykmwbvLY8IXdcAgcxNjJT47MMN0fyuQ/o/goLaajAbD2CnkTdT3fIhs6l/0dDVtQCIiwXJUzRt1OB5kBq6RGunLHqmOV9rxcAABct6DAGn4yi9V5xDar8awCAL2SNA4gBIMEQAWWGMmOOrZPc1V75NCRYPBMY1XEbqgh7+ggJkJ80baQDpkY6hzwSueZKsUBK2jdG9mLW+8uQ8pSTtju//JDxZJUp4b+BkuI4EjU3EVS6SMkgqE5i4ySBzuw0/LyHYuMV3R5LbVHGJgBfWRpMmLyamREW+1G1dgovyUcZQlnkooRHU91Z1HW5+5MeJn/OWW2DLYYgBqx5FOTWyH2Wk0BgQGfmupJdUMFyAltz4/of7bovhT6OHmGz08Xx/7abR2uDidcZTcTOX0Vi+SRNSKHcFDtawqwdmNb4Q+/teJLrk0SSpE7ZSWOewMjaREkIUAuRHWsbTvEzwy5015GaobPrSYreK/R+RH8jFVVRnZqrCnhipvrIO8tcfiaCp3/t96OL0edcXMSNE/UOfRJD/5C1mcWgIQZ65mVkOz3UDacbRLBMTR4FAfZnvEJH534KgQXchXqutYCNYWPKYVa+qVc9nTKlorrzz2QcyRwqbDh+qM2LP1nBNWWZwlW96Y+p5Vu85a2jkmP20QEaIirYJ6Kky2+ZGWQtZvHuATEJ7QzjH/mP7Q2Fh9abEwQLPRS1svvtKJqUx0rCRCEGLj8skT5sjU0DKMrRX+Aj+rINwU/Q4QVCgx98s0ZSZQ/5QxQZ6RxpUX1gF5Ejzo1fu4pQgw9vbThxeA4TL3eva2riWcOwdA8rpJVMZK5YIL2vSxztpNKzRs3xBXCRBi9/Yq65J8PPk/iB/gnHuOnyhcu8Ic2NJfjfdnW4ckRz/Vctcl+9PxpA6QpoB2r4FO0n2H3T4CSniKSm8aWxAVVPQIk0r0iYcl5Du9WkqfhM3u4FAXUUeP+qjuxNDOKdO7/v9O2t/PacWKSwTGnI54I1VAWdhxYDeTf5cKJwDPZMNpBaccPzSRBDr3q3Rzr4nvZo2zu58pYaXdRfk1vMGrFIk3xF8pksc2xqWk0+o9xrIMXi6pg+ubCAoL7+WoRoeH/Feh1w5giMdHnX1wkYhNxcGqNmUxyjSHxbRg6TOKXxq4cYH5RmkyOCWDFwuMCLPb/zoSdLzlfJbnkNL237zTlphlzsNMyOKdsysg5Go7ruUypu1A/rTtb8FaNhHcnS04jsz7ykJ2F3tjQ5ZqSRBfh/FGWK0lT2TQW5FRI2eYAKaMwo/MnirMNmmClxDZmBkAdPMiFyowZods2mnIDkJpIjBqODnGyGEChf+Ebr3/sDJBjeUFceIvUIDt4hsKqjyXnlTwHtRyKGYUuUACsJCrqEFide9ksJD5Qf2qldGCzXP+qLSAoQYkmY6XaxkV388UuG+JeIz5HSYFgOiMYOLtomOrF1a6xBqDXZiCInuxJ+FgldT5/GU81zSS3be2KiJU7zAinniIX63uGUpmNBiRiQ4ejA+Lgp3TSfXs0KE5xsBSprDr4KU7fIl6hbZBw8qgAhRJrWFZbx9XtD/QTWLbiFjaAvmwrodbhLQ3lvIYTx6/iNjyoHvCCTaU6ubPwGRzJsK1Q+kovyYemR2jpZSBuBOTO5yRIAbPrEsbhl2OP0slEF92jPt2Tq2z48tccDmYUZ0gN9ZCDiuMWz08rO6k64zqAs1vopPch3pgdDX8d7tbw5lpr+2J8fFJVRBxy1bxXekY5zTJmRTOa9x+jgOJm5JXT1AWuOUzZdCh49kHG3LNOBmPqt3p8pS2SOi0bEimcbmH/Bw3gvDmv0LNvb4u7QYwfK0JgIbmBbg0MnPtRuNEsRVwVSCZqWkvFzpRHPpJYpPxIWuartZF+OibuKDoN3O+KZeBMhW/rhTVng7sjVcOgHNnKrb3VYdXSlui4nGD2/JuonKSSMRwr3pIhhI/Hef3Dtv/gs3panD9RPI5xudKge5n8FilHv0qaZ29/VwXI6yOdOis/mnYh9QrfcikZWfxlwsC/dyoZXZAyOeScusw0KibS/Hd5Rdpp6yos+WsLd0hlQZWltFXYOry/lT2v3F4gxlP0zHZaWZnaTwo27JH4TdIn2A3e0LIBUBRlUcP1t3GX4OnIkWaR1sw09fLKi0HIMuEzTpsEByBwGXRb9QOA3w/MSB4yI32m/ZmhkyH5RuAcIFe94Q/TBvWUE5UI/UrQylCDIY8MAsPO5IalcN2gcR/JyTe9/sL6VypNXl2hbR/gBv1uoDqjzWQyPgb1onVQWuQ7JdaSPiHTl6ksKqWuGR222HpEWVP05hXYeGsF9Nf+DHs8lR6Go0cTDz+XzBMoyBtPBMxgiA1eBxIpGjdjFvTqARc5W7ig9ZxPlDB97/PdnhRio2GisX80r+v3cDBQljOcwx1UhZonvDQHunQgtJeCtSU8UaEqnCMGb4zElHvYVf9/z76ME+/xFjKH82JIH9Ccem+90X9qfUV3AIpXO70UWSFf4IE6rRJ11lTShvzM7zkUAy06p1nmPaADEsJu0d7OB/LacWKKsUBrWrP3WLqXS13bIMHL0j6gKwbpcFjl4kJdFEBgnlILvBdezJLZ7e0CPnndsG9rRj6h+WMhzyzY8YZck7BkKJUj/8BdS3ItFlSjnSYzg7TOY3fd9M05jKpgGF8fTUX5nmbReqJy72Ggkz2sBD+FtBIck3i28oYi/pwE+vyYOwIYhFAvH0VQCuMnoX6T+6jawId/Jgmg/EoUBfaxwu8CQ6HsdBigcHXl/sIeZWXR7L2GmhdrNzF/X/hXgQQl56iOHSwHAeZY03Uiy8NKog0Jyc0vQy3usuEmUhfr4C9GLnrwnPCLlxYRnwoPUmg8d9z4KhokFBaaFkuMlWJggw7NDXUZ3AotbVF2YnBK3cAhma/7MQ139pnT3psqc7Lq2JUoji3YavBTW2R4YsSUwFNmoYKZdoC6YWLKcIPnnaLF3CYbI/Q/eKxy45LSwS0hJ3m/kCCMdsJ8Zjz9OPs1Oa98C5A8d5U+7JLE2WnEMNoVCuzQXYmCkVcoEoSgpsi3QEHiZpFcfDW2dfGBztf4xZicve38XoyN7RCI3tpCsvL+F85CUn7JjaktEBWgFzcA4FLz13dWQkefIBLSgPKrTNX86DI/Ks+vquVgUUOb2HVRzXyQK4s6kVCglLK2Udpt/4tuMVgqAH0DRoO2o1dN5fpDTJoeTBa2Ch5ZDsNPsdg4bXaSJPn1ITwOnQyEjeglntX0KUsh1u6Vtwf48H9Ezlx4n09Uxjt5ZZql0q2FdbnrVxle90JHoI8P2QZnRTld43cmknJpuAcvGsfO1yBcglHYdSvKwiXKZnqwhzDKM0Ky4uHqxNeIEHeRTD/YxNfDbJGeng7ATWlQ/ysO6Q5KEkXwwkLVgYGfl3gDsWBPfXp7/sqC7/AW74OVZ570/CV7W1MiTmVX8zMsQEcAFItl6pCp4Rc9ouOrehr86ZRMKDHaRP6PxvaZZD/12TnguPay/rRHH4mNAHs+NNTx+Uu7EuZQkkN1VWg0IW9rKLAGoFyMMxC61KeGleD0M70hp/Jy9uXbxc0nOeYiXmQsWSzLaQV1hKcUm/rcKEK6Odv8sTn1keJvqrHiZmKK2ODAoFlMzOj3854T4Q3emnZa70PfJJ0x4nVjGH+WC6xdLU2GXwn/Kf062NDJk68OWIADZ56xhqsR8Qscq/ju8uo15xDVL3vxarWa7tyZNLcPLvEP2JnYs3KzgDeJkzcf9OYcHsgBJiU3otxVlUjEuhQYr9cb8hlLl1sP0HlIQtanTB7+IgRakDTRpUnixZQWNaV6uOaAlb0IytGgLU8Ulh1zDOo6c+WNdLz0S8C5375gy0hqdvgjAprhfW4gZ2I8xbzk2H79IU34arlDAoWwNoPuiZ/siX5tnkQ/776ecOtJLaIR2sTGE5HBrAvazB/J06bCxmxuhTZ5Md/ChTBaBmVoJRYUzaBRjsz4PR3T06ZLZOc9qwCwYggYp/3YAYA4vlPu+hAtpbFVNA6BV9gvmK116dLjEEL8264oFae6JTKQolNSY4bIH/WdCffYAa8bUfQ2xq0weQTs3HaADkUNSrl3kBabkJ4cgKmpGxP1FvHaiuOOFA/exuOEjQmSVkWaJPOnQ8QJ9mPpYcF2VnH8md07r8JDqyac5k2ZyIRfnnhK8Rpd9vYyq6h1s5z+p8gFgFvZ59Lf5BADh8YBzrfDnfOdTjleFoVpXvDW2z+KYcQq2LX8iI8k2mULG/DW7y6PQB3JpVPhWveV9HDnV3OmYL06aH4HEaNbp+W64F57UeABBaGLvDYSYSxGLWeT6Gbx+tmjIm5k6jGqAsN2Jrfl1zW4ixkZidLtntbuhk4wYsvFtLhrUsoEZL90s935tbts/efQ5XmIXUmTiGV9Apu+Fekv6Oq0cNC0xOJrr56K5Yn2XUmfdqyU8LLCaSQuMeLFKOUPfPl9fgxq3DqyDAYKyLqOBXEIkALkiOg/kv0mkkixqVGq+aYUHCCRP8P6bj+IdyfRjZPHhbXzWyXTs+p21GiPKaMZN9wyIrqJlbb1eMlnWSqwAlMt93Q0UGH/jXgwrEUjQ30JAik1PQsiYdMYrDBEnTH9Xl1FdBL+ichiazubonRsJhwpwZPMBrnS/kjXKKFmm4i7nL7m7EfsKwdUUBtSpMhS1KJqM51S9I5FkoG00mf2fTGnkb6RO5LFA94Spy/i3iwSSrVgcW6qY6dA3+wMt5/yKubO5zkm2c1PjkjMltfWw+HpFCRmUkPHTE2C+5lU+kSzunVv3m1j/Z947mgQw/RF7uN0apvCPPR8HUGyPIhYHjP+yGrrFaj7KlcLypJSTbXyWUGR0CJG8l/AE+tUegULB95xfmKsYwaNg0JK77y1rqjAtBWNPpvb0seeE5OjB3AwVikPCPESFJJJQN2CH0Wz1NRwXa/d3fbr+9b6M57KuYEM0IYR2/CvbOgF8ZZnYlMgLIrN2p4hotj7g0fDnSc1BIGEs/2p4HG1r+elTwt78NYtnEq8HT7zv/PXDLoDTzYf1O8Viqn2JNeLCthm+ookNPm4CkrqLm3QL8mDW7WUgGgE9L6u5c9n3JwBbsKNijERVaEutN7ON+Yt8/c4LsqxNNPkzVJVJvqHLpA8qpHBppey/llms/PX067Ic0ug80IynhcXZoYbtqHBmkT1/XuJ+GiWJHQBFq7n3Vew904NTq4q+SN4IsLLAGDb8bRadeO4+mc6gAdMDbOJWckYdIiKpcswGDeWOfQN6hN1/XKtgKheX/Y8bll+oqotOP5SRfjKvxtFBi1i+ztLqb+86z5peo8+epjkVwuIAklCF4HP0RGPU8QzDW7T4CK3AIHHAASMbneFrsbT0kCgvKujhfuw+PMkWHspPIq4KHnBiKEACm/CpcXAxKD68dTwl9Cv4PjmEI4hUEPGAEsUGJadxbJU6h8ld4HjLJ2B7nBTSXp0mbaCaZlMlIXVWPEnsypFOlhtgc/m5hAjtH2yTsvKC9YB/aV5PsyyX6wYkiSdXmwsiWMlvXIM5Saja/oQgkth/lwk+2wAH6VCBbRXqg/PC06juCApfjlUSsThL9f/WAqZBWzvLbNnex1gUYBrVr1Tstoiuv9tgk01Gh9wEx5DYuF6T6oM9KrcqOf+JYz0YAD18ycS9Z4IXFR8G+I/n0kOnauC7kG28A8TMmej8xcTZhdx8ISeoK6/IU5Jdo2bWke5kO4n/7aQSeg3KHOk+QQrCZWLx37X/9vacAE6BRRgveb7M/ADm0efoBYWJJX9Mnv1yc0pulLHgy/0k3RMsP7r7d+UL4EmwrDA6AGMxbu5or9vSvO3mzdz//rPUgjhIQQWEQkpWmUreiIABe8UTAv1xuMWoQntWqg40VxUJQzgaxk+T9xHMelszXhdVTUADmOF2/ZhW4qBslAjrLgIo4oRNGBDXHA+c8pnAEoUEZ539D/TLA1dxuEl2VKkSvpoIRDPRCbEYyIZ0Oa1XFqCdk8UMZ0xFxzAnDucefglMTiYZJRaD1KjKYvpuFaWEwXkwu28ABo4doDCiQux21vqxZVmO/LXQJaMeMDzEtkqEo9ILPMYLwy8KGbkOnEa14K8Gunju8Z/hCkmNvjYc35UFk3KrEI9btARZKPur7OtK3c2h2cu3+X0/+3QLbLemPt14PRGSE3BTQ1/l9Z7P4svMOdeh8veKyhfCht/OLR4Qh4L8p9uv4PtAmZ3DoCYRYz+LvauB5DLtQJXzDz/HvnM9pcdaJirugCU8UFul/8S9ZCpXxnCjdmYGY00ht9pnCuUszIvPBJuBLovEA8GY3ygrYsBHtnuYD71XJbTVpB/h0xr1o3xRWoz/ttPyrj/poOyDdKGwAfk0OwP1lRsWW5Vpp11VbC2BXG2KCzLfdMVVmVtdimAXIs81Qm6/OY1I6qnju2upll3gwLNyRVrtZhZYd1UGN3PGcPXQOfhBDgORoDqGy/B90gLbEKIFXZEpgZGJTQrjRFO+GBZlb/MWmsV/Tnr/iNEjbR6o3joPWn9mfA3SJliiMt9H8WZykxUJ+SmPdgYXRVW7LsKEXi9cY0h6Hz4eH3lq4FXT6E0Imj8xDS60tAgtnbxdHREp63SQcCdRQP41Myzs8W19ERyz8bRXORnF7TkarHP0HTM7oOm1vEBqa6Q9pf0uxEOXBrUhU7g9CGdbb8TClH1QxuRvPkiPZr3UHB4786c3iD1bhqsm9kHInhh9+ug6SfKsOPxwKC20ZyVQNwv6mPkd0j7NNyPJ9sgq3txNgPH1WmJefaWHsFYZyTX4kf3ZbeAR0YNAVNeYGyDqhHXnSmuNGPIqzBL8Yjw4VVD0LXKvmraBcjwLHYfVMrjIhzEV/W0RPqn8gMM/iteuWwpU+3N2wKdJRluFph8o7dJeLHYMmJF/8OnDhOqaZ1li7yuxQquwyB4y6BIpSrN25V/fZo6UoDxaxf4prBKmWso/rR50eajFSuQiWkYeIm6lJ/9zXC9QQylXlfrfNgK+rwh9v7E5lrnfqExHbCJoqll2wkHrwdEm472jt1zx+NeFSvR+ro4LR+ro5mAI+2/v/Cnv/ArAdqv9J2FMeS1rA0VSbjWuc693Dv5G+BblJJ0dLiB3A1+xlOGxO5VuYtPMK/+FMhvZ2/AVAXkbldf47OpT3fZDNY79WEKzwuVpq49gxZqer8CuP4gFGXcDpEHUxZ1NLdY9AryXz+kiDPQpYHc2UwxaZVCbqKSGIjnNjIyREDwyW9saQXMGxYc6Eme7ROzqanIdtxUzgGMlaCLQCAY8sBaQ138FumQ+jnSI6THaVN893CqDEzFX5cXTnsEV6vNZ68nx6OQgzAYmWPTps712CLsIYv5xDxAJNCq94II2jVVkHlFP7QcerjPE8kaW1RSi82sLiL3C3V9dnRSYIKH8tWMDu4YHNW1CmOLmzIyuPK3z/CXArEwI/zR9+jbvPy9KTIJu1x+Q0H+yhT+N8x7l9aTCEQqHKmJ/dokTjsSoxfnRFrVHMo+Wt9vO/R7LlVY0xqo4zcV0X2Xj8V+xr5eB0SblU1U5BOlIYv3lion/IK/Cm6CL5ULxw65SAwAWSdmAtNfVTuvGZwhyoMkQTz4IqmqQY79jRdEE8gg2faGmlw43ijBlvPNHUAuiNX0QGm8ipyM2CPt85JYIIkZyUTiUzcLEOlPDHfhtHWY99VIjRIn3vPhIJMWKjy+Euixbyo16w7XJBicAMz8cFMVwsda6MKqVJ1YpSz9Zm+60ubGZWbPRllinygCVGuJ1uF37QJaeF9hUDnaSyLYf5h/rOLlVJS2RY14sbmxsPX9lOiFhjaSQATJdmr22/+900Qcg9rZe5c6NoJa6rYuGDy6Rm73RDl5WhqRu9i9f+ig9EPP9ctjGhI+r27uLkxnyC0cSlGxzdAnN6vEKb8wcTgp9BHWxRo2ZiW4QO/E2wya/7WoXew1KDp37prDwhVdMCVhwK/qGV1EV5tpnBlnisL62U5PW+2F2QtUijvv58YSX/K4NWZk6ZjrUjxUaeGC7a43Gb6aSsY+W35c/hMww5cRJMoZQu/Jkt5+656/o17cvweexWuQVDXYVfJhpkaduDpYvISDkrXPQjTI9qNdP9wxHY9VOD62eBvXZHPjqKyUsI2ls3YRlALTnJo0CLXufpowRalksnkqcRtkZJJZXn/8aquLoYtiJMlf1VVmumEGnge6vd6otUc/2d+nHHOOS/hOfUyElFGY4XiWRqX8cFVdgMT8IF28qdRVnI9Mdmh8K2pO+jtARk5bcN3CnV/CYjCyhuXTAjTXq3C5E34fJMoa/IxRVQC67GkrIAREfhey6gGgK4rGY+MyTSAPEuw7Crhk9KtbEOK+y5d6jQQRUYUd8HsdjXo+3RV8caqJ9VAPz1yYmkCnLtZ1vnCPQ+Z7jCHQOk2qmUwaUq0IWo74wNcNfv0lFaq/ZgApuWjtTtmj9EwgUKxd+esXtY+cxULN3fYJgZRgAJo6oh4CUFzj4dOwu3YxOzqzys+fapE2HL7ew/D/YkLktOCc6PqaLfrZpZkTm0K0KkdL3iKcbCB1gMxrLY1YTbTBh5mqbLwAL6NUtRiJP6KDMalDgGcH5DljKyxxX25zn9+3hwm8x4DNXnlfjse/q2ZfDHNc9BdUKd7y0MsosiDbygcG6V+wTcDRgR84cdv2spoxKjoXKIc++S896SWI5yz+uUDrMiQZXXgNJ6Rums2ugNqTgMGkm+9SOTDB6DlK+lpEswY/Jheop2QYtOZnfsHqovFgTkpZTUXXL5/Zxzp24leAB0mdf1zXpuxsGlW+7Od157NhBwpzPF28OioZ4YBK+6q51r1G74ojnAleVQyZOXkKv57Lsxontb2SdfctQant0WagCGOqwz7rB2zbn4vvDdPgM8OEOtpUfMmDV816ajzipEMn7QGGLcoK4b1kzOVGlohWJgG5i0H9WjnmP2YIwaf38GZy9TKS5ph+BcLGQl3fSUpDRoP14Npb4yprbSrlCAZ9o3zhDe7B7ycrzn4JrurvCFsnuyq7bmjvpcnwpyfy94mB76kJIuSmkm1+TjK6+j6lJYh1q4GqP1Apy9he4moogv07J83/1al8RF3KrK3NKw5XOxoIsMRjB5u3UWNGYVSdHdsai9MNBTOenTYes5UQqqQCUJbZ9TmOI1iZJV1G3scLfBhQq11bTnlR56NuPb6DmNt+XN4aIWLDnLgVA3NXHxGWj0Ir13MYEVHJsDVC6C6aRwjnpTgg15rxXtsXacMso/KhZ15heN0lJqxVDrlCWvG5lUUNSQZZdzrhtpar48CdkliLw/INcZYhOUvMFAN6uQ0XvAWvSf5C6H6ymP3mGsQIHSMX3FFELSAptYdYuoyBLmZoIvHCH4lzoK3xSOdXe9s14/7KV9d+WvZB4KFCJ05K5T15uTi2QBMMwYBJqWBZOJ9hvDpFF0L7fhNwMK4wW3zK4OBwJPulHhNOe8WbCKlA7LKQA1bya4HwjzWl7gVz0HiJJj+IGCpQ3wRxextNHr7RtdlFJjf8cmfhW8SRcqql3UV5lfCfxBARfSXNU9jrNCRfXNPIenk7xoNfC9XydfYf8nTnrug2Jlxhuk83YwnnlpEJjAv3oFvqohrN3kGy2rnjFNzCUd1iD3XSQLGgpT9pZzapCI9N23BEQ39fnwmXJUNWerKH4kIc51JwyyAliZCoCX0UNSNfNujHHgphz/vkgo9RncTCGrAlwsLjaod5Oh8zm787CPuNprgDjKnmaw1w3cAOgpn3UtAF3PX4O/fELgYPHVF6xxQ8j6E/jFdlqFa6Re5t7lHlbIqYWpBB/3qacbRhFUwAV559GaZPiLQo47RJvTAOktaTim8sRZDV8vy3z1EtC70xnRn+Md/YWjZPYsfK83482I2cuJegvmK4zGpmofAQ855Lg+vpz6I4L+WgWUVTqVTVJFiE2LKhZgwJhO7ZHcW55qYIUsjbgIGYm/sfo6A4IkQl1Fq1xki4XWxr1JLKVHCQgRASYoxEGXxyITM+bvTN+6IaG+xNUovQWOqGkNlIv8yKHD7/IBZMQSCxltU4qm449y0iGjCZq8AMbanvWQncbObA32JyJ13Ob4HR8ES+Fs1ouw8DefOIy+xqXRIeC4Ok7qw7YCDQnnUBZbJL4mZ44hKwxkQFohIM3BJm5Q/ZnzppPD+fTgpsBjtO9Qd1w02niTQG6ioWWiDdRboCVhaGBR0CQ+CNrgHIRprIhdLisRd1Vq203jOLbIdvLSWUFUPqq0OeAl+vulPiMr4GlFFaSEFa4X3154NG7zIXjINjBnsqL66H7wclL2tr8UKb3S2elcvoyYJ7u0pmMW3S2o7APiFfgHBNOdcLcte1gsKxbDlYniksARjbXr45qDNEXc+3KnQ64eDshAilijYUaqd2fNZ5OhpYeQ4meZ87y+uEjq7As8dmhDd4+dOYwIoALOs1RXUyfV8dks8fN49sgJUtbkQas66vPoNTERXtSPmNm1K+yJcWaUrgoz+XkYvU7E7+wCP1fZX9HdnvQckVTYnk5UKiZEbecy16IioXZowgzJiNsw8a3IFMYMx0/lnwMo0JQ5YLn701NVVqPy59gujJfPMyu79YzPpxiHTSgQtEXsKsj2EDReR+Et2vK6dQb+8cp5u+OSuQ9TS211GxeuA6whWIUDjE9CWCwircBV9TnQmD4MQsRYX/Y7lCS2/OKutFcDTxPWQwhZSConSZXoKW5pdQirPAo04IuF9vUDQr2maF/1kOvMs/IoBvIW3Xngblg5ZH3q7j6gYyASkS0D/43T+9ihCl1o3cS5rxZxxbK6fxbVMUh2frgI/Lmi17gtnZl/R9vOcE/JFD/3exI2vRwujU2R1Zx7tHWCIDJN4ii8MUmsj4iHsde+2L+tuZ2Cw66UZdeHyCmX/IjkQzP60DvNzJm0xNu9VbSrxU+uN7bRNo2IkWGYuU1KPkOcdzrpq4WtdsA4iVVUp+NZJYREpU+/cBmmFKZsTBPVaDRdcZ3K/9jMwrd542akmOk4amPS258GVFjpY82y4M3UtUPIvsPwTgzaemI/dzlKoor/BKOVarjRhwu/Y0QoQvgPCwKWx96t8OjWDRACr0fw8TH0IItAZf5K57wxDdSdB+b939YF0N6OJ48vUnfQkb8xEZVqraFDmWeCK+7NbuK6W9Te4xGKMamUJn+k4GGb8YV8hFg7T9x+W0MROsbl+VhnhgD3uFHA4rZ7vq908fCHynE+vaKp2vcIuJBBXOcqsRxzOEHhwGjsXJdDezxObBG5UPbJ4lykAQ+gCBqsiYvbaAqbOQt0wSc9uOISrNmKxBmkkdfO3/2oCmYsiS9BMVURqMXtSw/TpPZ+PbvqNkf2hEmFPANbOBbAQtj5tfXpVuC2/YgaZfs/sKBzuxVlf/4a1Yi/2aTmgbRgVmTFgQxnvaj5/Kp6wbMeKqtEqxbrLcBEi6kOyzz0X9wrNSQUh3xQdP0VttOFNuDHI8XlBGSDrmhY6D6hTVY9ad7jUpvj3DBL/wBWRNseiblFRCYwBAwQinqW36Jg8W89rbmxr7i2eLu2W4fpdLLR1m77Cz0ua1qkW+/Zt9iaZ4sGmoLL0EMXL0eFdntc3HLYS3QsCEg2dm7U5+EPgIlCWaR90HFn6P6r/5rnlGqXdfyBV2yoJy37gkeFLSM7lNGVMxcCGIk6znJADx4QhKRenS+maJ2o5QlY+FP7tNA5XQvliZx/Ild3hwxpGxoRqIKFutrs4T2lhST3N1k4nia41wEIeVq2+0vNK2qs5b2rSKLI85h2hGBuvEj9De+CaV6EES/+xVj0G10So2JxvukxT73O+rpkU/XrI2UV2yHtAuUDWXTveqRrxmdalFT3YkV+IimSO73yhslYzQpvLWxPgbrmPupkbVN7E02OzdUuwEIqJQgvYCnIrCihTxb9neqdWtRBss7xxrLAQCNgRGnCBtCfMeMeC+T/Ys9d/SqYLdjuTT0uFYnFwPJpUPdswDgqq2VNOy/bvJ5T/LsJe49ziW4ArE7hh1Jpz0g92mT/vCYEWT7BDrBmTNvTpU0iYTF/dR/+j0MA2yHG4JlF/a2YUFL2yubgXA9HYX2rm8naL0XgwCihr5UaflJ5ULxcl5gFYLGy8RMIXdfMQcnIKxw8LX4CFJpcJn3SbZS9bHD13R54h+b85nNK3pzvRm/+y7TeQwYw5un+CZeMVtQXQERWGCPaLSvMZw+kT/QG+nuMGZChwjGRKXtPxEz6Z6/mm/IKaeHQaKDWCDFuedn9x5puYMNLH8BvSw/YqB0AAMWdIe0A/j6xDbSibahMIUVZrIcLf60QBWr9SyPKWesnKeK1y6sEb3BBpzAtq9OVWDWN9Bdn9xFxmUWrR1XHsyDmbwPyxSeWLg5vd2PJx/rZVe2jF8DQu1Ml0Nc3fs4KdeseJ9nSZaIgsbSJk3dPhn8g0UW8EAVFzhU4+cqlcGWVv/lbDwrs35AJZ/zyQqIOR51qqFELFseJ/hQbvFlE+jDJlnuqaxlrwVLsUWEeKC2HIbG7nWT/Kd+xYElq28dbloqOBBZx0dzhqSjUdSgsYrDjZwms4twjZJGenS9MJWHJKahMBm2MwsiRRp6Wv5mi68XOYqrzBojb81NA5RbtE63/SoQB136GcWNS75FaZR7dRz57KYB2lRdE/5+Ad34cFlpwh3RCj48HbB7/ZddK8q243cxaqrbfI2vHPGi/ewyGz4Yf3uUamQhnMvcCAwHDP8mO74HTHjZKRdbWpAskfKXhzPHy+I/wkRg98Oue8v/4Chrhhx8CznrvH/7Q6softzB+q3ZfHYb2VTG4MCrbPi/hTagV7VQQxozwrWZ/VGN4xJntfh6W5KuRbVxOTQ7YjMw8k8wzpc+v/Z0ev+owE9tiP4ARP6K4oVEbU5a6/5OEY8vHh0qd3aqmd9iHSwkvdrg8QwazLSrlQDC8IlJqnW4RZCWSGtdg6xMZDTHg8C+rBugb5vjG/F8UcXqpzDfLLIbXwL6DHi9tcPn9IjcxCb3Au91Ialm651cdkQqDn8eQOSMVhUQbrbIarQhRkyeT+RiXdjtp43RvUFL33uEmU/Pgc8gDpckHlj1TWY+7NDuGTITZ+JbNpNLJWXS810TCQS8eVatulbEmhC18emSe6bCPSo1OJ91L1HADP+rimHcKLi6bYLEVgiHd5sLB01BeyEL9rCoblZlcW496DTIeDvskEFuEhrrKj6tqufgwdlvUfaPEheE4vaaDf/4CJcb28/puquDaXC4OyOdi/3E+mqEHyT2Jg7CEh5djv6+pyCe0Sjv3ckFukc4UatpHtPc9GnNse4VT5IPeZgGpLsrj+0gq8+44q8k1LvZTq79NIlio0o/FbTHVhx/oIOqVxXGdc9s5Qyvepk4RuIwzmY08NLzk5sjW3luiN76tZbPRabWqkMWV+Q6tFlnjd3oS1TkslxCNg719fkl3ExPE9cOhUhucxNVqjqyIGeIUBOeiz1Z6f6Gy2KVH08Ct6KhtWWEQOG4fi0IVe2wHx5EHLi0IdkQyCJJMNdR+tji5fmCN46VFI84CqPmkmjBOvBoxGVjMxmf9fSTF/Ft2A5YmnuEOcJYNBV7+68onMT8Cpa7p2KWh86qvbqWc5znppXWgwX6WY8gXvxDwTdyazm35MkTuDDSdvN82FRXFCGvcxeDy0dNZrAvguTpi9mE5lFED3itnd5TD9CxM1mG7+KuVNQBkIPRC7HvCjyG5DOMAOGj2uT71qgPgmlMwhA6XKBuQfzgkI1xeR9p78eHFIiI+rLcFSmVFMHbQhMw9KWsJQlUTuXvjkKGGl9tvC7ZeiPHmtTdRtYl62Wnugs7Z0QGFLDQdzW+LA1JIccqi58ufukdW8c4OD6ldRAAtzu6HCZPE8RAQlWYS17LzZCRCFjgjXvhvkBhgsk0ILHL/lPDk//ZX74uHVur3IyE6mo+75GvnCevjAUa0T3AW7yLJS9e/UY0iOd6HZrWlCC7EqMh2oGrSxhO+4Nzmh9gi3T+sFMyvH+1aFH8BJHZ2/l9vK89QubpHY3cSL0Z/A6/+nKqCuQXWAUZIjiJEHBn5MYqiEnLOO+29PfWuWPTX/I2VFGXkvogSR1wqrHB5CH+mWYjKCdxKZ4jM590fBwObKoJL4mGVCYJunP4yCe0bAa2AgDgtNYSxh7Eu97K0iIfv6ptzKhcHc4X9bhJlEHFGz6/b954iOFPQYkbSKo8uun23/15zZlRtXe8XiHg+g+doekw60N9EHrAeGCIK+EMlMtVUgDYD7cxoGqf0pF2evuN6zv0HydHlS9DYlwwFChid88MBlZd4zj8GmPOr+0841efvnRK3QgY/fzfNDpLEDonmGkqnBl3DBVKcQdeXrxo5fM0xq8AcKbSlFnq4IFjinAw/SQOrGBXBl3zFuW90E2YOWy3596mv8hAlVa7kTavixrrok4CBuA9tv3dOniO/Eca0QxAuvAXKfQelcDKxR7tzTQktVFHqbi2fmE1qycKRq2QMzsFec8xghbcTabpmfPXImiEtnaMkJ9kbUE9FIIxyfJ2n2IXAST/jjey0wRSg41/gLgrIFejeVvjRSgatv2j/qNRTDBNHUenmKO6CKyVIyask2oNWzx+ONf0bWPZwL5gPAIMJwRo/1eKHpoJ6m3pIw813liOuKcrA2OdMZ8l1Hmm5ecgruklVn8O3rEp7iNDlsyGVjDKuVJiMT0NOUxKR+38U8/5k3fZh62pTrsmUOIvPE+Z39iUDVwCf0hpMt8lqJmUtxCb7GBnXpVl/cNdcjJlvPXca01EpmRwYhoFmZL8Ly9dbd/t5KQ2amNOKdTgHrjBH1VrWlKJPHCKNz4HNhGL/lqKIiyaLNC97m0Pzr8/9bcmPABuT3bTE8IlECz338VcXsvQmjpY2SgXou3uv0EDs2gDr+nG501J4nr0awCqHFvFyiDRmkJDI/YJ1tDodnd8ctM09jsBufWrLs9NkbutGiCuVC0lC/q8GG1XNJwExREpZkvfKdG8dmnxtxg4SyCigWkXAcOFhJtolsU0h9HJvcUAHATOe4/bhFPif3pxVVcOVxxJqmrj6lvzEX8uffUJHKqexZg4Il02UZUPe3yioHtvo5njyjTX66ZVJy6wcHUvTDg9PR+rvXuew60JdNdgLwTgPgNCpVUuadKtVcBMO/e3fcboYfj5n7C14cKotRfG4yQjwpzpPFt6tVqIv4IaGqPw7i+3csbwhaSpnrGg0XCqbb4dWvV1cOccSFnuTl+rHdXdCcZFYcMpchK1rpiEWAId3pfn8e+5Bnq7ZrD07K2ce0CffXB1GcXQbk9qbvcOahsgSs/RR4hUgoKIjhWTcF11gXIxto3MFxd+2E7WspuC5vhOLlJoBG5/jg4fD9Q42/0Up2cNcPefrwrHR1tLd4v2I1MsUQM5iVpRK+gicY3QjFO9qwYaVQ4ainhUU0wEmy8YEcf+KXv4esDKj0AAnELH0+jP8Q94PtQ6V/auX9xxclEp9zMU+JeazQqgvv7xAwe7WZUMGuZJ8Gsv6u3fQtVDBg75aElbl6hM5TQL6sxBJqEZGBO5nLhLIkgW7qUhMCj1Vhaa4uTzdqqCnUe/kDzDpxfoYrspVTUaffPL+lj1eUVXkqZPkTMMXDN6W4fjLEhd+mhr+aE2tm8AYRy3RyOShbtfZwx128DGKYGcgRE89JGalpmFfAcIkBLzAdE7yjy7iESeGH/ic6Lc9OEMtro+I6WfQtqmUYzke4BPlHUnu8HVj6BzY6KGClnSa7/SrKjVfl0GZ4H5ZVrmOjlMj2hVmpmM9zlICeK8uP8cxnhf04S02eADs+brdtgmNw7krJurP8mVKoEGq2o5dRj1cera8dDm8/p8Fvg5XdTM8g6/mReqgM6Zr0hS7VPTp1eh2hKlTjZj75aBRYsPrVxNnoDOLu4zPka6yPEQPTyiLUE84HZ0RbsTNOV6zUNbqOqieiBB5y8eugk2vmjo1mXnyVc2llZbJlPq4LG+HGSjVPbB2lSYDaucNxl2bXrSbJHEWFX89A6K7I7ddP206+HMRLA4VK3dAbh6aB2Lwft2bUHG3IjMwslFZfgY0NBQWYVDgZMxcO9fMN066LH61PjgO81UKg7Uv0uyCMpANsWIncwbAQ48Xdt5baE/sSCWRqLYKVCk8izj9W+22qmJair0Rx95PoM5rqwx4az7b5isJp68cs+vTiiHaKdriZr7XKcGR21KKabE010TTtxw+tMtmagNR6e2YEVdxwahUiJrzRtEe4uj0MgN+NoBGVn5Tp1+wj9r8ftkIi7muufx1FFf8iX907Ui3lxQ0qIzqw3sFW5wvGAFv6hOFf+4228e8puN4W0ZN4mzN0te0SXbLM3HAISUzwqfsf+s4F0ATp2lbrp2Fmi5go/A8oSYLTq6FBD8jZqr9RcHz92jl09mTd6o4aTqOijedEXSfjL2GSURkys8Zqex//JTr9dt2pdGI+8ZVBd+jgkTCIRpdJ8OeY2TlMSy1lx4UzvmnUqQp/uTBp74AY1Qw442g860bCRXu6N1IsD+Zwyw2dpCcBiNNLGbuZclFGZA8hLUUCxTcRHKhU5HPBxdbSaHyRzdr+YtX50mFiaFyyw4BkybQe3qBpFBOTclDewT8KrOl92oWGyL4P+cqxVfBGrrGZmd2FwFa1aZeBnV01Ba0jFSQocZ41SnRF+n8o2wZNsODcxv06Pg99trDMZJOOcHV8GlI4OiUM/zeTFg5ibOBMLg6xb+1XGT/ubJArNB76t5VSuOmNPuapQvKluQ7gUfaG1XKSeXOYeeEJMbCWJjcwCV89FhXZ51a5j+yStTYz5SeV2vV9TNeVQPpEgCtzEgc8a1hkEAR2Yur02qIuDqBZQf+oYq5FZBzf0r+a+WXHv98C9qYgjUbMM2BUleoZmUoc73AfXdOMQLhn+myJoU02d1s73gxOoZXqUvwfdohyTPPvSuJpCQXU6+Gap96xZCU1i/sQBmQQGCtAcqkdk0KiMBNkMcyFjfb9bSDPEG5Xeh8GSX9HA3LRd/+0MrfT41hPwLfL2tHgwz77eQHViRo8+1K+6GcB4YWklyz57c9qblDc6b0zzJ5UDxOrBZAT3YSKzCHgurlEtKVM/JhdHv7HdfpW0KiFKyvTj5XR57teTxgAOCvnQwmOU3KCyHpjErp2GNt28MZnefuoFQEGjmOSe7YxAVCczF1ShKxmGUR+ruXZ1qPtUsqS5zkHDm/zZ1Ixbqc5Y9gOyOreHNGkR/BYRTKKC5G9kxt+a8Ef6G88mdraKy/0lq+ZGb+dQvUQNZ00f468lThz7oOogO1ZeblMqPiXEpl5njXaZ8wK7tNSOnSow2WbMXtFAEm2E4a67yiJKrFP2kmvwwh4DK+y5LYHgsQ5A4DuUxpjRjJ+kCW54GLwK0Y+RIuoM8J2lZ7YFGyE9BuGWoQV0PGboAcN9B245sL7YEGhdkf1nWs2ExtGrLTahtJQLpK5nA2XAq53W9fdRp5Xq9ZroS6d2WCWU8iyd4BUgP+Ks4x3LlWD5r5bRuB5AwQyd/G5stIILdLYcVDRTRTSta8a7+Jli4Ros2ymM5Wbk1nEXU6LnyxzZdYkhIcTvbUIBvvbLZUrGPPoqnlpYODSsB9+ePoi8VTpSDor3B3dVBAhGNhBqr3rDjDZ2mUOtFsbkVzKf3CD1SAViKsFZheVaJcY4hjw02tbn4RAoLgzEmPPqySHkUNIg2t1z5d5w1P4xEkIebWM7K0Lp602SuxoYCG7LE3lYPNDRtW3V6VnLApcKDP2USNleP2oEChPTMvx0DSW632rmQRL8Y0AgUHyDcXFl+JX3TyVx1+Rf0Pv1j+s1qrCloHhVS58BPAzvYxT7d6RTwt23BsPvet5tfP1BuA9iG00GIsgwNaceRblpUnFF1PbYpHsnt9VxrJeJR4sQvAUjhKBd/Cfv+jwA2YALgtGSskPGG9rXlyTJsKrQs+VYYb8jKTbscYfergvdDt45mzQZtRJ7PEFnBVGKx8nBRumONV5qgiv0A5/AMW3Cx+adxOJIeXO2KHGV+2FbzoZcnNq7g57yaR4Wk/3eJhbrXBVzmWyhkxOQLtu5hdCfWyQXbe1vUdkrVR+0P9Mke5O6G2/uUCfDqV4NIJpi6uTIPulaz8JUFrPDSDYFk98TZNAcrqmCDw4UHp/AoiWXxjHAyVrJRzpXRwzZERUWwFh7B7RkBMiBy8OKRsSEyLuqDygNrN4+3S2k2nch+8+3mhJOimtFAnuB+20MwTaKdPWlRlHtj0no+L8AelnYZ5UaPbeoEgt3llKf1IWpnliRTEnujtw/w8scNz1d4Z38VcwcSqn8HXLTgqIuWmii5RVfgsQ0fbZ72DM8qFw9HRrxSXn/fVMfGfZ2Mug/XQ1VIHa2bSh4CfKh3I7NDNu2FkbpKuksmGRbLRpT9Ack+px94G9TnMTAGpWRroELa+1ie8x1YlocmUeRzJnvaquaWUjxo8YdeAhInu6PqN+eyfC0+J5ugzRqKFRVj0XJzGmU+3xlYUeLVb9cCb9fDhTXJA+ehvvPcKq+lqqhlHTmLXVEtAnXbtZgPiridBysF1eUaxnSoWZ8kJUGF9z6VHpyoY0SYGnoVpalDX7GQfiOgHkUo8nEETq3oCPQXb2qPFVeJ29811kbm4wqhjKuZQ2TXO48uB/EBToQ8M1i1p9jCGPaQnaRF/T44Q8ywJZPIMkxc2P8TJE9hW64HLWhwLgFFpnmaI5mYtKqS0YioBnMZKeEWZI76oC6vekWKHgbfw8gIVu6Upr22EIAfoYfc2cBou9O0TumZbqKCQeYH3PVLowpf3LBBKVFk8MeErk0Lo2LtGiptar8OLQmZLUAdpeFrgO4hMmqJw0eBAiO6kKr6r+w15UiIVsVDtRXnSg2ECMuxSbA+doaERXzHMh6JqWA7CjdLJfuJybr7ja3s6SS20YCxYh17nU0OUPWL8QNik0iOYeWAWRfbgUBvxalsCPV7U+k5WMDYR9ZH06ne/cSgHqSsdI8Q2CRxQTB4NuUi8myTiItYJo2xV5jYj0I/VzBm117zHpAT0BbYaYeQUUNY6TXI/JJ5fjVRUqhfFe3ZBLiEIhuh6eaLLLo7WvD00j5VvDzFD5chd7s3ZVHuSUYuq1+UbqUxggqamaikCN7klJWpwpfo7G5JM3oOTJoJAbYP3coOD0wd5YtVUO/Ikvi+vkelU9GouOSedqw/GUaOkHZ3tsxovh41et0C6b2Gww8wdBnP8jnDQQmudJHDr3KhERaO745+FUl787/FeHcdHjow4ts2nL53/s5ID7fZjbUl7YxqgIjlok49d5/AOil3iZgX485K49Yf79jvLDNztsJ/eiJFBF0X3gHsDrDU6fipxFTE1bsCnhJFj2TSd7GmkOzB9HZCKkl054qzLo+MvdTBDE8AhQuqa82OQrHELGtu5Tyfhui8dJey+x38i9489qfTLdFeCw0gbS0k/Mdq1lx8kmWlcDtmyZOuF1bfy2FOA1aUoM4iRvmBF86tJoCtN7eepgR/2JcoBPOaDFZ3GuSXtOwltxv/vQtPWmsOH39bJ7rTAaeqSxm2mKrLYPsvKk0UFSzvxmSmar52nY2mjkC7YTys6IOawJmf3mVFH04CMGRPJMbOstr2y/0IdN2hi5R2/IH99jL++XTOZsxT13fLjnTmrqlRDXBv6FMtd27s84u5a5mS+GyaTRW3pozuYSs25Fc+BErWRcRu7VZSV3Z+33/aiaE7YQIb0sAg/Sq8AYePbhUwrd5qyR2AOiMLl2Xp82AAVszwRQyQvcDQufTnw4rlpc3Br515Vz7SgOtcW8r2MpRTEQX/7f214NMysg1qMQZr4Y/iP6JjN5JC8gD9Uze7YfKA6g+CmSPQs5Bg2f28VLeRSTsddKUKn7ESoFVOW9cy57broTeR+pRrAfyHGcz3yn+453PaPnlHabv75MFU8usHeGFqxYNlpUxvAJQFhcO2BrUfpWr2HZ4lbnsxKbXf6iHPPYqpLNiADhEr+hKdO/BaYXFviuqx5N7MqJfLJkq9RR+pl3f3fS86JekMW6pz2GeI4YMQSCx3FeEqJfeKP64q2wf4mbLzxe+saGGSwZtMcnKg4TS5jy39XLrz+LEn9/toyRu22qTGwMVGuNP+DOq7cqMMX7L3jO2m5Kc2wgGQI6z17IINR+tR9eSReKH0j06Rd5HG75kYW2/O2xEKXftMExHVGquaXzl+mzIRszBi5lxYcmxfsThVZuwmID2yJ7gS13w8LOUoIQsiHpVn+mtA8slJO/YrNkBTYCu4kOkNkAtyIETKu/BAHGUOI1ystWVeZTUcTOa0ndl8rlnhm3HkWoN7+ZSg3Mnk+QzIBKPI1ir3chV3Y5xh6VcFPEnKzZqxOyxsetWIVZcUmmk5zOjTD5QuXA3O7RXaQxARP9H7lBe7EoyZ40UU7AJGDBI5nRgPjgcnzt3iOAsAPFORq0pmK0JOmB297EkmYnW9sh9ucrZtJk1EWh78a+Puy1XoFAth45Ld5dOOyXJ1trsOhzR5Y5MirumbzcxaZX7sOBn/AWrUAKZ5nZl9J17Zf8BOTGWaiCPjz/aDP0NiChqmeTLVDTZtnOHD2jXXMCRzjDL7NUdCCGV6Bo3v9pQ6bMujlidqCpCtWPNR7YMOsn6Jyneh+QMnShNM05CKCHV4w7Rb/GzIzk5QVXLlGWCtBkAaRTqX37/5MULYM7kLDdV39B6PUghxV+BH0yGpZd/rJVMvWJ1KLydmdeYg8BKoS2lZmFrIkz1D5IByOhP8wsqn61L+HxuJmNc0GzgV794aVX2lwNT2BIeEr3kpb7tWZYA20bWjcpwd3H/w8NSh2ciLSJnrgjbw4joFW9w+WnQpZB/AtzuRR75hcA3pD3tpQ6QzyEkSTMK9PHSxYTL6KPYS4egg9X/DYa1XZZKk0vAvG1Qn/HssoMVJ+ugzNUCpj5v4UY6xs3nYIUn76qAdCqvOzvkR8L4CEkInopEdI91MC8GAdfFA/N7oYm4hRMTgQrJ5fZ7oEawIR10SW/yuea+FrV92/HxyT4QnBycdKIjk4mNeOoml5ocRPXWhL9VrUS4y75CDv7DleUrnFKZA776mm5DXjf+FcPtiXg61TJQMVIr7BW9VWjmUSh0daRx1C3PDR04oq4X5Kg86dN5MLwCkYpCvNQCDf6OyjuqGR3YYF8vNpIpvx3VKZmw1sb3uHlfJKK8Zk0U7GDjU5qyNeVr3xCf3y0rK0CcERsvy94jwORxQueerG7rxdSYq/X5FaVl+QQgijgggE26Wqz5tTC1dhYaFA1cFf1zaqxw0QMftwG9Iyw72X3Q/0ss5BHqKf7LMQRmgGEUS5UR5q/tNmflr8G6NQgSgFoTCikCDvnvyy0D1RInUa9QhdDzWfCwfZehlkBg7ROS2HxerzzieQxZSzf6CbUTSu5UgeE5YvwIoigmG/h9nTk9uOP2Yxk3LM82NooxmsI2rco7s0PG2w76N1zRW1UtCqYjVK6t3bDcL+dRLoWi3z0a3qLLj5qC4lHBSf2JbQiFYzU/mMVseNefTmCwtEUXF3OYpedORdM3WuC00DrUBRxJOU6k6YENyenRSpSvpzV99o3WfmUNLJzpvriGb35Eor0/+bQmnQrCtEFFUiflLJDMBjFLJkzOlgVl/xmgNtm10VQuNEL+QzPiA5lRMKjxXCoIWTY7cFSkz/IlH7AqQy0gx1lH4/0hI20SSp8fxSK0LdkZHhDxMYz3+0bZN2eF+7W+oWyXIC73/iSWz2c5HzoNTUCyQDLKnpYU0Rl5fw1TADU4O13mXbehxmgo4iNFF/hVo2G0hzWFUgNVl3MPFYoeDS/pbfxHyjIqqowTUN6QW9NDKlT02+vdOMbvRphOUR6j162ZwaCn5oTHEDkxWAyqufo9xckfGa1sGkuACEuQJUgtpgqWBp5yJq/KijGRvewGQyjlDPXWod7T5oEDoytCNXt9KdiBtm7YS1PA2YKONPWoQhn4OOhFrQhwc2dng/KKzeO0sgwzPn+maYcnE5NFH2I72Ug4LHRhtkT7cB4R73nyb3SeDdhsFFHLEJb+UD1FcamC+X3qSF8dqD8kVFhsK0rj9/hzcxKohm8KGnYhJe3p67Am/2OkR5FuSevZdd0XbDWPuiUlcYOLJINVomT4dY/YktkrGAIVYqkRgMievurQjM7B8b+y64XiCgW2hJ3b98YCIbaNhT9s0MeXJbiSj2/NlRUA2j5B+n7qfmAB1FNtO+W7UKv3/+d9Fx/zqn/jTg3qmjjGdUu+Jfh4lcR74gEZySnYiuR//6C+sFZXWpaRum29kmjK+AorCkcmPbYvcT6vyUD554hIgXVZr1p/r1pRlCoZHn00L3Iz6UQOn8tME7is5QYX5Ci7ApzWDS+CClUfsFhVR+7zdDrdln5LWSHQbpmD6wt5ZnavglXhA/5qjHY/WYlHOM43mA5KI4U0B+qV2eUeC9saE1DyEyNyihDODaULfM+cA+hOpVfaGPoEzaKAtst6tz3UA6QAl9JEleWtTjUSRtI+DHXQeAj511Ulk6mAai8YMKZzWU7gbYG7BBYOy60fsi8cYNn19vD6QEGc+ohRqffYSvnudZ5x3+PhXMHIsJ9/auS7ucH9RCjdmQzJmjcxDMbv8eafXCHQZxWkn36d4JGzxN0+ifUfbE2MvEXsAM2QGXsWY5jXUdmD3l5/DD3kbkEAjCqpiVnAMv+x99BM57O7uTQLuzmINoEAmroRuDwsQFvZINlR/mR4nQvHdP11SMOGhMtNqMnsUE7a6Xd5IIGQc+9PVheR86xynuK0rqWEd8sYztlTqIPQpFKNAFfTBssQTkui1mUPhz1UUgn1LxDT2F6v9L211Leat/aqmkebZib8IhbAdYFZUDqdJFLSAllQqtiyYFR9OTvzoHXsCsBvEInYloWJB8d8Pudj7Pvnt8nqqK/ufhiHvykHMKwHdpX8YGHf337mMPOODh18p5CaOX0p2BRxx7V5fGHa49aN+1NXQWkxspgrJD8kjSG5KROg8s8HUrdH1yvosR7hMsK4S6g36DuWTzm0L8gXoSskUStFGTv+SP+pc8zGeTs5m2LE5+FnKVaP2zMVweSjVW88efjhSW1OyhuqCuGVyRAHte6R8khn4XH70PYoP8AViygxdIMm26SsBnB2Kb0Rj8jfvDyUBEe9gdkW2GUnqWoIUrFZ/HMK1CH0iyGeD/FQTxVzsO/p1FMfPmn4XrXwXdm39ONlwSrsBfQSvhVb+7FCvjLT7i77ZQdW0wL//I9Zm/oUt+Qaw0sRhDiGSrAgfupTp3/TOFO5Exb1rYEsXOvrkmVzQ1zisWZ4CTbYvpCigcsGPmLXmxzql/go3Jg/et9yFl8AfaOQUnWvJLPT0ccU38e+8MXXYPotpUas8PS4w9cB2gt4o2JR3mZUknieeVLmxfRB5zt1FlWCh+oNTY0DiUxvgAAMb4ZN9V9mbx+DhKPVFles11sKE1tCIZf8gdSk8LJ7g8Pc+CBKhuoHcpvKwMuPI/2Sn1P5J1oD/rMQ7StOatnQ1xRPifj7zDYXTkemWQcxrQBRrdJGcIRBwjrv/W2NbLJEdjMsUc/3LEJ3eRsiLKdBWfTCxZ4irAU3RWoVk1yrSEWBW3U6mxTB5IefXPnj4EhqMP7fSSRRiiFAdy6YAT06IPggcxw6W6FBqsqVOBMDf0N9BIUhXmo5+ICahK4ebd0yOQMKXB9y2v/Sm5vn1pF6hERd8XUpDXVBT75aYwhJntqkUhlZ83/D439+6ACKMI27++Ec41PZf3CR7Ey3aMbLreRLJBvFH/Hkz2FHJkyBm6bDnpL53n+NSvLJhu6+YnFvwQhYHCcY9+y25eTo6Jw/o+GtVtfp25LHmRepwT6VCvd+3hOsaJiFaygW3jjcpot9NOxKXUlVj6/tZVGwR6FA6Bh+qVLkGak3zFuEPyjJkCF+SmUMU+TSxkghjG8+CVor1apu9OJReXGLUFZ3bi3PpnvOTjFnF6uRJt3LpwOhgE4ANDXA9fgK6nh8D7QSaGLamoht38wp6acKMRe4TbfgBclSzuc15/KurOHE23ZgYCHYq6f/zps1k248xtBWMCX8P181s4oB+7SfEB8Nfnunn3CYcyneEWyjikC0MgmSdKqrBwIO4rjMOL90uqIMjDQMBX4Cw9HDdRjVvKZz5lMXNdiWfkjNO9aFJ/QPbDKKMr1KiloEIz7YYph/lhtdtndkrQa6DoZMKlceAeIB+/J+ghrk2ymE2qjZdKziJuPfvVG4u7RzLkiyYeMfTkci8SNqdaer738j6mJqCKbsfszd0eTzUJ4pkacHMv7z8MsQX3yglsqPJUEr4A/Lz34Fxl8g0QfWryjJSTARHrmygbt2T0qxFrUV6RqUmie2TR9r3pYxO0PrW4eVLYgtTReXBOIVeKj2Rkr7ezc30YOQTQqY2TrGD3c89GRkE0qEl6n5DVANHHwJPrVIENpd24HXNh0APJaJevUc1+8oso/WhOmgHb9R1+nKeKDHN3sbbKP3C0oJ/dTzDtMxG1SRxb/FHxTocOvgyOm3BQ8s6ZyTNg2cGYZZP5WgYttOegIjjWlBksNyI2HTYsRBctOyyFSatXhZFNVYHfvdizQ3oG0RdAdrx2FSfkqXU0/jd/yYnvhbiy7RLbinjP8fdKjRYOEQv++Y+rkZz2U44/BIwlrDpfcnrTaTAIasVNz1QU1a9CwznD6ZuHTxHu8MZ66GqhxCAqHpDd1eiCLvlZLKQxbifqLHVrk36fBnz8Ay5sW6wyamBMvN0Rt+xVX/wGF+baMp/pJWkYKFNNStsueq1SjEfU+z6xuozPHBz541V77Kn+6IHOnRWJjC30eBb1cm/A2fp7zEgRublaToiCE7vHxEkYNYIc70flUHK7vnLdShXk5PWUfuLIrov/8gb1IS92KqpJid33p21fyy9YszwMNBASp28ggdhl8aaQfj0QQHIbv6GYSoqpUV8FcjfP927Yz/iRRfze6bu8ie8ZgXTaAR5Kon9o66bGoBhSvNZzj6HNA0YwJR0/633ijW4RPSSG0ktFhaLhRzkKSWE/jlifbTC/XBH4/geX3yr+s3CrH7ifiDoDBlgFdVA5Ct5q8DBbzG9hV9J4FGzSHcY5Dd+pOVoLhoQ14e6Qei+xPFzNxVWpc/UuMGlh1CAgY3MZy6fR+Aq+xRlsjZ25tjD+QtN7dWMruzpVEjDnOOi43AwBdn1XAE7O111Zf3DV1/W8QLabSCpcQGttC76orhZUrwNro8rdGlSrKq3BYKLo2xkHx9/zaoL72SkFBT9ma4OE7GBV79l/ZfWrreAiWEqh8QTSIKowoA2vsl9oODkwD1xqwxoZYBUXq2NA+d0l/tl36pGLTZiSIBQoP9rggJUVXwdjRA1LqrIpGn3fTrlLzHBSXsNYlYpJ4Wz4YcLuU+G5yyDCarSQa6oPI8LU62B93EyzZlgYKnXid62489NvmA6Z4/fh4hhs7IEqdtpbpE50gYRB8a2D4ROhI2+TY5SI3O1+8o2msisPBZ8vEgQqY9YNU78C3GmYubBKUfK4Kan+uNrKPFBkLk90Xwybd+qMyP7gachVqD00ZQgAhjHTdI9Lm3XvoyoTXRTJ3UZWeMxjG6MSxHuea+mh1cY4NaUlm16AKad0iiWeE6/spofXyDRLxoJVkBJ4eF3sRw40051u7vAi8DCnWVwH5jLUW9KooTT0uDsToGYs86gt6tuHUrHx9GRyKyjFUe/El/Jp2NtXp0PzhMTTqY5dQMWPw+mVVZCciwI6H9ipkVMVxCwn3CMcgr7JntlDZ388Hi1fpheHupPA2NbNJtTERgAdgcdXhdnEeCjgmXtaS/DV7MRF9/fy+UrkKpkWmWwG+KO5X+v8gFy1J81PueA3zLctciR0OjFoupouf4CIdwtoXZ6662VZhF6vGcTYKsUygA8yDuxbvOtYb7OfXancOVDYAqKB8jUKlUJkBMStj9eiFl1gpnj1U00FrwAEUUkLScOzay9YRDw39ZltBmTu1MOyJCrKeCEPhvkxM1scYHqEo6xecWzgSYe85qQwIvtbdQAiy2NSTyPVl42gEw92eNWJ7xktZKQo2Jxg365UbjXwsjXBq6XD99xCwPCvCTBrGuiLo6aaBQ2Gw66H1sfZ6KJw/TUpqd7MtUpoJSlK3DO48xFpp7yfQg+ZsWAL2DLnBf8VyreAtiKKb8Sd/YuNSMc0Ja253ZfC2Torj0AUiJv2YYYpGCm4zfS+vJRc+3y99LCSF9bV3DkG6wQ9g9kXGtdJWXcrFlhk/OriQzpSIupy4VytABSNxKmhqIAjB0fJsfb7MZRNwMFIC5F74pZxlyv1UXSNJVebtdXNuOcWvJXVM9RazKQRhACBstRrAYYKEHnI+BseosR42qKLJkfYbcRZhmryU46R7XXs/I9s0W8Y8caVtgV6ViB/2MLv0ezxiXFayC7OtY1D8QNF95JRF4tVaQV2MF5AaoxW45aj9qgrDp+e97uhDIh22OT1+7efd5dTF9cfI+xdczjNWTsyaK/ihXXBn1NtQlPS6yV4mAqu2B6zHenjhvKiiqL5JrvjBMeN40GjHWgS4lz6TGi6BXfpwpZd+1hJaFQt3cN7wLja2KOR3jX0Okq5c3vT4j4fUpWucB+YHKk3LIi+tpvp1LaRC/aaJ23c8IXn86zKcKRRcHHlbwKXvd0Bh6GeLrfaHFgfPPj8mjaD0lhTcA5FmT6EwqFkvXwutNX68b2ZhDW5AwPVYUZBCJk1VcgMfpmZr/wMdYLhhCjehJHOfshWb1kEcLiTAx/S1XQIPbBRDt0n4dOFEBFHv1blhPU1/5K+T70rVg8MtiWS2EgmC24iF2kj7U+qL+eGemNsErmuYpxG9ssXUlx6qyhqo5qWr+jmhJYfHs/WlO9/F2WhEGplLqZLyEtGX+0FatlHanvcD+36mmlj9ZLpHiw3LTfJ3Lzu88sx/JQKr2/QZepsQRnzPRw3FotGCwhkLZCY9Yjy0ExF8OkXxWawzpRUKcRXuQ5E12k+pe6y3AMLio1BZfYEBhMow6VFDVwla+/MYUr6Bgd4WQRsmv8Daa2J99pkYJvTcPoJuYbpmEeKbi8ExeT1ctArXM0GImU8bE3UEBxJvmQhCGNAAANiJpaFFo/1BTjTMKoJFVb38BeX+DfmSjIgXQisTCulF3SqPui1sokHJ9h4+Nuwk9SIyPLkIoFwWMp8YsxKZJw/M6Vw0OQUUJwKtfRmtyUA0NlQJqDNPVgO5W00D+wy7ZxBZwpm+vdhw/UyjKQyG0hO5NXaR2HYigv8eiinla0eVkp5QoRD7WsW9mVPs6b7YW7xCA7X8FJik8jrZfhE8OYza80otaOJ5QgRFLLBQO9TFyoHuBnKzm54lSyKkt4wc/dx0WbP79g7WxUiloOZlj0TED4S9XPiGJ4RflBj/08jz13EnP+I5SiSHSHrq1xXoq84kP47iktF8/EEMz6IQzHCnuZVRyfjeJ40z+wUashgRRlPyHrViQXfW6Lbu3NTrGl3tH6+NzvM4AlDkEtRB58c9tqHRS73SRSPv0aIum5YGy2m97es5iMFltHjucQz2KLMyDR9jgKEIOe65W890gnzI1PuFwRAV68xPmeVDw4eBGVlszc+0wZOHKnr5AZa2rETo54wuKDV8G4ehL+NIPuiUsm85tzsVtiSzI0KN4ge8u2AHEQhnli8aHW/Ut2zAj76XSNRTweM/Rhyn9opk5CBMjaMydzRUzS/S+hZqH1B54K/ckmd+2mBcJBwNtPMH5hdIE1CAXBRwbX9pGFHhzjl2tzqDmJPFPsplfJciY6d8NXQiQcJKtG1XBiYZRU7Hi2ot/Qrd/IwNIpjXEyGMgf4ARmrnqhbrLqwedxr/fXSfmj783ZMR/K3jOFdUOl0PDbk91NAfeMNSENHkf6se8japKIP+q5CZcIIFGtLpw4VX7hacr8Tf56uDI6CgiFUUQ3TwNfd8MM0K75IRvMi5VOoRaiIocXa64S5DNJLmJK2mLu/Zxx9QRRHmJ0E2tzVYHnWycY0tbdsKdGAMTtcfq4iyZGSr4ye6U1vYgyE+UEoi50+3hPTdBoz9hkM+WEZfXaE8EWgefy+4dRZD0hKINu4+96iaIxm5agWQUhzjjk5fMe6Er73UcfDF2AnfEFwM+MpWqtzDPFdK+xJ0J89eMAWAkB6/iu248uKeBYfflQ2d+VniJkmpfDr7OUX2DwytllcDkuU3jvPH6nCD/yxP9mCIh5uwidHxPNJOTs1Q27nwJvEmuaShPUW3FIOtN4SnyxBPL/4C76dDwgmqDj1HSrWNotvnHfsKoEAXsZUxi0Qq0jTJk0J3owMBbIsapeK9K+T5OHkvUzEW+fi6yrRxWfPVUniXiCAgD6cm73oMP/C6XQdy2rTmunk08ZmQleTwthPjb/ONqPwbmlof57L5+LQRaZf6rvZJm7Ijmk435sZzn8M4KMj6nZneWrLMpVEHElBv1fzS3v7JmhZVRKdATASSs8dbSPLLe/5rxbzHuE3BrPG9CGyP4F4oBGHp1IWGBQWyJjaQV7/boIOM5xIF0IJ1JLPBPgsldCFYGO5McWpSzR00+yHmSkGxmeUr7uhQQuDTsTWs1Co4wU1sm9TbKfkD7yQOAiQWhSEhv2RrL3dmDGt5M3LVSsUcsqPklm8PWSnItcaSmqWsVflZLoyxEkYg/G7VqSVmUoLsQ6Ld2P+Deki7easDVhF2u1Co50Lz4wJ3wVib++1EJegFz4OyPX5bk1AHXdWbBDlHursEDHiJ+IMcLjHDMzuIn0siVExiCAb48XP1d9/MBLHX0mzcH9qOnsaSbSQ0VJA+D4H70nRvV2iMSjNz2jC9OVz/qBU019F13EjCebzo8pD2OdUv49MCMQwUjiUVB9tSNSTeNbOcnbdhPH5XNXN5OIAUgYO8vSE0DGtPOPqRbpjdqBwzAih3HnNZTiPJgP0wVh6rqMYW/GE2ghO7PwtUOsc3oe0Syh7VP18gv6eyUJttl161ZnS2bthg+jC4Cx7zfpxVLhMUDhoklbh9L0MlCmO8kYV4gaiJw2d6y1+7ojhi3nCkOYOZrlD291PAEhm/Nk5lrgBPT/2MLnaSzvwQhtHddP+i0Sm+UiRbnh9eQycss0p8b36AFqOEDxeGtBC8MKf9nrDqImCkjQE7C4Gxd2rTShO9BesJa6eFf0Gg3b1fxqLcOMbvAijnfMW/LBpFdBA8I/vDE5wgne4vB0W4gmVyvXvqWdKsiVOO+nRhoJK3DDqqTOlZkfeqiFIIDxUvLP4ymMUnPUCLu1mzjD06uGUwubmZdmCMo45AxpM4RwKuqprZiXv09xnPaVZ7yToPVyucOzQCdywd/tufX4nCJTmV3m/u2aEaC++PReC5HIQtG/aAGrV+GOcQ3aV2gHKScg//+whhp7nq2xCDRl7mq7N2kn8Yr46EJ3nMtAgh2OuasB7CuMB5Z8e64FTzOLq43Rfxd0u+SCugpUf8FFEa17PSW0MvfB7tFe9WIbqk1yglPjuO5Lp4clNHhPI92QUL+jzKUDnJCbWymVJD2fUgxL/od/radbaQAQj7I4vWpQsVKia4Pm4ekdQ8GHR9SIO/yBtn+WqqMtxX+aaT+hqnN2mrgnOjZCL6Fw8Es5Ap+A+ZL9SN1ZfPvn6nsb0siHc6WMDssvWwOMicwsqzya6KOEM7WVwM8UJsp8fqcvJz1ElOyvkJndwGuEZSTS+lJsYQ82t7zpNPZur70cYHdXPxvdAEK5pwGYOQfmNfmnV5VUAgwIVUYR1mVrwsu7RvrOTcfzKXrDTqj0rIpU10kv7o6MaAlnzwPnA1gH1Mxopxs8/TM0Vk/66rPEXPuIMDPNVCrNOOjqXNDJYPox5nFgubK36EvVdLiyxfWyzfq0E6NzjUDTfvYX+sWwls+8R2YhFW1Y8wsuACSxi2qfu1geBr/Iz5h7Wr1bGzx9TYt+7jwykqCYn/MCmelkKX5UO67TaVtn/7lRc8Mzi8GbbjYVUp2rM3QgVMg9BaLCkJ+lY6TXF5yHht2faq1H02+KBLwzwQmUm59wecVfhv/LKGGC8axjLtP0XARzVhgAfIF13bt7drFvcCJxQ9xyAMF/cTLULKjtLRS/qCKxLYRbIuvzKMFWTLcvl9vsgtonIpwOvYMEAfhXZqUh3lp8SCTjWaZj77vITe6ksaQoWPbx5xGcQza4fyUaTImtg1uEBnJGazP8qRZSGCKwOl3aNDO6ztYI5LGQEs/hK45DDIN1dfWvZEs82gGBHRuR/Omlz1/p49fXPxCBr7pmar7LcKcpRCoG0ag7MXUbQOn7hjUeuVfUOh31PFxQtYLqzO54zHjRBEBpMI6/olvLFbve3fD6mDjchCfLdt0X+jHhCwBLsKKESQgOtt4190Ddw/GTXmosA8NWUcYydnQIUVX24kz82/XOFAg5ZGFHfJl+FRFom5Yr1XYwJ2LkXGbtMfvVNkUiPUwE7S7fOOTnOeORGoJtq0pQpV6h/0lnBZTMMOxSVbDCtordIMcxQvTDP46xCSYRZiesfR3/bSCOIznUyVKQPkSZm0uv2iq9XIJlq0BnMaD++gqjd8gOOYBS9Vsf1bLID/zCxwO+IFgB8GJTAOrhI9niHrINKfJ4WX3fe9EDgZqsj349yGYtEa1F2vaayemZW+v2+HUsqxoLM8tPN/0HhE9dY1B53JKeld7Ra/dP5C7pYnLRhjRvsPwl5zRW9SEBfBpkv7YKT7nKhCfR9f8cPSWU4CmqC2lbvfHfhUd7xsEdsgTXpnSD6hgVSticXUu6GcbzzADMPdsVCBbn6WwY8/IyQU3ky/57g7lP5T2R834iYsyN5Ua+NSE8NTWatfuetxg+vIc923r8NGU45JODHEF3fJUmO4tkYSmCEU8Zgr2wKp2yOSyDkSKA+hkm4SG/MMFdC8bcgDdgzL7AaQIHMB7lLrjieZpOl6lgV0uYLPSpS4l7g906iHf22zLwEEPtw+bB+mh3xDlZicehVxUWvdxzXdtbO/QFQm9hgM9UerXRAcHh9/P6i3qak/ru/yAuHAFLEHTffWT/7HZjjdVsV3hLaMuWffLSyOWN6CylDOOJlprdmEDv4mFKosyt4HUtETLmTJghefUYoCLaeV3aKeLybTIsiuOgEDW4l06PL1akCvOOeuid/53draQvAXY9B6d9pN1Ot6Gsbn4iK2kDoMdP9S+5RUN6FZnwPHEhTUUcaE2mI83N454FOcUExT/Z6guT0Bpl2twrkpNKDNKjWqc0dhAVXrHbfCFAjMWrSM9OR0gMb+IDPmtKJRRTgDvz+Y1PGxFuJ+1F6AqxMz+fYYEuOeMmkgDdH1KexwiB/WBCqqvT7r6MuIqTTdWhZAyuesvwlSHurJ7LJgVdVLTIrKDOltunafU5yrTWqRRSgDr7nyevrpvHy1PhzgPZEdiukOQxiE4gITATd/p7x0cxjaUXAD6g5Z86m5+j22s/QIq+AQX3VQIbDBeFdGU87tEXz1S4X2KXs3CMPSJW8UdV/HBHJW5eH1zdghfadhoVdxyCMv2UQDpeSM6op4DHMNq0vLpnEtwnnPpocrsHYm6if+yNKoyZg9C1ArcheQLsQeFhGLO/zmiuW6ptOen1C2lujPqYL7LZrxHM8minWbwohQ3zX8sGJ1B6d2Mze+UEJYMaJdnMlc+D+ZBSCwOAr2tAcxR6YDHLgveUf2iWPM8JGYd4mjhAb6JEx8yZklfuxxb6oLlxwZpvhRYS2caWBLrlheWO5ajiM7neSv3FOoXBQqnS6U1jU1yO4nMt/sWfGMVsTeJGxQf5rjwDjEN8ilaz1r/MLBEuCkEVzlg4g5nMQXrJLLx92RqKOt6a5MGNbKw2ImTaHuQLFiMLhlnchGr+Z4rbq1GcBq8mGkcpCtvWv8ZnZXRdkNXRcaOJw9uH94u9Sc3jYZEWFVCevPNZhi1eD2PcbW4KVmsZ4ifK5ul+A/3MI3A5FfcTIYixDpJJBIMd0RzcmM9Ykotr0WMBJgNKc6EzxWCooESDAOXcuiapEGl+FzANIdUzcMishoTQJJa5KzjTerRgox2cARCHBFSPFOQ8eu3UFH1a3EwmBLs04l8+63At2cI7CUCZXtTth/AiJAKoZH7zEHKuBgImoLmAvzrCaAlYdbT2QrRWAryZtCOw3mUjAg1Th1eLSp32F27oWECUTxbnIGSZJA+WESP/ySdo0ZbKOZyvpLx9W5x19BzCLzpW/TfalBi2Bw7U6Qgx3n1CLZ5tSaa0Vh3ghDJx3aKtXfVUpIB045kyEQ2r8Ts1SHy/HxllUAwIcqNskAAa7T5luaGr3Fj8LEm0wRz57Bdlioq4YnBt0fJNR29rv32kdGSi0QwNNZS13EwWb2spjx2839yV+PNtYev8ANBIs5HemGAEhxIi4dqZfdR/IgNvQgil6CeCg2kDR7HlXRyThBSPUggYcquS1sre2KlYO5xVxlz+EfS/1kcuWtv0ylEVUfVkUC78VrJVbKWwu21UCinkX4ZF7hfMC1Uwz6sCCzYlmIYGj4HZTOz7Cgd2nin8kuIRHOGcYZnyCiIAOPa7lAs7FufO2JbNab3tlCd9kVGygpaqKBO+SJwxckJ5lLjTfqH8oDBJaZoCbEZU2VWwOnqc51mlm7mAU6m28vBOwJV1Y+jy6UOnSuIBAZ+UGB/LNe3rm9bSNiz4TTWZtBTPdMj4MU2udUgxCaKp9OC8P5+dG6WwPu4q88g6vC0WnVRQlCvzm1jDohye6uPxoacwMKWQUmAMzTRNLqWnL2sTDryvlFt6OleVQpNYyhRPgHlNXVt9uDKkG2OoORU0w0TPk9DcKEWpWt5mdv61cjMI1OyxkYVPrFYXTmKw7B/c0+zYS5P5Q7YEIfC7UR54+zrKzQx238bTzonokEZ8oNeBvCnC9Gm2c8BwBSaRoBtlnlktByV6TIiLO0A/VlI0+9t5YVr0RBhM0ItOEt8o7dg16lORsKKCz6iZhcJ+9XjMeUdL8CkhUPDOCG+3wWHrwLbS0rSiw8RK+1PG1iUM9QCx/VV1pSrwok6twJ0W2+NQm5PybkkeMq1Zcm2/k1Am5416WRdyHFfBNydb3+kVL6zYinVz2nIrGBD4b3o2+8XVPlzd5ZgfU0StYUjO16I1UysriwfqD6SlYE6pncH3NTxwUGodUCXUVHyoI96RuiU8ATwgbbApRBXpc8K4+5/CBA2f4P4lqLJ8BzVrUXfHZBb17fH+n7vXhDDGmeeQk7o9Qr25DDbQORMjh0Y9pgmajhNtPFbacmGq4s92YyXBowZUoe+dO5FR9dFw12gEStjQ0MssIPqDG5VGn9ftrQVh2/5LRgvE94SQgy1yoS79IUXs+va2N5pin70fr4vEO0gMekZWMc1JcMyTuHg0wQWeeWp0yYjHj6zqBPWwfgmImxMAc15VHlf/XrZsQmAzIhNxIm38qqQBUadHnupz2xNPE7oPclYsRA92XvBS64hTKbgUx543j9j2SnH1+kZPXueEkf8HoQF4z5A4oOQFpFJnf/dLkdbwY5VQqLR9V+u6EXBV73k+8RgFNBjxokP6U546XIk13P7y9UoWlctrHGancNRDvSmsxJ3bHC2obEK/OAQRrQw7xD4sB7AU1Ii7bToJ6Eok6MTICudcxcD4+D2Fw3en8SuKG8xjvqSqFEXqQrK8/hRwUKMUp9PmwfnQ6h+hzx5XSwTYZVxgKFgpKvWvkOmwLk3mf4lFcUIz9uHVZY9cOeseiRZ5KBjY0H59URkR7JOeduu5qTOr+HVIcJ946lYgHvQxqZOsjNt69hjrnllKskX/niucNbQTiDRwbognaKdB+yvshyoNHhAEYUa1LktH7b9vjOk76qMuf12DvUDGfzHHoxJc/R3mJ8PPeGJUhfam9XIK5WDBM9RHQ5N4axwuhDv12gYg1zqgsyCC+/ZYLeFXx/4+GEj2fVLpuvznzlGcFzxlBTYE8+fE3d6atWqps/sU1mY/d4p6m25JaNC6iKiZC1mgOBbNczXJO9e9O5nvV43WF5BmVUG4UeW4YUq32QGpQHk7Hlbi2Jo+ONtNWKrnAv5Do7HCyAQOFA4c9Ng8HPn2jyyQWr68Ithrhp5auQlmZUlLA5Z7aQobFYTTTgfT3EkBdCYqEFjNiv+FxKXSkPpuT3xB5jGZqFLonUpWmBCRpBq3D0vDldmmCMLA2YRbZcGZDywI7pUKgoBknO64LnjChHnbyu2Mue8XfREns1SK84k53IzdeIVfw/y9t0zCmwEsL2QxRYe3AUob/TKLUeZWe/Hg4JaPot2spd97qNZ4u1kkZ31uxsVmHvMtlggAcqAWU3o+W1f51O9vAD6nfFvS+2O0zm9nPykTknK7Coq0RmxtroOfwNyfoJJGf2mLpxxWd/NhlfZrB2HDwNVdNlJrlGlhg2aQdP86pbmCLgaOx9myysJ8qVX5sS9wjVglHxoUxpOazAjHehJrZCaySBn5fos5wqhJqcPmrH39tBrLR14qJ1pbpT/To+DAY6ybBIl1UgVg9SITKDO5j52tqF3mAUW5GR5lahsU4kORLHbxQ86t3UxUwTNYhWeJc0KV6500x7RzquH/YwGexnrSjhtT9y90jQ0t26z43F385JQbb8w7s7/1HPU7y3Ps4h6XbWnbVGD6pdm8nMttDtbrwuMP2FYHfo8QL2llLhfzDqdmzOH+BKYi218EsupTlXBH4X+T6iCqeJJz9fWQ6bz1c2dXbudzXryecxESzWVKHWcQlTAPoo0sX9WN/fyn69A16N+/kUNWAA6o6b5bB4DLBA+PCA2A1ubr+s2gZcWWQ/ENJAtkOyiUwWcAmXsa0DNyh5J7sQ79f3tJewWl6SfQMrRLVbczro1IEiVurxrCqPtoULv8KLJ6p4oWMfMljFNvJPSAj4m6wH+2nCDNy/l9m/RdcCvRnXxrCNSgbk6lbnNwoh79nlpxGHH4VdC+dY242RJXTRwIwYCCcKblRys0Oaap/y7olnDKiyPVgbivVLhjs3BQ52T9GYDUaSxa9HBNSuwORKBZYDWlkNu3YfIzOqve5QBzCCNaXXOlrvarl6hk10i+Surow30C3ZZ1bijyRQoGR9GDlRmnUxx32ms2rFoF3ZEoMR1zBUKntSLzsKI2/qemsqrdia8QXJeDuFJOh118b0ec3j5T4GSepYvOCHc4MeBpQ/RTmvPAxPlTvASRKwEXjlaIeSGwzETPC5SBYX553H/7eHuSUOCkIBtX+iYrzYdnctnUg5352sPi0wyuPkXN5K4awd2W13/WaqynT0aevcFpvEvZsnssn7yGefldriraMy/4PcEfWo4IIyWDIYKbc+KWBhjg7Iy9ZwgFbBy02rbYMQ2/u3fLzvi6Yu/y3W+4uX76HVKAVk/PemgERK2m4Aa2iiQ+Offnq4PpPK59WhF2e41MbOfcYNC5AU+fhdOJ1z+1AC0X9iqvWruwf6CEZwcptIrMvsMBd5vz1lY7DoeL48ZDBIwYlkud6KVC6FT9X9kV+qJCT+SBcluxSCIGwVdPl3CpXs+MO0Q9SJPAPoz+jCxQDvMduTmrA12gjYjpb7HIiCdOOS25ZOye7npndvnY5LCD0jfy972ynuIzDimmlRKgVMOS0E1Xjw1olhZLCdyoJQJU7d7mzulUzUXZS3rqN+6Y2zmvUBURUI3PWogw3KaF3ZUOOfBeNSc4Zw1PW5ZqSoysnF9CGmoxz8PIxSGlilpGmX8qy18WOU+fjcmGHwh5CGiGBNADZ9abqUIH1aG2bL0LHMp9us+uqZqhrm1beuDORVt7FR1/lXHGpW15s4r8P0riGTVGGX+9rjTBxRN9Jvce7kLO5QPEApqxWwfU3+AoN+7e0+Pvp1jNGWQJ7rwPmK5Ur7LK8KodgRFmYwix+wjk09aO/4nosF1EcK4e9NlAMbdNov1PcuVCW+1lAh0jqPO6e5FHi1jbTAGY9uUiF6DNB/UEHJh3ckMwZlpgec1scmDJxIiHrk6aAfG7jMhLR+Ef0K1TOTG8+PqeY7L6HafGihYpwizGtj+AfJ7lFUWFxjKif75Dne34lu9+kbVDW1eEHCAMkiLfZQdW8WxVPXeMHrK3HMZPcfir663Wkwx5NS624Vi0gCENtTXtBggb+R7cwsZk+1feSeAk/JXaeUa+55U2lI1oVPg0RO+RRj1N7Bt3K1xbdqANgU1KJu/Op0V+dwTKfUYZ9YuCUMFNgF9sWCQACiZ8Tnq5Xb1gSL8VYKT7sjatMniB0C6GYC1N0Ar3bKEeordTVpzbTaXSET7AxvgCPsyji/Et92PcfPNZyHP1Jkn9RzyfDoWtmHCdIhnLeScEvEbSutajhhdmfsiuFcJxKUavt8PTkokMiDQmxL3yUAB5u6RwNGQK3iOMET4GMbRPZ6swJpV7JVC0N3E57JExePTbZOHHNtuODEvzlJSa04fSH7Q788zAyxRJEoiFN/O2soX++S5rYZ2cUkgw2TbMmU1gIZVS4iQQf+al9Y9nkngV4CLsdqQIj7qhlwN+csrod/dhvP0sepRAEDL0oApDXZ05+qUc2fi605OPz9AkCj7fSEx2d3irsvkIlHKngjdCT+3vQs1wV8/gRLgQE7j434tX7MzBpSQDX6IDDVA3wvCUkxuuw6fFYPAlFk2U8FkycGbWRTSryTNrUKbIK2LOePUgdDifhgtVDhieSAIz6CwZ0NboSRpZYl4BEgm/JPOBSVWGwVwhj7gtBmAJDbEIa0cjb7oy6GpjglBYBET93Fhkt3LrpepE1WUvdvTVV8YtWVVio95kVfIRnqu0av7KwSNLVbHeixx6BR/5Q+/eeo0hRyxu3kW6aMlekRBqBPwDvipeE2BOVhK6LVWgLoSVnnRX/oZBx4a9uHWydyX6a2eOzuUnPkfXI5XeyTk8SygEFDWCaUAFPUdbZJ64O/F9yB6jdONkseM7m1yYJHcYlLzVPyDXK6chcSoz1Ci2oWN0rFIgAMhW3MYnodyySuwUGqYlBpLuSbOJdCdVC2qBSl936I6zzQ7M/atOEuPwdvplSTDBr9zv07Qdvk+kAjmUAxMxo3D8ni2yyYcinY9QtkUYbTqCK1PAcwPcn64n3lcInh0UxC9gKAAO81lWEqnor+HcGK1dsIKtEgqWNPaLr9NL3SY7w+Uvsz7YkgfjEoR/TrNnVkCwVeugC8IUHNAI0L/V4L3labDqdqVv6XAaCSh8sFQ7PMbRsIhbBhuU9tM4Urbb+19FmkQtyUvqSKTy6Bg3R91ZMZ9o8SmkEj6edMv1VQhZs1irZl+Zi9Fi2GcvPRYsbd+A6rgYe+Nq5mEL9Ssuayzp8XrVPSZih0kqq7IdsY93AHBcE1V7ihCqa0zsLA16/5/BE+bAuU6/hqFxTZd/ObKcWhsfhbUL5UgdOnXqltEjkUKXw9pCR8CN6As/fVubCtTkVuwpL5j7ki54xUvtOr0E51Aq9QLBmykcWGFvKarGNtLqRYhQMTAZreIOpCg0qu10G9BAxLOAwW/hKKYhayy6BF/frfv3wqoGtvJe57qcMPb/nAsb5gr66nRJAdM2W5LTbLAv3mldpTCi0Z4y7giQHnHMwkH02jj3WUjgPzAXDzRU8S5iSDvpz4FKrgaQr9x9AI3IUQLO1WjzXC1dDkTkWnjGL0CykxaiZVfO3Z740wkUHJTHEo1viesbhx+coNEidpZlVz2KQFSVdE8CUdkLjkBTZZgkV4Ln2nBbKtL1KtD3zsVyWwMmvDxOy/F5XUkCUk+xb//qvw6UvtABmM74KH0134ObquFRIopopHrdk9hApaqHd+rNtAZWylatDZu6qpujijWw/PudXf61Er6hO/NhNP6v198tgXIlqj3BzS0VXOvkZsxs+tpSx6m5GZT0AprTQPiOZMySjtdhZUx+kExZq9hOSYtumSLIzaWDvxXJEtSWRu6/ItEcsZLVnaI8hryEsRWLUs2MoXo+dzIeT6F6G7nk8zqEtEQNhMnKH0vkQgYVZqD4XU6UNAIRNKqnsw1onW+6Eh4ZEehj6/5CPTh6gqqLJG5tHQjEe0/9cDZ6dKZfGXMnw1sQxLedVxeUdAOnT1sG7gi9BfRmu8NNhF82uop8JDCnejjgn7MO7dsegnVTjMVRuc6z4cytWrHQkAyg5E1GLHUHTWIt0CgqvfvCTciwi4uVscu8kCHufs/4FD70zNLYo/jCmWsOdxwV3qk1NtWAuGWdgRbOi4iP4bDCiwNhYWWfgqVH16/mVBW/FuXqM00pEPVJuwQJ5afVnyfDpMqD69BhrGGlZQT9HXGG89+rmxKQopUgfgWq8MwGbWcPr7UlTeeK0mabn9hGjTlFUbrH5LghxUdWKMnvQmHbyUNIcSbB4ofwlsLBvxFzuS5aAkF+SIEPeomY32eQvD2lMhOBkaTHjJbt8QA6JJxm41rUvDi4XQRYUqjk0tDOC/5cjTHjHqJg1+IcF8+4k6ziklS0aBTSEMYY69Zf56JIVF5ksjSpqajIlGW6mPQTln7BWqZU+Wzkt0vLTnZ5bmQ+t5zBSko7KoAXx4hmwd06mGZ9JlvGDVJ48VIneqXo/UiOGK62difp+Qs2f0ZArdt7hEcIMGdKevVabUdI66tC4RgwdhwTrq2sHeuHgN2NvAOfgbi0hf2If+9yJrZ0ZuqLh2N6YUgdZCQ2+Yr+ab2DVPJEBa4ZOaNd4SBZESFb3HvX7MWJiDY/4KNTHxwNr8WBHZJqEuFWL1vZsCqlV5FQMX+5iyeeaVs/PRG3CpvpdT/2zd+um0dCfVe6svrDsK9YEX17OcTpX0J7hgQHPTgVAengumY4+yGUDfQ/1lx5T6GZMJnOdqGMoJEqLPE58SvpdFs7ULLKG2v6tCde0buAWmv4zJBCwEy4Em5QwDwpkJQoY7qQweBC0/iLewKiHWTl35TOPowTVB5g01M9asq3D1G7TfrFyxpQTCSQiE8+hHR3lJnc6JhIeWC9Uj4FnK0bKmOsvi11VGlp4atuZgHK9ZjVXu2VhLFbGPwXiqew7do0e6OlGWO2QzZn8u2IWiJfcBykrM5+3QLun2R2gFt/HXTIviPf31i+HaYuHp2rJFrxxc33seFvTf8/qP781mBWvqBePsxLP2KYLULaAKgw6XzqNZgHGHSl+tFrGBgvfS57cS3RMQodkiWA6QcKNob5jUiZP7rlLX6uowKhZF1Xc++gVvEXXupr6LvEJPtFSKZZNX3I8VrSmu1C5Tzt4EdyiytzB1KiaEMeV7FmrFp3adcA8NcUBmqcPWiY1kZDwZTaNL4XCytlEnetry5JR7nr6zWNDNGqU5ad6QD/V8/6K+a6HSgHzCnby9NwEj795NIusvMwmZzWsXdYsenGiRnPFL2U+gN842He3tQs6rGu1NxdDxPDNX7zSWxEvtPD9W4MI5g9KtT+la3MGQFoz3I9ljdpDWPklh4TA6Jbd+RSQDZIUzJ01zUYwv6lqc/KIfFWKeZqrXcf2we42L58QKU86Eb+M6SEZT56jX0vhOAWNDGIxJjUvZqv4J5ENkzQSOA6qVsg3fyfzVVMLLUoPcuii7SvZYM6uoTWQCFBVIWHvOXHaoyEMCzb4RlD06psP2K1bXsDmoj7uTUk82DCGKZgW1wQyx824YekAnSmt4ghI2AF8E8gk6fUmXC07yuKoZ19b8IJ5rltiwIwAV4XpwU/gW91ZsG0QpUNR8kPwvD+3wetJlFDYqfXHsZT3HrZTNqJ4oBO4OnA3mT5xO21i20J/u7/GcD52z+LVZ4zHDo4HPRQYH0pd/1H1B+Z6wVGjzOPtlmdmhH2IouzwDCm7QELcfnUy79qT0aA5dexoCU8v579GjlFBXTLfxu0jPhz4SNKFoeO0Ao5/7quW5gpIlCRVQsXfuhESGqLZ1CHq1cjGXEhq6ltEZACsfPBuOFAPqsjlFqwfr7fRWYlU0A6L8gCMz88lsk4BBaBVZLWjIkzxsxqU7bnF1uDDVelpq121VNU1mplpYXC/Ajq5aRumPG5WR2lWlG8gWqJfEiNetUlFtCeYU6oKsh6Loxc8L+IBeIM95nSfA3nw23lxdV4qhNTOUvMbVvfyVtUNIoHs3H6a7KtkAR60KavUZvbmgt9IvIpSU6lJTuD2Q1MOstF719lhZUzYSYF89KhKEWUddh65/fCQMQQluPr8BbARcR55JlBgaazkGaSJuSjUFh1k8JV7yi3ScVHLcZP5kOFMvw2RtqhNMDJ8tBogq4+RAuRupcjjQ7klbqRNyfSyFsYXZhC+xFPHGYF76qijYuZqKWF5AONRFRZetobdAptwgfAFVQj8jIPPuDHyGS+4BXr6KKki+BFszU9re15UAqzuyEOapSoEypaBOVSsxy0nx5pLxZHzyJ1EHHt1L+HQCuWyyMFcDoeelFU+0kBCp2KEtoy3MVxivx8zZRR4+dPAyUKdvL8XG5PdIjC3uSSrLwltgquPy38RMvIIUdfNF8MA+xZ5j9HuA6JdcKnDiZEEHikNBcZlVqhJaLh3Pw0U2o5+EsdJrT7R7MDjDCTWu9Q4DkGWlhdpfxHE/f7x5jK5lgd1NaoDOkqrwbORloCRAa6XIYL5safNvzBG3FzAqYUuaajfE9TnAyn8Z//YCVJJJmk9tIkdnSuqAV+3fnbUhFkaY6OrdwBIDG7Gb15JyrEOsKZoyAmPWbV8Z1j1nC4O775sZ7L7dKRbNOmWeUxNtRESBXBze/iFPK68uZkU3n0Bt138NWFu7ck1gKNvqz3ykRquQWd5M0A8sxb9I6Sp4eA88oHKRjzf9QMbmBUINcoCgfrQqDOw1ztzCCHdysPb+uDj5X80QhPMpwQ8QUIj408w94sRwhZGIzKab7ADMexOi2jgwylsPhdRF/mJOeOEMTez7NgiGOua+zcadHwspSBiXyI9JEXCG8Z2690wTnieUgtidoLxei/uQqXYF4mafc3oz5zogzxq7JtgHrsZH/oza5QHR+GUWyhW/cwuWHe0zA4RrzPaJi1N2MFQM3bZ+PtU8A8GK9+1dTQSO3sG5P4UHjKjXfKG3eyz9BR3X/LpxGS8qaypoiug8YzTYSg5gDWYWbFqiMoDCs5diY4gWuR5/9+3GvRu5gTY7ag5NLtMoSzEdgFLSoRgXaCleXAJmgvsuu7ORuBU2A7dodjh2oFgHGiJSkHEuZ6Y2+yv42OrYQjbVJ4ientVqhUqNTnUvfOtqD0eVO3BiyD+Jn29riJ8apfa0okuqzoAJ2yDf1l4BEnEWxem2AmFzqyaWAxK0gKqYSRkn5oL1xhIcWwM/hg4sortJokoVRL/V7HgO4XJGwQRzZZ6vHvwIzTRQipGqkjtD1HPn8nh98+bLtERqNQIWodusHGbspYmV7ukLpEmp4d7tZMqD8JQ/P2OKCAJyYHVwdgCJL8W9gP53KRDsXHkhIWP5e+R2GDpo53Db3FKYfSSPHlYQmV/qjMt51V3XVNrujsZXyhJezPzTKgluPtT+lLnv/+AvJ3KspoSDpZWFa2+ruFKX9/q0zRhfIZ1Xy+fSpujitzov0NFseYM99l4w25EupiMJPOG+IdPgDKqacVWQPGJ1MVZq4fglWB6FNk6jpqvyejJftijviD8bhewuX3kLZarpLzdI6Dc6TVIZGwrcjV+NfTW+JrwC9mxLSh3NY0786lrfuPsclTgk31GRhXN2+uTQVxietZOEJSEYXmsDK2pMFQLRBP8PG+/j7/AyVNSAEO69ZS6/uSdhoGpX82RDbzP8hYwMAWBaPt3xAVwhHQG/lHtSocWkTs/CUk7FWbq8tTVeK9LwJmU95M3LverBvow25OGQhRSsAUyMLmU0EMhUUdtBWPoEqY2gEe4d2qJyfvtlfDlq0LZNs10RHMrdkSX7AaI4Y9aOgSgYafbzreEBU2cyO1oQeZ2/0E4yxNbQHfkMsuljdD0JR6zwKfkZfkRksowbpokaC7pW1Xq7VhT5YDOhS56VxH7JGa6TWdB3Ap+3LAWN4UZ6EUG3KT/dYkSRHXPHRc9AsDTQXi1dGp3mt6RhfoRC9YeJKUE92/O11Pjg9dQlmrWy1FEPh6n7VBvxHzKNresung4ENpv+1aSYdKWF/axBqdTMXuF8gIhzlR+aG5cGCMl5++VZtPyfL9GuPd8YWYrYFxhY7Vo3Mwx8G/uRf5WdRgMH2knbIRn3rlhOvkJwwM82bVDnoS+NXZKhMQf54iEr6CQnszQXWQOegrY4Xlh+YUk23nDnQY89KhIjoOyvwYARfS9eSpdOXGV/xPTVHDa01OiieK4sJi2nFtFbWXXfCDYznzMgCdrubdSDZA2VCdBwmBtHFig88f7RPtNb+jiMv3Y3rnUfM8hR471V0U48JrqGQHaj+muKudN7cA0vHKR49RRu6HdZnHBw/vz9hB5fSD1K5Nlm5wKCGDlQNhneQ58x2xvX5Zp4IadipY3XHlsCvYeZo4PbT63sVCoNNepC/p3vPufTegb7wTWc/k3LclJUdQwKaIE4VQxmr3qh6xfQgabHXelw8H8C583ZKSWftvSLtzTPiTGzUN/HAlkV/8bIFMSSkzm1dHqxhRViQ60OTA4w39mVy1tYIk2jAiJB8HprXQKL0uqf6bJL6wwSY+a6QsXs0JqQqtgNfIUtV9PJIZEvcDtG3wglZp8cnG840Lg2M3MzBYUWTKQqe/B5LgGZyX6Qb9hSVZgMW30nJiPZTwp3DmWBe9w8ure/mHsTKM+LytC/cwciFqZYIb1HcxRjDyis6ZSjhfXFUnu+WDr3uOhncElR0UTgUaMv6IuwpVRajlha4Wt5pQmZjwqo5VKrePeQHBQIO91roHpJFU+roUnuEBNyePH5pIhPEpOmLiiD0jvMjGmrBNJwwfohgpmr6jWHrwOumbY94xFpWqLrMP1XL6Paa2rutp+er3WVLzv3m90kTtesCsL9JecMjqlz5LXj9KGYodnmhPjcHjtunmOP6308ckNvFHh6V+QCr5goK6qM081aTvp4NLTkxEAiVFKu8+m84jItt59XrzdgU/JaFzRMC0ig1AgGD6fuiWRDQ4LM73mf2fj7jv1ImKIFLYrSbjUIbj6FoBl8e51L6XbfEbzv4EemicS+JK6WvxLaujmuX1U4urj0yYhRDpS4rszciv8TcVcYTN2qas7pSepXqQ7ODVQMfFDYvNgXEb5AzmQjCoV+JhQGzFUhVCuTUMmbTQANmLXwJuTdpK+AQwp6jMnvqxyavTo/+nR4Z6HwabH/4D/nnmQeDJn98y6i1Pji3+wqoGL3CxUUxByZScx5ODU78VNctfkUhd+V4fqCoeGjNdLG4mhbLlrR8BVWy5bI15yfVh+A0BNu4pUZoVO45OW+PDIdllIRO2Sc+cke6nA9TT7+oyVPHkGMovzBJIq8DuWrwZDkjByYDu4Bbvqkvz3xpVQZx3KaznJX7sjTBvuTXVLdTBH4xQarRSuu+IWB1phnStPVpvxDY7K5Chg33J3NEL5/AdxMNqqqr8ssI8iPMp8MhRck0qm77dIrSBlSRVHYCTddF6dTAsO2v9w77axUuk1bJShyxPBrlNVw8+b/lOIjvlJusXBFxloFjAfTT0w5iBlReQO+oDTcSPw/QrTNaaiCqW9oWC2sX0QltGkgHkHwwxypZWYs6Xm+oky2e63Pq6jlZdcPjfnqIBqUx9Fh2FOQLf7QxdopEGlqJ3CYhpsXXVln2dKFmAJMEVF7Sdq4X2PGP6YWZViRoKp4dQ+DnpJruKI5+SVssitaMBeW6hG+55c2z0z+HcTPqGE2fq+OHflGCZTbQqtddo1rUpOLClnmg+g03McbO/tQ36lIm9z5DUnNx54F0yoel8bwGmC90N6S2LBqmQne1vXUmAjEPp0xe9T0Qn4btSQButjIS3iI8ms9xu6DyvKcpHkk/PWjRn0tX2AbHtv2F3q+IKb+z95riufVRljbreRu+ksEfokPky3haCnsutmRTEGkscqegXHItbWtkP23e13cjfcfjM9BxDBdUC65HFhVgNgjpw3ISJwVK63JlqHFFVXXkS0/wNStyR+9dCN7vHPo1gC3zeJrhVkX0Z6XlvpL2Daw/KX1JvqapWvP9OLC41dPvyHibg3JcE40eaoYXQMk1RaLvwiJWvq7jP+lKbCbdkbuoZuwNjVg0s7/BUJ/kHZEKvNOZAb3nSmtOqomdghkSyF6FUee9UYH6Df63e5sO/2TYK99mKVYXAeW1hPn0ELZkBds97fBAExzeGR8Xxh8rH9oMEZEQRvpppSnBJc/E9O3LtTyvXSx2ufEV5mPndex9EHwSfU/wUQ2rp7n1U6Xu8/HwFsh/3ha2lNnfHfIrYGf5f7EO/csATcfgo6U3uKkJhTO6VnoeATqElRpU5KAKBOPzbuPLlsp3qsj8wlKFuZ8ldHPVg/fAb70ZlUuPDZU3P/g3QRkz6I57P8WPtpLc0tGiEmtSZ90c4wwferSBiIEzCPqbq8YHX3tORBdjPGReG2HZRkBoofdXppmjCPWRY4KU4gHfZ6pizhHpwi9BpvP7MniogNb5tpYyWJyUiOugB9X0wqqKlrwzUIceN/FMyn5lofqpwa31PR5F5h3fr+MvmJsg5a2tSTzANfp+HxvN7Wzae7hTVnO5w7uxrRh7FGKFNDQNFBR4FrE9N7EtT7o6cAiWPYb+V0tVZqQZeI1ffTUzTrop7fNyq53UTNXkLp50o817OBfTIALcI2OBCWcP0TC758Q9nf3oRMllJ9lIDnORwHXDxaZpgGojc3sp3IHqpN5i3oaSnOWUNYVIt+KDpb52GhxVfvAspOsUpanjNOjTP/uICOJjF0PHKr+AcsV1rdbGs7AVOF/4xxZBSwlXqII7u2qIUPlilX/3jA0uvEZr6BPWVCWmV+j+GiSPkEkUcxT23rOGRjgFBwfGvfJr03UiK+cwQIXbd5J65KVBuWQ9ZRn7Q5vPsonUzm3XWobQPek1Bdkl6sYOXUE0VuZ7fNz5tDHI+vZ2gxrTUDeZje29JOlyXIr97F2fdDvYSFiOu+Z72eKpR+LkTLZfZroPgValU0FVqfDbn9VBKwKQlfVf44Mn1Kafaw8WNypQjEbpo/qjO8CbBU/BJXiCFSiVfmjqzb6cIgE0Dc483bVjjmXBTcOEU9tCOeh6EiW2AKUP5oCKGXRLplVVonartoxUhT06+L6tHEcjSA2IriZ7GmeY3KOsYnkr4oesxL30Iitbldaw/esRL7KdgVQe027VSMaykQgSm7/1pgiZBEjEBCr64FGPiLJgYxuZGEfq/5eQgy65c5X4jR8wZQLzCo1CwpBtD+IjrZ2vogEtU2wnFQKm54n4EPH9v/TGPKKpxqsIsJbxY/TlQRV28hQNlJZtNHT3R3sWckUrhj08frErpYYdnHD/0QfjE9NdJznTYX1NeOMRyKnK8546tbl5+IL5fLAJB4XPIA/SN+gyMo3UtenfD+ZZfHoPpIFT6ixxMTfnQCYpCTK2PMOUL+mApqfN7OYweyzJ169w9eIbqsjN9K4z4x5MGA8jJpI+E3/IccOsV+sGfcDQaqciU5QNHHSXOcVmQsrfIuo0P3vxbJPiOqq0pBhpwFkx6ahOe5FkizROYsDXVihFYVx2/hRlf60JT58qiOg1OCUlRoGMtdwQ9KM6o3/PjLHxAV2bRWj9W82Bee6hPn9TRED2DZIIWOK6twtHlV9izlH0HG/WEvBuC1JOgfQhSKXtH/7l+x/n3bz/kkoIoxb6usM7JH4VU834SMnyKOQhw57sVtf8ijuK5a/M2Itq6d+hnZfM8P+0IpRQA4G29QDDN/gn6g6vqIx745RRxeBbdWRZEtsiV4bDVH4kHra/WuNF3yuXQf4tswVyEE1xy1f/PT8tlH+3tgrKidmCYDJHi2nlEdV/gjTz666fjtwXGjPkKs8NKBd26jMFQuGNs74vIE5rEzoBBTgyr6fMCMqqqIaUMVi7swmgAZgAEoMaKnsqhos+cjZaUrYbqXwvkBMYdcinyb72FDZR2oCZf8HdpgkbJhL7yGpQyLUmO5tPpJio7HZIRbzywSj+iPJY0kUgBD5K10hb0wowAPYie3R+mkqY/qE26eLRh26jDFnvUxoTUs/Ic9ZjQLnu9NvuycrcJqBMFRVrRV1KRt5MCzdTJCrk5oqJw7oTtXlvBRrFTqjaYzZwY+xGEUO03J6tbpQiH5YTPs4cMdH/81EUpLwP7qIJqtWN5AOHK8Byz1qUuyWs/qRlZlcio1XCCk9mMNVLBDVGGsaFc6Cx7/uAsowlzGiINXlajZyOSVNaiwELarKlesU2CfAF3au87FiqSve8f1cEhPaJRRHT4+IgNHUzDDUXUprxLAOijHFvmfhGdiW5LiEuONsnLArtNfBntTST+OWa9jo8waa9DkKxDwqCQ1dIjBS+6WIHNymvSm4PEidJeb9fkOSMJTxCkVXFq7/NdRCCt4huuG7/4fTtmmKOg31Whbcm37lYZk35mgVwTZI0kD12mnUSoWGvxmXeHBxkgrt2JcxBDAFMIAvsTqMd1IOUO2dsMkjtGb5cWccNlpLh/kMBiSmLtLpOumdzi18W515xLu/MEe3pGeqlm5zO8g6ou0Un2kLLeq67JFckdlpgcR2n0IBl9fZ3wmz+HNwEIBll3unscsZ6rvNiRvul3LbR27QfyjY+PqEMNfhwUVrpj0Ocrr+NANA8eNFVfCDgDHsnbrYir6jea1HrGLlic46fDyTdp2W9RBb0kHiiZWgljI2oXoy4vLQisQSKe1YUlXzWPDopf1rdgLB2Q5dl5t2Ogeg9vPCh3yYT363YZ5ykMDuIlHJkRMoLxQXwmvG+uJyqgpNd4m6/OZLuioTncr8g03rlejEVBZLAGmTn9jD8dE60VxH0cnP9SeIAM0Foi8oxAjqGrw0VrV+remlNqNMCT01MNR9wGiwj1kET6LbvxU5kX1cr/Tur5tR4aYGT+8+5HJ0zxQxNNZFwHpAM2Eu3hqofDr9vtz3ebucS/O+Nvrq7LiYMpVFQ97A3AQH08ld1eJl9x/2gz0v6dwowl1BQmgaKZwF2vy6Q73gECARpO+/nGUbjnXtqnt47r2EPTnmSaZFKaF0nly4foGWaW7cBAKUOv/UG/ieT+W8aN1XYZEyvYQRy8FhAQy7FJP896TGJ3G46/jJiAnso94gSXvARiToh1U48b8fdZC9aHdKKo+ZzEY3QIj6uHheZhS0Kiw5d12N5JMkB9hNQjngeA8Oasy+TmnhvMF65ZX0OJUHh56/QHVj03QByH/b9oqIDEIKzp78iKlcQ2mDLc7u5yT/lJZSGXAPJBNhdrjURql4wn9JlY98TMw+c6u2tnOE19AEYGG+mml1nWed+M30SF3LGKj0AFUYSFJSZDjFrmkYKFFTTfjHCsirMFUJlD1sK11j0S0KyPD9Z6bdLAvKVgRsHGV1cBvrvQSus/DMcgyzTQy6JugxWFnvTd4EZBvXNEQxvyjxfL2uEYg6xf5GBGq8/WeYc7uFd3kIfD/B//y029obvr5y6vxixuTWSgGGaeXQNu0EA6UMntrB3miSzB0rzkcbaNb9Gt4Gkq5Jkd0jaANqk5AdcrBc/P46XnuNtIAZU/4+md9/A17vyB3L6Z0cgw8AyNV2hH1Rl/8qDOBnekBn6w4xNORlLziRYuYiDq9PUN2uOwD5eYTX4kT16AGukyf0C78hFxtWgHQIjFKyhVS4Qw9X9im0C5/keUhsdlBnd1dS6KxMKVciRSNAL9ViqmqAvXJv54w5F1TvbqiNtbrYnx6kaloA/NZTJznw63n21pgORD0FpV8u8V6BYlZmSWHGo3NALlIreChQA8L6EyASaBDHYyVqUfFIvsjTm2SmM29WUjGV/fAHgCIkXzkwnGWL5JB77oGH2kh1NuLGpmEpIoqJPfqjf56+x3+obpvkR6NmRcDe9SM8zi6dYOuLBQ1R7EMZjBKSACDhV1WnJPeRSeeHrlDaNIm5R02sC1r7tM2N0/MWhpY1naG7fOyGDWi00zPW6igjjQHechFVI44sKl6gv1IbYJcvNpT3OBCgUfnHIIAET+QFbY6e4VnG6bXvI2Yjwy6+RMK4niaaioRyAoTIpaCXIDGr/w2d610RURhxN0SO5aR3/1UPh7NyamkC+bWOzWQo9qT8n02CtyomVBUgXMJ4zaGUU9+CDzgc8yUduJDBe2SnXakXGRXk+PGyl741swR2aRy9MTUwsG6JdjAz1A7HVY2lOdTrduKKNeKyNPT13tEqAHUHOqle6YkBkJe7RGplotCegAREQqzAv0BddX9w4uiXn2YoO3Xb+usJTq3VgJ3Y5YcXqtxDWctM6YcAeXGwP2d7HLxJviVqwx5fzdPEekrEc5zPf5oZeq3jaDuRTauvc8uLPWba/5Lql2ulsr3Rf0JIDsGFk5sMsF2np/PsasiPlRz77iikqwIlihvZTrUe1ettd15mJmuzMxMzXDXiEiGRzu6fi8MkSQm1CtAEvp/oxC36xdICn2s8ETbg0Ulwgh+oWNG+By2Rp60UiKXIqKXZtkO3WBX6Bi73B4asA0Fz3h7dBevqzLuokon02KqxF0lFnqBGVuEd0NfzjZYG8rrIWbjvP3nvIA5TtzmCJM/Mg8BNN8bMWkPjCWli0qAHUZtvvU5V0SutcTFOF1gCXV0fgXrA+f3FG2WGNniej2o3qKklz377qU07J90vqL++d168WZvSPGiwLqF8trWMc6bbVmY9yg3uOBGDQhxZuunuwEOcJ6VY261LVMeE4GpgvgSbAZN6z0RCIYKIW8/j76EcL1lm//HeHvfKkUoPI7zlthynjGQCsEDD4S70ni8MIEIySKRHHyrLli7d2ktnIekg8+4HRK/gdtz0zL+40GXHDnk/VLVDH3k326iku5ODlMF0lLLWF+odhHFriynEXnGTT4rDqj+a6Qie1Ooc0yNvbw1lAnmo4qjs32Ad418WWKfjDY3c7APMklGcY3PqMjs0P20NCqq23ZWduu94Yq9Bf6VUrb3hujoDjsgjDx7As5ImCYRq/wCmIqwW9avogFbr938K82BMP5+7JEJxw7s1wM2xKkxSC9iPicYr34hAXDlbS/nvxUpBNDsGzmkDLoMFoXf+nYDNuxoZQDk7zFS7aWwWyjQeJurT/Z8n/sZYszm4nLiY29VmoG4AQAzAGkIQ39YzOHbmxDEMnEl25yCbQ6YXHKZxIKuoBGj2QOfofdmejCPsmpx+NfJ0Sq0+dxrtnex9bLJSK6pnnUT/1PCrszFF2yka5m5bDAbMWN9gZ8VFHcZ9svYfnNxzGycAiJKFQnJUJB79GRxO9k494xFmF+UWB5zHt0h1pLDl20WdMYd80BBd+WxQRb6muBftr4cp222yAbq4YYdEri6lj7qHKVkJJjnK83CKlUAlGtY9aIsPneu19KN7GNWRuc4CASILQCE9VTUEoxoBaazHjW1ECWurQYKuSzfOacpDL4BVLMYDxE3MvnOduBciYzXh38AZ+tf6hIVbi3GeiuFSUU3EcxCrNj2b9AuinDU//EieD/VP7rSizCVphTCxag5UAOMAk0VL5XShvVhYSlsvP1Jx+J7INb7MV4TPfEB6OGzW0Y6UHT0MClkKtp84XGctBX2pjVIAcazMVA+oyDc88PRy0RZRQFIme0TYNDWLEDe65rtPMxFZUkiRzUZ5CJijbuUGn3m6tFn6JUtjt6qURDRQNsvCy3sFz2bkOfBr2VHcjmG4tP+AXqp31dWDj1xqEBqiv90TfFgOWvG9R3jPoZQANTQoeMHABOOqSoAavkB7FOJUJI/js4+iScAOvJ3GcODUftCgLilrRtrfhm/05ShBZhPunWJZtFTl2W3KZyA05smfhDPqSZHo2fPCtjJQ3rn60GJi5UmAeT5KuXWKj5z9BsgZJRmaj4P2vqRtEdG28lPv9Y+5ZRkLTX+H9BrCmMI/OaOFFAMWc/vW2HDCXV6xpS+OYs4jLSSEBQay37+2ShwEv1v8aWuS+deApskPT/9x9kAw11rzu3wlaYwhO1eMGspmnLBYWI98Io+aar638Ne9NwU/PlwhVyRT8abslzeM9YxAlZvjtW817jiGL+s7ouBR60r0BSjz+vEIf++Z3i//SyfqrWxbEta4obNTG2UX58EgGs78cnZ/HDfJBh2CN6EZmjQ5WkrVSFsrQckEHCQuiKquhHGzsl/jvc9SWprCNgQ6I5EXZTtMqQwB7EJSF6F7xHlr1qLKIqSn5nDuFmGxxZ0SMENH6EAsNY1qb0ye6arSPbC59qVM5XVFbfbdsTTkIeqfazhemGuMIMfS+FejXTaJvmnjNAMQSpnPr8LjB1lz7tAEZPgGcpQqSdGgQqlMWZ+tEA0+cXhdEnsms8CXtawWZcRf5VbXANavDCviP5yvfWrCQ9Frl4Xlq9tZ+7MX1nZJ3xzAxjkSgnbUPjML1AvnfZwITal26sJUxOF+eH22mNX2PqqabCeJnUmia5JpyWNauEN77r2/4HoyVJUVgiKLXmUEsyE6j6kR+0yK4tVWsXA/bhGV/k1C/g/dPQAglgx9gG7ORlpvKgSjEhlYUAIcHIAwfLANbBrWpwcSh7lbqFSfrMgq210h9W4bUm75lezFZmV6htGCix4s5m2xzE2Kl7j60RFe4Tj3ICXuXGuwHGQoM6Cl2zYDYH3WzRcsO1Q5YC+yRIUJR029y33JkpCF2rJ1JjF2Gi2JwVMBZz79IKgemMz/51ix5tRM2GgcV3EmnJuy9QXF4gj3BjVM7tgxJeRZxq3I5tzLURhqsIYOKXQU7lm8VjXCwtxoNc6nw19qyES40rAigtt883B0rHXTznRpeyx46ilZjPLp+dQ7VY2hlvBpCsqtvRlBXFE/vaOq8KuR0n2wj5VCb8BfE+TN2oX2xBZfY33wfUJjN7udJLrPVB6F8mUwUS7enZxE7hRM8RLLdY4KPLmPr9j79ZfeL6kbaqPHXkp72hUNwZ+vYQ++82Uur9mOLmRd0lXuecQXLQUvKQY4RYCGknR0Gr+bgnAHXGD2nnqSFKSgh3s/jOWCqyLT3uHhI6838YqvOl0vBcdsjQX3C3IVGELn7mNNe5w8zZgjMd9tRZVyqU0nhPBOWkFnhBHbn2GdIouzk0LODIgFkrqUYZsxI6H7mS08CPmkJkhppTMYTbhiRlfa+W8BoM4ZYPPJ4X6hX8UIaPjrdHnM3dW54lEFRD2wD1uX+lnegfsQGeL7BQnwZFrdHMmytst1uskkOzePDo7Bg71aCndFhcHY+kBob4kjD55xCG7H5JYE2tUki7M/xEjYV6UA+oAzgfKNcnGb1yfNWYfhtEcUDGqJRJP/upffdByHdW5dUnW/0XR454cJ8ehdh9QUsUeayS75ZpexojWgHpGqnCYBOJtOkc9nNlpur7Im5cPxwL1jw8duDF1+hSPs7DHj3HiXZVze989v6M2cqVHErCiRLu0lFt6lI7p8gqe2heQwEv7i4gy9PAMKZSCLTzDTYwdivTvT7ntcZpfiNgYNfHJuEbHcTPZk5GqaIDpBZ+I/t4SyfDt8rhD0Cp/Gbd3axK1QBsVkQRQmQTxc4tOQBiRa93mE5FKgYGrMybQ05zH2B0upYdHE259h+41krjWAVQ8jupsm6DtLzGz66DDVYFgRbnkwURlYPJp4InVAeGq1kS2ujD8eUW/mOtFiE+RL4JGOEk7yxT3bZlSJ55aCWdOmChSn6FQ1tdN0oNVqIjEhTccu1yphAqjA5l8jO3b1VuKFxA5fRXAKf7eQS0KJ6+CMXUzrG5Thog58wjFlxi1J1uOu1mhpeUOiRBkRc0//SglZqmPQjScg4SrLohKCLa6bU6cQ5tP27dhKToSkZKY15/vQdPD+FiMqCKPIyYnI5dtTUblIGHjw7V7BLdWZlHpfeP8csNQBfp4nHxLjOKKYdUq7TErHAldFp1c6FfXuGnNziXIXe6qzPEsoHuoG4nTJapDgKURsru4FCn4psjJijkiqJSteCNonsvTShOaRz/N6YPG1+HKhP19I8lke4rhGrrJJls/xXxR8sXJsv/tSJUgE7Ck6olpF+eFLmw1RElzZDfiLSwV4feEErBjjNGOcbRvzsCNxhY7h44SCvO9QkrfTsjRsbltVY69P69A9thKdyyaOzq8crTZ+stVF+jEG1QA75YMDUMp1MU6vVDGe0yKI8Bk2tpokDDSCo+1K14SeCqSjuauaallm348Nd+QPaxf5GE4Xh/3kQqyZ9oKVKlvrqw51SgenK/xmGPUxpP0QSwdoVIIK2sbzS76BNDUUPDRYdeAD48rSe0Nnb+ZIygi3DPYY11hOhZMauz4ANRzItCgcPUrdvao5MrCubuCPx5NzuVgoIhQtZnTuFYKvi4e1jFqSplBbXJTzacFjEfPxg9YPpHjOxT3CNvoGbW3/jqT4GyVS5XK0FCCSNCzED5yO+TAnkhLxCT/iXxMiB6bhQBBLnh52OJcgC1DhtriuS3RHgzD5u6q1kU4eEXVU5c47T82vFgiwLiLdmjlDj5JdeT4mKaH3s+lZs0AlPQx5I+nTppxFQNuQHA+VrR5ewgomARPzZWJOFKgABR3LIkDTC57xUC0QoA9Y95ZbbWj3BzFeoo8RK+Be0DU6fbz8KtK4drO/Xw04fdOM7TvoxpEIDry15ZSa4GtPHCdr8z78ZVkpfPhJ34ktMPoQSjs8EnWfMRLrp+knZWWutiEhlW6pvRwTRk9D6icjmKooerlbSEGerr0cCGag8vsl5SUv5+YbIrj+eFOEBHAnY/as0hCZY+7cQttSCcASaDH1k096IU0BoiswqYdmEb/t2yBSTnZV4A2Q0CprHXQ1lNo/ObjT962sTif++cIeZix0mceEVR6bKCGFsyOVDOkpARPERYTXW5bkBOKMW0X3+uLp9UIdsvj9RZITL3oaV/RmC8It+tWEHIdJaLEMOx6EVfvlyk8YPoiQ3g5qsoC6fJ0pC7P/nHdm5saIXopDYglv63kl56d0lZy6mwsTrCFn2N6gxyYgivmrLWUJNinKeopHMN1dyMrGBmSJgvcfO7bErOxT2eV5Vvs1zVbI97Ae+5BmAjC46ljEpb/o1bikrgQ1l1PU2hznXwdxTifqB9aRFqUCsOjZB9JPTJ/piEewHSZiCUzcBFC7IKe3Li2DDPfN+q+IzmDhTHyPBtAROnRsC01OKpLb8Aqnn9SD+QK3vqRlpDsYXs8z3jl5x5NzWwyCedu6nlZEUG+xWoQzPeQGoAnZFQrA4k32YZQsvcglce6pAfnK1ySvdYyDP1Xt5pvbOZQr+9nH6d1JOpO0FC45RtN+xyFML8ujSn9JbTyP2BeM1xlygrA9orjI4dGPC23bmAcrbmy9Dh0BridIMrbXq+6G4CEXA5YIQATaHpA7B3wOzCt3zetiZvNPILr/TTFlVBC+OzUVcEkJgiMrH5xnIIjQdoNiZI2rsnDcu70OvPx3dj5JhLoYmHSzV1wimUBQ+3szSKCwfbrcwRIq2v3XVtCWFKrvX8/gB/bM7RzJPPHe3EB/MkaY32TCjcenTBNPNnwU2rxqIww+/P50WuqgKjA6Tp+ZnBQB7h1UmvL3LdGQBmIg+SnXRJUa/XeK5qaInTGC144lWYLIK5KWtq/u46MgCJgqmtjcWPQL8EmbP5jDDLgWH+Vdxa97DiHBeT3xCu+n1i5CgqTDhfXbCHhjKYlQzafbCXXZ68BZdjtEYINC/GulCNE32Jf5Nn8kmio38ZZiXzJAzhHRPi343XCBpxfuJHxGkVTC+K+MkmY78wTFq6sqjHajeTAYZPqznEu+5ElgTVxH8YtPgcV2HsisSbW8fXrBzsw8SLQR4ilXJ+9dzuGtGY336x+u2DQaZVyEbAqzt61RQVZsEztBsRExVN1xUkCqjUVsJM9CvsstaX4cTxqwMobDresBAOC3kMwzHZMtf4CmiLUX54DNa4RuFZdLsbmERgMl+0ILGsIMrJyGNS7QQ0O9uzlh+qEb67TQA85aCqoJwx/G7gove+h7NIaNnuSCCMEBT9QMAe3zkzcSsh8a9XQvOv1WiGZAE70cVaYAM6zqfT5wUJDD3GltiPZurdey5Fdz+coIHGO3TLDew4FL80VnvSKAqGf0M9UKZ5WQduduwXhKXj4mYqWisqdC2KhMMqpnGf+HutynwEWtvAG0wEB57KJ1coQP7YtwQo3G8l16Cq1nqcgishj9rHrR1LhcmAGKM7si6WJ68UqOePx98+pS1GoRQEQL/JuvjMMvPrVZ5K0qGLqLqvKbqMY72oLVUIxN9LWi3VjpKT4MT47eKYNstHuYE2DB8ubNZjjZmcbjrliboXSBQcfRqfaJduSWpGjqgpTvalgvWovIb1yNemlbDVMNrpO7R4cREZwzE5LUEIyRRmpQ4tnXjC9ai7JV1eL9cGE1AAoepbmbVb0mxTisJWHwCCEGQaMqTbvsc3acXBcbgvhk/6stdd2cJEImvjSBiqcUPumhTympyW0hXW03tTJXtH9Jxj0aY/S4GVHlxotj/lox51FdrdBkwdYnR80ZplhSZidVmI+17e1q8/cxYSRfbS30OFaQO5oY8ci6WGSMaRMJE1ac+gXhTO8k9nXN4FZFasWsWH+s+JAwNwzDjsU1yPlHh11zeJ3io9hQYtXvylF4qHdnSbfp1em4P6LFqAgEwR/AN6Z//W4b6IAVQBCRvGZHgm2brMnj9/LUF+jorzDqS+41Cpybso2sGLNIO0erD6qvdU5LmCzZwpCV9QelZwtH3LOzD6ggl1z7FyDnyadWffMm8T0W5L7v5pXu9T4L+9TDe4uUFLqfdzhfi4ZU9bRXZXelahWbKF3uMGKVZ4uuRmY9/ehYD5p2AAW439gPjxS4fw8lyIj/IEMUPaJV/56bOhgCZkQjdFZb8oc8yYJ/ZRDBw8SjFJcJWGdshV3WrJxcmcSgQJacD5abNBlhq94tbFy3qtgzY3BjwaFId3j4d1dRJ309zO5I/5qn5Q0R/8raqRqj5WmLtn7sMrLCH1zVs3ejEvqYi8Hv2442UPxmlw1xXB/7oCfi+Km3Na6jURFfPkmDM4Fv85+2h8FSesK6StES5SjjGL8uVHIj7Ch/fLt2CmklE8aPWdj37pnzzi7u2yxMuoml/MDe/eap+06L+Y1pCrFuwPQr9e2Kf/VMSDT5Dke7U/xRU0wEPw5WoZJy4l4mtd7v+uFDgdXSUWtJrSTlvgNEaVpxCPD3ZQpGtRiKciBVHGs1RXHdvDXM3heujrWxOxTZ0tpVCHKtgTCf0BI+cmhDJyxpY1kpuZqIvqiODU12aYNQ79BvKP4RdeNqv3W3UkIUvjSxO6dfDpSVvJ0WKrjkM/+dh015SlQMw6IrYTbqoHlFr6mSUQWrOrlqMLekqCduYvYbcilCJsioJqGiYXO0j1wHpoyrSFIC0vD/SIQa/RgDmREpIe8oMDTla+xvuvfcl5F/CGfJ3PBMtf42UPnvUBa1LRdGZguMqywQ7rVs56vwCfyczWK0VwO0sO63WPy5CEsA8Rq7GcKYrQJWgjPhD0TMlPdkfrLnLc5z+yz5aWChc84SRCHujc594XX0ZGEeOjFZJDq+K/Ze47evLP09oqNQiAQz+Qrs2daXUIriRlT0yrzRQKXdewdhBhCVtVW7RR7Y5gP2k8OcbMLcVOhuMrgkBFXRWmh6GvRox9Loz205owEPT9PktWFrPYGyZXP+Gw2+gWY0r88QrvUWfurdZ57EhXV6m/XxI4OrO0Nw+06KTPij0tWPaWZL/E7OjbzklzjWlef58k6oenp/AmcEHskYofBJs/etLyEuOngOUEy3+AZAiqOYjzSkTPfGzuxd8KECn4LWK3XBEFaMAZMdrYQczf8i6HSYfOpXNjw4AgmUY1hP0nZjopQe5+LF/5W3lJY+LuWy9tsViRefQRH0vIxJDO+xAszCZiINHGrVpA4E3vObmMbtFFPPdtMmsDl01cjqx8GmioJ2xNz6Z1pn1aHqHqiEiXSOppcsft/kOJYKpAkRybLdrtvJ6nPIIFEXbccYaldRzjZblGt5hUvf4bLH0RXFbMhXEPSvxCZ5PgFTYWhX0aJzzJbpwN8RipPnk1rGPJzqnFkt4tSwV7lyUbMc970UG+tSI06vIq9Xf3sljvpSQpn5yhDbSgK/H+9iEbCNb98h+L/LCdVizOFdcJn8b9C/Yw9LbcwfWwFUy5cFABKlyVSS5nbyLCl39DSS6JSqcgQShfRNn545FhiIrU0cnlWtNSjbrMfdtYlRT9s7IHtFLL4moZajUzqUlk1gcbXaXUZU63IQvUaT+1/KuTa11UQ20xvEI/F9zGENQpFobQ3+n6X9f0Z7i8L6vUMGGIW+U08GKfwbfyjzk6zzE7W4D1W6MQFPafZVCT7KMJoLAsobvXzaC+AkFIFrrXpsCn8TywNlcm38O8DOVqqPjLKEAkKpJEnyb7AA//7NrZjbuhb/t2Lc6mzO4C69cvlsnSLB1WxKctaGuduNXlFwPnYyZ3Pe4oWKNtLMpheBzRZ0eG745g75IXuEXyX8GKX8kyhA4BRP4ljvkwcCAvC1HA3+7F8QoHqtWEbhNxGrJunsNOhPrl7OzuDEc3PFIgir/jUqRjqZDrbBy+ryTL5eQEIs//i4q67GHrzj3v7hnNyZwiej63vTEBzcyDN5CfAbwbbmMGqISODwKKVCZXFfwPXU3QW2zvbsrF1IfOFYy57QDqpjenPR9AKTKivsBUCtBqA/UVgXecSYU9T5iN/C54DHRNLBe+GewxaA/rw6OCu6B00JErphBObP6eIpaajnsuwunsen1FbHtth4j50vueZKI2rcwz2OSsdk+rbZFPSqsVMdVOVEaNuekuWCc21ZZ2BanJ8f8L3i+7MHhwysYHuZXof3cofAyQ5meJ6nGTIax+dJS3Z8gGIXb4CGguzY8i+FxYIive8c04YlffWtGk4BwGc5M8MXfpqAWLxUj0n9b8dXoVHFKz3Jpc8L5UHVuKXc81D9LGqnDdJ3pRxltR/w9bo9gbQSf3h2emJJYejlwcXwtwXsApedeJ9kNJbb19mrYdBQGjHBnyag23EU4HchfeUOqETmpY4onXQRN35B7uM9fNbZ6nhhB3ecR3wd/+Fot9CJqnmUHdATaEdp/HP6zRSso2mTne8ZSBFxBF6jGxSptubquy+F1bfWzpn4a65gLf8E7BQMdufF2Tqd4AFb86ytDVYPHuLVYm9Ugon9V7QO7x/U8Q5Yhowkyr18tKEU1LM7h68Ge3lzZf955Vs0GjcuIiubZCll2+cAWJb3BcoksrzJI4EzmSt3N2f56crSwTSQvGtEgRzyrmOQF0kLusNui3YKrPydjsrFcZUVP7pX0GzkZZLuSBJvgQ1YC8fAEW+VcMJqEa2E6TPp7H27jvScRkw2PMVH27412tDYYhqNAMMBZpun2MKNwGynQh07AS8XBJ0yazOA9pjJk71Sj2vWdDzp7gscWULV95ekfNtYJVra2Y+3envhvXDsEjnN4Czp74dOu3n1cypqEkS4hsibc28ZbNd9t9gTO8xSQU2PeAL/TU5ZKQ+XAB82yRrd2gjELqv96fSsNWrUXlelc7RBmVpA37OWVfkA1RjmzeF5ffLlVL6Eg/yljodrQyVdEFGjgfr6Yaftw8+dFxzAAlpEHRFiOqjEgKHqJ18+I1H6s+fhkrp00o5g3DfApcXMs0gu2b8hZHNDHz3x5OVPo5FF/knZRw27lsrKS2i9JY77eiAYdOMvpZOR8pL8V9FvK4EJU36PES5SSalNhpihuQBotjPdnFUoUpx82W+2vRCXAB+D67fDUO/2UrZ0W81mM/XOa8mDP1iJegD4iaBbk8rsqp/kllecq+g+13WBZOac/MLKuz/HgCSQDb8G9Hz7BieMlIDoEcED2sAyLdlTxKVomovKr3iphvfhk3qY7ygKsRzQlF6+2T+fX9tAOfe1u42UmdsDEtAcQXc8QFYEjHIOyobscttRYF5PtrLS+3RQp0j1HqNztIS+BqF+Tdr4j+47BfTTyV3Yx06r4p2slJhCpV2TveR6luYEl5WdKVKHZNruPcVR4pUopZTvc5zbXfR/h/UGCV9bovYqBaXgn67kXoAYoPsgkN4nv4TBxA9DKuP4Vn/jxzb7uR+jCYiCM5xIIEG83UVxrIznB6US5Ir4udfN61nU/+RaDPXY/Qy3cETt6wE7a5BVdqvv3ZI5JZskI69eO6ngwZQ1uUkTdwEKbR6P9CZkm9ssogc0jyIxTlB+fq65zJC+Bt9tuKZWtKljC6zI4l4dR7V+m3zJ1qwUKMzeCq0PV4uNxBWhcVlFw1c0eIxrXB7ZG8HSUhN58W3I9bWGXmyMrMLXoEs7moSWf7rSQOUFwpu5LL/BKRl/75NM+84YJZWkbCzcgLFTNfBTW9Oxwcpg34CvwbwfRhHlubLt/DNo/HWHgE9v9hW7PcGvDdLsUXCI5YYcOUxnEfJroebGEmFLO2D9tBIjqeaMTPEj2PPjyCSwlKxPKdTLfKOBzUfHil9en7U0ZlBUmMgGSmyBZrEtK9FSUB4kTeT39iAt4IAF2JQawTvrCD8koTgGL7gmXJu/HoreiPPtjeRCJ6CN92XSfWfSxHXKjKswCL2IWHVcUKtei0nrUHC8X0zSPzOccn37T0SsDobZIEWSttXXLmofXrGyE/cycb2JCQnS+AhnMUCDQyrzurHs9GpB4TCX4rjYpvOut5CN7QLg1U/KggylvgGoKxypQqNDphNWQi9E9P/SWwBAfG9Tj1JeE9B+j9Ra4F1tX5voV6uVTq5lVM3Pwk7YTH0u9N2IZBvkJBXigdhP7quHofbX70p0biAvF7k7vm4EMAnHYbTFov/K69jmDaMOThHt2tZ21X3iQSmFibaXd3VM4d7CcrEVFDkkmRp808+KGa04nIA2T1xr7VPqO9Ezw3CIY0e5eUzSlqx/8FUTI246VJuEJ4kg93sC6hgMfZgls8akOmLeqqGNTGA68b3OpexL4hlVwK++0fROmlOr+H0yDzckWnO2VBTc/EWmBi9Xxl5DGBDAyTkjZjTghL5auMFogTFjMQHSQPlzgy6ZsDVMyssFyHB5NRSD9oNfBWU0DQjgBpLrO+HMli3HMbLvm0rXUBtkmtvL+uM59Vm98j3k+CAHX9Ro9PPamF+Tia/a9YsFFKIQJFvF0GHCej+OUKTYq/zlVI9J/+2YoabSYzNIQ13B1ONQ7GDW48Vq2KKs8idO1LS+dz8+eYT/0ulbRaYAofrBnKJYi65kokAtmswzOkNNE19oaGb67V6vnOfKIpypORqXJMAAIW46hRuhWe4N4e795z2Pdg8PZcnVWF2AuU9IUio4uZK5y6JmEO4+BE8zXeiPiqazXGgdJmtdcmidyA+vsvE2coiqpavgezXY441g+eIbm6XCLgz9scNxkb17Lb8S8REwZu1vSfhCILSk8dJTWkIS7UIr7A1ZAnfi0DjUUU14omanyqNHJTss3Su+fJm3bzfaIKlvgeSXxF923PlTd6DT7vhE1c/E+JgJfIbhhqY3AiKWridLZPlIRJMPIs1oUOMVTL5EhffgamIq6kHLorvzvHeECJVcBZ2rsx6hODU8ZTP7Cw5V4R2WTnFnpO1xjgiQ0EhJQgNqJnufQcQHIHZLEpS6Ox8BmpL9s6jHcaE8LAHhbNOezi7MbowgeZf/dEvj6bMgR5Rfm9EdYA0cUDcGElguTEZ5PnypxhITld8khkuIzZdKZUelelgsb2E4h5UCingseJPCSLzYoPbxd5oVHSDf6BYwzTG8HVR21UT53VUmzKdebq5n0Dv+xkfYRrtuQocuCgjBOxTOXksFu3sw80ZH06DqKWoG2iBu883nDk4BnPuSONCbJruoK/GTmU/JUHJrM1EVrFRJngz2p/UZR1jyFbF6ts98tBlo2WAUnKx8uMN8n/oLtZxzHQbwFqsNkFSGWpRAkRln+iT5keXfNJ6iysfh7it0Sj80CnYCwXR60vEMFi2a86oX7CHq+q4IR/XUGRmQeth9xmmZxDtsKYwak0iZcrE4VEe7NUR6c62VYqJjvpObEQrsrEXT1S4P6wJVuK+2adLlX4wR9a47zlBvaIS8BgPZbsJ27PFnA+EK1Mri03Z28lNH2Oa1B+IvBdnJzVU9df2QWQOBxv2NeAkirs66IbNoh7NvlELtWldgblzuLJo9sigSN2XmhonBpGVwxoIHI2ZXZGyiqz7/OS/YXy5orRkww9qHAOgyfnNAuA8kcTyXEBcdaZ9IeemEboc8dNb9+uhdNXKHMhG6MYUcYeuybl5wN4TdzXsMNv0f9M4U4zHLbo7ps0YkI4AYxMlKuwrySQS2OaHJbIO9qjkA+7MmTM5fAz4TvQz74Y5hCQlkhe2bkhc9BPxfPQP+xOHlzapwf4l6J1eqy249MQm4Mxk4avXAivTnpzTUyjCfz8/at2CqofjmkIuKwUXGDI3I115TWbbVNYXE8BMColJEYj4LE0xfiVhp2kLXFdmNOQKRplkK2i/tE/bYEt/IHOsimKJzp2l8OUWidDuRQ58Sqw0vJ/NeimVC/OHtA2yItJJP8RFv49FvSmHex34S8i6K6J8avHDOvXayy0tSmcj7a4lJjH7MkoG+0lHxCxKgRJh0TaK4BbQpFETs/hcOFB0LW426dsmW7jrn1JHb/AVuMpPfLiwdkz2I2NuDux7ckJz7v8v2yYfxHn5tUgwWpr5ceXQhhVOtIpaMLszYpGnhGChcJHTHqj2zD4GzTDCcAJ15xKbtkNDnqT3xCvEiv5aRzdYR/5sbLd8GiW8nQCGW14qduurowuhdadP/FrRbnQaI6auXzH5nuRd1jWfxNCgZBfs8d6538lixauICv/thridhW0aPD/kCdDkD5RxQ+WoSclPhGQPW6/i+DyKNSQC6P8gX9igV7u4te1VltgnW1IwTNjUxmtUA3bgj5YFKB3PCNxd6oSNoADucT5wJmjAFILi3TOIsmLHnDRqib1Vriu9ZRqO5w5EKo03Lz1gmXm4OUuPdXhgucAqPU92IsbDkVioqfwHGqPeikNUCq16lnO75vFfIhvQ6zsOhnKk+C29jQRRlRI5K1CIdqhtNsOfYpbLBt3AWn+4gkRrBtYfFz85xwBLfvhINQD0OBwXMp2xCmPfZs7Yl7kGqy7RksAOWwlu+yrNdvMuWWEZru2LiNbVITdAjy5Wgfi/19Bg3Hzh4O8L/6AxN9jrFtOJmo5mJtc9ocKLMfj+uF4jV46zQGdbe+8JDCoPndlTZXP7WXZkdm17Cg6AgBmu3EkWvUwgg6AVTZR3xOT08twtdjfep08LVcdtTdrKk0WHviztLRQrzkxvytsLgEL4+2Ub/NhbYXF7kqLf0FE9XboQ3so5+lZ1bg8exLER03nUbaHEME+YT6DVqewUYpS+NgOZMVzgQp/qbCsI7JvUMeyVSYERF9YqZi4+LZMlevx/GqwKfSMZE2NcGSCVlflC6gkVGW4g+sM3ryJb9aWajn2Y4jP+8EgZaJ/vbspSQPwYDODm3la676n+5YvNpok1ok0TwykxHpicXXREfgz4NR28SEMYLGQE2k726BrRF7fSPmErCSOqICUpVH2fE50DvUelB/qQAQE6Qj9zVvYqE1Z9ruD1niBJsfwbaCMENON45u0oCFEv8zic3PsnWOZvHuubcvNwAtNPggEgN6KCqtRokWnI9dv5lCUyEIB8L59v0AEmYNzImwbrdMf53qPheOrSZt9ezbbfj33tt15ZUOUlGzdOu3nl58nBJVVT2BV2zmz1WKte+2IEuZaXYT6rhOC7fsonrTSJCLczoy8pf/yWNxKuZBaD1kA03NTC6ewVDuBoLo+x/85ha9V2Q5FVOn0DbPQdKECJ8+XVhNVrNOeMr/HAmZPDaddt6qst98fPDz3ZXripN23hD6Sqqy3/JZ5g5KwRuWOiAOyJjDhKGPvGRrhLWpFGxqZMcG/s9SMjXZ+wKVHx2cRhVSBZBMYZt86YrQPgAg/yjM0kosquKopSEgLnd0TytBGItITxccMe2Qud6XJhjokDlgMuMFsvynaK+qHgTRZAXigL+l+4sQuAthKzpw+h9Ni+TbVwvXfifPogETgyJfFVOmsBESkcy3oQSUGNnb/GPY5JRxh96vspGZWccoaFFlxVKYTu0jYSfO0KOK+8GKBCpm/yzTJ6HG2YZOtIo2IBCo0PyemzqGYvT6lmSYgqB7Br/+mLvqabNxvY5mjGooO5e3+sBy5bDQ0lSIjBxVQLjGJbTW6GT3VQ9m8uDgcfDeX38M5RpriuuCUfmANTf+eHxqjLfbE0SAwCdH7LYUdBleecvPHCqOCVo+6R2U2/+bOF9omnlVeQ6lmzciGcnLKQPr+Iwz9DTQEtOXRa8eapFeJ73zc1KgMw0UCuqt8q2wEgbX7LKLBl+K8ErgQCNyzcgo/9TEXI9D8tsweb9dAUADKukapswRZPnSb2POfuyo9LsywhLcRBe05wbEqzf/nEFiIw1Uqmw7bz5D4uJSZOlMzNf/Wui7oMX2kQ9QfMdyjmJYpy2AMz8OQFDa7BS8iHDNfLQ/s5BFpmlIR+LqAnqAHPg1oslHCWaScUWw0GPjess2o0yn2rtgDXCbrxk/yHqz0veaH4VFX85GH8ueX3HScY72DntwHaTQk9TT1mwOB3gixtrfxMLPnmT/fgf9cYf5OmEH3KnhOhl3p61SfTgyGnzbAYZkGKNo7rWZxTCCG3kXa9yJh7oYm5tBdid0mn5lGS3sL5SRH8gMWNz1F9qLmcg5hjagcgA11T2RHxyRngkt06Y1lS0gF0En+MZunsZKeiyHIeZfp+aCikPRDPmyw5/ptHAdwM/2iqIWTeRXwAlS26qlIf3PoK2lDr+p7kmYjXbRdLx3eN5tmHRXO16G/B3xXL7/LZi9Sq5oZQaW7sjnG9qhuI9n7+3Et2tEYlrLCdPHdlHh+oTq14cRjKvWDyOG4YSeo5Leqia9CMeozJHwXmN0nO6wbPgi37YL4OJLG6+b+HRU/Vi7r7iYDA8/ohqvwTCVhCLiKd9bQq7VFkfkURVvMpLlc5HhuP1l6lfL7EByuMwqgxwuSuS3kbAKVXtJAV6lvRUoKBCoZwtKJzRrzOM24K1XTKYJRXnQ7E8L/H35fKRChNIYZEyeiR2tTjemI20ZEGBTVKUVQXjeSO91gC74iuLpWfCgsRSdItfN6ImPb9z2lQL6XWJNZFKw0rhM+X7FiWkBoODQAKGm/Uz47S8j+VHoRkg6uqBAAh36T7yebaGRayecZJocSaWbFQkiYXemIRJNPYvXwHnMZR5BOAjdLCBdiJmZPT480lBpCdzseKH+OSZdVN1NA2cjR34zvQnXltT0BSYcHZBBDpFkCtdcgAY3Qp42ucTNEHK7smiUEIl9lcpQIAQjqDptphq2SMws18rIGi5x1Qd/SM17oF3ZukTRELnfCylZ3Lv9kK2FRFeoBPFu9bcP16ExoALGXg3oqi1ZyQZn18lSNvLT7JIKQYg08fLYS2uVCet0narx28gQu/Es9zcaJipmpTGIilkTrgtAZUwsQQg7fHL105r7fLDX2p5sNfK9lrgneczTxcL6ibQZahV+a2QjRcC2THjzfnAKoin74Txb9C7PUJLeqW0x3vYpMdUWGtJPqcYURk/l1jwr12+uYl8qpNbGAhIB52wgP4PUjRJIbaiGsTWvFcDXEaDJLPCJrPH1rKP5rue2M3ucGtaxghhlqkwpFhkj7lQew7iiBObkbTByZnMbYa6dGyDkQCQbfcNIPbZgq1LnJzvbNy40tXXimFy1e8n2ltAjoGO+BoWmsBLrXY6NdFBFCJiVjPZk17GvsVIO9UtcgS5nzfWY7dnRKmmGhSrZhOJ8BBMkLDy4HlbciRrRH5eVAZiKH24qQRhTPXm7bHEdvJaPayFkqxOkWGpOopERcheVcmMyPEGmYyGQX21GEOTK2b5JvqQq7V1cOK+xetKCP63ZHVTs4DK7FijGTZHhnQyp8E0s5zd5q9Q4vnpY5JeMA7hwrbZAZECv0fbXNAXBizDyrazdbTdKpfOEzLblL/SJgGQVzqmoOMEMzOckGUlZAXyqSdeE8hng6bfx2WN37HK+K4Ny50alNcajDh0u9d+BtQlGTyPE2rzsQpJ2ECjnNfRrXkeT+Nmgron/ZviuA9hkivtUiZ/nKVK6do+bBd4FhEMPmVnf/hBNRxXgQ3yxQ9vONFoZMmm6vChj35deEL3CRlWeVu5jiR+3ztWXoQBvSy4IgbtikALLKC7xmd2VXHQkUecZ8vETw2CZG5wgZmWW3vvoKd9p1wXjFOh7x4vKL/pQTkpmFtVc6LEgxL6MnLf3Qa4fPny1brmctLBIWyubX2INeP8hwBkgaRXRvrEPvT57VNqR69bFuIlaLLHF7yDKXmi0rL7ldLq/d3RE+GsRAw0yGqR3YndTticGE9C4gUQjCOeiLriXyVx+Yq3fxOS69xOx+mWi+88jPDKoHjiNeo6ZxErb8wKl8MjAPfcKZ2I4piKE2Z4BlXvzWrdRsnm/uEBCmLaBPLxDLyhawOVoQBpXgSEfge+vhitwrwJVoJqtcXW3DuoYxrgkRpup5TbiFbRCh4MbKja1/ZxUi8sPnJQas4INlBbCGCB1f8CcMDYF22G+DDKyAoSaTQHQUGp1dk9k7LSjHPkgp64xJuDM8r2K50rRnDKF/ql5L4zgHpI259hVThzNN37lV4KhJGb0mxxHMhyKPEG9JPt0gCCZl5kFOfhjBdXOiD0FBLfBCqFKTkHalKxQWSscl/CpQ4KqWPtBhjr9nBf7ER4ib5qtNVKJL0y8X3J6nMO7ARWqMf5N71/VxKMZmFl/+d6T7sPgRwaMq9fd4ioofknCnBrtFCq4DLfR1Qb9ySQ3wxmZGe3I/0jWZZvYHAK+GiHwXkFS/4qW3gRlpNKYut38i32Stanrq5XI4pX3DdVjfcc9xLunZ1T0dUX3AKA0/bkAs+8F2WZYfIYo4/Sx5xzMU0Amb3Mjp3Gqx4FLP7Ot7azcTnWLfMWbymMyTmrkBfwfS1rh6YtFcJd/m5Q7T1eAt2SiESsAIqmzuOz48KlV0yvkmNrvi/iIEJj++nQVBIu33S1/8Dhu6k/vNLaUdXvdlfK3Xu8e8bzYLIXz1656X719F6WPU3DXyL1ydecPNhqk/aSiJDEFqQwbV+lf3Y98hLpbn4kdbNAyb1IhJRqPrvXW56duV/ursxqaOEWKYhVCAc/ovGiP0i72ZurZ18RvpOsIuxWjE2mT1XoMo/M7kpift6ojVw2wE8K6PMy3QnvoSyePn9uBa5821IdxBm43W397bl0aOJmo5LzR/O4iEHW/nRbS4SDPY2lxQ/0WqXr+4Yp9kYVXKTACkYfb5dJGY+NbRmX94qiBHv6RnL54PtHlMTOAO5wk5TG8EthmuiSnp8wFcK9ntp90yFYg2v5Fh05pVG7Rpm6kbwM0mHIW/tq+k5R34Yy41J+QckWKxG6Q4Ru+eLc1WkzpsTJ0LB1nJFil+CDQaXEPqlYXtOdwCTTZoc5KoC/Mq0GrR0gRYL0eRa2/3yPd+iuXrd9ZTUFX/HshOz7IgbMiyUlhmmLR2q1hGBIoJQjNumy2j4dZ/QCBP1RaXoxcGpnXeObRgKaFp7IPS1OgMahY37aYsB2uWmabRrQF+4sU9mS/UJwnb//kmoD6ZWKIHaHOXSVpHOSPB34+guW2douflz6sw/t3z8mDckykTT+bX74xnrV/hxaCU9to5C1CGJLnjP+fLoEO5mGxdjXAAY2BudbDmDNtE7QKujQYMISOctJ24KjEA/Qqa+G9GIp+GAwyizmhCzm4bURm/bTGu2b8cNncrFDr8XiI52qcYiG94yCz0ViBgxG2P5r7opop+76J1itdMaTnytgLFJ/6bwCN4VC6kT3hK+k6PpqKkw3vwBAd1fl+9gT25rZ85YMgYdddPNGyK6FE4/8PezxIOkHucndB6rXnMd+i7RjPaqHbwbw5vi35p7iQIZ3FRN03KyAcrjFpYKcaJbHFxyilW8s9bcUOOzHQyBJRqiQbWEfG7kt8q2ZGXk5N3sllhNUMEhxpMw5CVtb79guFHsuABVfbnQ9f48jVNA6RqIJsb5hgVrUbA2YZsszCgqQFxlLTkU55VsQzrgfeqVjzzuIgmUKTRZghD1mJSySGZq0MHpTGZiF5tltEVKrm3tji3VeD1eVxmtl4FLw98qPkdvRIhuCr43+rB1B0bNHXbyO4rEZ05IjyHT3iIIwjRLg0YUneK48lmcg+i3qHCnvXA/MHFpXzjdFWurNvVgMtAWN7LyxQsW9+s8LHw7iX5cpryuRhDxnbrWVyUrsaiXMW50+kCBexc6SN7ScUFUJH5K4/t6em0ix0b/V5yADMm3V9EbWKKtuxyOtJtgrWaG7zfMo/DWw0wz0ABM2kA0U2tETXIknHGfZDaYiNlcvYtJgga6/ZE9FmviUsNJWD6LzQpIIC7kqIrE5TKNrhnDTxCNk19phHp2SBzDXR1hQKmLK9s3wRm13IyxQQcBWdLJQ+7vvUriWHIIbMHETDa+i4aAFnCHCUb06syTHMWzUPN67QcE048NGpAailj7dzOVwBPHAEgj/65EWsyGL0t2SN1wo43mMK3aSPnAaxLV+8QQuwV029nofgfwY4sAbJvynGsbhIdufDzfslNIxqmM5M0gfNhngpLHkoD7z3+ZDiiAVkzZ/5Nc9gUq3Y/XzXShzfVtNGfWU/5Bu/KTLInSEdXEfnj/K+YyzW/8Vp10wrCdaDFL4OdrNH6vu9U2Zjd9+Ag7p5IXOEBhKHHcMjOlPILWbG8go8BqMg+FYBSU/QUMV6DqICo86qa48HykUCit5pUVrBBg/dcZSosRbQZRLfylhUHwVjJgCjti0fNp3jMrgJaC9uxa2hxI6RoALPY/LnTCjzsxa4BQAGBsWXn/VpVmriO4LZKTWoMMkrH+G9fQ9AqL2WclfdREvY2fZZnUDJ6veCOwitZLE6yZKo77M1nqrMXDQGzwIa9l0gZjO4HTotkUPmsAyeA5OX5ciqy6sJBdQ3zjRHH/LSGc9Dbic1bntYSq6CMUqKvBlNavGBmzX/rypZ/inhatBn+JZ/yAmMvy1JklYkTeVfqH1cAUeJaXYvbJfzzUUW3K7eMh8hIqH2reexFvOE9UEPpGIDWvr37nnzIYVhxWsVZHmjGSdMYEu6U9DjkVbFHRc3tYqMu7VyjtMMV/I24uquFXdh7hzZRk/3HXzrOm57h1jLPCYddMf6XoX25RMWzCp9hbXMTC3Fn2x2gyHD4bllafkKRwRyTPSgxyA10kmBf09ZdEctVX6sGtNCC+knW/OgBvLl9Ms70U80QX/oyxwUM7ovAvTNtMqiv4iQFvmqyvWcRFv5vBPgFNO+tzUUiFKywcifMS+iLjFE3O0BSf7nuDTLXIDMpuLZGDaWOexJqNtb5qZLpyeYwifOjvkqDsPMrYKWZ4cxSHbYJKKZnYTXlATYEjE2cmje150n4blVcZlB5ufV+ODjnO7vND+fDL8IFWwW2a+Vt39mHWcOPhm+ra7quvVj2V0tOPhX9yT8nBva6H84uJjf6PNbvMraVyznkfTCNOnoJfP2r+PUcdTzxvweJMsjD8g7/mQT7Xb6WVZRBJ0wZMBt0G0vzGgQniZwEh3DaDdx0sewa+6/GiRcIrktXvvAzc5KLTdghRh5lmylBBEBVT6pcUxlnEBU819KAdgmuNx5HPVsLNDguc+GbpNEwX2zqj1vS6NO2g/zgRn8gpZ1oXi4KjKba4NQ/a6qfnMDMlgty3ri67a0R9XrhR/17mroetMjiFL/RyeoUlmLOku/ngcxMKHJWtCZDTkgrP33zyGX7iixkaLPy92MeZhYVKc4zOi6uCLqu6mVcwYtpuZGvAtn+nF/cO2tV4IW3LMJQce0bO6Dl7Nj+/gViGLag8zH/CupCSzwj8vr949k8m1XZJC8yXuVURVkaA+ggAEqA/WcGA0tDNF4gfRvRKJ3wGcgPjuTSNiLBCZkY6Ququ+8XtB5c58p4ugmlO85Ok2O9cGwF0Rh3IfQEDfG3K3f/MZYWckDK/LkwKTKba37AhLTRjWCSWQO/ho75Ow23cVfYddzSy7EbA8KuWaGg0ALSH8rDR9dHQSZICJ0uk3998SENhEg17f3dN3UMr09PDtx/HcRlovqv9imDcjZhJI+E2cdEhQ/vScxQf1+cZ6fu8PQkuGQG2dcF1FfvrQ2NgmS6KFF39C8KMmzUt69Pn5NI8DuPQvSyR3Hxk7v9XnMW5ciC4wWojWMazsNRcHnvnPi6QA+z+tFb9l4vL92riBjvFV7aYze5HEDYt5LW9M77aIhQ9+DlyHyGGkvlZ8TFktKp6qQaH5ijPG90ADt8A11FqeKBDw+8825j8phzp72GhliY5yvQ/jrWTZCAtDODiNf7wj0rWv6tS8R+IydeojxdnzpnzbUhuEMwA1EbY/ZYHujNzcmSVPQ24hbwhBDrxkYRToxPm7mDPc7eKK9QF25pz3+AmupDm5EBG/o8pG1HUMZ01PaTXyLox0snQIoqXOhHCA6BQwggY3RwitnBcYlZnzSK+SLQggnEDV1QxRVJGsCvxEOuDCy9mQW69msMrINkAyH8fT/IbRWe3QnLxWGyntOtjirIdEa9YTBB1fkxZDPBm+XFl750ljb1w4vAq2lcQzZkAtFpRCuKR5D8LkkKJNt3wCNaxhP/1VJHkieouBEhp1v7DH5+jaQAwxPQTuGFts2Yt7vpM7fDWsamvpD/TME44/sg0BYpddA7e8N5LPnnf469jB815kpFmtrU5C0qZeXVOKSqM5IiOI8c3A5Jw2eKnYy2UBXKfhyp2PcCmOodwXfo5kkPiapB5GnpxPVI655KxLpJoqnTiRBHBUCNFB0N3J8VeqZoEFmkFerytBsvDTPbDespDsIxSMoMzBBr+VulcD+e82KcSSZxHI6nE8mRAzW6eoSQczOo1wURxY0r3+bII2BTTwQZ6f9Xug36i3ykPwau3A1zqGneyJxb+1RouDPvUC9ty9Wvc825UMfYPWViI60N6OBx2t4ZDQp+BmjJe37hOXI13HuWUwy9m29b/BfKkaCfbKkGeiNvPWuZNBMAzUTvaXeOLQ3uWxSQGmiWlXv2yJBW3KRc/C8FQ+0vSh0cZ23CC+R52k0lyzO/3t5BquotP4LX02ZiU3WFOnd7kVwBSGY+3/MdZ7sHjyjY/vQTdy196xiyONJhjPa9ifXR7O3cT0yKm8UGcJWnYSuzIQ67KH50ce1pHe7wUfbNiCplSXuU9aRuz6SGf+tWFqLO7UgFtG9JfTGpRbD/5sQwHxOQiiJtqSAitfV1Bi4srKRiMAN3zfgtMflCdN9bleyLEU02Zxq7vjDyJIn88oMXF611X4xyDmQ8xEF62mke/CpOs016DOiAnjDwlL6MeKPGdOI0SfitEgya4OcNUTvibkiA/76SMQjhWEhGQhDY3BXMd4H74MSCzyOpmiPsFzJSYCDaEfzJF45Hay/oAIlazMFfyU/jfBLZNF74qNlF/Pv3HN+yPkTkO68ynHfTIF9P1jycOepglgOGdEbJTI/E/j8POkMiI6zfdxUIvCUhAic8lbgwyQ4CjpIBOQ/p57mFumAppE/dFZJgJQg5XEpKSl+ms2/ndtK9HYpIjUDT5cKrIutCz8KVCzmCpHIPcY6SfsVbw4EJKnJqHLI0aRh4eWs6LPgjJJoT2OwoEKwNPDSTz9fsJ8EkJI3E6ecA9llsSf+SBzTGC7ssIUdIPPaUG7RTazXSate3dczAgYlS/VGbOLLE5qBQOhdi5dWz7TwPemMPOGz/zLhnhgckmYTWAW7yXWaoB0S15YKLostvlv3Dw31Xl1uTu6JbYWfExy5IlRPFBekp6bBRdDcC8Vz0ubaxtiTjo5tfat/mnKhiRoNtaL7URRklQjcQw/FuDNjesgPYLgoUdhRtnMMw1XUihNdW1+PpErHJe6jc7gjrqwrBG8JthqCG54eL6Db8ijp1jNvE1wjRyvz8aKLM1YcxcvHbxCpdQt5XDV0WXfxLwOSoMrAWK0kp+9RAFDrgVBVYL6VH5QRWgBHoxZq9WqE0Em0QYVTz7LT0VIK0DKSMHblD+xkoK3aRpB04XjD+it9UejKKXjxy1qLS2SqhaqTbWVA2Bs+vTEbvYc4JIC7VPZsK+MBax2EA5qDpwobo6tQb0ArJZo3h7vN2silaJIZmZVXdkR2L8WY/IPv6N87WT2VcCtptsQyKGbyZQ0doNglrwbYAANxwAb6jl0/LJg4RcEgON9jMCxhQqt18MjwA2PTsw5fmAJi3NjKj3zkiMd32yCtd2S5eLEJ9esv1/mNUh9esyfpj+uZJenNWbzjRDMwi8XCZaYhAw3wi5TdagE/ZKpOlM9PDvYbVHAzPQbvx+mqG6fJAmwHmeBPrigugiaAPtE4hRxY9glc27H+EQvD9EXoK+6V2zANuBkt8prZtUBRJmuD8IPkigDu0DhcRNhPuE7Nt8uzlxD3XSd1bmZCZ2VVDFSu2YHYry1kBNpsfnIftUgQ9Ws1VRMM3AAUgs+6dkZnHWizOq4GvmuBrcqg4JpB+Dhdqhed7I8AhzZtvxIt3V+0QKLzjRJycU+cRK73F+jw1w2DdKMnZ0fNw1oaWG7Bter6eXZGhtzdQ7UCxZaQhJLyFdQp1EmuJYSGNz056BgD9gzifCeYJqzRcyk1rnolZyt/pXRjAKbH30V8QEIzeJhwV/Zd6CilY9LTaiPEsCNRD8dQjPcg9SVgeWB4KDgGr1pX3wecz1ZBUQoW0L/2H6zzSE0IXn185N2GtR2AiMPmmYtEpePpJgvhqW0GAhpfwrcTF334Wwvu5i6Gtjr0TMi4tzBfqsAjxh1a6fBgVJb1VmPN20hy6B9c7wBKeprTwmB8wnCn9kC7+c+zxOfdT01pg7t6IZOXlOHNrJpQ1daaN0QD/VHunkddVjpAaFAau1QH2A5FllBZ88zmSu3Rsc0MH8kQkNZX/aVp2GLJG9oqVDiUaZe1JnIISKo1D0F0+gGoeMEJWcMyP/Xa3rWQ04npdEyQ00hGH98RwUyUFsIdxYtIcy6OLA1RPv7QOf9WjsulW1M1+KKbQZGbo/sO3W/hErlzFe7IsQ/JfiuuNt8ZMjZIfqsXFFxALWjIdsx2rmkAv2Rz//XuzMt8cqgQTlRuRPFyIdo0vWu0bGJPtTJ8unOHIJdKONkES/gc6GRNwWZXw6Pk988fu7Uf05GW+FAL6xWW9d1S15bnf4rmFRvNr39W/bMFl7CBCwbudMxR/ksESQjSY9ctjeZiGC7w5jXi67qFvfKSqI8WXlxgc5bFPXYPJHYEoh/SdfAM4M8uM197xGSrdQcFka5Wjkc/ZV4dxJkYrCKpCa1M7CIVkD+rpuj6rm/lDEkESNIaYRxyA6GSXBtQFfDz+lArOKNEf5l3KSitMHiOksapqatJY0icfJmmlqeJcJfNlK45MBKnDJuAwOskrSirx8ZLR5HZj/bS7I0O3Mcs58sfBlgH4/QhzPNKKXa3CRtVbVAeVcBNLPWKsMZaaxOPejD7dNYc/Z881jarC1xBJfbfod9aJLIg09UUNwnhximtfWwF5qpYfM8/T3ULxDMzYkfeYJSKQWFupr+nzgh3cDDj4utkjY2ALbK2bDFhokqG41nLKuGY3fidAwek17v1zTMTcsTYOLhQv42YyHCrVg9H7NSpq3NuLW8nE4rHmNzWoPN8fkU6NSF6Fl73xHPnQh/fzaE/wYBFbS55h1tj1dBZHFgUX98FHSBuHvRzeJYYEAAtNGSDjzHOuW2kP37CQLZ7wayout2TwdjCBGrs6SS3sR6CNg+KrCpPZ0CsiW26FVWujFLfSODq/EleZqk5rrEihcn/U34vFK1w9F0ZNLjYPtAN8mnFMJLgbbDfyir1/hphsfDXBA8mmuMCl+/HXKMm1R7DX+6uM73SEvmKxf2TgquseuOSxfnmR3oDDLTzGCrCniiwttkbZi2NsIhOtiiWmsx9ng0TuiHeenh8qjtBlg83KTc8V0QFyzelyD2w7d5UaOLBo4MDtUKiL/4gRi99K562pMVqBB4aG2w9u24y0JoWQdbdY/hAMWBiwipYX+4fVfVib9bkaXxNx84rwy2N+1jlc+GY69Huy6x2S8u1Ff3pVHq3j5sHX+4mc4fuh53GJy1w2HxyRSM0kEqV10sgKyuHSVzYcpMG9DwBxh1tMOG+d/n2Dz+fekipwK/jdVygm0DXujkANQ1mZdWFmoeR5R72iP9u7MQdzezN3ypM8BGZY86QGv0vqU0RuBspv82x5pl9QYYG4tSM454O7NxXaTFr12yEZAxbr5rtbGcYHpK37Rn7/AQ9794iKjeaRqLmiPKN3eYoaUuignaGIJWd/0NskVnjK+2ovAYXmLcr/xKonlQ2zGggHbVdfRaDXCblPRpzNo0aNXugSFDxPBeKuZ2uAzepUIb1em4o/vQNsWNqadpS/mulM4wdsNN3+g0vDePxci+pf4Bu5T98k9yVLaRqgvGOYe5bekzzefSydz84jaPXL6z57DjG1EvHy+iY5VPEDddn26ZvlWhJcOpjZ4YNK8GqvpQEDju0jBoeJt2cHqer/pQKtfITDwIKPEtq1TgocoeRV2OjXR3X8sAj9ZTSQAjlQHGuHsnbWKCCmHd+gmO0CHUGzUd/4PGNzv5t2P3lngW/1IptiooqZCVmXW5uvS+u7e4AYN0OfxrJ+bNyM7EEshLIWsfXW/HmgYDPwqzIR771LaFYHWIoYmlDuwEPLR+lvW2rsRvMYksiBPHySqk6B9kPG0yYfrLUOlqVnfjv2MxVp9g9/NSiylf3yhySayP+Tcl4U+Ah9K/5Rg59lNINer7cUYpYFivQV2iLoaHiBswdONu58RmDuP3reymSiMjOCqsLGwaMRxeK1swcMIMOW5cCyXciR64uNQB4OX5TAlZlhw1DJRW1wc1cuqfFyfG1J9zObpL9Quwk05Oo677wljp9tZ5r23NEgSPEveU+Q3k4B2RQHJFWPvJ6+jYBfFzxHpJjXvUEmTjsmKlQvGepo/bJjN8jdRNPIylYYUOvorbhRvaDhwYeS7XNd9bk38sVlvn5rRrh8UJ3DrbBABmq8Z1ZcI3yh/lrtWKk+uaTES+lQlSJ+Ado0QScjEMX2rDYDkl/HgaROs30UgymtRcc7qMnoDd9J5e75Lt3aBi4ONF+Ubtiq5nNAowHYqnll4hCiAkLP6mmY3yGZMEEXdVgel/8yhs+i03hSAuAAhEwBdsUjUwdwbqlgQDrKAkQ6oywRa37/0tVsTMpNufE9AgL+bggDxBh1mPlt2LXNXa1jaFSJRt8LEJd575q8MRSMwypCXwaHl+KuYclZ+xdP2YkmPLYz0eltrwGEdFmiYUlZklCll6vB3O/alpX2U49DXzp0+f9MBEPccQtFKdf0qtTGQaaQ6db3jW+sHNhjXMekvCWRpTzYorJ7zwTyJ9A/+1nbfJ5lStIcJXkigKz4pbPi6vJ98y13kkwDwB/c0jX3/LX6V474lTtWAUKoyMEsMsAf5lEsoCcDtetc+jySZj/rQGvc3KIoPHwqC3wRV9egLGa7Qfr45CTs57pTpzzO2Px7CGvm92+r8rBeJHYQwUKmBdiQBIEiSsAGoYXt51gGwYJl9rf3FdEUfCa99Xlvif5+bZMg5XP+ya5Vcx31lFHKrJDy1aF25l9veWW6o3MfTC6gz8V0OZPPHIxbOun1reRMuoWE2Zfr9Ew8ykG/dnHz7IpeAMpElOD3ogEItf0tZFwxmTb3g2qM3ffMGMaMbYBPMNlWMuQT2uEB9d2NA4XHAs8uhOJ3eo6sTThEGoXPxpz6GFS2GeRmQaaKQFZz7qZZzvZdzh86EHNMCV6cSu/t/AobBURUNW4IttUvIuYjjtrCYMgZhv+wkNtHS49N1zIdL+6jsYdMP0BRG3cy2YihLxgsODrEqgoMt2TIlyMtDae5egP7rnIDHbUqB7uJ7bRZgu+4bkCwga4BQdu8H7231nFY/bn05wAaq2WDH7pMRNV3TzpOlpfiO2UDAvLFlkHwDhavelMnXtYqwHWC/8SILX96Gj2YEVrxfKN04CTaGhFZK0uKgGfgasfrkHvSAcEtz4F5wm/4OqKAZJOvd/gm2TGfdf8q32+yZ0wDU9rA5uTn3ft8t8Be08PHMPfS6fN1m8wrlxoMXuP/U/N/V7laUWZTHeWzJaBk3OlycdIfSTDoGa2m/S+jwpz36Zxe82e3Of18oMki7+gw99M/18ZmrxEZ3QwDzYHeRVPvDGtv5CePbEI9D/8bvKETNw479/FV1jKeGBahIlr4QE76sP+JgH2Q5wW1X+EedgA9OeXBseLSRFV+YOsWbBTOe5HFWqZJYbj1Yc5ESCZXJasz5/bTUY0bf3G0Y14gla+6F9DaN2h60yGD5rLmjgH2pU9wKq3maScfykxU53R/qm3QaVbrm/kqUHYxcY214pqbhBC5xMotp0VJXGrulyzyXTPcsfXQPTLMYx7JHNW4TF45USADOcubXUzYREl/pM0tepbLjBh5y6DFvR+bY2k8sVMFDQMzk9DwFfYZqAzc1wMQC+/1NSCt/LfinotwIOFn6U131YvzZ7A5KbLUoqdhwbHNZJMZEVQxIwmzpLUiH0EHRwjErn2YxYkeghDbuALDn/NMZUtbL4lhTljrSaeVscF7QP+YiLm6FC9y4hM+9BWGm9tyGeY7vUs8VriejdUTwG8K9FT44rLbOJb0XQK/HLmE5D1VeeG6sDKwsAp2pAHbf4RWp50an53I4upO3AStIaGiDg5Gai1fJTRtfvZEWWM4rsaocEablgm8fnbNq7F8SHTBoKAiKJcuJ0bIYBVBN2HDx0b/UOQd9hYfNvDGDucttiVa9JB2seBIFIUY+O9NgGXibVSH3gOZCQSqTAqohNSwi9S0vDMVP1RgS9wLDxWtKV1oZhx+faoQAhALageI79qjXJYhERZ3xTYBKjJFH7V5GXjs4+Ljk/clbxZqJXLURuY6/9NoUBVDzD2VBVbK8dYTJAC5MLJhHuBjwm7fYQDtIjFWwApR8dyf89UVivt8gCHXTQ4ha7qn+TFGHrPZTnZm9Ux/tLFW3zDBHznKTtZLQBpVKm219TuAW5OTjb75/wMvQ0Syo/EQuw1p2lN1g9HxxbPWesqYVg+13Vwmf1lbmfGKm2RUb9oWF1uPP7vxflUM9Y6oAQSAK7HUSJN98KKH2HB1fynoANnRSb/th+YjjXtu8OKTcHJAzfZ4YIHnmE0+87RsmdDO3xDO0EQPZu+YzqhhzgFWeTfaPIDgSjswxe+cEqSNPZmgRHKWamvGefJbR9UfOTdp8Xn9cpTp+z9UQ7uRgVSunTAsSh7/3SQTJK2uhU9HCMXj6jiMq8NzPgD+IOYJJSKJ7xRFebdLTsM2IXW93VPbhZdV2ECcPMu7E40Sg0wiDtzDSwqu4Kus1rZxJ+OP3iA3SR9kNsQCl4rV9XXkPjl4LeVwiI/wQTizLPw3Q4oEzVKg9tVPj82MZiKrigIkHtXFy+0w7NTjIyK/2TGXYWpLgcwcJS/G+sEY3KT+MoKJBvUtLyQ69jQV1d67H9IXIP4GKQOqwMt06ViPpzwMpcEWuhkEK9pAkgXUFbkRZwwW9YcsHymIVeJw5r1bS6WqgvADWPwNil039nce3MEGJSqMJzD8/E0xiymbxtiRxo/tMb5L3QPDM7dd8U8/Sa4uz62It2duVj5ivoUfRwtLUjdFTuQ+pBLv2jE5tkx956b3dFxNpOHzK6L00q4+vZ4MAegIo/ZSXnBXqaJ5oUhMp/WxY6xugt/8TiDEEobrNKa8QrV5sIkm9SBB3vBEoQuWKDQ9t0U3yY4wjKCfKx4w5sAnKrvDeaRTjyGy2hEBK9SuCmY1SRYtX3CMBdQNIVnStDaWNRsvuA7vZZa1zG71kiyIpWhDrtc+l6hi+7p4PxGG/LUFkeK9Z/5crZ0e7y+Sop4VZABLGzx/t6hWyYsOzSpZSMJmSlh3lml9o9ROvONKfZeYs6giPTtRcQ+g0HDkxsZJ8sSl0lMcJcQSdlklSx6WrT1jRqODdqYus1IMj7Z/OQKTPnOeEtd+hl+o0yjAEi1v29WSLlltEz9Oo7FmSEADoNcRQUYAq/maaNp2ZA0YQAFpHhwc3E/lzn/775TTJRg4/D3OB5jzfMn0Fa5RzTqlaZYlP5sMz+zxA92M9LpGECuqrOdUMvcEBwBxix+DUFShrEaUjMVN7xoxE9QfIJTcPS2fs/Pz5DWBOgbofgC7LxwZOeT1npZksKhiPWtaLWzMuhNQyllwETqfukoayQJyquI0n38r3XNvZWSbpTvHm7rbJuOnXV8BPFaorRL1QusiRfxhvmw3jVM90VPu4qs20NzOxsPpdB/BAgZ/48ZAZsFGC5ZHtefwHuSN6qI0FjGFJFHBRbhRnwIaqLbgd5kUNAvYfhngNaSuj/jqzZC+V0XG+O/YyGuw/3InSzwOeJUK/Popxs8w7a9LvYF1xlnEhUHXwBlHFJrPKi/Mha8mgcnBAc4AXldckWoOlFuEega4Cm2VZzldAE1WOwVr17t9tmh11JroyOUFb6unM7aYQFwVbiberUK3MA5fWqbYcBJbIOoIR6l11NrgRrTW/6XeZsGGZBg6yR1lBk6+3hq6obiALnLrBq2L0Q1TzJWXZBpSuCAguoIymU0NrB0i2/wJ6EzVDvpPxItCipGAm2HiaIxvLpu0JtLDCeSOkAI0BMqTqXoc6AYJ3lVwBQFFYIbCeluh0zEBTrtY0W38mqETdZ3a/nApMwd4d7yTxa9UYMNKJQ6YRFRFR+K8yv491ID3mwZkXbmzf04IPjkaz1wyoaEhUYifm1ua8sXrbrVsctqZuRnUrsuIQ5Jc66sXDfelHLpS7h6JB/aPy/zLop/H1ATpCkYcE0escGRInXhi43ec+ydy7mFIjvWJPQeSSkQ0F361hoiMEnnbjth6E+qHyFZDSfHV5RonYL2/NMy7l8JMOcGIYqm7UmPE59qWzmWkAd3vcM9Hd1oJsCPp2iXIBoDIvXQSu/cKRXARX+dHuyYVLVpSh36z5mDUPjTfd3mTF2ZNetT3zc2E0qTDYv0RwNg8CH6jCZ+ftli3QZt4oOy0n7dgCzUxwRYcRPrlYrXNqO071f785C6pACunLlAzLJU/CM1px82/4+LvXVfauyC25ATG+o1EpshYOatUEvepowZ3SYO/FUZBiVAr8K26q0NUNkxAIf6jHrPm8U6tFlL/1oscqM5lbgWzhDg5R4kr7vIdddiTiPp7YJORSEAi9YIHYTm7sA0pHlE/0tganKZKYWegyScWzD3JDxPDtNjM7lRoy4I+Q9Eq3xYhjCopVrd5It+kEy9+HqQwO0c3pgau7rIQY2USV8faATeblA2Zoftkf9d319bmakbxRraMck7A0q9y1giDNN5IIerWDWSqxBNfmEcqjexRlqRrhF7I3JZF5mfDccLSJKtezAKrehd3go4UpPurJV1fuKM3Tv6SYngwc1TrDRCbcAYWWRyxWhEyckMb/cwOz9K4UTPtG8WobVoPF+RMFEbX0baxBCehg6VWoqEZtAKbvHTa3OQaTZH8X4GINPsqrWEaKZAf4wL8fXObkVyZGB8eXeW4NfNEOth/vtT0ahd+9+TD2fa+v/TCaKMLy1x2o5+HC7XpxCedVWZNW40Cx4zTmbkLtk3ptHBhhuDm6XFCFKl3yGdKEeWiEKq0MQN82q4tWxAt314l8zL4yeg2qFZI8d1dDD82AEBf91gJeH2UBoAnClg6T/R3oGzoNFgG1RE1aEc2H+PokXx0VoXTFtSIA2y7dgXqJMT9WWSfPSemPyvJ6VNOEP/PgkmgY1uIIQz/Qy8ypaR+ohmjM6o6iA+Cnp2gCKkcc97ZF6khJKNGXUxK7jrw5Wfx43iVY2GN9ZQCMeDKN23mdRX+6CX2E6AZIN2Pvm+qh/SIA5+tF/4vrwe8nqZbOIov8hBwUiNdAOG9EOxhe4tT3MSmhW/2YpqKJnf8jw+Yba2VS9cfV3zV5J6Ii2EukEIdVn91CM8qTAinR8Z/2KF0IqvgVOUZ5bQDTiBbcPgGOi5IR18yqPMiKIUNXb5euBh5zKZZ9J7mLw60b0XzhtMloXE79GxR0pTEqz8eAoAQa5h0RC0zXactDDmHs+s0x9SFHxiJDXeoJMI8pbLXLuqMI0MEt46LYNSvsYbES4xhO9dCaFLxKPUAp54J5nK/IEe+EM4UVcENp8yR5UcpImwJfyhW8nyQYWkFTIjXfV0Y8qZqzS5SIfVpoPyMn2+WEb0yh4iV1RQsWKYL4Pr0H3TWkOr8c78ELDm3BmgKWFVPKPs+AtGZrLUTwDGc3YT58CF/djFzPsrKWJCmJbQBlIbzHqbLm7PVlV8MIcKMslObtnaDtjSpwvNB5ZjScmC0iMa+4uFNaTWJoOHL2wDQW8otKCikBGh1kklMuaSW/IqFsABALt2Jc+a5mqNnxUKRHJO8TvXAnyn14vDLUPjmwigEwFnMeA/uqakcGJK6skADAftCPXllgBK9V45gzj5LjDyVzpH7sUk6T9RkJTjjuLF8cGrTHQOE21xUHE3CS0M0NB25VzEw4QrJl7hzTQ8FjkxjRdgFD0/JRett6Ef1d5XH2iZCSTnzUKfsqMcshfWxETE3BIWe8yZo4Gc4U9lIj2JsFijcgotTjeWZOEOxenePjK+VKlV9pBQxehOss+gr7RueSuaf4hU4Iyq1VgH+FTb/+2pTVEhA1JrVW4jMNrcEIPkbOjcDHtZSHG31Vu3hunw8Eq88D4zJ0llVICW/pE9c4t514tpuKKjuyeuxV2jJu2086KbsEsWaEX6J88vbh2xO62pi3nRnB+b83BLHzhqGrAcqlplcnK2CrB7wA0nejZWrOu3Wobs2voSXGT4DtwsuszhxQQKoyJmPOHMSN1n4uTTwOM5cUetkMN0WFZ2/yFAQbqwGm7GxzrtitUhrovgkBlsu26BRCDyWil/ZoQR7cWG/jsW7yRPpvLEsS0/zy54wWNLBZV8tOe+pUbwwkU2ldnPA3Al0PjZW17Wb6ZsCG+7FEYd6KUV6Y9VwWy8VyVeVwJACjzDeZlaSzTUeCPdfA+H+eVLNXo4+VMKQq7HY9RQsRo8/7d5jgbOMvb3G57B3TfRGRyNy6OABNUjdF9kujlBX84lMtJHMkbcGS+OYksJzm1A2ASR1joi11kyKE5iqiiJ+dT7j07YQNW6NjFdzbc1+diz7GZ5RTAnH+oYQO2zYMPRnXSS6qt8YuYrnAjMXkhNkSeHjC4B3edAoyMD6HxmxBYHM5lcpkUCk9ZfFyZ4e3/FcoPbPCHeCwitalvvzmMEPzksADMSeNnwhRVvs9TD3TNuaux0AmW7ql/pjJ6j2BvFdum/jX/TVp7M9gCATBwfUrh3vQiSv9qP7/XDzobw/cHsN3/k8ctFRUIZztvedxeqi2mAh4dNfxqLorrWQkjJlCRHayGgMOCNrTxqEQLAaI9F11a2OcJjq1XX3HdKoR4G2n5cnwSoxRLPsyBTjVA1phneXEbYAy0WaRIu03pRikvwTCdJiy3YH6DTs0XvCACkN7cU256l5vh/pvZ8u2RDuBFAaRsT1tvfXJreVP2QRZyFIkUytNKQlOYZQZ1cZKeyQljsuzCdn4QZutxyZsbEwFC0+smZw4g582FOP45eUS9TgLqRm2qQ39DW7zmTnZnm90fF1aM2JFy6dpnMmCsucZreZCdKrH1U7+Dsb0BR+4J0jYlSZMRxIg+ABGViUBXk3QExMppsWHUQqmTS6pqfbVKDYUXaormN9el89iA8XFb9XZEHkMizJYc5ChanoVNTfdbb0kf8PQlj5+HkRHN0Hl9170tp5GvUyPgXOC9Af9EPnsRWmlD9lNjMsQjS3QaOtCxslZZM4G0+eq+Yb1/j+Ta+Tn6N4rEkJ8iXn78t97bo0ZH42PYCfIa1V7qet7ue+sS7afOeHnk7JDktrPrEVb2gvPMnA9YevfqLzksRbknQdimMUwkqSk2nesdtRbVgsO+baPDBjcpQ3qW9+gYcsO8Cu9Q5RQCtD1WA/D+ZIF5+B9ZJ2KTVCXHk/sO8t5xjOvly74XgFQSr13u9cb2RLLfqnhJ2BinG1PLTK7cLw+Fmr65/nhMBAWlCAPH+E8E6sPoyeBAp3OLWb20qXDarK/tH5nRpm/8BsUXd34Vn0o4EIuL98bHj0J5fvkGoUbaucxPkhtYCP8gDun+YrtNu0MhdxkXC6xUHbeYDgmbd3BEO8UxLeuSIq5wJkPpf/mw0SwoEOjLhtS4tZmTWw70LoxS2Dx+MY4voOXuUL0TNrsg0d4LfQ46PuQ2UnHLF43/nG7UjAAX55js3tuWEUi2/gs4scfK5jxmu9u4o+rc9tW0+SezCjJXoavaD7BZO4JngATo+Xc8h4qf0ndA/IeaxR+7yPfAqKqkpVSCr3BEw40tOVUALWPB/NI5yPLu8U4GL/dWLjh5Vr641pV+VrjucjFA5XIxsK8a30anFWE1j25adXjyPWP3Z0nH5j/2y5IoAB+EoqFIFivUZR++KlsvZy0lcbtMJQkK1QuYKij94yO3giiJXeHTOWBN2jmF87TnKY7AlqSn5uVm1mgpAmUsp4w7H+M70fHZkKdonf6hrYCZBUbzuXDEU+9lOM1eWV7bxHIDG3ri8GIX60XMxv1sfQK6QwuxzAjaRtw/e9Q/IgGyYdRr9RXexm/7bovdRQpAlyGNsw4SVm6y6WrqMD9xyHuE9I+3wY/zYcoz5mQijcuc4KDDBlvom+JNPyz/RMtqcm5W2kVC7yZxt9xL7UNEnWloGzaamMRs4F/TUeteO69oIZM5Uy+ExH+ZOLFvDLVIkWyzhqJU9DzAKSGz/Th3UnTPEvOVKA8QMBigkbXvA2E0cqOvmPpoXk/o+NDIQYnwxZa4msPlA99pQ7aNN+QMQzTGSYvZeX10XYrYii3kirzT0wL5B2ID1JGX1BxJNurRhCKocEOA5p4qnyo9VJjtBdfrGhwfllRgXA8OhSRdMltNjM6f0B2qJ2WSk7c8Xb9q1c0EG5Xd4RaG1U0eDD1H63lt4iON1v3Wv8mCZRL0pPWFVu5er+d/LW8gr/kiDUz1gAegPyycIfnAtZowZWPKUQ5jyChAvFbpcrvi+CifxkX+oK9TuE4LIoj/A9mSprrA9wdMDxCYUF9rihK6uaJ4Pblj78DKMJn1uxjLhLZxQmdrGj6Cj8YBNCF+xBkbpcaPXTTJQWEkpIs+5qHUlwMzLGjt02JgFULLh3feexbAgPWLYnQLVUxnA+Tszhz/AN2zP+kWnGapYuKynO9SkYefflPBK6Of6gG94p05ddB4E3kxl43DWjA2riaRwth9ymMtZ3FikMiyynrQvuEY8FHyimbA33xCgquWS48gr5k6ENmQaE3pfSdkji4F28UegVsta+VcD2jNgDqXOHv+4L0K+zDjs2kw20sBfJh64Zs0e8bqP8ltufigu7eXwKEvNNS8ca2HtWXrpu4Zx24VdhqQEFs/lye+6seIpfWuOTJraLneqfgajbKdR6CleOZg/Rs9HJJXbTZ7mb2BD24Gg43jftjfdHBdkOuRCH3XrGrVuimfvP/Z6xlJ1U7vjPeAr0pCKkVt2hhuX5J+pJQcb729FgpUHFuq7X703N3mBpQiXbpaAvcIww5+9MDIN7PaGqbc/zNQ1JvHqlWFL91fgrvWmsH72nBWXtfJjWqgLQel+q5/xW5kd90uK8OeRxC0Gj8PPebtEkt0W1swj8GaCIR4W8t7uwRfnSL37vFTRD4CwvPVC0HJt0XFky785bVUh1DYHemwSDZIWnxCEIe3brVpiGZXa6akdC8Y9I2W9ISjbCa4ru6n/3Xh9B1qHR6eTf0N/Yzr3ORUXb5V7eg/Yo5hLGJl/7WP8T/4g37GMxT8JTXB8lHqOmmsEg3M2hK/9vmKtRglIHi2n4W1MjXMI+Llb8mwV3HZdHZbEJyTUMtYxmhWZ7braSBBaBZojnre38XjKAgHCpGE35tqyZSq+OZpxgopiiIGoqgEgRkiU2tPPUHajl2phPvJmmrk+JHnntzeBF7tXxeeoPs5uP5lZm8/6ICmPmwjytCUnM6hRm2/j25kAREeCn3dZ7zI8fwpHvBh1U3XSZGEBc10v/CrTwzFLwpRiR9t3e9+nqXhh6D6mkz7bygPP+PtwJ23Z+au0OxrJuKXL+J7CG5S63MwT3tD5f0z5gUPXkc6XgMDiLUMIFUxOx4pcL0LG79hx/o4I82utZ7Uq39m7xXGGnkn/whNKLobclw4SV/pK+fDgqZ/WMx7abvIu0GOik04U2OsJlFD/3Ie3rucr9gi+qxUt8QjxEDDIwIpPxtQj/X8OOW8sDVkWo/wVmqqL08RzD5oefYkvKYrnrn2BcYOmhJBW/6L2KNQpD5LbS0u9T3swfH6gCRQbinAlIjtNcmHL3hTwiWJs8FVxU2RHBEq7c6dQ2DXogZYGQLXM1q83zmjxZnYj86JR+PMWxa+nJAYy88YFhKLH3QQTMQNZqrmwSCwbcfxYQnhY/oMRJ0VlXJGluSOYutmWPTvG3QfPcUD70sx4CEDx+aVo0IZoW0MBWsMpPJnjl9La/1BNnD3htbuqyd2b5ZHG2jBOlozlwBAlknHMngNqjuKLuip686rxcDUWzM7auVfcWM4mCEEUOsEyZ44AMMe+mZIvcI0+lGnJPHeu2JBqhnVy+87NyXPDn0rMVmKEIRORUeHFwcR44REhmLTk8Cx9xd2cwEmJRY5Uz8oqmIZJJ89oyTggwnGPOverEMCneW2/RJ96OWTuGhVSM1lOU21BYCsoQp7s/cxjYm5Ui6EXH9YwjADlGYj+jm8ZmyzT4lepEssdxA3AgIDodxPHR4DFY9VYzyrTqZoGl85L+rrCbCoLCYbawH3bELO6s2zHYgmR7CniURKsNLhSgYLoJTjjGKpOQVUlMcZcgeTJckvUDeo56z4BpjlMDTQ7p0FVAgduWtlPVC2F5kttgy5mzXKYUrQqIzCuvczfEXFjXzggruKwjtLh8y7Gn8jNVnm9FuP9Kf9gMDQGjqP9p4RCWlG9HC2yaznSo9TdD3nS2SIb5lh1uKj8rXYhMmsvD+logrI8rNk4EWxwxlqqu/8cUXOmYX/hOasnb4Zs2xzR0qpRmZtgtVlyjRNcxa2fqNjC3kRBO9Un3ls87oUF+DCg/lRRXxLTi3EV2G19V3cc7tsDF6TtQDdnD18bAfnLVEuS8AyPJUF25XK8iccpGangGnrChK9j+TnUU898F60VVifPotuR1k2TjT5PYk8hFft4W7MJoo4JiwZW3Cme9C0iGseD+E+g90hMK4g+8QpriBbt/DbjitXgA8cYi3V5MtDXK6LsXOejDmJAm8r2bouk0P5be9COg+st2fPptEl9k9Rie8aw/2/ESc2F4aKIQg8aQEBybHjP3KTksnBc2xfxd3ySp4JA3QvP47DO4/j1ebxcZBJ4bQjY4LuIfYkS94oKw9RZGgh5NtuTyDOn2tXHpM2qZ6IA/r+M9IGSlksCnKuwaxQWeJSZ3+atlhXnW4x8P36ygzWb4p+QhWSApJ7VFngKWv51KvpVq0VGktEjvFz/nF9nseGxajBsF3QdYtypnXlscLrqfo+sRDBny0mGPUdLSyiunM1xnhNAFB/ppqgE8NGpBdp0YzIhmNIaCJiDKhex0dKzjdXXUaRz5ZVOhG+4aRh02cYIJhT2F4Dh7T4Lu9cu2MGY95dPdWWQUKvxKahZc1A+vruyqkDBPeVr/7zmNhOFhgIdb8P/iMoq3KWWfUeklnMWKucvgec7kqeMhEgZVdOM14vflPSVhK24DLDvzY1lE7rw4/Cly9mMZB8gI3WydUeiAQvHOOM7bHb9P03W6QRGGbViTqk2yxZU8pSKH8HNg4fmpzmgnV1p5pYtqDR+UGBg2boPP0XgmMoqFdyxYwqVtIHSL7OnvpsJaBJoCh7noyvqHLduTVn8oGxqxRnV6IZo7D8GBgNx3VJsf25Fy270/evfHxB7wWVShCqp3nsARJNG+BKQH4D6ImLUuyGoFrpaF23a1Cj/S95kHDiY3h+sMUvenKbVvuOhhxT370oq3cg4/49OanrZ08coXx5T/2Ffe6qbMmoQf+FtxmZbQyjsOr53Ky17fyggqfRAl9SXrfV8FlE4c/Z0BY3Z0MPIhvhLjSGwYYJWRACr7jBkHfnZhdRJW5KENYjUBdH+JOUnVPTDn+tJOBBAbnv8CB92BYCRYs6sSKFmpzIJamHMSz4FOkt++MHFGRSkOVJTUiTloYaDMIdGFw9kECahGRr0JR48oyvL2KXnoeTnxFx0t0PQn8HiNlnLaF9ETtKMyhnJRTJkBQsKSEUcc2FCOJ8SmtzizZxmYICHl2n82B6D6PlbpdO1jBI5xQIV5PpvPMZmmZdtx5vKKMjeUx0dYzP8OR4mZv4r7to2ZQruAK2f+6Uwfyxh8ENd6NrXZsevsSYmZNAwemd8DEeu9Ebdtuzkm+iZNr8kc5B4aT9kf7Et7O1dhmVkDG+zL1KZnHuLoey5dW+rOln1oa/Yqr2S/KLLzO7Q6JjVZ1a5f01Rn2hUSaE8OFsN2IAG4Hipx58FjZjJnjsUZzRGmZHT7V6BmL3ngY1H0MdZhyr7bGyun57OkXKTDL3uUqNcvlieO5LZ6nFXfmRn/1xslJmPHBxFcEFykiJwOxCgdaJ+ugIVnsWAkNV1v+dLt3cp6puJwytAxHHYSmJX1lWc3t8RjG/fv8mE3KhwdgHb0iaCucZLqLuTRvy6Wo1Jn+PUfoeY5PctSLUoXbfxdXAI0L+Dqy1mV/tRnFyVsv6EwjH9mWSAHQ+h2RbfpX7fsR5m+VXweQzU0FMGYI+J4Zzw7ibkzdbte/QZ34eE2fg+HI1z0HxLU+fAbG2JwLPXj2HVEGhnzuY6bvb3/rEh5KHqDG7tPXlVmIDB+M0VGpjSukGDCLtTh0yiBXyoR4p9iFRlrmEuBmqM2Ph7sSGt39suTnncrNkRoRG1d0ImtlhPCyWNfMssL9xWi9zygcaT+wTdW+SM1AwehSVC2jNt3//1ifgyU/ZCXLuwftowYbeeM6e5y3xFNExKsMQfGHhLVuV4kxHm4rKKtYJ4aTszOl5De9/i3Ord5MF8M/AJctnPqsHi77cnYY6nHc8zKo4CIdXmpQv7PbkljfPjsolwAMMJFsGB9dMlLmpR5ryjW/KvMlncJxYreuAdywBdvB2p3QdM+VECvW29EEeoTG7147b0tqtJmNsquKX0Ai2UCH3FRpprWUaWbjRxhaU4W1QmOuF4ggWRG1KYVwxLNPsHzGHBI54DJfQdDuJrhv0ngGWsI0gOkgAb3xq3fpFxv2RRJoNVPVh/Cvw0hXIIbU2FV5k4I9XvGXDc5nksKcg0vFD0mN9EDqt/Q0gXicGJBYpaj6aHU/sFujwtp/fmPgjfag+Z38Ofc8mvBBeO8O5ke0BHbZu3lZxdAPKGlMM9w/dyUUESY9JYr6o2eGeKJjJwybFFLm5r3asnTIb2asCfhSM4A68J6aRrtcxm34M6ClC0Mqy4zrC1DYOk52czSWhqo42vypuievlU1gatb48dD+qo6UFDuybEIUlTRW///w8nJ35QXTpjOkozDQH3SZR0agVHeVliRHJLSVufSLiD0PbxrRKP9FXk5h+ZwQuvXkwzp6XEdIo2zR6LDuPeoQXH+Cjx0RSxxudGkJb9sBNYqIY7Dgq78mWLAoJ1G810isrMe1RgXyPDl6n9gGG6/QjafZ9gJLgvmPjIWsArQHdVRutkjlcSX0bvQO8ePD/JoUjXWIR2A5wEkjJHkqzrfTp67xs+sZ8T2KKyGPIdbbsUrSfl+G54IBb/by8WyYY97kVhUc3rMoJ0GSd3NMvAMLO0cajLSUE+Yp3JJ+f4S5fzqVqKeB+TxBmnAYGQSaFOOi64l0vocatS+y+HctF6tYWEQykRhzEkwWLSR3aiD3itBpIBX+Owq8Xbx9TtNczHvs046Tr2wkg8Ykk3TkYDtVc1UNvf9TP5HLjpogi08KJBDgB1ksTwXerRlkTPfw/0qw6CsE5yyZ+ddBiFokXq9Y8uGjXgqtgNZm0vqdS1B0wL+AwbfwHGkkQ9PMlPDdcfJW1cO9kfpAj8yy++5IBu5hIONUctQR1cGSco4OCyXrdi8nWzBsXhpJXs59bre9nwJQzfHbAnOkyC43jhWsfw+oa6wgbj/6fYgfqmHKtk0jVW/AOeJinUYZNlrqzENeeaVeE6zTJYA1Ib2Fmh7u0s5vvX2hingQQM1nxdVluSuSSsz2PtstIvMlMk8JiSDpDMpw4Uvw0OGhKpi6LhUWZjaMNl737JiHQLNJHu+vKboT8R7iox3/kNYMU50+VM8DsUduX9vxa1EkPQq7XX0kKyyIaqt+1jMRrO06cpnqg7bC1jGR0zuPMTiqjsTOCN/z5DTqrmrbIp3kELW0i7Am2bQUS/shPsbNv30aH9Ykjb6vM926nH5hfe2Ou4elRfGIDaTkEmoQflov0RcpNgS7Q7Tyv7oaLURicR04SrTL/7y6G8QQFxZFp5MPRJ979FUkTlJEzdxIBpWVLKdQiiR/DBzAXSIPPJ5vzIaXLlCXq24iNFOXvQgZhD2/0JtsU8ivu5dDAkYCxFrJ895sNUg94hlLR7DFIyaudukyBHHZFYD5KnB59+d7hg9+dglxxZXZWUeUVkUr8aaxHLd0b7ZRmIdDHjqFJXHA1ewo3yVV7DoH9K7XPUhQUGyv2GaJkb7X9yw/KAs3SPlNqGRpkAwtAEDXk/pFgd0KKHLL5AOI3oVRakSSxmJ/bqsBqfnD+P+kIG3pks5OatoFTw53/NI98cf428luv/OTxu/JmRJ8spMJyafPYUSWbi8D5Zt64kZHhH44e2SlbeOwt/RZgHylk8qVZa8G+6yjTfaUVP71jqWGB/Z9meZ579Ng40/WNcqj6JeuR10ajbR4ZevUNcBt62yq5PcSeCFCrMf+1xl6DDBdoJ7cprHFMnZiQ8CHaOC3uIqqzEFC6V6ET8SJcD15DphOYfYcom6XWySHsTnJIbLrWZpt3E2fnQ/+noS7x+4ki/z/ZchlqcR+FjbiFVHTKXW1SgPp+KJIROkaYm3tk+PZPl+ACxTKMtesWFAx8Tz8+vQp5MbuR8kdOVWCAEac2jVRrffA8mm4L0CC/52j2NoG4Gl7vjhvftU5yjbKIMQIXr8/9qjxxIE9crKbz7Kjfg8/7hY8nBLn7ynrdHueITxhcHkOgDLGNAaATBbxMoDme/cGKwXSABcAVjZe38GHzpgRnjFs6b99fDfJcLzBRJ3mvXXTZXsTsSR4u+/YhtQOvVf4yeOi7RWX/ocrA+jtpFlV2BPyI5JUqLAOYoBrMmvGUIQVTnD6dFmUB+gQdxR6lsnR4DkiGcJ7OhBsbYRxemmk2korKODCseCd7tZHlN5maqZmA+B2ATauC89oMEoFrAkHMQW53RfHOwDh1Og6zrL/A8odT/SKZY25c2JfopYBcxnR9e19LgVmQsn20wz7xah+fQoOaHdarP4WuMRaHW6E7sOKI592ohBKY9IJUIk59lr5EApkozB6rEz36Z8YJMw9IOlwlsqcAwP3AmuKpNT98JFxx1HMWeOr+3q3kbQayY/FHBmnrJexnT8Y99aKePlrQjP7fxX6+Sk7vejPCiE/pSPj6nwo5VvNtC+y3k1/UmdBpwyalcg6jj4XSPkOWO0NSxY56rnGiBR4bx5/cr6/V0PWPLy4tpMrtjrJPdP2PJhfzrMhUGmihKwHRgW2rHiSAyR+ed+k95/2ngnI5hqyxfLby1NnFpLtCUpff8K/X3Nem+D5Lr5EEHxGDeSYI2aaht521S/SkY0e67pGivRkEZJS2UwC75AZ1cZokY1gbhc5SjdODD4Fjf+phaP+BKwjM3b6CZVK/IwXzbFcpuqI2hLmujPTtsPE+5WbeSxyelqClPDxhPsEwRHbiuCYMHxy8SO8ECjA12rtmQIf/B61rHMpfem5WwbenqatzHUC1pI4h/aX6NBPuWWAsAuM/pUztlD+AEFTVwwou1fpDWsklS3eO2FxjqJYQTsDCUuQOVXQ4JE6d0+0I86IhWt4GuXDEJE6JzfpDrdreCYssKs7aWnC9XKQ3Hf+ScPiouthNpSoBPDudnEbHJyCywE6nxcyzmN55C7GSmKv0DtjZnnKwV80C5eIUbbhYwnOD4Ep6uVhlX+16TjlKgoB3CAVj5eKSprU/DPdz2cYRrWIenpmuuPlDvd9fC8oJ1CfmIfHZo+sdbRi8/uQmWtddpyvj5CHM3WcnQSnl17jP90HV1TwHWWyiYpNXda5sn29l3cAgAX1a5yzmAFhd67FSa/lGGwgfmLjBDLIyE5Cgby6tkOa76Crhbi0LkFOzVjw4oVdx7yUH5+glkLTzrihk2tLv0xzUt970PdEFAuAxIqn5wN/KIPL4Rmf8Zz6eDXcUKvE32lIEcHhR9MbVWercxbmOZ279rWugwMxcet2I8/+8gyR/EA4OfKj57Uq2wwKxzXybTJ0ZXKDg5BTFITK60KgrF+2dbgq9G0A3d2JnYakV8kNI6rZdwSElNhO4DXyYyEDoNbwzVbHOorAWdkRfddUtugKsDJmsrZOndZTOMY1NEY9klwz3xqJDiercKHvw45D22MnR9vU+l4LVK6CHGQiYUDPtaegm6HszWangfwWddiUc6oICJOdLxM5ySDGkg7R0q6C1Tdoq/qTiw3QZyEJOu0U1RXewI9KWwirAv3jUnEm98/Q9fXw6GMuZxXPVztatAQUjWblkqEfqQ+J9GNGE7CvXpevuLqCNIZg2tX1FJwyckZS3U9rhZDPhXkpQQIRKwk1vBu89rtEaIrHgE+tE2xM5WnJxKb3NW2lTej0Fh0BwndpZVsQgSKql4/AzqZb8TOtniUhohB0T49uso5YxjKBGpx5xMJKWf5yCBsMKuEh6/BXG2MRpNPt1luDmmCYVkdykO/rK1Vsyk260bTXbWregNogvwiTLzwSGqj2F3BBxAgqosdvT+isR/HvoY+UjoLxqds7sBNjG562mx4GNs2jSZEmJslLC1fsCN6CoUaICufMfZVtGqLyEJ7FBtwLKYgyXBSztTMFkRUnMm2wHx72T1GGzmAASB6OWBI8Q79oK26B19K2q5k0bTLTPTzeZrTmxLVe3VUOob9+ZoZK4qgSpfqK3NoE7EkMwBPMwMYIF+QFJH0YVMifYy3WaZ9syWs+henSbH83fskP7VrPHR8SrMcghQYaEygfm3NByVZc/KhjOMBQpCDevg2w9Eg54Pbm7hXtPAyN4BQXP9rnDR6z15hQFrKJkYaKqGrhv0xPdKQ+pDPaQpN4lxqZ72x51ZdTkTaKb/OmEyOHY2SaW1lY6AsKFBKZBZbra8gyfZgfCDNrY4hs1/KIYuzm9hbGMSJulJhDKlSZvGqpJ/5iYUS+ejIktlaMQPkN02ChkwT50hiaGUf5p/WLyX7HD6sU8RW4jYOz2ABcTLNn+x9E1zxz9PLmfZYVK7gVm2YXemv3ERQSKlUD9xjbz2wLzX8rFCYsBAWBIzLGQBtVbfjsBwgDeUdDrkm1sOnPokOlht0EHXWLshtt2cPAfxNuiF73qbGvl4vXpmg42xzkBcPVpOXPSiDx/UI9Dp1nTioQDLIcdEG5JK92xHUQgz7TGsmq2zBa40S3UrWlqJNbRRjZt/rWcG2tKNH8vZINIBdFi83hiMxFBFY6PVaolQpBbyF6cpRltAAOt5ThL1makPzD5TdUC+l1Ehuu0RtWgDDWnbknu22rrpKcENQd26eb5aWTPaJcguGRkEfgHardK/m3as8jCVQrFTtzBSsI/E+ZvrTQc2X8cIv4OzHYTe9XaKLrO7ZNDJ8vuYlTWx2fCIWCF2IVmopY18aQpdRglH0vLvSmYqwqk7GpT1RClt8/1F3f+XvH0hh5VUDysek+GV9aJRpaEyQiMC5z5AvLCrLgjxdeB9WJyfJQOlTm9gR6qmI7XMM0+pFonBxK4EY5QNK35UgA/79iu8SWZplEhWYLZwlehWABW/zwUNmpf6VRyHbFK9b9E2v8gcVS4+GVJ1X3jbHlwTMLV2JCMwkcoi+K5X9nbbNCJqovS2dtcgdQybTPs/Sh2P5ktZR9W6YPqbwscTKrjn9W97VR5op4IO9i+sKKyn8cCLuFZKacL1CMCigLeCrk38USwOukImDk5QUTSHup0x5I6YYCzV/HepdHh0lAtmYgg56ncQ183c5BaETWeNnQlr/lk0we6Gd7v/l4XlOj3wr9c4Prd8j9eqL+N/hiUcL34n6PIDgD5B7itGnqigIZLF4UE4IuqjHCzAZBPD5juhCv7tghjqwOlO28sZIT1Ekwxf3jP8RsPIDLh/9ec34POhm6OuwzwHpeVZmfjaXaVbs+orf2dt/yCW9TFvUtbdRMnkK7RLjx4FJZfraH9BWsW2vGts6qnW3pq0bc9wol3eX/mgSbMttH3stpcLlJRGcwXeBUkug7z0vaxzH/Py7iNn+/r3G2oKETwx+zHtR4pe+evTFyWndY23WBQqL/d1mjTy4F8u/K/Db3LpOdgS9HOW3UXgGX/ESNUyd24vSx6kKC7nX5EocGj196I//Psg33pE0rog0Om0iEbjaOsBzas7MxLwaWCDSVuQYiczvuzxyjAfYNTbDuGuPEv145EmSyGRxQU4b9qww07kkUeEdmFxF5sNAxdvmlSGswOOMB1Qv0aVlWgCJmzLGcZ8jxrPb7joJIOVfydlfyZiV3hAi5EG0ZFHdIpydqjSDEFnD8E8EbeR6kvnzirGywwjju1H1jybqtmUJd79NxQbW5a2+wX+Juq13E2aa7HolbPDOm5SIk5QRfuATdydPGQYmhIAKwkEsumna+ub0qn1Fkz+Rd0AW7n7z/T2fOvzRIYOuXFTn/RCnGxeIo+/90sY1vdKk3ifMVRAAZUmGK16D4ch5GD3/iz9Ycuj50DshNILUVxDvVRhTm2gSAbdpDTAM+nx8rwdz5b8cyxtV6I0qwAGIQEkmiAVnLuGcirSZ2OM9vBWsxwcKjN7+xB7VBW8Q3Cwtp3UTw5/bbF3784V16OGtn+cWu3KnTrbrAQc8wvSdbg82Cix+5JOiGeEJWq1n3K9zISmw/SW9Y+PiPAYLSeV2uM4QceGh6oCsOy32To+2NL7WiSS9VYslPRjbd1sL/ymXqQ/kBxhkNGQBCjjWinXGtXfdZsbh/aSqLAq69vGk+RhwOWuxnHD9QZkJGIs2/6wUJrgAMnzbwU0Swhmdfvru20JAmeVI/ZT3Z+y/+FHMpqQg2zMpVlvmYKsC9cR+aePXdlNiPoWp5dJ6MW4AxBZpsA5lkCI4ZzFfB9KyLQDS7+Bou08I0htznuBtgkRtBMmkyQPy6DuGZiyY34gNo7SP5mOw4zchB9dPoMpovtIr1xakLdJeimNf5x+J30JyyQZMAWQj89zyeEAMGiTXh6sZQBAXdd+C6sO89AjowkLZWTAskyeY8tBWRlEdYdx8xkmFinIAqp97eSUzm8+kKeq6Q7Ofw/fo/qrNBoHvbAbrVv6xNitsrtr89JKZjeiOIcR9PbLNt7qBoeoFnBapqXsOsrA36jnvDCYkoZK4RTfAhvAJAZ24AOI7tPmhEN7QR6b3C8oRrNIFHd2zR7uVvw8dUMj8rQmEd04avFEt4+/5FNQxOlNOBE2eWR5c74HEY3MheetGUE8MEstFSLpH2b49spurqbiKg6RFunG8htJNNeg1mgXflxe1YCbBDkRyfdJvwa3jaonKphdz55kOnBOE8AKoNSk0dKK6hu8hLClKajBMDV1BKAhVUF8iZ7c4Mty3rfckZrJSpIeOEDjgzK0Hr1RQc12CssIx6zhCR/vJufYqE5WPo0SJdWD3YRPXTYovw8Jm2rMArhGz0ymw0qxyQZSTBVDihsT/vI2e7HZRj4om80Qt3ZT9kNCBPVLa3qggzSGka/EXLNRmZy7brQINs0r2xFUHDBcsY0d5P2qTwNo68kXLlAXZxvEBGERiGyg5jpAOwzSAU8KPnj7JYB4Mh8Io0DvCUF8iNrCAPZlzQWVfgg0RFiD9b7YCuqql+sn70VqZPtcrxgSBzBAKnX/EWyMX3/DqEjpIzlgaCy+AFKWrffz1StJRQVGEPv4c2jfGEh9kO0pHZSFUlE2O95r7KPqiR1sFvqbRY83HKWkGkxpjuwOArR4SWscAiQvMBwpNMV48mwYeyyK154YBORsZMUN/feq+qUocjZJOnemK/4qTbtvC+WhLzNeRohl9Vw4AJ59J5ZFgE91irqvHygP7hd52Jx718mhNWzuVL6Qq2PbvzAIvEA/5lcr2HfxNvvzzW74Raf6gQRKO1360zAgK6SU9agwLcXe79rfo2rEs+KM6/oVjupxpcQO7G57VyFM04ogs23V+cbiZS/J3muLPDTyqwGK1dK4XsZ516sOg6XAwETULM4QFW62oRDWyHNfhiEPqG8L+YX4+KfhOxwaw2X7cx/lEki5ivhp3TgnCyu4QBFn+HEH7vZ8gIRVM8aQeBFpwjY7brL9tgrNI4xm/NzoQa60hpQmg4lm9Bs/YtYNxgticcDcvFJlHBljipKxtVeWx9oECiTfNHLxnI6KXBcxVOmywiXzKHI80U0LCRje3KxACtVlkz0L7j0tAmkUyAdF5lNizlUNZx5qEdYxuPdPywuieqWwaR6YJ4EIl7oh8hh33ISyk4oWJyNpS7f/fW3KYGIZjXySKBq3sWAd1MXKNVaeJf3OLk1z6rF7BCGi4KQrWwGd/RgUJwmnUwxqCwg2Vir1KqdoeFYyKTPLVt0+krQvtPlsZ2S/zKmJy4X4prw3i3FPoX0fB6wsUQQ4PzoqZqXmQmSvy+D7KXqMXNBMi5M8lX5xDpzyGATeiks7U3JuueIc79KyCoEg6vz7TCC8zGmDUHTITcybu18dmuyRGVG/Rk7ILRsVOHjg9T3qIfk3uvW/iK+HqyMTC2Hmp/VEMYDO3h4ulx2eacDfF1IfuzgjgfMxlNB3QyVna1CnRibji7qB4g5vbRT4ISsWfOWTbJk6A5nPive8S3TrtyQYn31FHZTT0f6NavBCPK6oQp3W2yG/cEKuCMMDqxYKH73M12b10yOOt38E5ogVxZWleSLl/dvEfY6ZYwtisWFOZpSO0YkgOvgn4aKxFWhvHt15EaFE//rXlK/5HtgH9jzgKWU4cHDsUnR6sT1KAeDqj0pA7UlXw7l8Yz/WIlQo7mlaFF66x8MaYN35XBsBGkzLzienvVhE0hrbp+MW5nh6fWtvNfiPJ7ooDYRhd7AZQMaA+nlbX7O4ClfXLJAba1hhrzQvjXsztcrthitlzVbdrdWxzwQZ7AbPk5YJy70AJirkek4gEHBMV83kqAeX3FS+KPzd9MKBVGiNXkBX1Kpk6f+S9i4L54nu/KYPyTTde/g2KmKnl1B3pL8mad9DrrIOljJsNGXexrjSke62SRfc10WGHMbi2JRm4rPIxKU54kJ21vf4ZkidvbUVLwYdEBMIjH5oXWc73RCSmAKYCnkoKN5+Lzew6S59V0yr/ulvu7qr0k1wPSM18AUMdsIWX82wvwlUhhZ0SWWS5QbMkL7e5S4yp1hEyHuMDc0C2CEDDxJwN6Bl3/ukbdL+ecbrL7o65PcgGjpLsUDk5jlHzpWxA6qCri3c40cIVUYD/C9bGbUMTf8PqWBkXFmPdiQRvlZtiOjNQKDkXKV0PEqRl+g/GsbmznR0Kpz8XpXAN/4j7Ct/CdHOjqHyrDtIki7OmgG2eJ7BZKBs/qMPIe15p+udoTm8W/jN++YnU0xdGkAAuCrtEfG6sNrqdEGpNrbwlVY3Ltz1JjTD64scmSYMz8nkKWcpEZZYWpmJEbEc6bAvAFQapLj6enOyzJMd6VllLZP4MyM952TnArDl1esBZD93p4g1d5Q/sarL1fdpXjIbtKZ0ikwjvmlA/yKhAWZbVeJg3pCRRDwBWzOp8+2uGN44jnf7qVPrUDLHg0KCsENF7Vq3hLTsc2v8Blbv19CRWVD55F2nv/6jrQp2eMivHOi0SCfQ71PtUnT+7ADWHt+GtY51OftKw9XV2eyJ25U3DMF+UkyQb4Ds7R8OGKEfxh6T2VBaEmbmnU8HYvv+yt742MlUxmKPV2z79/x9LM96CwKkg2trSiLbnp8+Evwwb/EncjXQinNkWS6WC8i19ucuAqJa2wGYVbx92RoRDOQcDt+Cz3CMwnUiJ13q94dxOa2RLQZgGh4WPSEVyHnaAtxkvp6mfcOrAsZDx78OljgqPsW9GeAhubwqhlXUCH2eN/BI04BaHg5VeFBAQ3niPAM2pW4Nrq1ia6vdmTg5ayXjKL+VQy2Eb3Fnq/S5e9AjbHhILrgLGTJ9dBVVmxNW12OpVdBE/9O3Ve2uipg87utFT9gMgQ0ngPWfYgUdAglI3oGVWHG4P1Y8qO7jHncLFpffXY5tG183gvDVd0M02RSs3jNzBCUGsD93Y1Dz7dJMnklQezuRwMWaWGkipqSnAeU6uoDggW/6J1QpSzAlizoklvuHRlXQzpRGHWEYLrHawvZItbvpL6GZqMYvNlvZ5AVgrSWHXNWiW5OK1uhj+dC8qyFmtxXCt9MgSzR8OEeXO6vXOg/vHarVEgoJsFJiWStHmQt62c/ojSaVVtpbcD4+quzMrDqbg/Hol3GEwUzLYGdKUeQ25v5GnxwvACEOiHkWPJ/3w/d1ZoujBrN3c/V+tEwf/DtTVK6RSioX1n2fCBMKrFmGKQfGFI0WKErVPVDCu+P89DjZrj49mX6E2qkUsd/WKOjSdTTkCc+DfTZr+4b4hsVbUVEDS+vL1i7rCNhu/tcH/8g9uXomXapBrS+4pmQWNyaowJVhSqGcvy+Ge+p/RNERTUOJqsV9sZ1rFdY96GjclJv+/l3jd6g+R89YvlZgyx12dvZ4wRcYEEqp4IGBQp9f0e79vxgzjeU5oLGLqyUZ8TR31Ts89TMUkU6RouIdZq1YvQWUH+IPZGPuY7pDTDW2M2mTc/UFsJQPpDM6ZnSQ2zTdjDf0JmdlZT64OSEo50QQwAssMxhP7ZdlmwkeEy3ADcWzaIJMNbqT/IrA0YMh4xgdDjTOcT2tQ5gw1m9ZmtbdtGpxk2jBaNGEH9BxzG5oJCHIKFPbF9q/qW8VpTnQ4c666jY3FQawYlcuhnhFBJdMqoZRtDHFl6EnkwSH9JZoevHVeBjf7U63530VISA/1NEnCE0H39OHinpvYGSun66caxiG/Wba6OVihoswA5K6Fnqr/8CAcMYVHfK6ImpHUOaP/AmZfVskJxxb5d8sTeB6QFB77saT6FeGsg87CViJVveCiRPUsfi2c9J3iLY+42E6CM0slrnNpXO9crSiH+SuPZJYQjmSwSYfkgp3aZw/QLAdUi7vc0LTIxtU510YXCJ/kkW5qv3Fq1uRrhahdzaTrgDC330mkGaidcWFpzx/AE+hlSyyfQSuEMgvhQnae9Bje4aewtTCRXhf7RQJT3mIRZ37VXLhi3cswPLrkncnQde9+3BmB1xltbUhUrlCS9Sk4NRzPMxfybPHWNduP2tzm9MUthacmB6FLknHKT2fzG3oMFwR5Iv3iJaDYtmMMEWJIlwEPZrSPFEFjcickSYf+t0VpFeBIuz4FVvHFkKl6txUJaDHa3oF4U3hMvl1bOdS6d2+qdHriUiNJ3wMgJgxe6hIQ46YW1c4PzKMMVA0xk7V19EISsxLKQ0i8X40p8UDnmCHRwx4BBkXKHNvQDRpAxd2tv9WIT7Y7QZLAeqKNXNFeaKElIxzjJ0TU61tISUTXdxmcKklRTySwoDL1Ax+GHSyxgiWLvhJWt6iY5MAvDw0kWRjq75qd/rxY9je0mnI7vd0IYv7rUufuipb+RWsdqy75nTleAc3cQ4uvPFILMdw5MWdck8Gh0dpMW2bw3l2ptwvfhITWq99Or2Kl0rwV4COV8IwEcVT+g03yBNIPsG/vWC6fNYVg4/KSeguurrVpR54tMzHskSe5opTZ1kwVj5cJIQmQHfgAKVnxsIjTGgEVTQSXIkFI/DAvbcQFtzXn0qomB4XGYbMlFo08AlOe1eqBtY7KwViZh9+RfJ3uznbiY4d/kjItq9MXJRpBYQkyM+OSKjIu08ihiwJw/0a6t4KY8T24yDRmluWAT0z82grlwK3fuuYPVkKCCVY8RmcTmvNEdHhoqQTnw5lHyVFxK40SErOHCrtO2s6PGuDb13pckQJY2cJ5u0gDwPARThEIK0XKNSNH6ApTyHelqnABZTjDxpH5sl9x+/2LbY9QDUktaKhpBOpHmQfxHusZ/chHzKuynfqwl80mehKGeJpWeebfL1td88IfdUYoC10dw7N7Xs2Z3ThgOcIHJ6FN/df+SLmjI8n+WrhpbCbGanOyNYXD4aXAs6/8OTBPOLiR1LfS0fGpizgv7LOCMy9OFrsNUXCm2Ko0KZ2jslnT9yBPVINsXxdsMZ87Zt9qrgKF4I3yXD4CQPJvWuEs0MA2gz+H7f7wrvPeUHE1+4KqJq0aICJCP9tmtZCqhRT48SshWb/ZoZuW2H1gMnr2h8Q7U0++rvP5JEFxFfTCk48Ka5B/QI8WKELiDT8wk3duKNY6Ast5Lq27bR/R3qr8iCbzDQ6Cj/lgAWcqPcgexV88A3om2WxeyP60aZZGeLSeRKo84m/muHFezv6Pd67UXjI5PyH/avZQjp0bG0GAWZ9nZ/FDisrhjPUrtoGzAtLowwfmM4ZyFWxV/jjJ8YGBwZVJwypMdoTT84hN5lmyZuSuv1pw5yFv7sWFmSRH6zOzjZTgor/RUfZlKGVInj0/kya6fk8v482L6tS12IrY2MR7GTgtsnH/MHMF+fJJk5BpLdbvNwi/0xBZ/+7gOoPYLOyJT2yFvAewoBApubJz7qUFNYweQeFNxaey8x5BouAaeVf7/68e5cTRW9T26axIi8ruwyC7IuY+JwZbWfNICehSisDmbDGXyucTcD+zM3ESGTh7o51fLOnqxPj9SekUGNYQ9nRqA6JLqSXC0iwykgIpPl2x821mgdmp6JtauOHg/mMaRB0IM1H41knVDP/IQZARTJdpLangpozlRnJXwmGuVqKUw3iMgX6IIwvuvy7QyCsuJ9AyPhzo2+efRHEqM87ulhpNAzSV52FqOnfIlv6od8qhHqVvRxezDVtaj0CSvcNpB9IO3/2MvkHP5O/uhR53mKoGmFilAerHEvZuEwoOQ88hFBQtgjiUj/e1NMz41mdH/BqtoGzknX9+cxpH6jCvjm28jzBaOOLt/tgzloKdK+wH0VbABw5l6LEbQZ8ECYnfOTS4pMhc84mdJGONYTKfqPUvCAdC5Nqy3Rr/iWkKyRuhKrXh8dodkoLj4tHvPVLydiQpmtRq95uTke/ribS4LvqcZyWGLM9OmXSB2DaKdKQFGgaBpatxdpbVvkGOlJUqaXojQg4SGjMXzzdN0rbjajO/8s+3NniGNPx6L9vR9UHwOgKCTC78HtUjBekpXM5oC4xypW+aEwD4GrGcvzQkpD90Yql0eh7LM03ltwxbLeP3pL65cXbIh6gzxG/IWwrZj3lZbWWjX5TP0cRUqqR0EkA0juTISNX7GADqEDS84WfdB9Sfk1Q5f5jOgq4pktzkhOdcxYdJH0OzrO/z63g73jfv7w+/U4XiBN+YhsqZLFRBh5QtAYCZEwV0bXTNYzINbiC0nY0QzIMMb+6veaMfypCFCAZEub4gKrBE9oYmf9mvEJqNyRr5+RjNFH1/DWnnkRwhFkjrv7DzWCV6YbAFYZc0c/KdijEx0OjAp6zFf99iJiCcz14tscf9C6dEIKxoZfBnj46udXuI/rT1o3TW5/3IaHWVAKb0u/FeQ/HoifYXw3DTP6+mHhoULdn2i04/fsGATVqUcI3YsEz6NGADgVm8PUYXaeKVnztRqoGWYV/f9Z2VBn9ns51cf6CEA8fVOcQ/pl3/U8+Oy41UrqXKPFchuOi5C0Wj2Gx/4KNY0AQ9MVnMfqL4DXXAY1Ve6f+qig9FApGE/rgBCnBnKxCChk3d/WIMoudTNWVxLY63aDRlrFedV4QHyEC2qwKjmUGmoQrlvxDI3+V64U7yZRWC3h4YQdxNFr6M3vn9qB1xodvDeTV8x8egUUUMq6A2oFHMBXu5WgBDLMZFfKWYJk9CAthZyJcxjiR7gsJyr5c04cpxsjcxbJv+7nVovVedpt86yglhuBGGK1zQBgafq+Dn0xdz0Jjr4UckYsc2BZoagr0BPx2iQJX2bDqC9xfb9u6+W6BnG1t3rThWG5k5165sfGdB6bKF/rtEDQLScT/wdEg+9HLUonf+IitgEy3aSkscdf8DiO2PrPYAVBIwt0DoHsW8iKIs5frO1XpTRSchfSoHueQ12i/kz/+dMS63nQxwcIB1s8yi0Np9peEX5YAH9KFRRIcahKzVCWDHT2qN9ddTQJhRZ/woPCv+fk4hHqcGLGrn9uACUub1tCPejmsRLxLj0Tgn03UPkuzVIjF8XIZj+agAuQyq1eRcdmDtMdhymqXe1JETI3ewMUkY54VM/eYdk7luivPKhh8NKSJntSJgLCTEBifmc7kwPPfMO8AJaUU1k9BOVsdL1UuSciDDiHhsUwSD+AFfVh9TgKPghqDW6H7yhnIzYxn5rCrD7s1f10BSgCJAH/nLwiqyH1IMqabbu/xZdssgZSUjIgcvNoD2L4eUSaiPhE8EFACFSnAmhIfVa9jybtSsdbLAJvBR2Wqs4kw+GkMroDlYNzGMN4BJ6RgSVRnNgDzU9Wg42m/VtEOVul87cFfwHrNSTKxvwFgJcJIbbFTzD5WeJIzym2WAG67erHGMUG5YGmFd4ulboNOLo/rzqDBsYMVDzza3i0roSD1De5XdqJy02WjGZVbvGYy43SiTUfVJ9gSB/Mrp8Zf6DYTh59z3NBTNMjtYP0pG/C1aFnI9mTgdJollQV0Ui5DNKKAIHuFwlj2T8U1fSzVIx4POyeu4yiJPQ8ZeqO3K9Dq4yVklyd6aASGYtOsUHeADdqLknCzfH0A5iyRLAOeftb7Pn9YKavxvo17cjEj/Z7dGTSRKeLhZd4sVJcxtf2ZeFtvTRI00bRlfkyNt6DPokNB/I7+B3fvQE4vzMXuT9xhURIEAuEOLOs9TeFFlFE1T+3YZbu2hkjz1dhO4SQXd0yks/BBMj7llqp+VLSNC2dPoZ+AG+rDsFWUmHXRgqZ7CGJ3ia+C0QwFvskw4LneI/qt+lYxgRMh83vLmaB/yTeMVfquUlNa/NS1rbo5isFH+JTWtLJfw6GjXWL1ztG8dElStsKqUIBfBhTvTcYTrLsDzOWQZ+PpfR3Ip94v+sBnpdpWuZqeQGMK49exrBu6CFauWoUAtHa+H05dJGHfreAoUHYpDwf2q1lFlHZym/12d06Bxp+WwBxUwdu7XU5TacuY/eAaQpwxz1gI6XR2LTJaJdNRYHZc1tTDY/PZM3gl5OZvfr6MfZiQVP+sZ70sByQbNGtW2n8ETgwepRLx6MlbfTcSqgEiU+Y0wakqtpLfOs138OdWWW9tFcD1CxFMWilC5gf/owVq4cShEpl2wvtDt5quDUoyYR0/+2AaxsN7VJD/pSTDaKit0uA50UmAKluEBW5A2N/2CAvptnjv4st6rHn97ETo7yyP2JKaBw2Fz0hMe0dFx7kSIurIYlC1wk/SjwJo3DmkNvUlIn8CAo9E6g3yk4qdxr/KPejluTtqXBEfd5txK78BAQre7ZcQ9LoOMAFNl7wsctt8yFoDlejyH+L4Bi7d5x/ZG7vRJ60JlcSYfYq3HhnKUCZfCe6LAQIGSvzllnznoK22CHP9TtIRXyKTX1Bi9vwKnI0p3EG9ZbD79ZDF9y58Mu4WkVsmYZ9mAPaKLDq1yIIO1T8mqk5d5JVOya5T7f7QU6BkGDDgEUCMGE6DIHl4Ty6fSqFdrRvWyZ01QYJAFzozaOLg1Y4NEO/7H0qGsJsHfhTe++z7JPHLlK5i+Ir3nVCHCis7niojjcjVtZvnKOcE6A2UIvT5QZOP+PlXZ9GuNKhsaJ3RFm2wEObq51CyCTicFhjDqzkisjIE2F1l95b9B5NAmCsfqEjt0UgLSFXO4xV/F4TatuNwi9xJbOlMdEku2ZtW6NC+5HsCKH9BPR1kJEMzA2gCQcDBqQcZL/mJvWZd6bf+9+YrlY3lTWgp60Fe5/ySQ7lVJN9y2OCUmR6ATZ/0hl8/nfSC2RbtFO6k8DV2U54mk6j00VDmheG2VJKHVjuhJjpdBIRWKajHfvK3VqMEDShap9VQicy1i6NQWLwpPS2zXGPbMwNWxpbuFx/yLXt7BzPOk+3gK/RG4XEWWt1xI82gLxjKBh/v32kbbFSqzZ+tbDiO2S+6u5hehfyi+uzhoMtDwyvPgG3iDRAsCKYHrc8LfqU9ZbMHEl3JWXGAy/ihgDUGSNui6baT3Homiv2mfuCi4xCpOXzhrL7rl+80L4iQxHMC6kwxSG04DwbFGTUEqjXAvV6iRRw1QI/G7ma8h7P98XebcOxOiVzDN6P4ICdUsJhDjqfUKNzDrf5OgqtZuBoxRlQutj0RzfrtSHCfbXM37ZwgDg1RBxCzFG4QLc3asnR62qIjVVGTqf2/YtpTHEq6A3KteAYrUqEEQBdIwfcIwXlDMDswzwyKU4U0t6RDD8itSEUdWoOnSnT8+thfynT4y6u4pVuK8Cqz6Cb74uRaaVBvjrrDQVaRzEq5aaGvcog9tFwHBOeDcB5aFodZx2CA5kJcxUxAXASl/kvUjl/UwYLgXX3JgxgdIU70fSDTxINlokh/ygK9ZPFncs/JAdg2iKTT05xxgj1Og1GKWx9q7TM4C1vp7s9jtb7iznTj/IouxvKuBDokegKw2u1CnGkpmRgTnBzMwjrtkm/bbax6rqLz9b2fQPpavscqXcNer0AzxNYH3JaYaEnMBGWcTi3TUCAHx4GCg4IZ6F9FvelpWUKYVySdF7v0dk5owIH+5EZ9rOwjuFOf+TkmkGmObMSlzOSuuozIzN3k9uQPryfJbCeXZHwSicrpb0OXEPOX78huE2LfEgDX02r1duLAd/aCCoCcbW2gV7JF3C+NUoIJTwqQAWVQEcyVEKJi4e9nmmXqu2SscXTRW0oFqHrRAYWKotlEO2+PxnCHpbKwOKZ/kkbXdpAFC00ff8B51wCkHcW7Rq1GZ/PA3FCM99RyaKHZtzh8m3UcmiUqztu5n/4ap3CPpr4wMP7s/vvPluap477t663MjMrhnhN5vNpyhUjYEWkRrHPa3vGBGYe5ZEAXVUss0oNQSBEUk78wU5VbaOExy7O2/g1kA+L1BK8OeANWpVIv0l+mFGN0wlj68mgFJnMQ3G+y+1ntXs6Hg7XW++81tHusU1wNfYIOWWPSuSIOOoMQM2zEMyZwlcl4+47f1QZsY2yWPSKg6Frbto1mniu6b4PUg70mAtX/qvLC4EE5yROKt07TWzPI4ykehVuqNF9Agk44SOo3sk/KXO4UcJnWvsje4zMrESoCX4IDi/YgFZxoHYZanN/ziqppPQ6z5/tplS9A4+GY8V8Cmgtz63PLWo3iELPmsYe293WgNEg2t+jMSdgSPlFsIRJmL3G1BhOgNTvqzWuDhi4t7YehiH68coFZDDk4AVYiGS57i44AIVzQef2b/zp4WeI2G0gyuimMdEaeUO2Srp4mP2PavYdWt/E+yx0fhiys62FOErZMYejM4e2Zr+9AfhwONnWO84hPinK0SCbJxKKeqtZuJX0xYv0DVIktPLz1I3F8IMxIpQ/zX5K/a8PIW8T7dU9/NtKiRK44eD7W61xa9uP7sPek4+OyoYoURXqEa6LotM91K0ONk15oNN8TsD6LfSWGKMrm25WbZcN4NHeIkxx+la5ZwjBZ0HvFsicx+mkoHVcUwuVmkvVIwzgSEfRhYOfmWKEXjKvJslw/WVQpBNGaU0RG+r6dXsNj1doPrrFfhqA9EohnmH+fg5Srg2u3lzI8ZtrDmYtoj7l1252EdQ9xMScP17J7MkZAgwP3xhyyIraOQnhvJh0dIaRMQ3sTqc2H/dtC1ou5ukqh1g2OaH0PCkFw00NMDVCWGanfy+Q2TzWVgqm1jiUB9KJT7lMCn8Gvvto/2G/KYlWEkXL551sOsEphFj9meRIQyF7Y1qJgxPwhOkyglfn2XvrmZtbxEjbc4bPYBSPZXmDWud6yjaq5HPoT89x42r5/7BdLNQs4ocTLLT8ONxj6+oB8cj3lntcDuQCr5RaBsk6ObAXp0EZZtpDmufDKjOt+2H0F4kVlKlilRt5ZJGUEERaJthaY6NYQbfcpyRpB7HUk5kaU0r/Cy1tLF8PG0xgtaEgugeFeJa/jP9fAnBQmzrMYFUynaLkei1GMglncVwnCa8djW0PdmfWZ0OhVLCUKQA4i3TMkh5B33dKJ4dvvbM6EsGPnVXaJutgBckVRVw2xjo6/wZHAdwWWRTe/sQmI8WHIBVoigC28Lb7slvsV7vDV17H1ZG+aDjk8t1IgqroIAprLAV4fSN/ring1f4K/hKw0JrKxhcukaZTp73K6rgnAgDp9b9+rjVjKdwi7gI2mtL4H9GuT+yaVIeMMNPlhge7NNh1Z6gwgNkpp5E0pTUdF8XaJuqdIZAKZxo1lhTNS/i8VdxFlxBmjAC+sNao66eRZQFvGNZGaZEvNMdpX9q4ftmu3VLFLs0oizqQJEpY/9KuhP9882/xwYKjcsgCy/01zlTWN1OCF2RizWxDsBbdt0H6WCFlQTllD/Zm+tNo66kPtQZsT0zTvQKFqaWnpqFT6cbNw8N7GEFKawwiXAEaqHHN5NOKznhiaJOjkY2Yx5vwFscTtqj/Fqb3PPC8VwW+bJLHGnfbwLX1oNj1TRk+Ot3NoupnOffm9/BLC2oXliYbi1RZ27Sf6jJ+BIV4nD6VPDg1qKUXxgMLUjUNTYcQA31aOms00SXOytGsYBE9NyjEjVwxy16zMu0Rns2KjtiRTTWQo7cyZ/D9uzyZHwB8wqA36QDDcYmZ5SRnf+vxMJhiKJiSKdElyIdbpuo93k0xnOdTPEyAaW5AMu8kqgwOTyL9s1c+QdYtKqvwLpwDV9sQFtCVkdEyK22CCdGDmq+JkUo3O1ESX4hZ3FO5KUI++3nXIY7koYwuH6w7roNkDnYIRe7hqIlYUHHD/l06Pl9mOIP4Il8uW5/y4uITKt3hOIM2uqH/IaGau6R475BRkQOLwa7JuDREilIfJky0uqOo5N7v8kgOwcIjYnzXfdravJT/5NO7CEyA7jZiMJSkpwO+juM1J2Gpf0VzGqgHiqHl1PXN9ar1UQd+p2XWivrj40i7X9d9EU9P4/6hdIKKlX4tn310xlSkv28yWvL1Mm8EclrH4aywasr7svVbSXQ34UQnEpkDQYdIaIctbqxk2dArpgPSVLLRpm8/EPi2iTwh05FH3uea8toH3s4mjA8EYX7uUOacqCkDTnlCXfa2fzGdhvwIpNRo80F/IUBtZpCVHkd005IdyM1FJAUnwU+0l+t5Nk7iVde2LdXrdA1CLzq+7zQOHoWqDcQnGMI0VracDtN27Hdkx5O+/D3L9ZxcVT49Ts1Twkn7uB5npPO2+plCeUBfz+dUZnyzZIDTwutQOnNBE/E+koFOKXRnsvF/YbaQLgn2EmUb+LFuNpca15zOmzUYkj44pau4rIfHfIvknCDWYuanYIHlWBnu5H4ipN+QP711v8nTnL3wyxDws2tuWGDbkKVWzAoS7A2TJc82C9zKA3c1EFLhDp4IFZUAr6XxlWitgY/jqVoBI1XhYcrhddocVFYMemx267E+tZRFnBwvO1u4GHS1OpJXNxShYpPHVFE82bJJGH3aqUIu7j/M/FnNTRdLMwwy6p5X6WacsagTHxHFLDrKUrPyq2vvKjHuzEOp1rxTX3TiYS7QL5xA948+/679ZjamNsDNZYdxzpZAKbykjRd3l1jSmA9yRxisUUJeW0VeWC56Mg1PRczRSDWnv/C+2SJDIHbSSFtqkbi9K+drCaC7x5uOYEvafFjMY5THHA3+DCVD5z68WrBQZzSx4ZbCYyem1Z+PwpWhagHA3euH8YeudAzcF2ap0jXF8YmYZ0eZQKxrIAo42wyhvzIWcOeqlR8o5yHSwdjiKiHm8Rvvc7NwFaXNwxcbk0CeoLOR7Vhq0xs++ivLnJpNlEi4wksRmTOYjakYmJPyRDiOQW1kjoNcD7Uz7ZDWnxuR1Cy1wZHLUhzPVBEawYD90JGfCgB0VGZblaBGkTA36GFf4uzpIWkkR4sCBH8Ao9Pxj4TilQY0HXCntfC5QrOeeDT7g+glhpiUbq+U8KPtnbrAhegrWkL0WlwZ2i5zH72cR+JWIgtOY3Htu7FpxnU83aEbjTG9IoWg0/m8Ij+tBYaJf7KGMCkEbmkDS2v+jA7faT8Fa2BulIILQaccIt+1/7kt82n0lzN0+6BgaMPE5WVNxbTRDItuHq9+8E7rbZUGcpiHKwgXCKrKzg+IBbNNqh6B6+F3lFGLf+MPXcyehHXZzN02uzCpbZ32laHCrz1c0ZrvwFVZWDIEG8Z+L0ho0f9JXygkeDahHJnKyGm5E6NE8UbSprmUlU70OqHlQscgBl9fOy4wfhJ13KZMgFCOWBzBR7FSRvpouxB3JDD1P9dqC3iPlpAGCsy+DrDSQS5apnnWzSb9NlfMA4hSWtp7Ynro3JwpQkcUHXejbAJu9G9trTKXJ8A3ndtIA0eXPSFdn1ykS5Maz3eIMTZDLmkmlKvHgJyKklQFgUQ14PRdkBqcLKIkGQMG2d2BwbnbNFUbjc8h3yVP1BHljN/jwo8DvvrSbryhSUnTi9C6u2VSJ0CThgK91ClGEOZ7+P/8x40zE2WS1l+PUu0kVqsFIsX3ctsYelvZmhoorUNHNywEZ6VVipwS2YQirL1ACBth2sDXM7TZphQ6zUTmb2jvU+3OjaYSD5lh+314BPqlkangApg1behKI4cqPaIuhfgcG4SmKc+p2ZTcZpFlx4eamu5xhKhCs6u9DearvSnwL0G8AE1coY/MXcbVtQCwctAq+gs8TlnFwA2wBFErACS3ForE6aJWwGyHtgHGhL82smmijcTCRxwWaaTQBdKV/wwI0l2qe4KI9GWAxK815E/TVazO8Vi1ScBpuYcgQn+Bux/U7OHTZorGuJ4gE4Y+xgWixFTyBlRa91Z7GlTIE034GGH/8pgE9cSWMrrATCVOFeyUoyXZP66U4T2Yp5+iRKKDpPeXtw2ckUsESC20CLI2uuVUZK8WkmMb2ty+zO4xTEXQuSQG6WKlL66GSPuwh+HOjVtkDA3coGtZGGHtdCb8XGjgyiH8fl+jFwgm6caZ2B4vs4wfja+8oPO88DU4DzR/PGrE69asqMBsiCxV31J34/T4lzzvGerVHSeu/gUdvpWDkcXlAeqtYmy2i2caB9hqVvFPobZ7JYLpshoaEx6WWHHPmsgqwJYeR8EH9kMj16HRzQkH3PbVXRtnJfl6VqsbGrKCH90n+wbKMRbM3mxZgHVrZnVg5a0wnbEOQdVPMkgnNOC37ECf61SV5rGzJk0KiWfdlcxf1T8vyCSQ1EIPoBGipVg9Vtgd4gxILmTT+XBjlYvr9Zmy6gCLgtwmlFTuZZ2YAkaLL0f6DxW2xzKS+fdi7sb28Swvfg1Esg1TcvYMhtKa26yjGyjXnObEP8bGwDk+bNHHKqe8EGU1VIlhudnNeFhqvHtZkJw+b0YICEGGbpaPMScz5ZHeOKDlbDAnHrTb/Twoh4VLbEFgZeify76ip0OYVhK7I9QrgVaPZm/njRraSmCdtRL8DSZaDhhkCG9xMZruJqEHzCzWfwU8E+0fdGxDMYzAsJK7gewLQmFEDLp/nO57tCbVS+1vhRxFAPHn7uLQsNy1yYi/8Mtu/gKVUI7Zxyur6EYL/clOLYb2li8miRMsvvGdWlZu+KS6ewJnuk99SSajGNKlDOYJUeBxo+zHSxDbwwQB90ANbp88GTeBM3jfcUdQdvmrqAuVJJWOdHyRNxTRT7HBZYYs6WX/gHJJpswugG63fDXojrsAy2ELlPlIQw61kVIk54V8rgM5yL4tpJcK9MkzjurGq8Utgk9BnigMwxV+jWQh7pfos/v5smU3QL3pNMQ81/dsm87xYTGef4iflWtLKGPzB+Zthjv3FDeSzAm8BmqFNF3XRbrYxqJAWhdsZ9N6cWq1Ti4UgO8PuH7m6NhVUus2G5Ofyv+KYRwfSQs9XUha0n3jpAc9QIPpM95aK7F79cx6VlEwRCsGdsg9RS+jpRUDtjZjileOB3p5hStxX1r0Re7ssC0Kz7f51JTPBPxMclgh224zHtj3wJ1PXSnOktTvnL9QHo/8saf0KmlHPAjh+iVce8PAjoEARixK2Y7PHfRSxPsu1qlt8fJjHxdqlq8DU+FyVILmv64448g8+tXB8WLm9fZGVE1kXHOyYy/4eYOtKbDNQiOL82PpDODvEIUz5BETj99PFftRsdO5TfKmCRKJhGue3CI+YTEfwt5wdJJDeyAADPbPVOsNY2a3HaRuaCM92beR1JWdu3DzWbta66hYix8uUTwYJQle/eDY1b1HrsbAykyvlXxF7cYixxA+by3KVxxOG44MoUSbhvZhM20t8UnCLegRHW/Zg389SXQFn5S9RskgD9jBHHRV6Bj9Fc4kaI0AXLX0woLUY/W/q9Nr7uiFnmkHNIFUawtI0tasTbE45QXzX6bJMyvaYyLd3sADDJ/1Sl3c+gYlwCXHi7wQSArjg4kuZQSTp85NrJdfXAPUIaYyvEeFvo2NOit+ihLM43Gx9DEfO+oV3BBVCYlAYArnvvlN95TTJOuX0PDHG4qyZEwiALMUy1nBkarti3ctTYqQEHV47F08EkAaNroH+He34bWChXFTpIBkG2GFjs8UoSmHYOPjpxEp0+NBr1waNrvUcJvzoeDXqAKGLvCGnJn9rk5hOITK+t4MSazkCQwmRvpp8IhCJCUagc9NqEAUccF4ralyquBJFsMoKHaegPVQc6dtRWQEomonUvOpiAPygXgYwN64Lm7prO1IsZegcErdTI/46/H/RF+XYdeUx6uGxnvVGLVfYsEkQ5IMgirXNHdICnjzZ5ftSQ8wpQIEEhljCN2YHmNmyIM5ADMev/HU9ISjK9cCdwT1Kcvhb4S52MRQkirMVIsyqh4WnmG7IXcI7O2RR15CGSUybG1MkzAxnYj4k5ZrpHOBatk+YeZB7tuTllmVKCKOPvWOWsURBbRGDcMge1cHwW/wN/w8F4JL/0qIydklCUheDzI9pkmO9xeBGvDgQKNd1/nXv5JQZQB+dVVOdYILVQdzzXWqRXpOcnqybab/PHyuyBXxFcfgtfgxKyAD6KvXyFM/7TB5glt2RxXahMzjolaiQPOfR8eKKNxRdlOk7LQawb/s6UGtq2T+i6tZuCtLbXsQpLdHLzduS06jKA0flBz120rKlEjrkiFp9CouA6KH8xoUoWXT9bk201a1V7fJrsK24eWr02yV2glmg9tmVJVUFSpm7XVRqBDffK2/Yi4PCqX0gi2R3LXT42z7Ozko0URObm9eqbK/UxNRjnzySgKssz2WNfQjTyUrZfKq6ijUGTc6KC6Nll3lk4SU9HC1i/b9oeCSWNUr6q16PmrrT4+ZuuO5ee0Ac60o2QYGVvO9TnRj2DS6uTO3rupIeeJ0CS7a8jDX3eN8l9OKTJtG/AW5qgr9RsqPAyJQs7O1CikdV2C+bJjCuPxvQS14a8QygkHgkoWJiFZ2K2Nci7OTRSwTNEmwkEhgqXMF16fnHNJQRa+Gbf0L7oDc43MEHAMPcRj3jdoAiz4Whkta7c8PeG8GGa0Cs/v7kDzj11WNgUUqOYrYxNcECnO+cF8CYGURD+hXQO8LUvKCqxDL5rtTLRe9+oPpKTAxf8+oijj1bS+/VQ0AYYdi2acQ2ur06pUFTC8RTHDr10J8Pe3QAVyx7me8ps8Vif1m/BW9FM+NPYyQCuhT8n4vWZCp1qse4Mtky/03ziu9TOPWdz+nlbIL9dgUCmnYEMxhAzAf/X99LfzF0POzGmIQpjP0ukOZPYhdEtvCu+JqNFzYx682i8EuiPaSmf+bJUmMjLuGMReMVfLkgUgSJm/mH+lMu6m8pF0Xe6rNAtQ5e2h8oG39futG/hdKJ+u25EWgQGpaCNeoyjfzazxjzIfDkfok4y9kQAi67RWEGzZNqjl0wJLJntR4qSc4Bhqgx9juqyLko+LqE/7WdUz6QR1PJ2tTX9YxBT/UbE0jO9PYoD9fGnF35ZCzGrSQQSMWma3CiSYTdtblzY1/yKWhoH5JMUSVB3mYIYEzN+qIuI/IYvo8SNgG+2Ck1h8bd79FM7fW5UAXjARLDYQFwJV4LoHCJWdLN4tmx1CZblwNTcgrNjg6qm4poJGZ/WWpH0WVaw25gguovf6yiPAQtT6G2fPMojm0MPAcpIfxZUaj/xwQU1yyCv/OCq+D2OSmf5RpfjKV6WsJH1OKB6WPcqcrIp9JM8sbYa5U4LUQvGWV2pEb9lfVX6mQFl4hRtL+v4fHc+3MzkefQmOf2AIuRj7tx/0WO/p2ScL868s+sR5eRX0ugyrHwhfBpnvnund6YOX0fSBtcApRf/AKP/1vfCDF7JroTAjq2HvpWRKgNz727QGkCZoomwhbZgYm4u+6YIVhetix+b9cLO5TELjQd8GaRMiIh2xP8kaILzzpRzxb/U7L6bxNu9N5xsmIJBfYXakaxq9tXabmGCZcXmQLiO5Y2B5XgQWt+SjF3dTIqZFDaAWkmsoWUgkzcYSWaGVCQBxMMV4iST5bU/VBmWH+FP5YrTynmxC6uIMnprDvBjE5tyGyYaDe0PgUhPQ7bzG3x/xPMJvTlXCoQ67TZ67ASFceATbVBfJAgcy2Hr46xutMp9090XhmdhX6zewU6SqoXFftM54zQeKf4JsQHcWCQtaiJQJBCjqiCKSM+f3c/GqruyBkPeh+rEiLIwG+C/E+6EIcHj8XZfB87IiPT3VomS+C0IYeSUHemJDHvacpzlEE1dVj/dg4+UFAhOh8j/ZtVd3LaMisZFGpR1aa43fODqlg/Pq0SUY3XGSh8JeMU5nXh+tY8AAKOOLRksHchs8GpXhD6M3O7UdL3/KU5MQjpjF/Rjcv9omnbFQ3H4UtWAWbfyOhoS7B9io62hu3olHsZSz4hkkX70vyr/sVLBfS1a8dwZLW7941w95pYgDsutqntNj5cgRci8PmBsZmLvXssRYZUpKZ02CQdQncWLNsjZPqeO9X8ZyLnk32HKEEl+gbBPbarsrsPBZC9juI1R0i/Wdarnr/YvSEP/sVG53rP9po+55UwfVR0YEWcakXiAegptFFfd01VLb3s7v9v40AJpSH49ECwXJ5i1Aj5sMtXqfIVPlPCCPmUE3aHy3IvolVCMrDBZhpVEpPutynjFCbsIyuDkcfJu1Dluw7E9NW6fIzapeb8M0F1eAc9MX8iPHxSD9jwktpQIzdkd7Ke6PRHbzcGf6Kw9gvdXeJuVm83WpTEi5TiGQXcsMwicl+dGPBrxPxS6iR1zLA1Izw6+65n8QE06FhOuuf1ik3rP/AMsowBCiXuiHiUaKzDfIxdmCj7RXhs0KXX5zxILyHdk9aSBRpaCiExZF9f19iTYXW/uQaqSaaVd9PvjqF3UnmlUikK3b9hPSUAGoPgHtcKw0hdIKx/8b2IlQyR7ayiwL9J8SvzEp/hRD+MXNFGk6M/aMW76DN0JEXLehDVvFJtDmnqEyyfvfFmTvFAf4zwuAJMJMreZlwTk6Wj5IFKzBKDarqEgWtS/tRm+VF2G2krAn8dhPirppBXBlPOBEgZP2UNlrR0AAZ4f9HI0rpmGPsFJXxy6rb2EWpMCR7m4TVK3oF5LFWG/U9ywVfhQOMhxIGs/GZealr3fuWlwgNlYUMW+06PrSySJ9jiwbuR4nmfC5EYCvMCaO/KReZk7sp9Buru4JLptknLjf2ZYM4xkxf+yXvCszntGVm7p9F0beYAOa9XWwPSMoOX8zqlgq8mw/QHAS+8humsd+iRSej9NVNXRO/7QOwsxO7VBhgLPycFuWKJtQ/6nuk0e8d3vz5cC1O5MynAKLcoOGqDlVLsSA/M+ThJAp8azRQB3+bhXrly8cKVdxZgLXEAghBa7kIsnrdoi1aQaFcXRkUu3nm7ZA7YUVQFsGunVLVKYbqzv9pAG1N8+VvD54iWtJ8I5KpaQzMXyUlpm8hL6ubdCAc9X69YnzMQxu0QXCSQExgSGsErkD36vFeZvy3usGWx8g7sztMmDoMUhy5sUs37KQWlITS4df46WgTY63RxvZfYeRZGcsUIx1WZYQAwyEBNH+Qnpm0S98VtMcwOORyG09cOheejGXtsmWtGtcSoElvDoIx6SmxYQro11lD1qrsgb+sEUB8J0HZQE+u+1fnnQ/mvf9pJIz7ElS75c+yULNtCBz3CLw0rbxnCnojUrEtInYQkFIGrNz1r59DTdx3l0ldF/sH4QB0WKzV1bP9GrXLGlUPEsr2eMPZNDFVywUTxUhhcjede8UIDkY+D1lY9AMKahzpouAx+VYplvtOAMYmJIkKMLoHXmuN8DHOimsbv1M70L0/ayiPZ67BRzy+n6JgNqTL4NZ4plEa4F2Ew3SQCX+9iqhqj7KiabAv44fqWJflqEaJOfmMifACTnRWRTWfsCyYcD8rOMHYQvPMvyqZxy8D7qP7ImNBMZnnY81W9yRRYTwuhHs6JN8Y90S9HZ67S4+Bx/GU9RxoBpxSVNLj6WF41wOjymYUZhUYlgWfynuHXQnqU/qIdd/hpZE6bUfNrRAFcKZMmf71kcxIotHXl7yzc8B37ayGdhX48kRS++pkW4kldam1/LlDLe2lul/DldZ6DADPX43jvQ89flF7k2M9KpKL29qOeW5ufx4xolL2Iccc08jeeI4XAnqZo4uFI6vIyk04Tv5/GQUzbCduyEupG12AgUaofrYcSm2d08npIy2rPrCfre9t+96oMZtEfVBo9zuE5ItrytM+6z6WSNVhbCmWYvFWNh4p4V7mLsdMethQZyxwe6Ol70nrw6x4bG2JKywFbQcRhhuUy9SNvF6LehTKQia8IWIQD49zxUlEjJEO3RTRFDi92VTORCo2q+bixkpf3ChTDCMUbFZ1kKoPR1ciWUsRl9gOm1Xalx3UgiD9eBOvycuAwwd4CZQNHo2eloz+i0A6ATq5/GW3hqgq0CJ6B9Sp00breqI+jf+nnRXOZnI6Psz2SRB5iaW6kGEL80UtHqj/Wv5mptzla671d+En2rf7YF7aUWUPmtKs4yMoDNLos5VmXWQmhYm77azW3blNwzC+AhHxr7CHyt67GbWJ5gOjT8mNMciNxukTMDPShlIHSOczE3qtq5mfflWZHPEo0iMi3fubZYf+d/OQchzkXENH5+K4mtLOTSPQMoFc/IGoKWR0pxhRp7gyEFwURC2TSMAiLEUlxx62cPDo7vrzfUfxWJhwsuN9DDLd7FO/WjoOF3UpAesczOK3fnlAXjDwmeCmCxZ+BW7PhpUxMOtPW4JE5pIXy4fOCoVUqYs4g9Ytq01CkaeqYcs7+up3E+tHAq9MZ95HPf5TZxiSxDZZclk15JuxXAfyguDXCeVHJP5vfoNTAcSZQKdND/3YvzBm6duBCIdl2AKO56rdO5XErCGi4cMWUJy4z/fzncHVIiAWNTMqRGRccXuiZkCroT5oPpK4tapEgUnyLjUbKNKVzu7l/RXvv6e9aVYARWETdV3aTwbFBiKoXL0NocToDwFZZSfhRw3zpNaHjbvO7kCbIrh72A68r7idb1zHUZQ1/wqYbXfkARmctUYJeQ7+0mRU3EIe1VWCJa5hGApkuufi4rvuGMiNftdTO+hFgX+s1dIAwksHJS9MpjR9xb82XFeuMl9b91y0ZbiUxFQHCBUOJzHRjpCkywlgE50JJwvjMRuLX47peyUlH5nUomQ1nAGLy5N8lq+9azUhbj29UT48+GK/nypKz9d6O/8flvBwDBK2d/5xUqBYh/Uw30/sLpGIb0g5A38VyYFMFcxNwQLL5092iatnvDUDIPslGRNd9KTrvE4WG6vtQMzeTjGNyzk3bn9ZRcH+YvBr9cLUk18MskonIZvod32KcCBcSHSldFvY655HL0jthAYAXDfA0Aq6aY0PmJtZNuOzd13jd9xcFkDGdsHCk9t5JcGVJtuIXPiAMqOb6k/hKlAtr4A3Y94DZbAsHcAmTj6rSfftSjOSBkIyEVipZhFbNG92fyK82iY6m+BmiP1z/FSkSB/BPWhA5iPBlmUVDBGgekbQ5iN5627p88/ytnjOn8TysZXrH+F/MeuCa6wEWbqo72I5tV9aBPf2+sFnO1gfamHp9rqrLgp88l32gHmIw8PS5xwyO/BscVIZ/XbmQbaAD9LOOVRGjNqxTPThu7Us9LKwlFZNjOzxvZ2kODZP94sfuw5Fw7C3Qe32hZBMwKzVnU1AI/+AK0enbg0wifS4FIOE90qlk6WiASY3r+YO2QPi+JKclYJdmeJJsXNaVYW1DUnb2TPAoOVyNoYBPwNX0Z9KGNvsDA1T8YvMagg48SWP6rMaV+0mpcGXfsz3QSIuhvaotNFQH2tkUn9StvQWBuQL4XlNXmK3q1mB1Y/XhrHge2Ew7INr/+H8AGBRhPjFwS3K4bJfnuPNYR28xAtSQUaSU64QGw/OvFBLv6EleWBXTWWYybG3/p8LoFO2g5R+t+Pri0JdOsKJmnywZpdFnhyGJoHEaciyzo/Kbzu/40UeWKzOY+CgEOl6HF09qnxBxUuEiQjO775rpyPn9WlRgKLPNEzX57e2CSeQFpcSWplermf3t8SrLiP6Fwd27XEF7pmkT+SGzUq/aWmwyeNzMtcndSqZ4xK3zaEn+m6vGJkpokHSUQ+0RcBNmMzyRaNbVNJvX+Ot+VMYPGnxTbsEQYxTeqViYwV+uxazs0yD7SjtzPqUbmkNipo3llsabxwhpJaaXe1uKBSGVWFAegzJ+FB46deZgkrhZQZz8ZUG8S8555ClhJnv9a51HqEl1WzeGSdSLSOx1h05p11vvUung27LqGl/IdNMCK3pBVeTj9COfPVc8iGyS9t8j5nIxb5VKOforGkWZC1DvTX7AfSI2KKF24qJKP202ve6VnqbsGrDLHpm35EjkjkpbK2fNRPE2+40GHltqyVkZIX8erKmjUnZgMtekobj6ctc+mAYbYnvysy/CAFmZvGLHXQpumYCUMGNSp+O8gF2R4YFEfhxMmMidfMzqs4X27tV8UpegCuFFgfNtxqF2HpiqNMD5gSaW+cbd85re8Ph+qz6ebj75sIFbbOCAyN3NfOalBCAe5nTTv3VKgyktc3Lhr5X1CPFrkyLfq+rKQscWp/qyiVMPY1M7b9GpS3sp1y6fL68T9V/bXdMt0tN4H4zlLF6ah/qkuKOJcBprehLBGbsJryNgNt/C4Y9ZrP/oSKQwVWnMir8UFMlGeC1VdCLFv23ZkfsKLsbvgaektHErevuPBQ21cga/7EEOCi/EkPAbx/jSiXKp7h1uv8SYhEcNd9zPmsULHAN0UKE6HOxZYV8lhOS0jAQ5hwuRQTzIB4wGVwsgjhMnVIjnVNRFUgsmd0lSp+wY1jOMQx4gWVFk4OHG03/HNopb/DuGwOHTK03zeE9QYaiRD7oB6NO2g3mRS90IQm+7Up8pAQsDJpdRN8BbHzxByVw2bTmFqtbOc8+YtXtNLyZ7hYYG9V9AiuadFS3VdXtbOoHdeWM7Q05tCzS+8GJg7g4AvOXjH2GELpvjZ/XNU61LxY6qWCpv8kDE9JfFs9ooY7saDI7Jx6ucd/7qL/HcZ0Ub7eSBc6zXOMuau/lQMRh+1x/YYAAPCIOq4lbIjyV51wfsdXpIDsnKbfbeXFQoVZjgMohCpW4hx0htgABDhFlTLWuRubPvRmaiQMlJbyNwht5qQVWxJIYoRzlPeXyUqk3OxYYzYpP0bBFJW0yYBaBitMx2+IFGkgMpMZhtesUmYpe/GyGyuhERr5A7HVERM/F9LZqCxeTgQuCivH12FDonY6PbHw1mQYcnmMVKdCZxQSbuod9iaXNsBILnNb0QvNTj+octH/+dlRvtsPKla2fCNXbOHmklfDmXLyTB74wWJQFpuwQanum696vjGdCRRPXY2uUmItuHIMKz/q2dnbTLz5+vvY2sY6haajGpxYOfh7Dae2R44TaYsscBGJe/4ytOsqdEuHw/DSJ6af/VcR0nalM2h2MkkGPVJfs3xDLYAPLKsD1YL3aMBx+GQpiOXe8AHBZOJGFlCR39ymdzjhBVkfjDxcJxk75/Pix94Ga+4ln8X58Cj6VwLXRuXmtSnH/2OQ25ZhfDOjWbZgEOglBCtzV3WERN7ByPV0tHw1jGutjsCey4ARK0hOrPLfFK+GtdRiQJI6gEv5L8CNu5mv+XoHJjjb5jADFxLYbBQD3mHMzMm53gvt+20if3eybpPNQ5Aof4gXvhMRYSzDoa+45HxIKIXZ2zSQD6WtUqoiVoPLXEppWdHE0NsJRpjha6WkKyz8mTQ6ZWEtuQ1n8kp8QLyLfkp05yScVdDMWJ/kakW53BjXaZCbS0AR7Sk/95bXNyF23Z8BRlFfhmSE1+tUlHCDCX+78N3f5olmBNj8PIXv4gxekzcn0Vmz7P5L2l9RuZ2eDL96zI2isYgv0Nn+FpHOcuKYVl9kX1Py18pcZHHYbmEergVAauCncVtXT8SwgSRoKob07wSho3WB6Zlm3pwn1jBiIUqIQ5Wb70BOnepNc7RfaR4RoX4D7QnbPznDXyIi3dQm1oKmW1oywJEJAsMX0knkjZciHBcy4/0iogKmT/N1VdxbdyVqQFhj2UAdzUPUHN26eNK/qzOhpBtt89OaJdGkWcNwez2xQJS6KLv6ufDZEDKHbuSm4Tk3/lAur8eVI5QKPmSLy37SLQ1g4PGLsuRSZdUp1GbRPQ2CkluAn2Svw531OK+flkYCXvyjn4zl/TOIxCXZ5Epe36yh/lfU4T88HwexFwesQo0gB82zFFCox2MW0ZUu+Y6spANS1aDKyVOG3+kDB04NXZlkC4okPe8NpdKRlY0mqzZ5A9zS/4ymRmgjV75uR/UDL+6G018kIMYL8/poJoR/jR9QnhyOYFJR/m3802aUf7HO3OadapNYVl9Cpp2qkC+9gPhFNza/RR+ih9vHSA/exK5Id9DpTQGu9jG9FtojRF51nPXALILaYPiYvP+BPETeGH2FnVj8LWhgQVU9lPKsNE5+mdsL9YXJbTP1Lo8N78dJr6fA3ye/a3fI/0ADBK/b5Oe/N7q2Aj8Tx9q4OW//cytXCtwCjkeMpcx5KqNFX3c7j4CK9I9gTl9ruAWsVV+IuxTaICWPuvqn0sEcB89nHTpAWMS+R65IRjilejBwV7yIBZnZrDRGhYTwuXrCT1x7M4LA0WTyW5/bvRHkP2/oRPxNCgCadfvtNElE7aoQZsGd22vT3YiNeW2/QYpouc+gw8aymNI/EMTLvtwQdet6u5Vp32sh7vnspTgyfW/F44IVrsb7YIREpy2E8MYjfb3McuH+vHxpwT6ee+PK/SMfWGm6/r9OJsvZcFRvaWIEbNfMw+GU+BoOs7RvUBdZrZNYKBa8zkNlKP9Fh+Gvudj14DDqxMukMWrzw0teuD/S8rAMuK/v3Wl+avJPQQy++i8eR3q5OTapTUbSVlGxmXv1AXZ6ExYh6aojtN7WsTxl48YAZc/C6jqiQ3tuVScvH9HQMWqf2rIRUCSraAwQWrh0eBdicmg4vglrUUdPB0v7x9//tDbg5wx8jLsfDCVxOgdvwFR5VWNteJSlAyY3w1uSh88MWP89ddqe7ONJ9gN9TB4Xvok6OmiIgO7JHyu+fESLQe5UYAjiRdiy/oJ3HWu+7aDiD72oNvndaLxHohhu2e7+4I6bCAz/SyJoXVNsn5uYFuT+t8Vek+Yl4kownOQML8uKJ77B4W9mZEcpF2FmS/WVdzZCEUoQ7FwHu3edkimElSLE506d7M9enq7q1kGKw8zWfl2rMyWfc/wy4cfnVbYDtO3tjbW5mtIeoej3a6hRhMs2sB/mXBOCvc58CNZpwmv4FGhdbz1e5o5NTrIW85wCI4aQ+oMwQ4Y1C2xv0JJTYS7NhIAs+/DvLPXjHcnlYIz0rhU2DgQ7n0Oo9Gbwtx5b95LcbscgkH6/zEKuBsmduwjzhIjixYhTGz6iIqDkjS2E1EmzdNnj2Yn86gt2scJyfK5PnDcvpzyYX0tAAZiPbXHAfx7J7VYu6sp2tvLy7/OGRqgmsRdm3AiA7e+dxbloYuFetVD0tmoEWp7t3Vm7M8d6LNo+DlX5C5YSOjsDh4E3yLkCpPdBUSMvdE0suTQSmF8pACUB3Z8pDwInpjRBqQtcbumy41lGml61AA0/Kd6c3OR391z4tuYtdKyyGtRK3f0ou7AJZkf5N0ZEKKDUPUmK7nkTkP5Qinv83UVXKJJ6sXdbnzDl6s2bMudgsf4MY5LD3LOHeBy8zcHeA4ddcZh2tI5cX2qUp8Pr0h+5BQeok40z4vyrBtVwimrno/gmnQzt2cxGyCi8DeRJHDEBfBQYMH7NekHFv5pLHdqNfgcZCU3GPKbSS5IyHTQOyG3+qY59U2JBMn5Gu59Up8OAuaQVyIxDxeZyWKx77NnSip1FcsR2dbpNZtNZl3EejEJnmjmFAjQGLyrQPJTwklyWhiLpkCMxTK1CDbw7Pi/ZvnlaWpkv8CXhMLkuOpb+98dIrEGQ9flUkEgfPHSyKwu0p0DBuvI6NIuJaNiu2UfVeVunotgOnLcP76024UdcurIV79UaW+Vi5nlyWHp5TYKk1JPX9UKNYhoS5nrHBqyPj3TxnpTtJ55pf1xjZMa3saYw5iy6MBcoqxxENGyi7Pc7FWU8dkxsl4PSo27FMaT2ZWBHsKHrm4DRCPoWL1na/dDp1GkcmOiIgvnNryOAZUWPz7KQoC201Tw6kOFZE6pZllQdXcWoFzcjpfCm3umiAmYkUiCuO3yVHM00hp2UOBQo9Of/vamDhiKiiO6Pj4hIuOcG0BkTpVWWElYZzTSjt7Qlglzo7FJoO8tk9UNyNtqpbcmjkUYbt++sBcHjNRyFkxeVPCw1jjnk6p2JSO3ok+OdvfgGwhuESh8Dr1KYlfH9S8Y7+JusuzhqSwpUVudc2gnRN5snCeaKWFwL0oKTuL8IrFMG3QFbZ9dkNFKlyQ70lGFY7HMKIkc9u3z/E7A9r/dKPpzcng+SQJrEe98YfKK4EC2LiXmtFmx13wlAj292R7FdD/bgQ9shQVfax5BuoSkzxglejxDw+jl+iA9QZi6Ese7IZxKw+20E+SZ2x8RevvLRkhMEYFsK6cJXhiRWSGqZU7vkYRppmnwChs66RbCt1aqiUmwETL2n4/0QWUacV9FR3aZPC3+NKKEPFcj+67LXb98rbe5B4lYkT/GNAtWjd6AunS8HXq5PnjoVfVKhNjH4aSA7QQozbgecsqUVf9HsYoBNYPM1HSVS684LoRgnG74wtSXhVV8gH4OdMLnmo+ofKnKN2iLwHGGfhnYaKVGfybBlyYV2R76StmH//vBMIzdJKUKrVR+sG8EI6ikUTzK7c19stzDC6K2YJRAp1wIHVVHjYcarVCn+FCKZn0qJFriKrhs6MccY/w/aSlfS8eqLc7hw6BFmHrwFYazFEOnxeWTwNTgn3jX/SfB4WbkknXnwKOBN2VzCp8VXLD0y8IylOtQ4PB+ar4O3kqrXzc8zKTT458qPO4UX+DHkWWyVyS6UtRzZnt/hmXlBt37kNwhrKZxxCtPLD9XBUytNDN7EwAdukSkj1NjFAW5ApRgBl6nFDuUiIHkmbOd8YghXcsXn/J+uJVWjl/q6XkNUhk8rinpSfLExgJGVTxZ3ZBJUCmYvnu5YXkvtWqwr0jpik/QWih7Z+GYMSWjmUfdFh1IBAi1AGGzvcY2WUscTx3xNX7vY6BXcNKDerNOw/wR1kq/RLLsxfCkwdzt8DgbqAqnbnGN5M2AGvX3dDlaAKuxLRBOlm1ANWhuH85yMTuf+tmvz/3NMcY+o7MEk7EmsPGSqAWXhgnM04kUcPBfyTRRWd8GQfL1ajJo7MvmyJ1st1szqBAKs97eEAg7pJrFktqNUAwE+D5dOLIwxRg+6LngqfrTTiyx1R62SOZANjXBw9euoIUtoOiWwpeG16wnB6g1+Qrh8PqSQjyM7q8XsAl8/bsTXxUWlEGjJX0h2v4yLwdXskwiHr3hQt47Vvi3lobAB9SqFcUY5mqmg4AmqmIK3KfqxAfB9M6KEJY+n2GpZozrgFrGDS7cVv94+mMWO6BENYVOa58f+bweF9X9LAomAQ7fMz4L1Sg48IQqXvqVj6hFg0Y2/T7Wxav5DvwEwkjSSkzNAFbA/UQYImmjw7hnA7OA1E/laLT4q6+75wLbspSgxe8xA32JjgoIx/6i1OAOOAoM7fTD4yipx62/8a+PnmzDGDL4GbQqTjPRKv1QGtuGXsHjsW7w+IrsrMoZDSUjFkmJUBwLzhf94H/9zvJBjJfroJuK8eje5MfVk9nkEo5kplgn9tnjmxh78+cWRXm+S27/gEsq1zzgT/+gKNoZMa6F/F3xsY1845ZAsI1bWDquyR6v9p/8BLwp+9HxEjCbI2dkweXxOXlLoABiRZ3Cu9H7eIh9Zu0mbVvlp79U6MOjJcnNuXxfOPKIEy5Wkt2LBIJgytvI6oMl4BbF8FU4/u32/f/6pP62NeuyICr8DZ2abUqXn42eGwjtBliWE3StgvRow1z9VbOe/+N3ctbiCT9qKpaqmGMoXRoWTj/wjtgvnxNWVn13aA6gNfAYEKVMnQlOaJt7SlXAEkjalOLyMmWjzubgt6LgLFmGDDvbsP0dtfG0zMJ0C52wTi2AxYfxDQw7JKHQRBGcjCwcwSV89jysOgpg9Q8sCMvcK0uXxuou47K+reAK6M5YK4pOoGsiu0IExt0GLqJJFh1YrtOhH5DjUpgYA8hc93QmME3NBXRV6j9ETaAHEZvaHmZob7kNSZWPMzARLg1qaqiy+t8nHsSmYbmSgxCLJ5c/GFqXrrSHUNAiWB8VcLroRNMLsv+YV3nYdaSp1D/oZq8IWN9awM5yDFzdH0+MvliC+dKt0jn55Wy5laKewMQTrANo4b1IuGJ8dbbW+TPDSDUcB3c4hzA+7vU1SJ/FUbKmFWdpBWUx6SArHH8fyF22PvC0mtn79o0enpLqefuk0EM4ElIbFOAySXMPsmxR3lVO3QYMwYfUXI5tWfJRe/Eqh3oRDtdjQVJNw0XTO+6JGKZwN8714m00su661ew/EfcqCXTePSaixPMRHOwuiSn7AyzmO2W8jpWKn5KW8BCxN6WSq7bNBbMM/FmApTjYikHL4BjquK0MY0FOv2d1TkVkLdOhceCCR914yI2EcxuKGz4O7tiGAHXV1Qa3V/JMjHyNJYLLp51uXvZqji+YdOQt1vX220AuRl9DQbTNM/6oh5v5JnYvryhVZA/dfdAVvVDeBDRk5Vdqng4EWe4nuB1RMaXHgxQT2ZiLvQ3qBxySesaCqKafY7vmaM8h+qYe3b3obgBDRZ3XmJEFgfeiyGI0hGySRpzsZdMhfvMuNUl22bUgzO4ihkP6KMUX6RToW5JRTheLjLTqHtl/JHs2EIHQlvc2uUxWhznDKO49ASLvZxsDgnA4DnlTUPX1Zseazuo7saexgtXx2/0L7/flXzqszGjFcOo6WpkMrtEL9htjOspz9/uT8zP+DNcu4QoRbpsB2yqxz3GTrF+fOkASE4dHAC6OxjRAKFQSOI0IrSpubKexm5vNhYnQRX6LPGqHxHPJUXfyF1I/dpbtn2k6qYAXJpfdvr+9qbNtZd4rE+x6YogsPWnmeyoZ1pUSHFsoAgDMqcs5ngbuA3o2TpyYBulzhixlAk8XX7JmbHdDNUA0Rne32e+PsovozuqN16lJPJwDRhoY2sD40dnH5/iQdP5K0rJ9ofv/RLMKrC5Xv0nHbVuNCR4o4KcC8nxii/9yG7gLedAL3kFOWlHqfnDhe1c8lSqpJquorpOWlfYK/5DjXVRqtMdpidUGOF2g7DfQ1eBRVQF9T+89ua3VihYMLpT4UKDuiiqOry1rrT9VxJWyD3FVtpiOcwNs7CsPcPNo3X6Xqu4gkk02ZHRyQPkdSmH2CzyaREKNienhTApnsVxVojCD7aTMN3yD5fFJwbievKRfudG2lbgxYTfioCnol7ZhtSYcjmZoyj5V0rcnHfkdgEBIjICkkl3I2TXZbZs6GlKTj10/nCvnWWkTcbt/2XsI4O26Xm8mfMaKA2QOAxCQxCc8TM9mx2Vqfi58n7wOzn8KkJX1F8WMOrUpA7Q6itoMR9Hc46lvRnSpoX963awVt3+CdqnTzyAe1As5MAqNkpNqzKQzOvFf8HZQCd8oHOYYkP15sVcX3pfHJbB8YgJR2DIsrTpABQunnO8NVwgQEM3RMSeHPxghEgiMNICNQNdOGLeRKg376QSiJ+qC2c/CSpJ45g2jA+KVwX3FC7oEMIW8/+5wBIJuvPiX/1nWxgO/Ye4VQQOk49cRYT45hjogE1wzV8F6qSZYLigB03Pp5rnE9iFY41zXn/dUk2/Wwu0L11hGYRsJHeneJw2e1PXDv9qh3z8oCHL4jQ24HH4txEIApMBzFcrO+vEOx9sJOzP8OcaX6r0Ug69kohUMQG/rlQU74ljoW+lmvIwcgmO4H4in3pyybzbo+ux/ybmOSg+rN8bDDgs4FU4hYFMNOAYgJdzqRAYaFYbreyM1mEpYl5rsTtT+x1jR0jpMshH9j77fE9C4dwGMu4nHvuhlyfcF/Ywn5B5HGXCp/B+SZzYuyNfERmPnbU6Z9KE718e7ZTCqIpyb4aa5jdyYjuUCDXqruzVAEri12N3Q9+A5buixcr2Mfgl+456j2B0I6bNPSJCyvopdGaIFij4P723mqwZVESjIys2BmfqAgNkxZYZ2HOTDAbpPFQd/sF1x97mh47WdoQFZ/TTdROetOhrIXewyD+9E2lTPX+k3sTZY3uqFrtpHVRDAn35hd06KPZfWHSe2A7ounGueWYYeb187z3IiaZILaiUWUtMo0nDBMdKf4J6xcIgD0hTbbxyjb9XHQjQqTme6oqV8bfuo9esjcbOEB9q9+6ApUTiN7GycwbAw5y0EkQzJYEzx/wP4byw1PSLg88BLskLgwCsVNkiIAU+em08gpAHW6EXjGQx5wxhCe2dwsuOYNyHLOaLCx+hN5lzKNk9mbaD7y6GKWwtcffe1l4jjb82EqVmYd37u7OxCo+PiNNlUd/tAd9iDKcrOgeAOCjhps9mCWYjwwHJyNJpHtBLx3M7immW1B//wAz6HKR65bKIvo1IxXw3lpDQtCTqxcFjwAZkyt03Vu9vuZWgqHLgi/NqEU+1+8swQNyRIL1QEFpSW5aJxBd44hKCDkXH8BrofKyFDwWdfv5CW6iyX1RAoEszJG7V+Sw6ksn9yalW9WroJF514vt/ZEfmLFBZzdSQLgTeWl5S5XNElvx/sjjzHlOc9M2qvNy4orrTf8ora7pExjpnMvKrmxiWNnG5ARsHTerfNGxOoR7voz6d6vVXskE+XTYb2Uv9ZlLsyCh7pOvbCr+guDFS9hzD14ZmxNl2eETVfPzcnpWdMG1fd/Y5S+wIc47i0KryVRxy9KpxtoBJzAm3KMGRu0AdgVmFVoEPYehmSBd/n6ugVezKQ4BcAxKF9KRCqohBTEnrwsVfqFg/ip0oh9quUYUeHzYlVVq466j2BW4uCmBJDZ9uYRfwRNovGmqFM5ZhOHl431pl27B3f7GxQpEg3DVYiaOF9Mo2QPWYQVKbqqXV2ptuUAGdb+NvgSKeQJahmhdOCzaINPKMokwuhA++aG2P5Sp/9N7ZFkBZ2A2CaTk5AQYTbRnh18h+lj90moJPR6K9FAWC3Zdd/QTgDKhRlftpQrEbPdLwmS+s8dHxdsubqKtmYnNYaDGX4bTmns32M3sgaWbFnvYvHteLRfhqPIenO4xdlg21YW90seSm9UIwpb0WWi5R617M7WQYK/J8egxcHCUFNH+ATIZVVxqKWmshhwdcmC6f2lsGlyyNwaQVjVcxHooHyDOA/CoekGc2I3XdIuSa9nuFYeuwCz9xCLzPwvKjOW+aUpelE0PMWHbRuK18eIY7BbpODK7ttT6rDsP6O+G3YtY4XXuXrZRlp1L5P90v/gp8e1Er4QkEaLa/IGz/sEhSoRYvs4UGdBhN69eRsk+pSBtEQ4Khsk18fbZrtGZwfeenYG7DWvYwhat1F0i01aUaEasKuEHhzBEZxXaPcY6bcJVbxeX4TAqXzc9b02uom5vqVS7IVh3teLjwcURU2p3i7oDZpDAzkbIlH9c/Zq7AyaFKsk+q7c6KA7xwQywuwWhlH1wlUwslAHyatSwC90bMpvgAZlq8cMlhBYNsaWKuOOSHid2ojqBBZWN8GNpm7Wl0yk/H8ilYsBO2ThrbcFIIS540ESr0karB4Z1tPFoF4w5e16TezVoLlQGKFeLYhQrYFxMzHYtTtwS0h8zGgxEvoBSErcHXMBbsa6h0xlHtkZt09UYgD4++6hQEmslqsN2791n0alVEiUeq4N/7GXU1Anigd420Vnxb8zY33QXnOWbYDK6burYS1dYryW0e2jUkUyFMLuHLvfQvwu1aWtt2ecR4HCDPMk3E8xepESswiE5S93xHNa/RPa2q+JwdsCST/iqlLNMhLO57LoMNgPQqOxLEdmCEakOX1J1tU9U4DT2OBL0azeLRYSfjAJzZg1dNsviyz1h3Z2g7PyCC2iSfM5KbyY8UxkPqVtVo5+dyaDpRk+d+n6zloNYknfNz2zpzpYIo64ZBG/qP7wDcaOp3aV5k1Ezzqdd6Z7+dPXh5FP2CCvotwmc1nA7ebCVPVndgul8ub106t3gWWU5zY8LV4uJAdxY0/QT/KPP6Bw9jSt25J2yAQCQAoinreKcNTeb6SDt/p1Ao0BPRybh8n7x3c7FEoAKCEZf1rZSe3I80Z7MEMpI7wk7mk/+qofIrhmKHypXbg3bTSMZ0woDoTtGFMQd9JolTbmaCVuTAp1RZmP9g/vGTo+zMfqlthjbe5JkhObWsp7T4TOHEAFePt/bKhhKSpzAPxSGZfX5cDIOtZ6yYpSHDhV9nhSK47+6fq+asi9A7GGiH1VLJWds9dCKq+Flt6pofop3yrr7MjGKFi0IhhNRxchHLr2dYRerwOqrRMjYlnzYOtIMZcjOkfYf4otk5XUSh5EgPn8wri9sWiJbkDKhHkJW6okWuTiK63YECmKx8zBJp61RUoTWxr1LcR1ZHThAqAZNm04qRPjbAwQYGNwGOY17Mzp3A3/MPNacAtxzOGwcphEZIr+hs568ynt5kLPCEY5u86mY0Nghtl/HItkivzOD2PuQlptft3H6+jmBePFhhgy/5mjKNtZfJ11AJeZhJrH/4D1zM+7bZJkA114h7ro7BJVkJBmV+/Wz39io8wYRVXVDUY9u6EsFDPR2iVKJm0QnrK8mZKKK6yQWyvFTSWpyR8hBR7kYkoM2YKATN6Xr2UfkLoN0MPd+FljZl2FD8O0KU4xcXI00TNVHN4uPdRJ+6eerChr/UQmVkDrQr8Sn/99T+THe2L3/YuZYPL9rN50W2hxRL6ZaM9QsPzAklRdGUHejT/9xuTpkdnFbUqoZxz6vbeCzt49GiIuwV80tNf3d/E6tnXApCxpmsgT6AZht6/ILFx2yZNuJlx9/4Uj/iNAXz15MvTvYSrvmIW9+/PZ938qrLUjWe8UvfywFcEqw1XOR99Eegl9NL7sNBrGoP36m0Gs9BUbMvNV4wG91mSXCV2TgHr/JBD9k49GH/C1LSyvvQYVqWkktQjdOEdJhc1qJ0ZCyG4drMMx64PD9f697bt+GqhF1rYgtI7bLVp20SWhmQfqVHmdOvvcwS/FnrtGDdx3pbgOSN4vJA5PtjUNQxxPZj/Q5uY3Z5pEUWdJiTngvYPJfaLpBhidOQbLFxQQWTdQOx05jVINLmEmu17RIZ1PIi0MAvb+PS73vR10zqIBuDOKeHx8UQMW+fHUaf31z11bSPM9jh/2CEYaAwXKmBRXu9PSg9dAeyWx2BN4OIr8mpaBcoLuHaZqhsucRa9Pb2cTIZFt9zkwme9ZBhgjPEKBXrkIJxK1JysCzTuOafMkp/8dDPRfvs8dIwiEYlJ8Jnqqx5NIeNbFQGO4U5Em6XI/OFiXYuJ4C5dY7UomHFuhXaJ8f9k+qw/vlW8L+BozDCpnwaT9wdt6xTbEGfwI3aXCtfNc2Il4a0ZGbKdoUEFcpiN8aJqFn7mm1u45uq0wuc70rZ+JDYsgYfwr9xpjkyMhS5rGF/PXW6338fqerF7GgSeLRvvjHV6j1J+/gT3B0UI7V2VYHS5ppKvVznwyU1gLy4BHOtVJbs9vX5HtuJ5inPqmT1LNDHim8EjKjYhsmz2eSQUimiz2r1OCY0eyQ+MwaTmQWJAk2l9CtoCiBWW5jbJb+yybozJlHYqSj1rOP6eoMlBWRKyZVTtSOfpPCujMdHAcNrvyz6GvQ+cKqgG9qu1ZJdyqteWCRqSH/x+8MKMtPQhJp3SRGLuOwXf/CSOtYcf/hLXPq3r4XBUURfv/Zd1XZQYmuG9gwvyoQ0qwYTHC0SVwumQUPkqO1Vx7KOhSZQl3+PSIzLEwjtMsT6dqvjSEK+dF7bQECK5H5qdEkSwJ7NEKoLQaw99gEOOmuj2yaGtgcnXyoaOfK9R0m8rWsijXAJU3JpgoiD4KxdSk0yFmq8zGY5z9A2xsJuSx6154fy1uKah2WCooaVA0Bctsh2eKVPk8ZxrcOy3E4dKxkAtglpbDdf331q6zjq7nnxt9cM2i4uy+evimdYoJLZK6r3U/0wKlRFetH+3bJwDMSEszgI5ukbGxUiH7O02JddY517HvlX9Rrq/MDAqH2yU3YzU2xVBymwWgewRoiTZnnux/lKfrBvZ+6V4IJb+8AmEljFJ8IUK/EzfpWDhaXX2yqZfdBdlySppG3LtlAHFDcPjfnXxUQmtFPy3Iy1YcX/FYTDmT6ewec39ZSbxbQtiwpi3G3AWhEw1f06nNvKj1oWOk4GG5ow+vdGlpS3yl/WyIAoY1OYFBqNRcta+EkEV0/IN+63OgjgCFBRckwkMCPNIreUAtuF8aqLxMPuIJGxr43KIpWz6yoE6QKGqO1LFHuAobi5LJ9m6LvZDCq9Nnbqd88EQVvJPRVYm7jBvc985/ZlfwI7JgM7Dnl9pOWusAF3R1feSKmLQC0fzechWgHRzIrf4BzpF+ru4GbbPFcrPjQfSdgHCIdMTU74/O29GgDHKfMnmmsn+2NLeOWQhHg1bDyVPdtzzJnfvSQGQW4nE6/+5K/UQFj26N858XzFB9UTETKE0Jn2fhF2LPKFf9o7U5VNytFjrpkVaPUw4BTbO95Uh6cqNTjF+mb5dzVfdBP8MAEY3xPp547Ox9MQaZMUKSvuy9p1DABEeklxVQ9ilk1VevD/JFP4BY0S/F2Tyqaq1h8Ki89debO9BqemC4hsHF43uSgIVNKQWvr/KhbwIAP4J73AqlA/FPXmYN7+vUUS8PgqswpeKPT0oX52uSC59ARt+wJGcMHraNWosn2Rm4HFAEKvPCled2BwO+xUgIUHHKXuSSOLtkulRehWUQ8S0xpBan/D0upxZRM6uafOGKslUMWG8vh/YK8sl+WGqZ+jMwjNbzUvR3FPYrjPU+i0UGsh1WlPUFEX9HZMRZ6MP8EPRTVm5vBxgOlL02qWJdtm0202j46WJ+mGNfJi7m2XxBCXoLTF9F6ke9i5hr1o9mvWRBLIvMnvFAP2ATyTMHQY9KaEQ//JC2O/2kdLp26Y0JtYBiERDrHTuoIHFKee7XUVAvlHId3zKRW1IA5VF7kBa+BjBFejyAhBg5hD+u/A1GwpIStzlvkiuno5Lsrevp8WNbKv/AaXhHo5aI+gJ7KGt/Dk9JTK/DzsfoAK8xaymqABo1mzBDf6l4cPbumVHwPCiBtuslQfrew87N6+/xIwKS4N+o8IKKeF7Fcmex7JkVHkXBQfhk/kFBeuJoNLwwW2UvyoX6/BjiT0SGuXVB/32vGEGDcYMx64U+rZce/e3Y4WKaHYaDXMYJ24m6fhBbP8YUqxy0czLa2udbfxx/x6SpV5Kh8cI2rZhDeqjbR7Oaxr47sUtk3CIsDJijHpd1qhniWnikCUYLJUlwyba3tEdsF9LcRmK5z63lJEV82pN36SMmLMAahMlgKoAKqrwX5J5sHJy76b57DfQqFlzDrUkK7LARYHPRWEAhg84olfcnePxh0oBvzXtNEqd/ZSTFLyMlHPh7UDmhwSDUfv3vW7cTDBHfCLtcraddBZNSnxQzoye8KBQnQrW2JKhsUQAwuQAM9m31O+mfYP4lJjsbBgOKNrZO2GMf4zfRmMgUHBR5IqkmkJj606cJKKxPWlYdPSzc276xMzfnukkZ1i5SuKVq8Y+TAi2TNNVSyJ7VAiNQ5C+dZHi9zjPaou9UxXWGxShFUA66gljSjghtulyUoe5rvJngESpdfa4sTKayDb+FtGe3lFsquRL6YrJoHMwVDnptpEicY5IlD7qFfmSG6+AcGP840Dur7k9yuz7Lnqle4CuuNOh2YhSTkUfvm4SRdI+xWCcLT3K/7pN1x+EEFXrvb0lexsJp74VweCBi10tevjBhfepuWQvapVpXTguNXkZaKRPHXFhvaIIknNEBg6NWHHcqXIkg0qei5209hjKPtJqgnL6drtDq7XDI5UFD+j9wzxC0TWiNVZ8MQEySmmtMX6ekKQUPk4hcdzKDTtY0+qvIRXz8F3oV7Kr/r66/FE4jCtqr6FIFjr/qgERUnMCxwo8hSLUbXBLKi1g4HniKHRFv+izY+6IJnrpbAuSWIwG7kLBe3HUzJrSrGlKPg/c+0bRcT5JOpkPOkxVeDS/q/SI5xqUQ+xlooDUySBH48GrqK99xnRZpbxQb9U6WLyuNd1yPgWvEgp0u4RL8d/bKY83cEeXc8jBpTjh8MrHfbsK7blj+Kb1zYVt4E5GVpM9t/wV4ARZ6DAc03yjkbZzvsz0WaidmfT9VijTsbjD9MZP1Oxdqbm967ZKzjqdRfY+axD37vQknWoq5cXfSZ6wBiPqEEWersRiaX+/nvvAE9VbE8YdC6cGSqzQJ30gUTuNKxnUhW/it2aqAaBQIu8vb/z6KUsre2vYRiLXc9qNKnfZt1OPaFq5YY8F0Fcvjp4F5/Oq+mRvLh22zRLYSAmyUyokglr+iFCu/rwjP+kGtehFuWOZaF7Zmsnw2lCRYWIlvhzMdlJ/Bu4m3KeZu7J9O7XRG3cHy32Z7bg+8u1/VjPl6aNgohl0GKoRbr+xxTWdAVKaWnBb0co/rk9xcjVWZwrAMefVXkQH4yA+llB+4Zg3X8j+XFmOm0YiAkYgorYNlCAElVZ/C2VuKVIwa9tS5UtzWja1czIh2LtRNOCLsSGvtMj+i0EX1LTkJqQXQJAHQQwX7d/f/p6kWGiWE1U9A9KvaIhz5ikFRfiS1GdMeGo8szI2Nf+T8ASsKF7NY4K0/uJGDMsh04qteV/uNWfbk0wVpBJO2mleaSvRmlvlt/B9hb8Qil9g8nXxWJLaYpmIKr+Eu8ablG4uqTEGa095MjawtRmAgozjugFEaoIuixCxsgVf3xqQwwvzD0a4/IOEtfMKJWWFuQRonHalrS5RaTNqEafwMC3GBMoEOiL+qlO6znVw6EGnU6NV580xIGUkW6dNK1MWRLzfpFJ/lYKl/Rx4SVEHdmzjMcghqtRR/tyjAJDBxV5/5/VG3KZOswDQRpeRLCL0l776owZ3qWOSSFPf3xUE555wUesMNWlEX2v+2+I2sWHKHo2hUfyzWPZATPSSu7jpXzkKBOSi0J+A6+7qNivsrErM3vwoabotqaorowNPODn0RlpynSYB7rFjyTyYxSEiikehbHevIiUdQDWDCS8EUe5K5CCdoIwxJU0elm2DGQP+paipGcpSQDthV6rs2/YL0chgY0wpgqI9YF4DZAisMrmgJrQqIGYCzwMyCbsdoch5FVLKkcTRuvcbmKPODakSF/OI8B2JnZWXtmS+SxVyO6gv8YE9ywOJeVvVnt7u3qDo3ZKPONLcF+oPVZRrpjl7aRlepXwbrrwHE1TWbnNOstb+cZEF282UlcqXKaaydujNTT0Ei/hP/oz7yteoIZ8UQmxLa5255WZ9+kfSaHUmhH481roHiIwSCaSn3MOkURq1aryMZOfPjzyW3t4cKRT7vZom7PTTrxY3sYpWiWFSZoO51EcqQvXqfzBsqKiSae0hhFagDKLAEVdmkYp4SGSv65XRIwsA8S9dfRVrrTamCt3Uc92S+wVI0EifEmuXH7AJyzn3D8JFuif0BgNNeNde8noj2iooQqVkSfmErFLC6dPcuWJjNwtX8uDz297tEBFbpU4xjAI4JERQth42x7VbdBkKrEXxxoFgzx7B8kzwmOTAwXyOMJ2H0Y0TZxkjB9AZC9QDcmfVPL+u7ss/lA+Grln1RzqNpElKHnmwDolhI2Jx1qPpjZfJwsGgbvlVnpg81XPOrkGhKt1ES7cOsMIl8KWS8G5w903S5UMY8Ye6RmHTVVfVpdmf2IL/2L0E4QhNx3B7eXRpUe7EesMwLqnaUMZItNhQf1ocCFbHpT4nnYgXvlU+ujresj6u5ERxEdHD/WfN44ZirtPzgUL3+85/fl08aSTCS9NtkyfTQbDN+crg1r5rDcSS3pD/nf2apWSOjSUWwcPnBHJNZVfWvjZqC0QVPW84zlXdTBedsi4rG0xbTVeLAI5yek23js/K/LU/VnYysx6zdiCPrJzHDLRviZsklnLJ6rze+H2ZY1+koBCfrIU73xUS7v5UWMk93NNeiNBOh2ZhUmiKbW+nNhoBYXv8G8rvsH/BUMVWtGrmeLqCEPhBX/HnUOYktAWdLHsyLpKD4f10XdzIfbxfY6oSuxcRxwvcw2VR1BlwsGWcFnWjW4sTgEfWt+1CZYdSjWpc3LL+25TwLgCpXDLgQuSCnnratnubA9NMiUIAo5RqRQOIiZId8vxFGwUACFp5BXDKMma92bu5u9lGQfdTSLNnMcBM/CJ4b1UmSLp05C9GY9kPR36ZzNpmReJQmlPwCBYnoSWWXSarE0oa7zv7eYnr0Y1IXoAaNFsoVeS4fwGDEJEPDn1VhOzLddGJI+YvNRBuut3cWmNynkuzPlndyL2KDkQ8j4ArdbB+ZZo2uBqLg6GKoYA/wzA2yg4WbE8ymKgZU+/N20Ingp09sLt0xKK/+Abbsf+/CUyQn1Y7yrVPSDzakcpZiDl0lttZUX+KKY3aAY5WxsrIK6zekcnCiT3LgjAIFelaRwiOI3helwokmuFVybr4YnU1c03KXNBEZpc5IFQTMmNl5JviBhQk6zrrrljnuWnXIeGxdSEQ055e+fysxeO6YK33L/Zw4vGIHKPwCrbx/pQus+rmX/P4GWpskoC4kk5xKn04VJMB2iVQcPDFbSm7lT4bnn/w7CRL1pwcVyAKtHH1/Z6L1E1mFqsIb7SB3K3Ww+nMEum8WZskpNaRrcdkJmPqz2vNgpa8akm/0hxY2VrAd5Ytok97WmgLq3ukyiRstNv5sdK46Xl/G7zcwcMiNQWpXG9wlAeA4TU7WHZ8HD41tmNGmxMUf0QW9Nz68eueHsbR1pNjs9TB9nlBi8eis7Qa0YtTVc5AK8jJgHcY+faNyMmUO4vvYaWs5gMZTN5zmcY6yU74tmblNy2Duh5zRuKJKef/xuVfBUNNOuU0D1+PtOGYtmR0EPBhuMCimhWTdW0ykewIo0Hj/H5AZc26qyMF2S/kwFZO8xOkOxm9NJDNJGorKypV98jneoac89V6QSSL6uXL1Q9f8utTQraCzWd/M4lPU0it+F/cPsIL8O2Tj2FzoSgLKmUAw1sKRiNv0HXDFH+ufz4GAp1AMqM82KVZtGsTwAa+930FY9Q5dSOcEJo/rVDRPo574ybot25633kTp69wBCJTMxO2nCi60b+GVzu6gweRDMvPSPkP21ovhTbv4kaQZaIqOGcWjg9L1KR0EaVl/Gdid7PRY2m0w4TTaj2Bd98qe9UmbgnH9jWsvHk8J3neOeF9HTlmT+QvHtcGrFa5NFQvHE1fjIl+jMnXevzc6wKMG5p6qZ35umS/oRXYl2HDC51ohNwKebN0inCpgK4fZQ5+2Ll9CA27+sSrXEuRccISU6qxeCLJPagSbS/tccljZp1cEIeiPEa1Pm1nrHFOQfpcwpmwAhX+hpu/Dxc78dGWh1rDGdkfuIeQxmlf9jsPykNPdp9dykdqoT6sZgaw1DRb5O8a3r3QMms+qO2oEBbNPA5uX0CXcDhaHzYh13/IsDFo/79ffgE/HKrPEuB29kAx25BCkLQsCGqY5Y0YqRSncFFjopDf6HwpaPWZacB5ht8za7ZUlk0efbmaUkU6x9b/vzrJXhRDKnQcYoEdyG4u17lVd1ymfFoZ+5jUh0jHOSa21k5lClMGqSO9TbjGR+DhR/fwxfOBSGC9qtzqGReJZHSrhLVPba0efac4HTRfSgOcV4wDwvtO5OWY78U9nmB6SobQCnV5TAmd5zuHaFlVK1wArTtz4HgdIPwP2djSHPckU5H22oKQ2xrqfQBHkH7T3GBEYs/VcHQgN2KqpFCW7feq1J3fNFzJKPnwTDV/REIEPnLzIeDUets7kOqLCCnod+6vsD5g4jwzU2g9WijuFGmDFyITrQNqH8JOCNYPTiWZ6Plx1iExu8BBxfvYZ+oGpKYFLHRt1513tyOfiDJKkJrZLCMUSRKzCdqKqnCnBdLGBWmyOlRKwlbtK4NkQAN+L4K0gWytaPbuQVBClssF9Ycnl2tgTB62AmC4pCUqD1s+oPffOjg+Wq3czDz/wge5/tLMhkWQYBAnDMbgUabm/euqlh/mBkHCax1PNB4j+OAuHJXF5PRjfxn5IHxD7LGKkPrpuGcRHX9tAxwttsnTuSZLqxtDHQqWSj3J4/QcrEPgL1OQP7dG59IaugqLAgHn8KfvdudbjJf6LDM8VlFIkVzKIYbjcJdA3y5rS54uyHLRLrLcKoslHComLRJSGVCDdMZaWj43K1e4HoQIY2LU95h/Mn0hetC9xOD7KUgjjJNORfduyOhtU4O8Dr8KhUpuWxXmXDjoQZcAQyAzM+MDA0JMLWRa+G5YSoepnExdQGBunnDGIEWk0Kbg+zt9xTUPIUG+Ng8JlBOtdekEfYawNfPqM4/gZMKJj3f9GAAzQbByHtFmf1yKpKBs1ZzeDSmj9uqnOXNMGs8E3dp+lDv/HsZ864nm3/lJDATodIwncK9h98ftp85o/GCcBRB4VrgNYnguZP1NXoQ+cbe2VQWD4Z1hWfD/d9oqau7H2RQ0hHl1gzeJPV80pyI03ttpaC2jllaK8xcZoZ1SxmupcSNgc5MjAC2zz8NHJuRYJ5YehN8ZUQDkmh3J8tFdHSEZnSF5apIrKtE9KcEV6VtK/O37zKQ9IVKC7MYu4XgjgIVL9XaKqc/hy69WnrijwFl6C28n/He53tSZyGLFsjHXMUbwSRZBHTxD+r3NSGyASbVMFZvEFsvGCIKlK5UZ90DuBuFULg3hP3c88hVZuo2UbjxhxwWaraYCuuPgIs4CGhBejx5nbfyXKP6OtSFLM7B1MVFOk33N1NVBq6cqt9JTx3wL//JFNRZOyOukoimzu6OZNt9YKXfSGhLYr8sb24aph3dWMXAsITMZnMNw8fhdDoEn2AHWg2EqwpBcwpoK3cYP1Lpj5Yj02AqfQmreQ0wR5G9gP2rgI/JCPWhARtDI+3IJYZA7jHdK8zRuKtQqH3MW8JXEnn5vMwT4oKwvgsuv42xYtBllqCj0CjwdDfA4NTK8u5XnNirrdzeRz8I9Bq0dRTDJJHM9Dsrxfbc0ncS25TCowh93RTHK+VH12QImZ1qVNSS05r1vYkNNvg55Fa83vq4lOheBkx58qllJ/HvCyTB0YrEtwdTfa6QBHDEybyf7L2IYZoYZauemYQDqO1Yun5DwW4VgqeBnFdwgnXmQ+iqaRzaFR82t+esu/Mbmyhgf8wl1rOREyj6mI80OuImwiNLnh2BhsabUGUOLrw4Eyywuq+lH5sIU2oTy+3qiNrIOBpJHepb7EE1TWOc5aQFqxjTc1Iu56mfL7k5aUeOTinOvlOte7APi2yjirYwCs5HTySpQz3O+e3UMOFx4J6vuJ2aIxNY94gJLhBtxlfcuJJGpjc9a0jq1nLQByjfo09kvid0coTbACrrsU9X/HgbCjjdbFFvnKe93AGsF5TkfDiXl6LD8anhyTpS/frsgo3WeoJ6YXxObkVez6JplRWUE4S7b0z0w07pxXiZQi/86J2u1nd86iEGIzs/XVEyyBnPryIrSpus/mgnNt+uh0w+h6F2RVKzwIiFgtvKXJOB0domOmfPp0ppoEHZeQN9u72rKaKqWwzxvVD4nUHsv6wVSmzu+wsfkoqOs+8JJYj0Mh67uXKDmHfo0CFZaOgQ+agiy40N0G4fxOysQESxAwblxjnmodG/dTlApCO6v6P391DBpAofUHsChN/nIT5NpfCdsoAbPRgfkC/X1QoNxM3aNHlEdBk0pncDUFU5CYjjwn5srOujBp0mc7apKjHv3GmXy8mCJJonVlo6stMebnlwfB20HtlDnBWGJE36CqkAwEY2vp1W2ntUJ3evLkPhowItTvhFL8NbyE8WrDgswf4uJ7GDeHNSf2iFHsqeiEsIyca/rWteQtp7zAwt7zyj+4/4/eu7CsPzi0s4M5d92nhn+tsLCqZS/mlJbLBTmMghOeXCkgHAYd0WpVK8fqTiywjrBgeBRx5Wwn7G+s3VzgmdMOwyPj0puf9dlZJ5g1cL6JhIbR6NiNidQkFoVSKFL73Adu4YxRzakc9dDj7kQVbuuXajWs3KRNAvsY40t20gKOGN+AI6znRqvYKHBp8oxI7oyj9JtFekxEfr+ZekVo66QLfOB5CdIMiGhzlxcbN5acZ2WINjz25nJvKrCJKLH1CQlX0kM8TMDW4oV4kOQ6Bh0ZaW+pl8WrMccooRtw3CC8JHNbHjO1LKDZgeng/uXE9hUtz5rP/zf+ywdNj06YA9I2VS+k9DNRHGCXv/HoiOE56/qnPjqdfxq8PLEs4rIgOPNCSAHLz4UbohCMGuSUum5YMLLvs3bXdQj2l+BmiCSRB5MRzmYvgFv071xyfi1vTfTjUChULzXwlao4mzJZunzt/7zGzNOCiKPD1UyR20aKVvPZcILzIEAC+kphzcgiTETVu/brE8nYHtkeV5qLOz2zW5vlcLIflyf4RWjrb6Nrp8tjsUk7dxxHsSMt0Ggq8K+wdHa9ul6SKcowolKPP9oxd/ZHcLWdICh6U6D4g0f/w5XhzbuOtSKL5srE0svCm1A3qi0ePszkz3RAJpk1RLfjA/TawuK6aQZR+ThteaIO8FhnKYuLYEJKYHFkvdo5514Pyc9XGMoRglF6EKsj6FmxjhV+Cppi79fZdQ7p2k4M2Z56+GWSXUNCI7M4dk+7kHEomExxtjUcdrKWAcqIHOsLw3Ciiv2c3fxhe8/gsPQgoDZEWj4qtMRU3o1nyfcQ3hmms+r6AuWinPceWNGSeuFpQFp4s+xk/mJT479wnfx1OM5G1lQIzD1sFLmceVNncES+Nf1u7bWdzS4ZGbs2F9b+ZoQA3l6fEe5YMDviDPZ2e7u9EiEw9broC/KbdVHQaqZzC87T6kPHexrAdFuXcNXpDhuoaq53piEXmtA2yaIQjCcWZfzID+Sf67UoMRgAVTvP8oKys48KrAvqfYtytPEfRpUM1U5E9nS83ZDDj3lUncCS/4DhvPJ2OeHWa7L0gvreq+4DkuxA2YatdpQBbEqUhKYdFxauRUac+g3WLV0SOmzV5KaOQUEG/ynadT9eOTojvPDH9Eh9jDhH9GxQx+ahW9BDYMcGeC5LhCaWJP+zMVQA7vhxyaPbhuNcn9Mj1c+bhNvgKTMF+QQQV7+IHMdeJ5ewYX0f4qW/EaCTmYg+huDCsPp2v/YZel3dA/J83IsqFvzeLzvScWnaOq7RjtFJ7Hpp5eirTSdWJtBSgqawLx1xt5oqYGJtBjFN/WK/tBUZv6wNeR51Sr97bj1ra/Mf4bkag2CT04DT7Fx358s1xKNoGiZPl+Q32VEFLweMII7zzQV9VedzCtQOnU5MUsGv2XD9hDMgObS69kznNxm89LEUlCCjWefC/uBnFV6o8Hmwo1HsQDismq20GsmYbG1zsoxDik2YJzdk/CFV5gwrh+0sZbt3doNTVmg13WfdIuMyTwKug0DrsnUWGl1HJcUR89tdMHsTUQGo0M/cBTk4fGjdEGZ5QhrvkJMSnQSiGQkf712qx4UgMD1i62BHZKSasdOfBAO+TYyBQYEqCR9aEHA+1w6z4TNf4YIxHwi5xCGdpWMFNY2E4YsWpekAD9DljZY4byfvVYWZtKXsNgq+Df1ugFT7+ws5LNDeMUNQqFia4uoB7P2aBz7QZHKP35aBHX8d7jmIDKtngjQF+XzNsfNLgbSd8F29PxZgQeh7D0xczgan4L0jobeHf55Bp398gj26sjjjsd194MvIf5UNyt6pggBQnh/Vdev3DtH0662Hwy1H95WC/Sip6c0jeUQDFOvN3ZGSpwga5fqn0TTUCRxkDmR5vjIBTDt0s0gTZO3ky3qYF/2hp12VogCDuemHa34Wgmmkib2RmHUS2sJH3f71x55uU0wyt5489Adv3N7s3iEavPWMd2aQSSgQLysEjvAYetKwaRMAy8Sfm5taQJO0qu2aZsBrug2WwcbnIjMbGWCILeUkOl+D2ueALEguwIgPjeW3STzMClsnqSgvj+RzUCuQxDJIhYBWAo7PIZJabcW0+F6MywhxePGlOa30V8l2prdplAvxcg0JluHJJbnsAvHgiVh5rCmit3vcAoE3PN3R+XLmhVE3RIZr7bD8QKTNC1Mg/xVbKkETra08womLeWmk/JekxIaPguI4Yhc0krwMElCM9Xr8Rz4boeKv1/+Ra4VecY6KdhRM1ZL09/VfeE12LLQSHCUjXAIa+6TZCSPQKm3G46lxIRf+gFGc9qyrh7SN4bq1ylxVcwWno6uotxjb3cXXOh3RfgTLBMZxDqAHTNI8ycX/XslrYGSDztT4pqD6q/b8ccIxudAUBb/yjfgY7v8FzfbWwXkpEOMINvfzjw4x3TgCehHT9PekE/hbEeGhwf8SdehgDSMIKVclV3EIo3tHi4rxUVisl36xNdc5mc/iWfjBr2QqfVHpQN4U4bsIi3z+uis3bnEknzqzy5HHY1bYB2+iu8xq3dwt0ZKR/22zGvPTXLhF1yONeN3iMaKt7ggDZIVWEnTXySnetf9UhXHwDITCxLX6KhbIQEKm6hi4MH1wXrYMTFAaLK2QEs5QOFiQMTLuHX0s6nVG91QF5Auk/J7/j5hjfYHkp9m2hZ74xI71yFjgx7HEQ5ppxgIUCFy+c2dojHuR2YSLBxJ7KPLWEMzrSZAd8HXfuyW1FW7gVDA6TSFze8T2Gf43mB+gc6ZOQvDhJUQImApfnoiOKqYWMFQrTxxgUF0ok7fhXHHsQpBDXK6A+aSqXCbxyF7bsGsRPOxorfum8L5/1T1pOvJel5ZgIHrrK9HE33jbV13SrgsD2mijiqfSUymUeZUumE+wFJi061zwag6QcHEDcyJsvSFJPQHl2xnS8lzDOyjCZTYP8dI271293Kv8a2Lphdonq1dYi4DavU+RZracZAQWoA2CGj3mtaXV2zFMNpKQsfd/1Oisf/n1vE8zBA+WTJL7mclBxEjIVG7impXKJEEtLHM2jrYMuXDXPdE4ny9PRWJavlS5Dl8eD5gqJ91bRQ8+xyb3xy2KirE98rScKCVyazuO9nz/MwJwVHLj1EE/m0muuh0rFbsStT5kQcUjmHpeLTxpNquXtEBOQ59A0Wey9pe2mtCvTrj3DSmsGJ9IkKqBZCIj9mZMYgWDJvacNSrjMt5U2SbRaX19IsJo6pXzhuh8epxUvNNb8OlUdCCMiLbgHu9FQ5xcFZoWBnmm/9ecPwDqy3hb+sLkbnok4/rXI9SzI0udwrFMsXeu89e1siDa8JU1xNOXnG8HZMmcbquPQReGD6yW2TzYQ8jWbRM0bxUSz4lmj57stZMEpKxiwQ62jCVfFe1+mNrKwVg+dzbJPTpDE1SY79rMdvg29wG3yiyTNgStLM70alqVzOxo/gKeGwgK7rFLjoV6RN0WaPfA0HsJFMjr6wNKjh54rzIhNcuKbtN6shU0bz1THLId6YRauJXo2u34LqORvnWD9pNa6IfAaIkk+7AA/XL6KDIxT5KWiS35Wc6kt7OChDP6Hj8PR+pcDfIMJGRnbd11Zb/AZuXP8tKGHouSQwPufaJvByvlvAwnNGR5WMyElAxIc8jhABMuuMeo1bTjAg3f81/fvUov6c6s1mfeRqlmO17gRIV+nVU09hczXYUOFTM/h5ORsgQiOuddgwhh6VsY90QWycFohp24TT0gHsyMJD/aFcAf57z5oF4KZY9dunrpB948JSH8/7gNqn7okdiV9YIEe3tFdrfSgknb/f5xJpRjpb83C33tWGKFJuwAF6GxoEtueOFsfnu/abLn4bt1wR7Ah749x+Tvo07OJhsqWWYy4Bngls+X+bUDdHTdqAYIsfbK8TY0dQM4CYA0zQZGccHT7cs35X2kLdWVl7mmkwBSACaL34VAXyZPm8zy2BKpf5z88eo5vUe132V0JsA2psQ2N+vxqmXOa4iyde7WzqXEhYycBkiDcWJS4nRmlniwhQ943gZ/zM4E8d5C8/BgKCq8ZXts/QZY6HXI9K35+XvwhcoTAk79Sfuj/X/9egz96wKz5vv9sUdVnJwXIluYVOE5i5xWQab9rAbBGq1VsAGdObWFLKB05x1VTWkZe/QYclLUUZ9BJ6oxA/UmS0uegJQ8hVoViljciiFjhoC9f9Eqbuvb6Px3xuFqtuO3dE9YIRX00P7ONA0NPx5U9+YzSKYVDMnIDO6s4fXeUEDPnUc+m2uWkbNghqHxv7si3VKKcdZClyNj/KlXUtStLcvia/g9cmWdd4lmt+VS/706KbiUs7EumIN63pDbuhSauQ2e5Tf48R+8D3t20z6HisABjjfmG1iCTRWjH6SOO4ShBPvumEB2XHEx5TnUlmH8jXmJiez7oCvl9I/7F3lFUBD2qH3b0qDwYzGJdXJwSPXrGsVCfENN6WGZP5ERtwUikkH2hmgNVRYYhkXEOLYrZPYBVst2EPG493qkGsEn/sOFGc23BrRhYyW2mc6QpZCYIXGMcPajzJl1J4IIJNJWThiwmMJ3llFubxQJ4UCwpxMrMgjXtgdRo00sK+4EmphGs9hvnDU/I75SyjOaZTj5enz7JCYzh+Oh36n7NH1YP6XAfsDPdoT+f4Pp4pw5CT1ZekTz+SlcT8rRkt+wepe52jaX3q08tJYC64nv1wuqYFl9xktnWnSOE21qx0UbuG0gbO6O+oRwOQCumG1FnotEPOJkM96vU5x2H6F9ORqimQl0Uuklfh9iE7WTysscAIfMtGGtRReaI+I3DkQ3pXU5AzAdPO5p33os98bt5rZcXRNgdWCnM2hy009/14kEeW/WAoo8zhMTqMR0Qvd1eMP5pbuCz9IfY8vWpoJqqDsBKz4SzWLre/x+2CWd1Mp0flNkfolQPbqdjj118+n2ZFON7jsL9QZLBZrvBV5KD5NUZTiBq0HeYmtPzb9HVoJduPibY/foQqPmXYpe8LrFkYC5q3RH0Q1qs/UJONaGSimTQQr12uQD3eJ/yRk9BZmJNb7UHMTLI90tf+PQ7Lz1TM+hO54O070zOPQ4GEzrCq20Oal3/BPcPsaGXL5pQV1nwJOKuve+Ih2Fj2xV2ndaAkZOiGdkR8/WJLCCE5RNzb18teI9GN9Jsjo6ZaMEShiA5nz/ig+BUHl/TGTOuvB+HUZ+fiXWE9cqg/W1LcsyxMKkJ23ocr8nGIBbMAp0sA66Fzim9L/M7SxJVuYEvX0eEQBwcvgNL2kUo2ikOhI0fSNPGfXLqP6vkEYlhOyHOSL/PtVxTymiOocdk4EcOx9iluKkzHF6VgCKrxlL4/nWMoinHm1i/9BN2jjlDUpcK5GGsyjKJTsMCpcYgjC+iCATh0w4RpxflLQtvJBpWGQeNyTziNYlS9n8C+qNeeiIH6Lv4bMANxy9SxkFIeqleN6iFFVw6C9aYpsg5LVv67uAfnoUx13EBcpEXTyIh+/MV85n5ocqg2w06rYLheb/JVV5pdaNJDhD4u+b5EFnO+Nap2M1Gk0InP1Qut4O4yAlKgMsanhjCSVnde5YxGFizUXNU6Y0rZt6bjzHRZbSefs41ijhE5tc2DyBxiGF2yf/V7q2fC4kay1yTBW7Gh7Y9FsPyyBWzXPt+psradOOoQlrur5nMmOf+5ERmjiXlsjBtbuNMyGZnl9m3QFIsEf6COT5GU7CI6IV2DP8XwyseYubAv5AIfQ2501mt0WY7wLCs55sB+DAdwYEsfiiECTuRTiR9VfTKypOZ7yXz6dr01Y5C8/Xpqxn+idDoc7qyIbH+NjkHX9itChls60GNsMYnSo3WJ30ZBMVmp9Vn3rmxzOkzDUYexifaCKskn688Jz7wvMzS2dSHrq63/+5V4OrX4Md+lRpoWd1GywL6QqRNOTfwokPJFAMpEMSqbBkQAywqbeQBZ+gqpcTjHcUzGMk3nCiOr2IH43bE0WmL+/m8uezfL3It1Y3EnmHn2KfvBsYx0DlXNK+LLEPJYMuj3+r/erhAO/bYM3UsAuiUZFmniB7eLFrZbrRWzviI9SVE+8rOfy33S7uoQSqSbz04+fxDeDJdBKloFBqMuMlgCjt9ARnEFovQdh9TnlRK5SrTObbr4KgPEVlZz/jWQOouq8SbW2Lp2iieHAFMB7QPwaqHcbmd3bG6N3fERMfi1B27TysvE3KWrH8fdHnngmGAeqIiLdlXD3y4JiG0b7qyog8bzB9h3HH3ifqZE3AQit+OpaGjAUUw82Gw69rL86ezMNeJeamUIIINHrcBVGQqxGAIUJHEUMT+JfgbPLZPFYZDVFBBsYwKepHmfBiJIy5/+3fIqUIC13sjRdqJdf45SlvbFeuclthYSH0MMFiUTVgs3k/lFpnIB6LrsMUBgonbzoBMoA/qJkrnDQh/4KJaeWG0Fx2CxI7W6wsi6bMvd3bCpTossgtm2utqU+jbR7iSPp47o4tvH/N+x+lZTz2OeK3XatqYHSV/coqaPuZBWtWPq2iY03WJhFU/DkL3nIFIt/TAZAQpukID0GqRK5cSwi/tayxDN6UduhmydBxuQiUIpy53iF3Ackj6EbnKiqUd391u83IE8P9aYNo2gbr5AG9JUM+jv30AD3sXal3ep3K2wZTLltNO1C3yaDIllb/t9DZK5EFV5KqvqhxhlyxgUZbdRtLYXLS8K8+L/mRxTmXq7si3NeJw6rpzgjDvaO/sDjoBouyR3F+y4A08N89SoKL7hnX+84EWXOmGtbZHAlM6d9S0zphK1/ayZ+d99EMYBTKqglRqdcPOGtYQhxUMb1Cf1i9enKhicPizoLXwGpYhDgCw/lkylCR33Eu2SvfwLW1z+gU6GVQCEsqno1hbDTFvEy9nJonfzgWv7+DChFp4filbwuLnuWwtx32M3XCX44GsHK06b6dYf5OgPxClfAkPqMrWCgzax0Mmx8klSbPqjlN8mPfgVtr3QwO9Ht42HF9X+hAV0vjV9dy+gnB5w1ip/GhucUIXWKQHC3txMIxQl1g4IpUaBz77KD5oiMbW4+qThX0mMn0WZukJzXbu0UHAGggx9qZKx3wPFPHLGSKU8Q4oPR2F94XBRbEUYakc+L26dHdAXjfpCgTCxe3pz88ldQzwMpaGMWd0NPLdDuEg5PyOftsOwbQNsQ79SzWkwOu1a9uRgC+SbTf14PdvZWBB1YHXYmcFKhd1Ri8UDQ5IM/AMulx/xdF77kCU3d7qHM59Ls3ty9uF7e7Mt8P4iV5MN3ACb+wm+QAbPiFnqD9amvWBaKS/8yIt5JvuH3Eq+1yNegu4Lc7VPb3N5rFUExYT7T+yZHofLijse1g2e9zG+ZIAe0NTUf1xAlpojcbuAzyCpwyl1AQRZtdIc2SstBq1v78HQwBKmBKbMsWBlSeAUrR0YR7AmSu17f1UKYAG/fYFuhrFrzHckSl+WOyOiXezpWt92TxOs+Ck+o6Umsu+3/2eteqNUsaLPKfhgM4b0vSwcBod2stSHIF8mxlOeHv9OnS9eRfORXBA85DvGRg9+jbIGRD0NBIkfH9GlitTHE9Wge+5tiITqIgFHtCPn4T7XTfUMTBPHG/G/pmJRZn0ogyS86wJhM0gxgrZlcp8XJO769Uhx+BpsU2+CVgphsgdkYMqHDkJlSpQlfGSOp47+12QHPZklej9OmJ7nEOADT11uVsX0jHFqnpO6WpNhKiPzB6GXBNnbQ/oeAne24/Et/EeazmNYcZwQKRc3FkttkYCDT/cesa90Q+ZyK4awvmZiFTJrQV3A4Xok8dZWWTgdM2jK/jtVc4RxPUH3T8N30DO+ptmA6nLWLt1c1fUV+KU/5DMvSLyvebAmREHacNsR9xKu27ynnnUGtnK9olJuUbaKQZo5Twv6CGuHdSHfQPdAMp7d/DTtAyG8h+jwHPXGAHduQ4tjJ5w7khHiaDzQV48ibwhdqhxXmwGamQtb+6AferfIfRSksrkQIuWUbH/Ruh1TJIqA64g6KxvQ5JZ2pyKd6WUUqzT5N3AfSMC+eGYs07eAfJpNvzpFGSTeFA32Kzw9VvYokoTScfEjxYnTzL0Hzza4HT4BVK9h21UaoFE4pQPSjEcM2Qa4kwXsVa5VXV8Db5+ljnNf9t025pHnH+Qn8rCsam32oFjqDUoPWFdERSmDLHrWzseF2hVE+6+ao2uNiSGhZc//5Jumedn3/4XczT/Bdrg+3n1SaKleSN1jFZm+UO7iJLo1Jn/SDJrrfoaq8qxRnsl5MoK/43WZ9kCU5jUTyaFcE0ydzEg25gnDZZh+D5ongYwAa7EGJgEVtqdjDnmoJ/0tRbrjeUEFKm5B7y2lamGi2E+wG9X7SH1mdl1V6LoXeiNd4CnsQQDYemxy1yTBu5eWlg5smX35Wr2iwpx3lsFR7KePwhDAsskkkZG8yF6WL6J9Wn9wTZjViQ6uMVuSSlOiB0S+/fpSgvndSsC+M4f5PwVgbeNTzEcsEmGSJz/Zg4wRF+AvDkmocjwhIs7CJ257FIOx1Jpn6ykD9n2D6UKyXFO9nSO8onunIh+fFJ5EkUDQ/IJbhz8/44DBW8FfBUlnZodOkjzgi1DFBOXhkZ7Afw5EmpQJomU7pO2dzOluu5K2FlVN+3j18rUjrdRip7EllFr5gvGQAaD8DtLWU40JctVbLjKc00SODnZsGEfGBpyZ9M4rIWiAM4HXBXKH7o4lPOn8Q+DsCXhxKLhtdxj3t9modlvpqvz3GxGWs/aAdUPo0VOWSYLO8XFcU6dWMSYEl0Yq6w/jIC0hmcXpBSk5xUaMZRXyNr+629J3TchASlJQNDFYPZJvluUcz/phcw8BoU78GkIFzsqbPz1k1UCU1FC8bnAiedF1jyX2pvXdSsS6nA71UdEmlZxouX4uZ+YVwsYmOZsyAzjVO0sC+hit248yP2z/zlawiChCf/R/4iL7C5J56Bt/XfGPy17CTQlYfGUuY9337FTqaYPbO4l56iMsA5YIgB/xgraFWr6Ke2Dj856RT7r8rkCVrkw8Eb1xQkR8cYti8+OpPuP3RV5bQ9sxd/m7NSPb++b6DiyTR+Ay+3rDwTQ78+PBoc6k+NShSsRqPr/kYjaFLzx0tNUdp+8lcE/MBYtvJcanSD4l8SUIBn8QHpifMfhIdKyYkE2a+sX0Tb+ShHZwLNxSDDn4XKlXngBTjgyUdswrYMhle2WsIlEYNjBJadKOSgZee/Khy/acfdFxANhpNPg6+rm7BRSQWiFNbAbsQutcoFMqNvg8hQRyBqZHeRIklrASQNQxCHH8gtwNG/qUnoJZM9jbdkGA1+kCM+p94dsHb6GiBcMbz4QACZxXOCKJW9OiTW62qvoJG8fOBUJW3emXMOlpKS0pAanFDRbNzw2lHp806/19gan8N4YvVmicg0BQdfZ9yp8Zfby0TAs0UXEMXHoKFQhj/sNjE6LuFYuPdvz/Ddd+0WDcItHzRmZgIvvMe4GhmhXuIDLXfpxpehhKcqeFKcjZASWaaBi5vwpV7txBHXMtKZLwmqtrhT4wL3/vkfUMu952x48X5Pijgb0Vwp56A/zUU19S8vBF1Ef8iSNg+bA9CLR5uIMk/z8qZVQGjMQYRmYFAPtOTGpvJJg/gvHAsxsV64kp9C/vf+PizDTdREnkiRZZVHETXGB/bJZ/6eeuTt/lcGIG4AyrwSG3L6j1OmIshN1+ZsBcg2SmNG4qE47hGw8Ei5pDQbLFfazki3i1I+0ZxPI6BUZ0BQd4hLpGxc2VuoUZ+5qJeJ6/PlWk9lgKlk5xfay9qTKUbV3wvFm71DXaYYozdwknxATujSHXTRveXIGQNlfBgAKqmoJuRvOT8QD3Am1XGrBhz9tQYji6sEDZ9oiqNV9bgmYs/2BIXBub9kW77nVorx2gbRWagsfsR84mdosKVyBk2WaISHvBbmBweHJxWh6Roe6sESKPvrI31AIEF7npWjWt/cYlM662Ti3n3BZl9JYyZU8JiVwhHa7YaK/n2ewPvYrCZPPesAfYI/bVjnbWevD3Y7Ib6C1fA6HRqv9gNI/KVqYEGvtniCdwHq2aNPwIFOGKURiZzqocHNihn/v/WSxngKtw5jGGh6pGpifUG7LxVsvbDvvPfTVhKe27Da9ji35EdMa2t0Hp9cQn7K/t04NT9LRQjgSr9I+8nimynipHWFqemktVIs85tYAv9U2G7Esn5aWRj9LBvW6prfLyaKHTYuV9XQIaGbtWHT7KEkLoWFbS+mKU/UYE8P21bh1CGxvee06HTwTMQ+Rm8dTjvIYtt8Q+fiJU+pRefFbGRyfu5N+ZXfn5EPZGHS9PkKQkqVOlSlvDjfVC4gtZgii1X0T3rUDK3W9Wpyq9k5/ILrLVN7uGYKW6w6PWDLBlHntJBZH6mwZbaJr59TO3vqT9VYECUI0tV3pshOEnz3eJY7zuLK/LV+8nFEfA4SWQjmUJJixkZq2gpQgpi72zrNx91ulRrUHzI6x0SCy6DlElY2LaODrFgtsl4crGMmMSUKzEuCxsby9aOeva5O84baO6SRmLnVTOhbmFIYfPFqxpI1tROapry+x5vBwbK9cQsf6CRCf8/BmHIaWw/Vpoqy8DuiWy0e/Q4hLkhIpqpOoBH1bCD++nVhJct/gKPOHhjrHVz4pNRe4cUtU2uRt4Ln4j+BJ3dpYo2VkM7dmsEPIqUrs+G5BCxhigE8bZrhdYTldPCDiERCEwIilJQII8/50ow/emfgZd7F/yxVvapWGAAVG2AAdHU24BGoRox9m7ac2OLPAf9P9wNJunzJFzba3FjkIlRCzQNCu4brty0AwG/9yB+ye+AspEJLXK85f4GcPnkQUxy4ODfV9vkM2z9YR6RUV7cvNT811Zgf2kZF57Km+oICo387byKMe21VQo7aUzAA+ZAxjxi/NwSzeQn/zmWsZGuwKb8LtyTvWsvojfV5KU861+82Z6mkowPFt2ejNJ6mOPqzcbVV+dFUKNfvaIZmfMcM8LtEBKQIhpPuNWogAulaTjMs1NqW9DSv0etimwkoW5AlFqaKK+bk9nTJJ3oV0QvBwC2FMf3X9Ok4u6pY2GtfcNXydnWij0MQf3ho+vG6DS8vOTrnEvioiNB++FrhKBwfrZr9sgLTSAYeh+BuTSW2st5invdnPAlE8qPrqcAPMmecxZItF1vlgrYE0hEH07FyKdb58pc3niCQiCrCVfWn2Or762gbiqmYdGO4rrzlPydi8Rb9Ph/s3h17XTL0vf4qPi+k/RVPsSa6srgLNLUM5dyQkoiBm58O6+e7Hj6O/9aQUzHIiBhnAE42eAW4bWgvD/mRm3ZHAih0FwFmnuV0vQNgnKmPbMF/IXHOuAYWpF9AMac6aH+GjnzkWbpZX/sXBzw02hNvScRuKHqkNlTOBJcBX2jbwgm9wKFzSopfDCogF34TXYLhP+Wbqok+0aGk4L3/a+Wrzg12aKvMx4YIE3T4OhSUNvoQAofZelm6EPhrSrmPqNgaSqHHHu4OeORjROl1bngfHwThUTkytDjZrFB0EOXtSNHAb1gwEKWRKHAlsB1BpDcpLulLUEt1Ac+97IlezP8OEkv4nNrOyuKRXvb9t8YERBbzoXlJXo77e6OVenMiGXQKJOm03MwIO432gMBh7s/OvcW0t56amBn/RoUXxYjbS1EqDymanuQf/m9SZ2GRf/Q0caY7EDDVAxuXbTCOT38ZMzudxD/oFsrnONv3DmA3l9V+FAE/YOAXy1kfj8tZfPT//KvXyafyNM0XIXpH6wO0k0HdgOYgV2tWLsOnluG0f+ZiLNwTMFipZaMQteG8i9Brg180w75Ic+Wa1H4aiB5VLHAkNgaVzorG/c3uiONhOjNRijSRIVpJnL+v4JrM34aMJczJoS5agngWCrV37uAI0/QM9GeoRvHANpF/L05I5x1d0AGhL+1wMrDjKICHbluArhSWCV+I//3LmLhQZLpO+dIfcRcKTslns3GFmtx3h+SHNSdX5CyTXVHx1XnDSqXXq8YIwwN1gTfQBc1y5COqUyBfxRdWB+XNFIWiCVctSv3BPQHqBWZrMRaA2vt66ROtkM+U/9KUnRLL0V2FmElyLxNe9EUDeiBv4S29ZGMmaZjbxbVbyEgTnD09oDf4hwoLdKZI0246Nr6NTbwyUH5Lp5B0AfE3XpQLkH0RARchCQiycTT/x3Q63B3teSUcGhrlGREOPTY8OXlv0l9K4/eB6I6CXK5eCJodN2U2D2u6dtW91h5mv3FiBwEPnse7l7GIBSLje/9XEim9yJBEBMugKJC07S+f/IgxxrBvDTXdEOH9YiDljekWAWfJg1GWn3oxc107oguoJbb3IqZCAqZzKvbCgno4005WUx5KSKv7bVYPl6dGyr31GrZxFqhKDTcNeIK84Ml70XMYpsITLAIqXb+sx4v0Jm7uvOI8rvW9VeTA/t5Wmb6UK9qxYDqx+7PU3Wx+px/FBEr1SSpVke7lz1YDmPJll2B9WMiWVfogzr8UJ8xqqNrIgCx14yZyfWpkvCzMuWDw+bmWFoznTv4SUXyALLnnDLJQBREStm7be7GJdxng85OTXQpMM7GO9Yx1Jz8Ydg3RSwtgiPN5yqSG7qGH7/4XYIjzig/INbGe09NGLhPz7itzu++gq3GmsgQyx4fx9q33W0KZgtioeQ44MC0vbfo2I/vVzjYyPZIOM4tTmC3lbOlr+A2AsrcciqVwm1EKvqn/PeGl33qPUkLN8IQN5PHQ7hWegu0Vd0R76cY5hBAXAtqdx4ROVkcSjuITcXiw0yh+x+0OnFv8cPv3j4XufHw1aUjvHZzSvZCarnNaX0DyRuEaM+zBN1KrwdAj43HqviIkGzRWlFBWY0ucKRiI3v9cpsr9N1UbgkH+YkXXX3RfSlF04NZptPg1cnydmZYi87khEZlccsUbQr2XmSRFqq53ZdJNhcRku2MpFqkoiTeFa0huW7aJfXsIh7lbdWQVmxW4WtrrJ+JC5O70sfo9QHMWwSvjyhhFXiKQ9e9dZT/XwGH6lY6mebJVPt3db47TNxH7ot3yWxwnUod8UeEI3I2wgbRCRYVMUn2HqipLNAmTQvXDNCcnPADtKuDcbRTNC3iuON8phub4eb0uPnuieLAciNhymOfD18H/X7DmERmMEMDx9fMFe4wWg5bI0Its1MqnI80fCvkZ1S3TB49J0IViJWAHCJzQUnh1uTvscitD2rpGsNg9wMHmmZNy7ylQ5p095o1VT69Swy4Sriaq1pJb2Rg6sJihW+EKNUeMaWRtw9n+o4gggjMu4duPFR03B4wpWrTLXBapnSOcpdD1M88WZyX0ucBnjrt0OGECXuxNJbtqovwvOXpVVTdmh742yeLQzeabNgj8rRhYTIG/Jsx7JTvtJu3DVStKvKzgnxoSzyP1MSHSYhkoTmlaQpVmzaxLzHjKtMC+VZUDUG9A30cbMcOoAEwtbvev6yMEJ1vn7Z4bnKut+CRhDEr6UjP89iyd5tkicK+6x3csPDi3+l7uQTqK6rx3oZ7Oe/JdrfpOuKMWSCVzo9aC0RLHLZlgO7lk6aMxkQBn41cr4QcxBRX4J4n/hCedJkCVjrjnfYjxNjnT131MWovJNckhH/5ooEcqdmfwp8rrXLjhFTrcRixrVvX6EItDOLDRtlPo8rajbABpeHJ67o14vW2hvNAP2T/Fjknwkx7U4mUe6nz7KNz9rSqRvy6H/7ezDhGPOsgZ1VBpanoEgX3bX2f/6IbgQuaPliJXLSFhfhPsIksjQz/Paahnd7HbPNtfz3j+iFyaks3ve1TZL2qs7fXIIUO7AU3L+uvjiUePI3mER19xn/FS+N/Apf3nwevH+rUB27j4ugoS75JwdCqEJWP9Jr/yn3qBwDcZ18NKHoQ9VvFPGTKGqORBOecPHmojIwIM1/jrbc/GBg+Uq7Tl5oexy0u7fIq4YByIXfe1kMrtKEI/pestVvRwDtvIWcCfFSJ5x/L/YgwYJ86LIC2ZBI1kGNJlN9+0EdSo/RisJHy/QgQvQ8DgFcr8SR2vt55LRQDzFeJQk8iVYbo/KfUHNlUpsURME1VB3Vy7XJ7mfkf5sVYVhK1to8QF5mtkQAvxDIftDsd5O7kqKB2rDuBWhYKtpv6Mh+IUu9jGJaUjE4T4iXnpBTJtuszGUeXHyMpWJgl6NfXzSfZp/FlQyd6FsF07qIKKY8UHH68Z65lhYLTbh0hp5swYW6NhJ2Vm41E9aTk0LeU3WHDspJCT5x/SplphRWku2Ein09m/tFhiY7rBhr4x6RuhHAazXTsXSt+ILTssBEoU80VsakHaCx+OZcgJi5G63bFeG94FGMAjoFIZNIX7aYvoqzbsdgZdpx92JtpNsHAo4LYdbMbe2EQQqYVUrYiJXUS0ntMIZkP4FxHE8eQtUmgJ5tmIMbcE5p31UA19oB+pzLzwpJU23TQRHJKvAOBbYohouXTdWcjUk0dM6xTcxmOq3jcJ5B3nUuhUHwUStALmCV03LOfaiQflxN4kPa2V8nIN0Jb/nr8jV+7aHouLzh/4koRg5DUovZkY2IbDRwomHASwQzK3NNmr+bxgm1HsMPHAo4dHnJzwZT1lGgQw5kV0RMK7oCmRfG+RbqefnGj8kRg/ZzZ1kjAnPcMov7d6YUnSzuV/X0VFLgTfkXICHMKsPhriDg9X2+hjR8pq78UVc1Xcb/rPng2EUx+pIePzWkyF3pTQC/Y7ROAjrRIbghnSRBSTm6cxTfZmTL4e1vCpI4DRYNG1kSQ3eoCHK0OlK5piFCMXwEA6zimBC3ml11wdC6rF4CWmC74C82CravuLeXZoPwv17vq89QaLT3dMhFweSePcb6mkgdfm0jcUrJFf9r7UJiuj0clFFbnOynAsvaWmTp4kpa7MdQvDxoxhk9lTiMwMwGNqGTCafelHeIpDF4O3rbVnLhKmFtjQ3Hm0emOLW0CVlRY324nVWZWROy47AM3uiC6btJMTNMRUlLFo8z68VDQbxXux/ZRE4s6W1cyVRtr9sq3PGo/Bw8OWHt8Ddz/2EapiDfAtmsBNwWQ02Wj6EdOBQEoH7Yhdvf0q31GzV3Rfp8FcH9HpzPAe5Y62abVVotoy7uND3KXshwMrwAnuhKs6e2DnrG03bdYXevjCee1OR4jxGUfWO0o1blUiH8SdY586ew5ks3x0FQe7YqovPkj7IDqbIZtHta7bMqZamWKItx4sbXq373u+wR0yuLwI2lFnw6pC2o5/kpng2KCJaUrwnnDazEy14qM1gKE1OBpa35PngLHCiLZesl8b9wSlZXh3yXQVGhLFc3FHHVwZwAy/sjVV3Hg6HqMSbXCvUKyeP07sAyjE0is7PFBTyyDjZb/izgjrC2s0mrnNIitO5sF+hcXjigb9yG5t4FzXqH+AcN21Dlq3mSKCW7Z9mUtFL4O1aL1P9bm5Qv7VGJF+7+dDN5Xw9LXM2B0v5BKLtfWvA0zAvCTE7wejCiZcws9GvOZM3XYJV0/KhcPtFxwU12Jf5p6nd3a6Ynj7TEdrg3pPtxybaMjCMIUdypWbF+lrwBWjuN+aNeZnL7UBlNfqy6P9tjvUfxHtBL/H46Qj9pTaEAgNgW5/tVa3ZCfZWWwlI71dk+ccVXDgA7xWaKw1zzA/+VPGazersIJBNYT44OqUGo+CSP355BN8E11yLwcHiEB5x/Y7QpAGuEYMTC5p9XQjHyaq1W8RfGmg3zvvU29OLv02VCyis6VgccJ8HggQZqblLiJKVnNsPaieK8NEHdNCOTw7saH12YmqedLoEGwJaMJnPM4Dp1LiAJJS0LgvyhrLfg1X8XflNL7p+JrDpe2wlA8Q0qqKQYMON59aszB43uwW3O5ppOufrt7ZtudV43OrDqIEnWMbSRzdT5ADdeAs6Z2g9ib9FlpyNfu7WW8FilZ7mOo1ToBcegIH6EJLorD/RhdXEpbk3JqlBR/cOCLM9TAI+cYI+fx+qoKt3z232UCea+e3FPcXLhbTrxQ4BhpRppoK4Ouj6X93suCuGFwZXIAktHi3bTTr+2BVf4uSYYPxKOCiW02X/vkMzPHVamdC2p9+zNfHze4LOLVbYONzXz90ddY/XEObmJYGMXbB+WavX72ag88Ua+eKm+any2+y7flXTQfhsHc1BlxcbW4W1dscoags7g3V5gayauqjfWIp97FObn9sHkBHsXe179hW7H2zY6ylsPNpExLT1+6WrU2aD8zqxQctrK8thOjIdVooQ2rk3W8bF003icrphc36UaWc7VkH2jLlww2B2L1QRPDxsqesH5x7dGoI9vR1BScbxYNzlPN2LJ7qXAmCpZu0FkLhrn59d2gYNVcHWPZnJI7ekn9HnyNLJNa4VKWrRdYLM+2cFUMzszAlcKmC0p9/69OnxSjNDu68AE03WkgdTu6YFT78Vfz8aF9YB2pBbx4Zxw3GSE1nDonKK/cCdG8lTZX+e9nSaIj82c7oH1H2r5X17reeXUO11g3DGo9FZptKcgHs7vZ5FN07NZP6RpnW9yvSx73n3IVQQxqMJnr3L2XTMsIMBovda8O1qBhVAwwsCpEhk3DAUoSNo164Ytf1c1Mf2/nhKZixl6DDVf2GsJ9yTBVeihiSUWwSbwbhXqnnoBcdlSeUAD07y4R9wmCFhoP8CdUF9ZkNJuDaSezEGT1HjNXStlyMCc/R2e6AZa1NfT/jdDWM6uKtfoS//O8ifkUBEtdQGhPCiGYGFiJ2FkRbDCryXma+i7Ji+/oRSeGu/+ysczu70bkx6KBz+qU4m5zIhoadPCxIuInHG7OkZR8tXg6F1GkS7gaqkWiSuDA37aaez2zs06nNjaCi3u1KMrVCTnTs9lf6HOCvtakKnAwQR3azAgyB1vUzn5pkRwrOSW/fLBtTQ08Dnw6DkuTtAX0CnIGr0QlEdtraM4KSV+SII7yli7Fhe/rgMmWn4vI8WoSyh/w5O5//3dqW7bGF8uTYFYLDJ5QJi1+HSw6S42FWH84DPzjXCIwc+Cq62dB4RIJ4hKcICv+6aFzX8N6GxFbyGwR72LY8AMOovYiHpYvGaTD02qGu5NUEd2gu7hMMpK/Ioc376DyP4+QshXx4jFIhKq0YKbY2GxR/OwSmF7Zxd7x2RP/4J//FCpdVoh7cZ7TWMA3p+E1e+wiABlfZYEo9kFpGJratlRFWhLYFj7y026qLyerG48Cd3R5Fkrir9thQCOZBywpZyAcOgBr3h9Ih2AQxGe8lxKDYLk1u2K04gGl4blobtIG8EkvvreIzyJHOt7EfK6ec5mktosAnBa5yc0MZx3eDc+7lD9VgaKYd++2ayqew11m/AXPyqInSwQMWBmLxVkihnP+AhtIO3r4etG3J+fxiwoptRzI9WDwuK1OGRLV6rILv6MlWm2Kyw722Y6F80nIVtZg03Xf6WRRF/MYxGVwEOzdgelA2D8Ntzb5/P4xqeRASDEci8fNTNr8+xhXqQf35E6EdZCAbteijtkw5IY2pQEO+zKtZF070QC3NupXTzoqeAqfyYz5OK6r0hG6GgoQJ5ZtGZ1USJ6LUVnvPbgphB5mLjvR/22TKJalaY0PbMhSdT+ODjSeqTt8nQkq05or0nmPOn/ArhwgMivSIj0gg4zK/vkStAozsfqX6taj4/VzJsrtz58eO0fqoTRa8gPCki4naqsT5OEN1Iqao37W/wV/y6r6l0a28MkmgkcRmOSUyeZbYBiWSxt6ueQvUCgeVDaZCbLFZ6jiIH0nqhsl0tWcAsbkcA3sj8V7Itt5RixEKIkDNoSF0UjYz/IgCY25OLAm/zpcGU0P4BXPmggvZCiaNC0SbP4rJhcIzGO8aqA910tve38/YhYfcAx8YbEBGc4+EHnQzpSCr4y3TpIuxx7sYxXb1A02weCpK3kv+L47kF7kowqVSFm4WgF4vjdfN05cXCiU210/vYE6L8YqCyns84sRtX/lqcHLMA7SV8+C3mCz5XsaMfhpFNdA6FSnAaM/I2Kx41FMP8HBDLKeaDlkl1Co7Oq2iO/cVQ4B/629JHBjm2o9g4HbdPVfmyipPSF+SZgs+UG+bpQEP9zmtPRmUJV8htGu65Q0VTntrZqU2a+c+Cy6IyRlMjhFHfH28RieVYAIcGz3EgVEqrVkESDKbDlIrRjyJAxa5oKmfDBTEM+lkdnowCTnjx1Uto6fpoyVCnSqD9cku9BMuS0XcRlIhFNq8pEJsl2ob5Gx6WcwH3auaGckhzy/cdwnQGijHHaV4yRcd4I/fHxe4gzPeTUmz0tBOfKDv5K/f4aChpoFDXop87MPlm3gk63vU0RPjwl8OT93IECzCgwLZPR731gfrE+9h9cDCAMt3LNLKFsK1rivCsubmtbqEfBiE4pu8UYq6Wbj3alg6fv2sZaFhOTa+1o26rO+qm8MYioDbmw5hOcoY++qQOzZmJU7mWmVCQUUqPpC9WiUFMKcg5E/5PGl4sDw1b7z4mJ9lhi764O5qGTnsoYttInwbn/spR9g0Ajnwf1El8wnUgNUZsNCloYUw+nq30smOKCtApNT5SID61ab5TllWE85n7BAGrh6mUAnNX/VKh1dUWXdc3axgXzso1NVc9fx5QNizmGMq95gvF/sOgxJtmEF1n2SafUR4sBuH5Ew1uE6DqUmamLyPq9R9rYesgNgF2wtnFSQz3z1oBjsGJYDZ9oMHF2WSWmX2fMepXdQHWrLXki2PBexEBdvg5+xI5bK+nZAhvjDMncKHrfkAqHdloyq7muhU81N0V5oaeQhDeSb9VH+A584ENQSiPny6V7TOxtP+jJXYuZOHmYuD7ej1Y4ZAds2HEdamXmZWURoGeljDxYw3kHZlCA0qpDbJXTuuLaqIV98IlIce7sy5jvriC1ea96X92iSRT/Xr/Jxepo1XQwgJuomkv6E9ftVEAYxUn3S9y2puDLfC/J7bNwTq2qMwynLrCMxKq13Kfp1SKTbUhIE4GwzzzndWVBz6NKOgfHMTk08qLbg/cW/JLgEENkXalK6UZJztvn7nsfKCFlR4cgB0P8Z7ql/R1fByKaODkO43xaC+jULFVUKOLqWQyUc51VlVhKWMuHvIgV9vVg3zbbEnlIFqkOdneVgMktUggh2NXm2V32pzdt3sGJ30s0aulcuqjhxXcQanprPu0a76ou4OhFOTpf8Fvy0XGSbbpE6w3jin6aHgWKGucrd0yc+utHPZl4Invi6ZxMiwPr2GDi/zhu786QtWAsxY0TSYEPuJxHBS4vKessXP8lbkIBwnKsZlK2pbDH0mc8K1f3HDNExWAfMsA64faO61ZmXI0FnAAE+7GkAob9+cHMAEwOmRVbf0jEOn4hsL2BJo7i2R8YSLxJzHMq2ljTvmE9sTc8FZaamwUb8llV6jdEepAVRypNmfPqsBZkwZnYJb8m6kiJHPoI9d+V3X+lnoonRb7Ribhf4+TErTxxnsvj3WdzyZN3K8G905tT2zn8vT53FJlkEmTKGbuQHs4xJiQep3wUOy1TEH+cuct5mbIe881Ds+kyhKBPepZz21nRJGbR9nk7MGp4p25sRNuusRevZ6Jkg+oWDhuW+khnbMAgB+WoyClt0CtQsCY3vrp3WohEI4fFocKX8BVQT1Ac2atBvSXfm3SggPq0mi7B914UqNsJTwWq6KtLkCtLqWNFT+gPZmupQbaM/3pTek1mDMrsYke3QYOdMjSzkJ87dEEl7rL2aCqrxFnrh3vKuajGlcdyQy1c9aU9tgGU8in2tUILXpwihUBsLrzHlRTVBGdpNbpMhb4vNeaee52CHF3d6z3IlZc4BSlMEiuosDLCFL+6PrVzYLm8EA6IRoBVeKHp80vvTBdWV5aofKJY0qmH4BdYlAHgbSqs006TPvk51eICWjN+dhGH/QYLRIKs+zQHb0wXpOlEtpttWhTck27nErmYRxbMEJp5Cq1bplBYux88OYPs26S9hed8AEH/NrfsAb04EcyEPWwYNkTcEQR9ySJ8X2pNiPpzvYkqSqBNnTe85hSupf0xgkLrlFWMK5USllET5ScZCHNvyi0cC7dYLbf8cErDMkECpaVC3cDlWCsawZuClC2q1N8CzlWuXv5arv1DbiAwk7Rb8XZc1cefOlyB01ov7mqncSCjrFQlu8XnlczzYaBl+mVeCKF7LBEIAkt+IWMMMao1CS4Ws4YnaBgfS4Z/6BluPyhqOdG716+w1qosBYgDWWcBjExYtPYVwZnICLIjug3G7z02B/hoDwAly8BUxuWanazHC1+sD2EvB48MdSZipLL1lOcZ1kiY/xBL68up+UR+9TJgoATzQRPY4vzmgceMU3NQhttKGCcaLu6AjpExjM1iVPT/fy+gwzNdCWXlBjrlW74tHSfhhA0Ao2pVK2J+KzOzMRLktDoOvUnyrSowHUTF7twna6KIMJrxO2AN09Mk+mUYYET1uexzpaHXJ3fO5TS9UCPSEAE8x/CT3xd4T6DuatAaXXr0I5aDmdKznUqMHm+mjWf0qS+CFudwl/k87yw0iLkPcSgo2zOwUquE3j9r2DS3BpG/hafzJ/nh1my0AGRBhsQ9POGswN0uMHiLOfFnEyfH2VNyddkf/0L7qXyDh3RWGBeSW+tmQGNf0lOPFsoWxAbrcmfCetuhTFHVMdf6uCQOp7Ti9koRrBSDAyenZAaYFqZEd0EkBRxEC8pnRx5aouRbxDZaGauGktfpUJX0uKDguLfoLNmD6/XBtV30ypEhBt+dT5rzbLfdK4HXEkGyITzS/VuwiLbVhmzUqY3tJcHX3NyBAWaDol7tQr5d74StNBQsWIHkuBuFq2s7PqQPX1N4InBrtubIghrUQabPEm3k0ri+DRbiZVS5vrw/HK6daFf9uvSCTsTttGk3qFDEsFQkNFknV+6jQf34gBh4BL/xYQk7VcYQ2JdQ0K/rrrv9Qgspf+Xt86/54WUORCXypG1NEGdTBjy62uEvbqdQLucLYFE2as9dzCPzZL4msJ2wUk7rr9hviJquakGCe9RpHmKareEKreeyvJci89a6BRk6sx/ZsZucYeHsu9UJn/Ley11UVL8wu1w/pO+jOhjD/J8ccNiGMUSProdbmLtvvMXvtEv9S9qE3c0xvAYl2l1byt0vJonBL/DYv/DUCSa1gVftq1voBm3vPmlSHntGQBezcNp2H5VRyLK+ZSF0hZO0sUktJGiuKVoETCutlPOXz1AXAkrORKH+MCzbQr6kNKiQccucrMS79eTarrAPJsXaL8l1ydGjFC0sH7kFpcu8ziBhuGjFrDZ3MbDmrr1wBqf3TRVrdWnVN0uZBP3NYTrrlMKVxtvGhQiZLvX7OjXtJ8lMWWBOvPlplUrriQrH/LZnFSNPjZsnq4ErqBvubUM/iHbm6EIGkwdA78qp2Y4QDvq3xUp1SIyPZ4EYVMQLihjhD1NlBlBsvhFmLg7JBpyprPrLXOkgKivHvslEs22JRsNhR2n1IgKfd3M2NsqSYeSYJHxNNwpEC2Y11uw4x0DWM+GLCHuY4WRbCRC+4JgIwsr7Efg7MDUTD7kDWHYeTIT4gxl79hNNyzrg3dLdGJiGrZpIEM1MdKgoeJkk8YrzGHfAWLDDgMAx2dCp75emQvfhoW2owAUzZIjzAOC4CFEu4+mz3a3uQhJlZMzMRRP9j/q1LYIPuh+rmT0mrS81uebHZd4R5Q46nmzkV6H0VVX+o7REe2nY6rOwmx7IOhKVHq49baMukO/bTqIDVCYRn5WOmiydyCkaM0ms51cEdX4fMKytzeYLJDrDcnGCbnxMkAvCYGYUHk2w7L12tZ85Dumagshsz7y/Cx8HMRym1NcCd3ORY/VVK/vkHMVCreyzQNIcHc9ryNFT1G3zl4k8V8xs1gTd39c0hw6jcCeTs/3cqRXYiaILlUZ5RYR/4WhvMtMNG75CdUw9rDA0/tqpF9dTuY35Gjpr3pKPBTmOBUtc5wD6wO8tIfmDO50K3uno4rxvNG3GaefKWo3xNF5kEtx1tLECAzV7YltfZjgPEBmXXA1F6DDJfgQGGnbB/7JHcd3/zY29rd65dHAt1i4ct0xwMLavrP2S951PyfSPdLzFaUDdyXyu8gZoRecUUeEhqWvEsACbLEqwSCV53wItDMUi8MgCuQWBHRZLLzF9s6HnGRpUd3mX9k+pw8QV9p8w4GKky3sHCVDBUec7LgBaE0m3nT+VSaXbWhswZ9ibYF/jmPv5rQfExEpesRSvQhsCBi2CRMEGB2ZSz8v8jRLcjCifuJESgEXT7I7Nq0jODdVqhCA4CfIVvnZ5ruxDS7wFvlI9cwUSCpDfFf1hr0a5sGwy5xoPnKIqP+xiFvGQft+NpvJZo3oSNeHdn/M8VRqiDekteyhYO59e8x60uXX9to3osJ4udaOd/BIyoyC+gDdCmBxhMyDu0pDQU7rhTfFOOO9GInqgOLTU20I1EtBFWYpTUhEi4ckU0JjaEXNEKsdPqvk4/zSE3iqsd+AHBO5MGt0y3JiCr3EOQHvyhwT2aCJqlWeDWflBLbm2D0i8R3PVYhU5VitXGelqdIwFIlb9uAELkZZfsYg1Vxqd5yQVlgFW2sv899KeH6d257Iwx4YbgMbleAOMvDFfxpxiqgqCETvsGRQJ+SUiYWS+EghWf9Is28XbnViPvJouVf9uhie3QbhFDkRz1uzEabKNOIkpJ/3TIjP0dXV+7TYXII+u8ALUr1yjr5+7I1I/rMoMQjE4MwuEYHeJ7PRbkd4rQrLMhmc4hM9NcsnNSg8VK/NIfabG/sHpNQYamg7Qv6SnBLR6f+ULcziicljr8I9Q9jkykZld7BRSER2xHlLMa+zQRlCHmlUCIczQ8dU4hD4Lzz9L7pIpPAjn5W8uXgVFecbKrTBUQoMgUsI+5dwyFLCFGJy+cVOweYp+kZDSQspiLZvVWMFQnXJ0FbuVP9P7I/e9YZ+/3fLAcj0w0LxIwvfFTmHoNT8IDDsF0RqqXlHTBMBiOprjHNWDSX+cn6SedV3nrdbgxQtr29/rAW5O6cFaVHH2wr5kmQ9ghJTGOyvsZI0muORRmvnlAaWwRtM+aP7PZ/n5BHXAeIQsrdZirx5bY3yA1tVZ68jocGmfMPIStM1QzOV/odfRKjiP5aIzp0G9YDsHsr37LJ6GK97Nt2GoD+YU1DlBO3EXy88n2PY+kol1ZtKs8FLvbKVLk7BiPsvQA6UmdD/nl6ugjsc6bn8CZLgZVdmRWuZrvphuuiY25m5DXmN7mJDT93JZhXTyanz3Dk1eq36rMIsLYn1LNtKXHrefE0I5h3us6OOszZpFkYuRF49TzhnqUA9zru5AukPL7EOg4z3QoynHYC6bNtwATg/OLpK3DT82izWw2LhBQd/zCkPxtFGOhJHzKTwC0uZPPeyI8e/gApZqMjMX6L0hTYz76iewK//5aiIoKdxLxzF5gPoTTaBfkSoQ+WomxhFDT21zS5hmrxc70S+8DykuoLn8fZE4C0UApi62w9+u0RNaiK/AAMDO+izcaeyhIa9ZZl7AJKDxNEpBLyBP62pbHe91CypiipHB6Zo/4zr7fXnhI/zr5+WQtKmEP3F+1/5Y2XlIYccKBDBFvkpxZSWAJjhEQ0IXvczrza2CpaEvXdhaeCSqMD8NNYkALGqKs3o5OsMFFTd+BG8NLt5UrY68CiTvE1Ewqf79xCdiGrp1AwQrg0obwdgabIqoRFFiHSv8mY1eRyY6Dbhiy1KYRfSF48NYDqwTyR5h3c+xwMXU5Cn+hpDS9l9arIk2cbHBIQMI/gpeXKGdYZzLES3Qshr6EouELVquLuRs5i4YEbHd2I96uC0spzHoCkc1ZNPMjBLavEjPTd+kqiCjPm/v/g1ypIQLbXrcNcjc3zYQPqzmNYSZIycOP4/h8W2ziNQ0m9DLUutKKwYE8Aj4D3mpd9cg7iBfprkTZFgj97s50GWUjCoQ1j2kMZjR7XlHwJmZYMbuo760LK86OWyKrJfYqprND56X2E7RDAnYglPWVoba9ZNUOUoJ0gl9zabdIIZnPBqwutlk3HxnUM2BB1X+7Svhw2qgEghHYTG4yZe5+kODvEvalcYhwHg53EaAj9EqA9N+W29xqX3SaqstEi9KCek/9M9QqUvn/CInPAFHOtM/VHbz3SAGGaGZ54gc9xP7gjqVQHWQMx0BiNGRMl3+vW1BZ4oAigePHi4/5gs8xN4YCyGJHLLoUPAxu+rP/NhyXYf64YRm3QY4rGTK2qTSNkI/7vWJYOCyWwkPrMEHDaxDUfIad2etG82qikzlxCmg8TZGjMUnuaIFZU33qTPIPaNKQdub5ZzSaY3A1qF+02Ham4YjgQ76DBAvCF3lHNPj1Lg/P45u9KXiTSM9Z04JfJbChNyQ+P4JcvDgO73A10SbqyQjJPTVu8pdb9bt8eDPBIHdMMkmFXz8ngS48liQuw/lTdcaLa2lzEBRCd9WhOmkKWksg7CY0vde8eDSvBOiIFA2rclPpbhxWqTsPezSSM3gNmmVGXdXo0KAjLoNP5c4z3oHlOfGsuca9SpIdLQC2LQUMi1a1ZdPrBcuT1RxMSjutz48CDgx5IaPAHuNoucTRfihbpIgp4YsnuPM9L46O6ZpfcGMg83cz5AqHsEZSNPMY4oFMtyQi4YhtP+ZsHUUIVA8CAmemK9i58c4Z0zAc4yXazhEmONiYmBzKG+/S83JMcIwfIRmSkOBZblEobmMfNhZAkYz93/JaNL8aBo8N9W2SffV+dGBeNJPNsy59vgwCUx2aSs9am8/VMLJCHVlv8clb/5Cj++I3+OvcRyYc9H5zDaRHya5UbYCzVqtVX1iFgOw6nzXgFPsIphQmRBG9cdiz7yjzkGT7Bs1hQynamAQ5BBUgGpjxrSy7b3Nd1M2iB2HM/+Exh4E66ui/Kaz8AITBtW2p8SNih7DgLEmmyhOD7pszDcmYDSJ4mqvH36N9Nzj0cYmkdKvu+Zc3Nsvkt+T1uH2Xy7MuWW8udolZvUKQtEkH49/NH8gdybBczbCi5XKEliMII0uab9RIHpWLqiGm/QEt/nwBh/jL0yAn+0nq9/b9aSGTJUakPhzQq9iIvXP8ix3ysjpBusmRUUI0H9MW24nXjBDZYoq1weUWnYlabvFTqdIFgk/n/76u3Ly+AgHpwZGa6SMeqxGya/XAb6CMTNa8N/RT+JJjnF6fT9iBvBcoa/mTfgWmOzuvLsKwxzxkN9Y6PeE2pFhn+DrYgEg0r8gm/+Ig/8xZ7aRlnPL0rgITjG+kT7HjnWVG8t2dM4orJAwgDmn/B4YkQOUfVvxit4kiNnG8q5739GUp/DKyl2rARpKaxxHkIKLxu0Ic6Nuys1heTnf9LpZbdmZpRPWJjjNSvlZ+oFU4bz30i6AoMH4NJOINjbNxycyenEBI8DBSZX1NdSsO+s4zcpmWrkVzD7uc/U4calTnUq+n33HDNFFn7x8kkxq/DfEkxLA1g4H38tx3gisKgGX9IpFmwfWS/npkerIDBUzbCzDHegUZTWhXE1OkZOm9lJ5IXDoqXoPXIZ+dx7nGFPpsLpwQiiNH58TGH6sk4S/g5xrImQtzqToECNfyVvK6oZlTsULobaK9nd3Lchs907p0mP9laKsUu1TiH/3c4OmKEvtSJRnF+zcnBLxKFQEPBrVthTNPTcazbKc8rgq0p3dEIPFtAjZemjFrqL7Cu4NNHrzrY7kPRl98LwHa8PXmN/fGVDaWkdlZvom5XXzAnKKNavLdUggxtoBGSO0raIi+So3UaOkSBv+SM3VYx6UoYRi7Lcz4vHcRnGtuZX9tXV+BsiBD+rtB33wB54iuYTcPEJ1KbVCa29o65fMOToiSVqXttrX+P57d1E71nS/tTO+zXlkb/1SOtcFej3bUHauY4PE3aJD2iPqD5OKCF4XH7myEWT5eAv0bjKdxQqTzpetrodMfZKdiiVkivO/iKaR5yAtRTvvcT8UHXlukMkK7CEXc+pLmuql4qtD9MIbOcQBnYUsvzTL8l7q7dT3JNI+0GUp8fUhgHN+h5idN8a3ULLR2P4uDR2uRafbB05TI9EA2yAg3+tR4/rFuKkJU9/mwixZgBq4Pu5xj1X0u6lQvlhgJWtm4x62WG0y2Plmz094Z1dZBCVqSPQ+BWofuuiy+FO7cDGNDxLv+BijPV8PRJlvQiW83aonzPblXloVFRE0leMa4LrjFkKgOPdwrdHUiYlAWQFLICpyYUP2WE/7MoHob06Y25mgqL6vr8s24kRguTqxVCkBuwvY/2Ab52yo68XHE1OsNVZm9/fBwLFSRJJR0JJ36uqAswfncklqhLLpo07LAKnSka/bLyfTDfbmg0YT0zspvWo6sRAeJZ7ljXno9C0vTeBfC39Hzi7Na/d8oTtpdocJbxMr/iBSmtQN/OzdjeP9fghOOQPtNzM8NUijbJ0oQb7QBhD5rumRZ/1K4KSx9Vg0rVJj3+ETaBKhGbp2G/+ZPghwwTg/bPZ1DNeThpJoNqXhiMqyUXNq6yFznQzU7YTzcsjJG6V1EjcLMUtx4Hkz//EPepQRSXTfQEgpneBkbQ7rOg+raIbNVxovhVxD0c6p0jemvU1XPXbDXkI0i7PKJvIgVMR5xhDWRHt/KWjtbr9YFYRKKpbpEjqUasOsT65QZjHN8pdG29+7vwo/fT+1HzYw4bx2lFFGSmo7k+Du2Nr/47bgHV3ojEvvEyUqmxN0Z10vrq01gg1TbZeHw0G0DtRAjHepFEF4Lig2ugelo11X9H1hODkFtYrOG2sJKBRlgDVORjLQCvtMelE5E6O4Y4Hf0OIRSYpfKsSU9g+XlTl/Thok0OTgy/KDCgrRthPQ3v9ktJt+j0U9fHTeV+pPc2EXUIKbA7E22CcryRcXnSkKaricdYgbo/0TnWy3/2GPqjrozLuiwCI1DzuxYcf9oWDCD41f4wTleEu2aGOGzis+gLJP0kLPKulnisa9OyzO5fIXCMg4+Wbe3z04P9g+gGCHY3ZCnC1NP26hIqwQZgecJkem4qWEAub02cvJfJtziwNGjzew7eL8Jtv1GqH4OlDzvaS8HAiAWxs/j+XS2ha11WcTkE2lnE9m78JySS9qaLtVU8H1kq77j8YCQtiFEhkzoFWeTRzXeoCTIraZunJv8PFrniw4DuD3+L+Pg71HucpSInDyVEcj+p44uoxz1j9y79WRx2ryGKZPaXFsC1QhlFHcP7XPUCCNkNPah1F4eX1YlPd5CfdODMOXUM1y8rxnSHQEfO4f+qJ7HMNsW34xvimdtTo0bbH1/j5E7MPsk7KMI2YlTFLBxadx1l8dTHg4KGbNsqTO1mvD7u/xI3t9Pyll/anDgihh4ZOqBsz8SvrXkJac9fU78z1iwclMZI28VwtTsPYuNXP4os6hu8aT0ZrHwPedirkRF7RDKCsqyLZhrNCKY82k6bBV6v9TzMKZT7RTUSiUQ5UfyWyJGy/Mb1kLAQkEeWaV0AKUTc4/LJtEIF3QuvhFrC4479opibIer16lDa4tW9Mr6eyJa2aRvUpM2oFBLR6BoDmeYWGy+DefS2GvbzgIXvI8zIo7PQlyDAQfq0deGxUei1ITuCWa596dwSKAqEMxwLiD04VsSyxsMCJ1a31v91YoFE600SSpuCSouWdll62mWgLpcQZApkYPt35Enyg9WpYQ5jBLPp8ra0I1DWmfKVAgOf3kn4qHkrm+oJquA2iNVIs/dcu+QZS/fFMIv875FeJM7jMvqIIEwQ/VxOYBHVmxt2TbITKwsif0dB5RuwZccfz/s3KXGDZpVy7EdjjW7tElAfco6RugCgEubpBwkqAzZcTpJQoWcuYHKcNPDVk0YWmXO7Y5hmDews5EUQkKCUa7wXte6im8wg9RQyjLivPg13a1l0ymL50laepYztME+I0gtHHjpVqGECi8MlmnGcmc9QuLV5Nt/XM0kt+x+BxOJzJha/qHNlZ72GjN1drOEc7h3IInYoNIvzmbls9bEnvREyvy8Bu2eaI0asq4SnJq7w2Gpkmr2kU5SEKDp1AIF0SCp31alAYkt2Whhf4xXY0uTljkMaq+ambYwAYxVLkOIkWM8LLlezu/ZB8aaEgR1wTnmE9yucmEEKlNBfBkccYF+MasfTSm2+Oo7febg/d5qYnIWo9dObyX9sZRFvQbzL63bgbrcDUHyGp5qIehez4MmOZa5bYgTGjSG3keX7UB/m03FUun9maGx2qa0vuRNC1kYEPXrsJ59Fw3+D/dymXqWbqy6188aJOGWslZbdFgazLCtaIb9VW02XCOAHKhm2UfZX5Wdq8ix3PQRcn4SWfTSENAyVZxzRWJm15XRtg0Nync2nTpF+q8HMEtijhRD1w6LTKTuWv5SFIzSAV4OnqwBOiiqivAkJ9ponl+Si6v462zELX53hWFSVuIPVgK3YLAvPlRo8MATxCAtjUKLjh3++9PbC0skbsdmvNpssGj5h3D4IhqHl31IpcfjQF27QhXUGt1riV9VTimkywuVZpVroYS5v+1dFWdtsnY2ex/+JZlgNzGF/fv3rT/AkUb8R+G1aGh4A/11Ek4K0fo6f4fLrQMW6XTOg5jaAu6BmU7bYYgpq/TGPScC57bubvskFElY975+pLrluNeyc/lbCvYZy91GISI5JwlAKDvccIZRPVqYLOvuJWtRU5gffO2stZEpy1X3ff6hhQT8rp2W5QiPDP0Ob/HNFC+QiXlOAgoxUJ+A265qvtWwD6K7j08lfAGHjZr7dYaK9BtO8oPX+IFInmqHuWysNpPoWq/MhCL/epQokbe9lR+3w9shBBB1nXj/4RRI4wIdd9pIaIjH5YtH3qMKKqrHCkxCf+eddRQbK+tDdFi5KGryIEMQi70mT+RuuL4MsDk5yPyLjLV2wqXq7P9dSFyxn+BZ6Dci8r1EIfbiBbz9NVFlU+g8QSXrjbbsBhje+khcQgg8LtsvFdZl4cXmMnwqMHIhkBlKweUPhzXKtFsvdOEeiB+xdqNKICSIhaq05fxBijrk7Ova9RT7yAOGmh9FztHM+0Il7szOzcDzNfDK1wZ7SzDD2Y3yJUTU0elZMdKTHJMXCv6Y/d/xa0/o1CWcA6ZlE2YPM/ehsuUAVbLssZFEX3l5vZBlb56hFy/imYR735N9OZoNaiwdxWyZTRYedJ3k2mWqkUhdrnJDUyOeGmYtvwlyh+EMt8+vzlnlZMgef7erBJ/4eYxlK1RVHiSKt1FjEnrea7HnIm71aRoZBs5fcPtY437qoKKn9AIMHtRjUglE8FE8t1PB9A+KgmNzsw4eGGVrFflvHs6Lbk8X+GFY2R5651adsHizYsCG0KBhnbu3c13wPwjuIy4lS6bkQjz7Rq9N825GlGf+0KCJl9za4tasA+rifoCih4H7w8eNmf1d+9Cfq1iv2miZkuUmQ4cn/T3h2mUVwrbBiIn3g6d1IRjlKQg5wX4DayYX9jLLnm8cMBOQ/djVkJlZYbPCc/9+oTmn3vQIhGT/PjOJXYDYQ+twzpKntkuUzqBBraSQ3hFDdK6rWEIyGKVD+szMvQeLDOw3Ceo7X/9Cnl5YT+kKJ1xf31nTodASHQfp02YrSmwdAdqlU+sJCTLzOrPnKbrwLtqk4CEhQAYzj35V6QmaTdzLbEmdsiiW4iLtlDiHh0ab4MxTnEXYVvwB8qU/Xipg8GofYw6J+bhjU47r7fJP48ee8IVn10qPntDkEl23CIyz/J9NysYWdT3xPUUdsbC+4F50dlEkTXMSrDQFls5ZEkj2tPL9DOOJbcBkDUsunhhpsyrdIeJ7kUWzUSahjAuYVsqxcyfXRYnm4nay0jWHhuJj4qDWMXjEfIDvaEuawpcQtmkSn/iMpIOJQ4HwMtREpoGFf/bEYP2+f7uwS0kOOAJiXHNaRMDbsHlhYTaaDW5mQMM0TdsVfUYRvfuf0rC7C0dB1EpsUd5aDHTjKD2f279HWcyl9NzfZTkcX3xj3u+WkM1uKCMWFj22+gMXOWDAFtx1m/1IyjyHsc5+zMKBPnQPZLndHruP3wTSOOdXIT32kRU7aMK1OJYBOczudTR7TPpvnwdGNcXm54vYLDDNDzyzYp6M6gW28qNVNROgwXd6c+FyZWQTB5ghTeH9vEOcocjF83T/yjko7nPXrJxVqmbiTaetsHzrCrMYgz3NgxF6qMVJnGuetQKzyON7c2VrC4Onu8TDD6CSSo9z9xoZavZvNgxGZ16/yll4UitLXng9V5K0RGw+7dnPaaKlMtcJTQcYe3x1fjvywIOzuj4NQoXaBZkb2ubAwsl/SeDiopjfNYFtxcCKn+xW4CllJ3t00H0j/a5FWlnSWK2bkoKwlMG+S0lauwsRDYTsdVtvlMJ2Zk5SxzWEmFKUbxkcpikoSvv1wvKSd+oVkY3eE0mnCrbUMG8nj/pQbsts7OvnJCid57N3TCd7wPH4GfFlekFYOwwXzE8IOgNnqo2dWdpyr2iF4GKWsenTQ4matDa8AtSTwPK762l8RrHbNjziSofMTaf215BNTjhqO95dnCVkj9Aof/muJb7gwIppVYxGCrJDL2nnwLm/YZlL6uFZd3IqgQyo9uTJ+lnx25Yafke7SrKJGU1owlYhMRxgXyEWct+rbuZt/howdVklPXN/5LuKscyAZBhAG3lKTo3ShnVN+61G3C5KWSvm4yWNmpOwUtG++7ZQZiosejkBGjeHzmiLOCp8gWSoDUr+Tyobdi0shhEsg/F2wNMnMJZTNlt6Fxg473XNcRlD/Rh8ZDKuPXtZFgDhb8bY0zi/oaPDDPZKGDBv3525hXDVQZHE9GXiDkT8Ho+Nc8G031/HqHdSM6yzl+z3Lk7BfTA3fLjdulFeKEy803v2slWXdHYg88Er0A/E+46kDHuhmqpJhO2YbfvPC8pCm38OlgsbD1sq3TOMuUgWX5Ai6Sx+HfkORzBkuo4kuv+rLs8zcXatJEm25RZu5g6e+C4WTq9jXSFEfNX2arWwYMdUTzVxwRxii3nWP5eeosqKlXqg2OJrJPaxV2OnWMWKfPfKvdqDTJywct9dz+8oWRXSFNR9PQ9ROAO4DDTZhyFMdHpkZnRNutScCaMdrUBVIbwgwvX2jMEk+8GjGSK6MaxnrcWVqWTcksYDVilOgOJc+kS/V2rqKonnWVL8C3wPonnTRqj00SexYBjTFIugkrjw6BZ8ViUpDtPdyZsio3IktEQ4/yM3T4RtArnz26Pc3qxrIIasizGG1pHuRjb3FlPeeadqNT+IwUxoEDIdg6ZzHorMWbt+oBmTInInSL8ORL1ZrKFj8lUECYyb+XcjRdbxqzp5O1T9QeiyGCV7kSx5o7xW482yOtkdUnlIyaiGFSHg8he67peLOuTdBqj3QiY0ehOImXdCKxjNKWtziAPg9watfnfPdugOuB+K1Y/cg75tavOxux+9XH0FEeWueIXQGXaiwj++gRGWhk7SVj2TMtOmdxifiCQh/tBmfxrflxIGMVahsexHM+RWak1tplbm1sCNoOcfJMto/WXip/8+FlfAm4XEFoscVuvTgOMe95aT35t3WxTFfab5RS/HlhFvQQsppU7pz9B0OqeKhoNyabrfGGnPh8cfx7QkbhcyoIsT6GJT7Fp6WR39Bb14ZQ0jRo9q5OocX6hmm2fpADzfmI6VqQJ0ifbsyIcXyHpIf2ij+hKTIuBfHhioeWxdAPw0Zeabdy0MJchTrq07J5WjHCzzjCBhZZLu43xtaFH4YNW+X8S+yPChfomYQB2Pe5H0iI3Kw2aotqtJPDIU+Df6aBMnYHsQX7ibh/Dz5X3Dx9ATwOZKO8ljlfdRi3PYakR6za6JmeQQmPsR1Ok64ca8QB6BDXOb+NX6itSrHTJUhT/Yk2h8JayVbTXxVIJcs8GMaLlslD2WMnPrJIgGAh1YG4KnY1qwJVpCz0nkr73H0hVWpk/b3KRBjKPd4zVcG3yuvMsgOsk7MBbTAlZlsWKUhNdhRH3gX8TZLgMk/AuGKF11eH5mG4fzGg+TVqakle6yhndad2SJPbg8e9g29u2FYVdVEgcOFuBZ8CMThbljVDazePBtI8xHozeGLqLNVCMzXNQP1aITsHzV4Ja2vSLFtcItBVMtHnNPlK/rVBqFq+6GP+/HoUi83kGqxJhyFgR0Xvfay1J7YdNf+HecGx4/amRkMNOHPxiKvYIOb5r0VQLWDgQKesf0Geg+uSpB/4c/G9MFpxrxxaCf3nErJH9OvkXYPXUAwM3BVvBvROJccMCTZXN3Cqk+1Okgg7KVlPsGCCy18Aqt/AdQTl5gv5zXSco+mhUOqMRC6N0soc1SkoeqTuSJfzzZw6dURCHbfZDj/U7Bynhb3+6wVQr6JFsHasRhtfVD6zg5LGVRh+R4SDnryrtb1t8LTqMDtUtcB1DFiXUILa+ULP2IV4qc4ZSvJiI/4cRsFiOIf9zXSmbFhsj8o1bxEGIwjN/RWkjNIMJOJnMdIpcvKiTR6bs0JL4DPCWMPdsYnErYinDuBLeKsyXRZD/16wQVXLt6jt+6VEUbhSekV2ITygWV1WtmQe+3BzmFiGn9JijkK7iws7Sc0DDTzGl0pVixMFUHsX433dlykwmdxGpof8QvZMoW77bALEut7OSoaEaTEOhT+HffbVkmEF2WCk7wUyRArq7pK/+Zuhu6b4X6ztk03toFYOAdFRZdDXeFYrdiGjubJqcdBMaNK6EjAaQMCDwMjfTPlNhEF9dPwiXAgW0khrbxCC+Z8niZxltWJ+PlvCtooIwXbkYIos0ywV3LqFn4ICi7pWYty6H6BQ8BONKR4srO10w0kHVfwlXadxwAAMQGwJMwWhmFqK8mTfDL9dcmHv72A3kZZ1Zlat+URhMHg/qWO9tXn4xLfE45p/UklBRl/BpiHp4OV03eVAE41twMIexoCsEJgRx9UQzBaGLJIfr5vb/xb+BGBr4igziz0r8KjkQXodsbwLR8LfC+yCqTZTfyI4u3Tl+4wGUT6te/6JNodyMTd8Ck0gCditWHEvZQn84+OT3dGZ8krwPSiZ7IYXp33C1auFpVBY8wBIDVXnaNElgeXEfdAx++Ogg4z9RNYN1vJ4vTU2j8VSTQkb3W1r3npoAdqmpk3cyhd7O1xSLmTRAXtD9P55/G46RiUKqAun774Mj234S72i13+tE2wrd4rSb8XgMUMAEh8GU81saLPsiueIEWFmskm7+kyvD+7FuOXKsp2SaQqC7zStoXv/G7Zh4XjxFvRBDmNwUktOh2j+WfsuM10kGavsj9NNjIH5DZLjTxiD/S3TPIul+w+XCu7jVlQGEgiOCBJmGKQIlUe9yxWqGfby1oBdz+qZTBLTIH6dsrdr9CGwZ/lUdzEGnO4pnCPt7Gua02HSLnPxnehYYJMG7S+nf609zVDobsWZRzHuC2nX/gQEio6FctP8wux/LlcDUCGXl0KbVxL4yga6yNP4pfzexixUBQKEEGlUKbR6WFqxjQDUznFJzSu//jVAgZf15LhUU4AG46QIVoA6TXo9dVxdOqx1exMwNBrU7AIPgVq23glLfG88Y4vhXmD0YbawHNHBaDx6POKQR88ZOeI21BnkLFLcAuPVir8Cl0jvM4tamb2+lP74gX74xB4rEKWdbpJM1s9gOuI1HDq4oHLmSfqFaJ8IroeuZmKzmd4zGerWJxEQKgNk1DryMdyoh0FsJo7xSGQeqIEm8vPm7AEU7MgIVkzovfJMnmrIm9cnLSWg7MN0vHQeCHp3KTbmcrVzrpj+qT86Y4MAo/QmHRszzOKLMxNAD6D5CWMeImr/R+IS637DV+CbvlMXHHOnSMKiB4ixbKtm7I/9Pvs7HKRWTuYSsdvQnFgqpl/A1CHIM+pGsfPW8sO5cV4PSywh18+lhVjiUWY3TihURTkLlDlap8WJJpI8918CerGPAdQEuTU7Lo375IMD+CZDC7VotPGJOFeQJtZ/UNyczfnDzUMK8hi11ZE+HUUHT99MPTN8OqaydQmnkgQ8v28I6XUMpczyQJBuMe5gvziTeAKwaYw38b0X2Am2hziuGLjCa/IUiW9PsaFzkIcSXyzBUsZTV/IiuzjxNq96B8kPnJAB7x8Dmk0jgnFZYvE1Pi75shHuXncnVdsOhzuiVZUpy7pDiZfS72zohM7kAvFPtoqY2zXyQKC2TgCIHYAUUoemYQEm44P0rcOY3CePITJyCBGgFz0SFLdUQcKMjMfn9kj2ZpBvxsRgFkk1EOqN44/6AwnsIBadKb56mbJzYaN0qRbq1GtNxqs7VhbB6ccUi5Si+AbRLlNLt8mILDoTRzSJklmfD2Wq26iP5DLd0ll7ISEgFDm06x5zdk1CtA3t4f8MpLFEoUQbUcyZNoHZqMriNNgWvAZzjGab/muqzL3+nGgAFT+geFnkQEBEeNtDfIwDOF07sHQMF/jkXdp4OG8AdzhWeegNtfQeoYKdz9PFlx5/sAmBqA4AGqKuTnW/3InC3FlMQXTW/tBs3dvmp9zqMG6vNG+K360wd3g9Mdu90CAzbGM8Z7xSxSkUWvc/0n44SUIG40rH3Zci9ErH8662aYHRp2gk5yGQB1Q+jRauchvo/ZNlPWVynEJYoayOAUN83G5KwT+rGU5O9s2AuwkSwv8/pIiejChFvCxBhoOa/vjKEDAQBas76GYKYcfDdE7MMFfqF61t9cjrSMQ0rA/wx95QlQkWAotC1wHHOIhDAEJrdBg6cjB2IuIwu0shF5hyXhzIdueVX/XJJ8aC9r2YK+WFSXX2zVsTS98l3xIBrFwdrxQIRi/Q+lgLp52+LJi6EDGMnZOKGMysAIM4hdCUFJ8jOJfcHt5xyDCb7jdxXK1TY/NmeDIK0RxoHnCilGmi3vmrhyvGc9CwH/YYrg6ObuGheamEagvx1IWYNOshNRrkY8gH/kKZVNX1a1rV9K/DfvKiiWrnYgaDvpiaRHCJ4MJdPND/Ffnwt3n6gjpm60LoPg5ZDZa1Fo9XzAxkHjvXwkCjvO2hh8TndLxDlxtsapvf7S3j+cvn2N2wYsKxuGPaijdXg6p+/Eo3/BDrgPJvQ1HIJz/sTRTOW0ZE5BqQ0fIXCvOCRdIp2nUHEIUOb7dbbzi1L8f4MicLVCsQP1vguuYrCZHKKMQTmJMs9D0DOzr1v91VfhgYHdvo+WOi0mQEn4Vya4Fi+pebvhPaogmQUA1xEvjECaWGlwtLl3cROgRS1G3aTZB3fyQlBD06N14uVQLzLUqXDfrhVghlXXo97tlCDDMQHt4LXUn8FDqpBrHCccXeCknk6UcUvfigLpqvL77Fz+TUn6jDshHWWMQ5L/FuAHfZHi+StSxh8+Pje/kQ66ffGwOvPNQVx95rI+4fzjCotK006HuJyucbYjlPTNAR3RyUTBN9DuVpIXRlM4o+qgysZloEFwxzu26skQaYFYythxvDSe8GwVTrepDta/gO5gMdRws3dApRD1dLu1Qp0DtyzMzYLVy/Z5o4DHgXymM3LoSniz+Tc8Mc0qLlqJX80uhW/sxZtvDiksyHdbIQvjjMCgyK92tg6npMXKT7inKyEswGLIMrg3uz3AxYh1rteHgKsv4wAABywK0Ubnlv84QFU9Dqdsck4VVg5WM2FGclx0uZA3O+o7h/zr2tFNg923KaTMwIakD1VqtajR0I3tK/m4R4IUt4vt0x1QYrRSR3WayuFNSL2Ehium/ocDeyMbH5Tt9I22FjW1yydyF8nKoYceeluYiOPNObdKs1yCFpOdUcJjg2T7ZxSRXLgOnV02a0HWbY1kKDeU9EiWljs2CjWFowegJYsEvfumnecxs1p2d0lO6snef22Pw1sTY0vDQ53hRTyRINM6I07yAiuGQVGaMGMSyBibAS2aQWNbm+UyfNh16sS5o/5s6etmvfkXif06AOnHNHnSB7oA9EG3/K0ny6kzPQ5tULUkZhKr0/bCIrvdxTEjMiBfFsVecfyeye8f/6trUIlHeIwIBQzpbSNLFBUjP9/OEKnqdb9PnZNhuxlhpWmv6OZ90UH0Pg9pRST44glYhNDbhbKwWcklFMTEVfZH7wIXG679EWi+Q8qczGIykoMwpnb4A4+CFuMPFsNrqTYOREh9dlAVT3h0PsuDwX5O+kBukfn+v0eNIs1fRVGau/3/gbUB6KrADI/YNNOe8i6+uJT7MAlxawC52D94TLRpQP2nu3uPMP9aKWgNS+qvEXBgrBcB2gudAs19GG4uJaxD6j8dQlOw5Yh/69F8SjAnUo4x9M+Li6EXrK2jidUuTDEunj4sIsYg/fsiNhl93+dZihGc67Q+R35XxOU0dvBKeHdwqQwiOPBFAyz+gyIPNbtJEP3+t//vBYdGsKewwjRTKEAwv4FWenkwMeKzUMxM/An2tVNn9XD/V/kBISAsMA/ZBX+FolJjA1MGJWPu5QjuMgOlkLfPRGqY7HLjsiOQMvAb72yjr6eZEdoAJg57leGLWC2WMF5Wu2+NnYnW5qG5upzJ14rqCNfoj7eDvI+ClwDaf9w3V57FP27zpZZzcnh11rW6+gvfXawoB5ecMHMw88aklkbFzepEEInDbXgse3hMnhv5lMqqMdtlLAYN/ngh9nO0sL6CcbfC5uS+EboYD0brXkTDlT5XccE8KP0QG9MmMYfGV9+8JerS+o3r6HSahagyLAvaCS2mSmo0BvLRAXALIUXROaWFFZxjV8baLO+SqhSTHYiHa/KgQTv4jfNN+Hpa2Lr9p7kIkCNJxaJNPuL7JCGkWxDI9yJP/qjGcBy7hKaye8ElaABTR0FDNCYpYQ85d5AX8IRHGl4kn71DgT3WiXk8kjrCI31a1n4LHN5V4fAjJORpsCK+9alRtsXUAs7sORDQP+byXLKC6iQ4oO15eW8Bmpsen4SxNF1r7E8uqhSs0PoO+S1ShnClgWsEoAc4VwyHuBB8qtsS8VeIR2p/kDjkCd/SZfHNRac8RWiPCvt2uCer+Ya3g10572Yu95LBAg1Mw8OZ7Y3Ve4YFi58ROajvhvYyJy/FARXGe9tJ1jyoJAtdvDS6biGm8VAdikAjPiRcJnC/UtNQXj6/dqRzhINKh8+bEIuVfajI0ei4kE6QCPlEgiIMOcuDNCAabab5zIv63NLt9fQGGQ9Oz2r56iJoaB1YZobsMtxUFI7OaYtvIAoVWT1ikd9NqZwQvKz3gGl/GEyVRMNJ1pjAz8o5LsQrney4/ZYoMvpvGF0WPXXWMNM4Lgk8n9lj8Gd28xDI+Dwknu6wzeptUOPEUiIhD72GsXtyzG/qXU5erID21YX3ZS4x+W8ApN75dLg1M6iGiP1ejzgf1qriRMrr02NVIh0bsrnFnS2Lw5ZKs0y0lT1Yh6v87OKNB+AEAWWmM6LTE2bd3+5tGdutzqX7FMTdfMYTP8MriSHt9ZuMTRgxN0oa1NsmSEs3APKazkBu+2rvwYq2W3eFx+Tyj746xs9FhMse/F+4TJYAig/X30KQ4UD37XZ5I6Iw+yUUAt8R56wBmttPyq0CbGggn4AYPic8THdCuk+79X1HPTUyvwBmlAN73U3w0ZCfEGQ00xaJG7uFmjwkUurjP2Q8TFRFcdWyKRZtrLIJKfhnXcCadyMjyy9oKI4rpDRZKOxojR9FlXsLSNR6k7AW5915FSAgx7ZThvHc2gUwXML8gXE4kK/cyszQxfiJfoZrSFKNqhT1uPw5egnf6W1YX8tFp9TkyWVpMJ6C0senY/jLlVpfgQ9sxNm7LAvDA+nnhSaih+HkfCh5OJQaQg76t/hWZdj11TmRKX6x3YzLLwL93VkC3Z2eaSS1GBXgsh59aQGp7TkfHm32+oLsp/1Bcp40MwBSMD5gld2p/at2qrNafQcXn62TZY3A1U72gc12TyMuzf0hwXMCbKk1pLqc0Y8iLJllGmVKbmcf4JeQ7quC8trrVdwueghIf2kA91g40BCavkOKR9gmtAIY3iyr50atE/l630x9Lr7Ro0BPFO7uA7dnRGYwTPFKh6cWziXAc9CvouAz+4Sr5fr6zE09ETKMfU/+Eop3Cu1VbBAC7RfvfcqE5xApSIra8blPZwGoh4eL9wU/pIlUQnsVneiIybub2r5wBVgYmeqrFnnBpPIzTqEy/1BoZWt93g35NLe5JgX4ivf85vA4Oj97aXgN61iqpGnciLYWUi1JH9d+30N2cXaedq5xZBTFHHuvo4JmlB8kDmEG44GGH8bJLyKryZnWs1mFRsyruBOx04esgXT48mM7ZO0Bezx18aKl+3ZB+7FEHON+DEG/vLx0hV2BaoQx7mcZhXRVwBVC9h+beynZAAuV4CeI96+aIL5CXKxyvEBL87hhN4dG0cvOT9cRp3ps4ymJ1I611vfzhxoHuGNnTgLe9126BmuCEmcFOSVpVeL2tFZa6dRhEkVUyssgB5UKuYzS5lG7mBu+OonzQ9lRSUlY8LBoMNukCRPAWnncivIgatWfz9H1gMc0AAlIeVER0WhLYOqc5hLfsEl3TQzZFUpugxvgGwowJzBsimAmlp7bP7SlbDIb7ZQz+VNxUgx/xr4cNzmX16pi/hkrEFKEnpnwk+dFALlqpU92hbPOHzQ2G+13NcxEA+1C8ZLEqf2IBZD0ffHTF5itfO+M3hLijDCqYdUI0TTBf7t2EgR4UFyyKTTMHnxCR99KtvJEDGuCXvIfpMiJKjKaeo8glpWnObDEZylPz7TVmbzulAtl0hIRB8XV0Skrma+khhZ7q6FTiX+MwT30iCfaP6K2Ea+N9Ruqd9IUwglwgAWr1upB8QHiEJHIur8bww5zDgc3ys8NBVi2peEB2fJEBweFjEhbKTqFYaPXv7v2ugA53aaObUIbWdA+EwXMHxtRBXCXzHasaCUCTjg0J9Vyv3dJF17cV8ke623ZIxt7FwyjUkk/g+bT7wE1dTJpgjzM4TTRPwojaUiDdu1r4voBIVpGbJTHgxTagwLaU69OhNTum0+8IndLquzqXUxm/kWUOYtjnf4g5IibHBtbXOD1Ih5l3lzTZ57mqp+ZTt4k+BA9YfIY87wZMjfEgz+byT9b2+tH9Qm9nFZ19stj/SrSQVmAaNSUUJ/nt4ho3AfrOUn83nG5JIw/ZHGcbI5tGNvoVfncUKTi6Yp4ifdLMr0cCY1xFJSJZ+XuG6Ucj8IooR188Nr6eSgkDyCn/EGeJUDwTeQNjP0DKhibz5frbvHbH+AIG79ep12oork50SDLzKjykG8Vn7W1SaTbaprioNogvaJdFAsl2kgkpCUFMC5SIZxLf1m4oDN9Z4YYEGz2nIj2Ul1vaW18JAKP1gVHEVnkYc/RbUIVw0lVKXGgF+2ZX3AiY8eY3HmwcDPI4FS8MxH5j2OgcgkjznyXuM8NKU4zNvMEI+qVUWnFHw/pCHuZyyqLuoVewgUj5YVNrRQFkNOBEvJ5QQIpoAI14cR4/AdyElZv/Q9qJMBCpuRxvfTCvn5pBfFBYwMTA85rzbiZN1kRRIaVDF/zUB0gMxFB1lT8PzatV0ATPzQQn8MWlVCoZceT8FhoDoNYqriD3MtDe8UAk3cb5yP+r7jrr+fHvmi41fsfBvO2SH4HpZDgR5NNLHiDyg5VKfw/iJuTBxfQb++cN4TwOsPh/HFD4t6UOln5g15XFqI9x+8t5asroNN7E035/lhYg7PTXId5ekXqycfwKwNzPWM+QE4YX94Z4k+cEuJLOC/sARpxMOuIszf4XBiq5P7Rw+pWOhNAjU+04JM+cXtzfCu2jbONepW13PPgm6vhldo3lKD1Vr6hwqCkAH73UPBssftWavjk4cUhc8Qok2HJaxXp/ftb6Xk2qgqShwx29dQ+fykEOpWEpmVUsg9tmDrfMKxEoSEctfbGR3+kXmqX+b/0M4VmqcTw0dgnptZSVEhrvVDbALQrzWHFOwUx++c9saXHuq1ByZnAfsJcbspkZur/kmstmNwfViGSt4PbSKokfSZQDCpIEle+6XcwK68lpZ685T8eVQFW4xh8/6TIwzUuw/l+Gg18TTxmjuzgxUXNyWkdbXGADPpLBYtNHHWAciiXd+Nxaof1hYxzfgFkHSebXV1WoAodlPoEBcxMEOXR0bBKhxjQtkU4zmc7kxnQvVFmeB8hgYLhMUs4TYNyDnppdrQf1o8bCJ2CihiisZ6yVyZp6umM//3PQUTpHD/GVclAmM/qIAaiyYF0gj0cKZa2LvCvNJg4QAdH5/32juoAYDKdoQEYQDtU8UVlEKCgln+h1LFP+ZDU8ShUfoV2pzjlopowmE/Dx5rnwK/hfJk4pXyOfOwgW2qcHQXvJDKMstyJ7xmLuQscaAObsKfQ+IbEZvtZGzSa/YU3y6VeWrukEiKu53oLHxtWup2IFdonLW1fcBPCS+ABR5ip5HlTuf6tV0jo503W4HoGElpVk7Ah6CXPqqviIH48Pl02YYElVXQi0iZNWSeMK99+UrB2Vgz1eXWMeFwxt/CDQT9RoBvF+2+C/t083xKJNVCRQdev5VFlVPIwfFd0L9J7ZHv/tg+MkQMUbmfSp5uywFxwSYMH7s1xzwjLfWdpkq+bSZy+dE2uLMhq9GoX3aD5224zRHXOfLjiXThUiUhCFw/stwTL31QdqQHG3DEzLJjbc/4MH07VNxyW2ZBSgcupJBwzCGEPB8T1+IV1VmGZ3si7KK+cLUz1Lw4GrFzwRoaAAshs3dX2VNzGAi5gxSlS2YA+lTKkWMxaYIiNTbDSpWjzkP9rrPiREv2dZkPu+pqt2BoPARZXy6o/yq3AiCSzbV5R5ZQsxD9FsqAVSTBWy4tvgxIbCjsod1vTjKUTyyivU8bU0fgoQU6gg+QrryvLxM9ViRyVOjhpMku0/rX4akWnKsQpOKWWIiYajn8eupMkA0z1Mbi3cb3cYXdgPTeH/d+ZbLzIC2EZTaC3EefHfQCWNlQrmsAx0iuWwdqPjE+OZAWLptsduYEFaJ1CK4AYEErCPzPs1jECrUd84WHS+OJdzArlbvxIPEtW60JoKImza5roFoZePoRH7fRvex/jnVuon4XH0x5vofvkDxe5jso/a2xAprVYZxtNzcDbCx2+Jlgg2acBvlFYXPS/4RvHrdAvoMn94AOLGZ34XbCo+S+pxOyHFX7rU+HhoGqSK4xf/A3Is0cAsQY/8l7EIPgy7aXJym7p2M63pt54kA3hMLI4Bv/XvSLIBDPv4+5P8ZuXE8w7039rVORomhOX36sNoISpRi2G8Jc5RdzRkt4r/0SQApDFSTJzGHXRIOJ+wrxxLKAvdfLjD0Mm8oW3jrGV3m3/UuuIBmguVM1UyxXn42zPQIaPNMv7jM6pY7gHuBQHrXH4Aj0E1eNNG4+BnbC+xraSZ27FgwVOCr9RMqjCo8JEIy+lpiJl2bd+zEVb937FGQH4/N1OUOgIN1bu9A40xfB9cc0y8YH1nPstswQb+dKfNDg4lvjL48Zdbawsda1j4i/zAStMcJtiaVRjHTyGfK/XWAl5jqAQSrfTXAdXJVQ49hElnk0E3vhnE6hx6egHfJVY/R8PyCbAmb0ADk0iA3n1b//bWekgV5FMKv34OHty9kTxxodArIOWeYDEKMUXh3Jb8uTLGTwyjdPC4agWXm/Ua+15Lc4L8f/pUHTVY7C2SMe2MDA/VGKt5tKb9DDAqiB8LhU8u/I2r6M8rvszLIlV76ZpXwADlcxFbXhnB4g/aylyk6pJc/EJx09T6bBm8EBXQAl5YPikJ7l3fpEVWvEdOJxhBbbWDVcJmEOtS21TfqvWLN+UzU/aNDUqvKDD/LGgxmqNbz9QwcT3zg3IsjNBy3Jz0oI+UXAbaULynCj9DULSRcs7gXUuJk4n1ip9ofyhAwjC3OXArkGw21sfY3z73JlcVgt9+M98x7UX+l16C9/1AAhTCfH8xhXCPY/9Q8FWajizBEFaaIjR9BDCrXpQZbHMeMWJEOAdRUPktitT9OVPYLAaHl9+cG86LNu5O+q6fA5Q0AgF357vBAD1W1yBAS6LJMcZ0V22P8BJs2LM4JkFV8CWoDa930e46odo0KPbaNDc9d4DGEqTvNzn0Mjd8JpDo3di00lFlc8eY/lJDc+gBJlKyHx2r9lzy8jkcSRakSwepO0V0lQn+O7EZ6tqDdV0LU538wSKy0QW9CsfuX0136BwlbJ3+rbwvpNk28x0WmzYG4Exr4jc7jwoXddQGo/GlLGgQwZzISsjZSdiuIHv7Dj/59mF/MVhuzID5R/oapZVTcivh7yz0vzbA8LYg2I5voJOkP2aYBh2djVkQXjultfis8qZPOtSJ0Y+AIUmh3HcOYyD76WlmtXJBMCLBvOm9izzfU35ZDnwUC6a5bU+44bUk3XldDaPhNK/ge6a+7XH6iflsqDsHmoYKdmVlydPLRuyzNMkAfowAjCQxqQ3nMBLmxdhCx19s0vW5wGWHK05wQDhmyO1P3P0fLIW854P839XgIGpZVTpxY0iDFG6TbSOS7FgSLyjAQaSACC2XdmlV3fxIC06vJ3YmMbQ7uQftjdOhWU+RnFYRqnvZ4Kst6JhI7x6sVgDAYIJHruqeGb7918PEROGPjshhTYEfMt8T1LEPsHXHzE04Qh/a2d0aSemqUpsRw492TRjhDhAMYC0J8RffhvxAGEsctNoRiifZdWa64LNy//jLAdlqQh0FGWRg8DaXQrKyP9hndYYf0ulqXtnj/mheeI/WCSyBD4kxysUUqugorSdCSiUn7QiE51JVSELTJTsN0g4xSnrmVpS4R0E7Aq8EQmgF3fekyzCxZnYQaIYNLuZkgn21GMUeUzxLQEGh2GtRq9NSWKvZZUH52XuEUy2O3jt9BqVM88BF5w73EyZi81rdjAPqSCpaXcB6DKjMRa403i2PFSur26oeD9CK5cjNgtLA5gv8pjHbxAxPecliVU45lh54sveiCXn1FfLznCeJDJSocxVszrZSwItMPHeOSCHHwTpqcS8xAYPg8W7Zh7Pxjztk+iKS12IMuggsIkfCs74jaKcJrQDk+d7aW5slEj7QKECiDEvXBw0VZDmfEK95pwnTMc2dN201f/+wvCvFO0slJ8sVzGkHmaTsLSCA7L7KeSgNQQ4dHYNboLrNm0wGlIxx+O+2YH7p+3r8zVvF775LXbOQ7og/pthJeR6Rh2wQ9aqyES09X4Q28SQdqjp2fCVyAYIEYeHW05xR57rUoonCmuquN93XtHBKN74qVjncmIaMQmL4zU0GzocUFM1ysL7uk+LOhEIlCoKPhlAiAPq5DC1TbFI80abSCMFc/7dPNZxizav7M8mxaU6qBmemeTiKR/cI3lCtVs1NGhHzhHCl/31xolwikGiKVaZWD3oPw7tSKQ+XnON1sQMYbI+VVyn2pQcx3lQIUMTO64a9z2hINa7utU0wySGT3WyAqRa6Z3Wo5Kn+WBiJiH/AVyGI5MNIgb5uW/Ms73zTo6VOhwUcwaB0GKfdvnGpvA4TcBO0bT0Gy8M/smDmruq9vQq4AWjG5zvFQUbM08Hu/8ds11PHeCEoF3p5+SuxlR3Uf2M0DIq5gzC4wbw7F7FDQCe5LrVq+BwrbUc1PPpj7jH/Wd118fNAVdcYDyNTl8ehXgXtwrK4FxaHla7Tw/xDItv1TBTmyFBhq30KoGzhkX3OGU7IheBg9of0gi6pCUqyaNQQ8rKJ2OVPhCcz0rt/UeSm2aKU9DgTESJlFf19EOh9YVddgTCoorxZM/dMU4QNsxz2qFAMHpAsOZoFxtFFN7EmT0W4YYoOthnuwqYX0oA4nppgTTWKaVcJU0awwc/nvZ1wFul4rk+VFCxqGAJ4r8k4+aFjNcXvbY5310U/pm9TB7z0CUHeRh/eG9QMuYHUyq97MRXTvQ7yDghmtLpj6UO5AkXZoAztgeSj4x8b6orZnflUiNwKhOY98Yf/lBlPmeFBU65a6iyDVBhYbXM8BdLzRRWo8EziXqk4rEdZZ3d1yxV1U26YBoi637h5ju3Ook/QFVPM7vhNK7dGaSaDgBc8aqqNf25BJ91YA02Kci6zWlxK5XGxrC0uOHYYgvUE/73y0WmwY5McQrW1tgqLLtDfseLM0YhooCBj8ANNAzyghLpIaktwt66NroNoAnmDXJhQqlDg4S0j5ViTPuL2X4HA2t3RiiMY/Z6umAj2n3+FUgjIvjAl+2/xS0tN4BOKLFnlVb5vgT4Zjg7tDpqNqane670IWiI+8T1SBvfUGcfvteJqV0E4oTTW7jexRRdGOuGgN/NLpWJTG5pbynKInHINIziC+nTADqyAGS69a/TIfvcT7U9tIR9zZo3JId7WufO5N3Yb2hNNVjaA3TMk19eLX5P98NFMG+RI4FefwnWMlErCCeU073mQN4XiLe0ArCc5UYGj6ON5cD6AI2wBKdp+9NKD9iuR0MS/Z7i1eShqtyOUr5j5eSMYJuLzT49Ak+CQ4GqLi5KB7fwAlDIYHv21aRrfPtcqNz5OZG3R19wIoMuWAdHEbsLl2Y6DaT32wEolKYU1VpH4I1w75cOTRVNFYk7Q7PBQ4/VaiY+Wsf9Et2oIzzBGewUldUnNGRA/HyalJhopqmVNZmDsztMaJ9tmrvcqclzEkPE9iknbq5bM7/deOFcfyNxl881GFv53b+NrizNJPmoAr1QHKgr9L631XMAz5qVccaUxrKf7x4pLhfp1Ha+4FhEk4mwqJMwejlpCri8y5AtuaJvfQzBfJOY5LjQ8CQCllOXiuN/GdG69win7KJOhT5AsQ5R3vMcoMGgLYFr9MogHGYVAzYM2FSaFkdReMxq+63ivG7nAWuKF+TqScV0YnBdUBFeiBQJ3i9Fbj2YftWppMpqggk6KQ4M1wlV+IubJ2bHFG9y0jx4STltCrAzxBWO9HG3dW67S4ajIQQSlp2EutFtL16LCR1CSwai6B6fqTqTBkP11aNMitB8p0ZwAHUSY0CQizlInMw+hAIW/nA+FC0anUChPiz9M9wZuqeJkpWyCzXPcbcAH0gstlgTChQBUJA7beF9ymLd1FHl6FCfeCSYlCcQmMKSXYqv4ezej/HJHK9pNS1+KbL7m5NpZUht19uDmKriIzt3d3nuxD1vHDUKIQ+VQgnN513cVB42dlAU96wkUIgrY8BXtvXFG64NPvmcAFuq4juYcFY8IC0TBec92PoqLiz6vt1q+528D/4pLlxqTvieRjxawZDkt9lnFxJwW5mtf6+rneI6lqzw6uygBNBeP4GZT54lo9sbyiGG5CZ1ucmlAx9E7/3JIw8azzPStStpIsUPi5q33U+PGAlkqJQgoq48AfLildFICSLtuRuVVQ5ramyLWEY4NDTanLDoDpAfAmjn/q5aWv+CMCrvcRWA/R8v72Jt18SAr4oa90GjO4EyQYJ+kUh/eS0dw1d7OMXPARhtJbEXm6z+kmuOgWoFoHng0d1fB5apAIR5Q/rNd8JTYkOAWrSl24kGaQ9RjVwuOS11tCJTiLa8m2hWda6ECeAvfXk4y3hisz1BTF2cWKyOAH+yrYlzJUTlgOI24AAyecEHBhMgjOKmhZYmJOnTGtCwRB10jWTjgQUAcne/Px9khihSTPwIlB622S2tPltYzSKCAPGWI1MalZpOPl5qTfZqBUT87SHf+NDjyvDI6JWEUMqtTYdCJQoxRxmAEfPMhbKiIFQuNM8O1SkABZVnXWkQuVg71B34B1UsuTt7hVzAtIxJ0Fr0mByq3o/sYIMJrApQBsSYr7grjVFGgiXLVrQZyiw8UpzwiAzouglGYOXe8jhpFUe0baJppIEt243OOzy+2gdWjL+DBV6vqeCHv6hWd5WCxY6Tek+aLdMzR7ck1CJ3vqG2rCqSVGeiWuyGsebnZVGiwNCjkAM+W/vuJcDa1lGjmQrvhY8H2vYPncSy3YfgYLThckkClcNwjeZOzChFt0dwjeDnfITzhh50zcvrNMJB+gTVDhJ8eW3BbBNwNJW/r4t4a1OEQp6uqEokKD5f1dkrpNw5GxSrG78VU2NmEShLYA0W6bDR6gsY0i34r2ecmnEkBlWDqb6Xb+nkTCLTvgjX7n/RJ+Njj9F34PAw/fJu8zQ4JQxWRmEX+DOr9z4E/3Tn5vHuBra+S1ep9bRcAUr0Dd7QGPHeMkIjXWDzcICszB40xXD97NovA2gLT+VRDmmyEyJNmrQBQxhYB6w0aRnADaHCqjE44thdGVVx8VXkAxoJUjg3DUVYicPBuG4t460IVrs/gNp7jz1eV0nxy5WYVddiv09n7Dysds56+yIApOv2AG09b7HgD9SVucS/5uF0Ve7hKF3ex5kzLiziuzNipdkkJWmFVsKnIa8a+dg4fpLchwkVwexQciOI2vyL9Q0AciOtbDWB8UOTrVTGMVKMzxXkNDLffzdOUPPtE2nRrgQnYzeLuhswTACbLGzVbk+iFkRNNJmWUWoJkT95W4At9sK/qGtN192YrJDJTLYYokOGcj2SGct5xXI92RP836MILz0f8YGs8YryNEucXDBZ5LfxvtoupExwaM02Ot0YZXQo0fijorebrWTT8IJxTzISpa8vlXL0O+bb5d5pZuGX9jau9qZLKO8obtF7r924/fvUPHtDBLpJ5ztZ8D0H4a7BzLVinUQXu4a8Z3E540MBxyDbYq0cGs3sYgxay/EMSxHKu9InHeDxzI6TsFhqh5ZV4Zfd+ikg9oMYKZ7AEi+xhu3ttVrNMdhroFnYN0GoaHPvz29vtNtNZKNVRou6z76P5WlC1Hri0uDsHk0zmeeLTgOKytDzRWI9+4OxKMYLn7CXl+W+8PAPByQBhh0qvHzXYk2ujLFS0sqFtAkhKoAWKy5tJWHQAyhG+8EHPKXPq0cj8+nXqFh/mOkWGUYr7izLmL24DYo33uGEmEPozMt1bBWEqq2iusV7g6gND6I+f8TO1sskJz+GOUmgfUn5/CJ/emlvClu8v64J436SIUwFTwEzuIhPvCDzNC6WKDHZEm+olCpA92qQsdnokfD4fDs902hM7o5lUVn2WvxT8S5rAzTcreq+gyLVxGNgOHYpXxc+4QMXvwRNdZhB7KRRXXIrvtli+RhYXccD4gNLy8/IJP/Z/vTlb2v//zWIlgd3iIiswwDDM4SKvUb0qHpcW8a59XHz/dIrWqdDbM17M4JlpoX6vepPvnqJE7DtVhrwFJGCL8Svcm7qbEDm6ljw0Byg/r+TP3AjDkH4yZVn0g7vaQeMbLMk7v80tJRZgcQsv1vGDULoMpHVZdAOmiBqom79OmNoo5Sll1W41MIi8IWnC/WtfdveZEYrdew7a8vx004hRUO+TAduAJudHG2n8YR3w35XXQLKty5niPVCSBzD8a+B649SeNUyct8ob/7nv/17S7lHNtbZ50ISRZA6btJEYQPRqpidMNIRn2JpyzJVliOg+E0l+fWa/hOopE7ChQpcuhLHIlVEwrmD4fKefAqss+K9N4kqDwCamt9s92X192qT2HccBaYVTacQErc3YZn/y7KMCiSbRWE1QP5Q8bowCVc6jrfMhvwWaSmXWaTvVTcFqvnM0CTm5v8uwP3yKgHoyKvkANf8wP2lA7DsWpbQDQ6vQb4Tqgqo6rnZkbKcAkE3VMzdizPQpCkDw/dcUBhRmBQEOVAlo4uI/ZOFiXXtRI1foiWQnCMU/V/JmRmN0nxJt4anYgDBz4aJ8HkkxRnejooogC6jmKsrypPtItOpUGCDhxkx3d2uTgxTE1eXha0IWqBpEqDyQWaAmhpvTaEgM7NrNFBikRpaMOuAKdzT5oLJ0Bm/pvYSYb+Cnl8whKbTLhCY6jTNbMQO6V2Ts6PZ/xOZiJ2/tb3ymM3okEE1xEzQTqKsAnJ2dy884QsD092KJEt4W2Mq+BDjdn8s4CkaEj4XqcgGtQ18DZ+HBfP7yN/c8lpVWgGN3SFeCHqFKxeOm5c3lgaMO154xuA9jx84vevYo+cZLS5z59B8CInMJAwHnDh7NbT7kUAz5wOlEW5aAh8pEP0YTzk7NPG8AJuCU6FFc6h3B1QQgBBKL4v+AiEKxDRPWqTerLeWDkZvkm6t5iTexEq5rqd0TwMK5mh9moz9Ie7Op3OsikgkwjiqoxaI1MAexoq8Fq/NSxVxJ3Hd/YFeYpJTaymtRNi4DsfIXi5oGU1Va0GNhsmWz6wWNxqKLl2sBbl6Mq6ghntv4p+ZNYAuB0wLh9Y+jWPXvzOCY9xCdPF9qjJZjVfyrOqDojIcAGp8i3n9XoNxS5H8VL29/PohGqIOtRD+5Prb1t59A2WX79CKLGZcbQS5g9FBL4l/af+UM1YtbOTH7txz6GHqJOsHKxQfKzUkx3RdMaX1Svo+kgVKrAktC5A6qZ5/BpApDVF4BwyBvJBd7iq7zbIHdgBNJVQym0Ug12Zdpyu35y8OtfAUy1t7906g/e7Vq9NgiSaxALlL7DKo3vN7AmLvd+gR4kknqtHVSoPbvDAPHgY5t3O0hLyxg2il7v6QYyZC0EQeDR/wCtdKz78rWBXlgUVFExlxrCl67lJio9lUS0AVnyXEnjdeSBo3Ey6pg8Xdk4NQiMmNhrsNdpesEfzBVAyrOhtFRBffiC29MCcWbT9j261WRDVVh/3ijhorjt7aVJpK6NI4fOb4rEW35f+SoTid2WUlcWPFn8KX2aLJdHZYqsJfqf6yl6iOQKMFiHaySv1X0gVmzuYJv3cGcKCiySWyvzu9rjRdC75oDmMsl/NfkkGG6BBjB7qxHUS0JI55wShqqEnajQibDYJNXIcGRB6rUgMqVDfnTzu2Wg0PgYDc154Az+BBd6pT/Oyfuq+Ius1+p31DV2+ymBPxRWXmiBkweZM5UcQWUq+VS4w+qxrG7caVW7JCZm5KJtnfXG2XMW1Hy8ZTjtyNkwp6PFvMYEGgnRuPcEnBnUHR5mxRj9MbufUSryP4AduTw9F9dfX8euCNq422TrFYKDtGAHNCZkyOjupCRBlWuYnueoeDXowGtzjI0I6iWV8L1IJ2gauKEnVW3jvLZ0C+mNruefEEHk4BPWnyruxrC5Yi4+JKQKJg1d+uLyMVz57wLqcJTtoK535CMNJUgiyhvgbjDIwmEAzjpkYSECyKDFFg1S1ppVxOl59gWSDmpYrw+Wab+gMR/B2y2HOGdwReE7e8dTC42Bv5lWiDXm7g1Pl4zaLFsCdAcaMzJhDLR2W85pxQ6lnaz5i5BVsTI24hnDgiCZTN0KKs18K/7JwfiYtK2EQYCrw497lUbce9jbAXl9Ezk4uNEtirVtrF9dfaHIjpuyMSoodrwLhQYNFSwgmOL88u6s057xkjv8qHoV5NPc3lh9iGaIpfiQ/PebZ0MUVEMOs2hPrhCrXt5gUEYW6t/HnfNqrUVjtKJ2DsV6owDAXnt9ArjfNvRQ8dsNz8C8QUJhXxFR4rHkEnaKpkjEPhdnSxEaeFCKfWsutTOXHbGm9E/3dfVoA/Ilo3rEzB8OWKg1AMkJw4Xys6yjgGmVk7FIHY3ljO7fhemTiipQNuEgs/DudtCmEgVJXeYkfsBCNLR+RejkwOx9AEQ735sIxa0pfsdAWFNttrpY/c4Iv254K9H/VfXNXrpGWJv4fe2mDGQEghkBrFQzn78m25Im0IgU0D80yC7Bg66Iv7ojZwH7xnBjV3Ho5XBiXMXatZn6CvrvxQBNFuYQIogjo8u3Ye2xIkvv321f/cOm60r8xTN7XBqedshPaL7FlBdGOngWhTZmOkVs88soD/Xlxv/806qxxfrpVpCOXRYaKYwqVZa+TYYm/5awDBUWpMExYIvKe9y1lqjFpye37OkkKsqgCgcL55+Ef2ueJumXu/KSCAzTaPT5BENIZ3kRL9ycFYpadIacciUkaz1LlfpewDJo9avpv8XSAUqAdiMwzX6jNyX49INS1LIGDOgArybs0zLxyogJXcFlSbNgk2mP++DgNYZtr6vgnAUWDEsD1dtG+JBjO+P06jTRadGHUTPLEwGKLIewHWdreLFcuyztSu7Sb/mHr/wM/hLzahINvC1c1p5PS9qBm37yfUhRcPbsJwprGAbkkwhSVlOElLG/bHK5y0437X4aYBCljTpVvhD172saB38VmUI7galXNxQJoJHFzMcA+kC57c+OnZ4XLrTJ3/kQmtzFNGhcE58OepCVB6sgfTN5Qngmv7yIIE+/z8CbI4VW1FwkZRIyYpwn9E+cRrHELLIkvMJ8mdec/bPXhk30P+rQq3eRtbQhzniPxaQCZwowuPZZVmM9PvIagHIa3Tj4sZd7tV9c2ZfBQkeRUo4GC9V3DVgHFN8KHHRPINPBrh4SFw91eRRtJQpQsiIGG5jHzZbM3zbyaDO3ljuzRueou4rznhNiWmXOr8CAZ2Ms4c4IjmScwvkYk9Eoevlxgxcr7o45IFsASdyHcqWDexiyA1BmKmb1EYnheMdfMFA5Ac/dg34IjMb/ENR7HbeZsA1zh20k97/CS5lXqkd6Uq9ZX+WiUFu7nTiNUAT9UBaP14psuGsB6ysb3mXchDmLT9xiJJ69HpsI+FbHPwcHBPvj/XbSRUQpLlE27FcxMotimPsobHmEg2/6l2x+kAC4GmG5AI/bncktzUfzzUHNoCG7OLUwc3LDbdahPXEnVK/9Ow6hgmc4Ty9BKL1Nk6WFQo0q+ySMVr+osTJlXsbtqMIamJxaalqqjLXTlQzvi2RPeY5kdBTSTrCxDZE35dgl6dZUXlgvmU3ZMcQFLmrCzFmLd7k4vIxF7hQVKT/4EY8tSyJejIIM4FTIn30j5FzTvYCEken8lXT2eMOinPDsO6iu8YLidGB85ZH5HALv3OnxU+P43KQ870fTozq43KhIHFKs5SW0CH6208wBTcdsPTG+v4VvdVFMgizNbid8Xy79iv1hAm7Dbpq2itEhaITPZe1nMRg4FDe6nFw9ZHacIkRRQwsK59IPFXzS+FWHv/kls9Nkga5MXdMR1at1AOQoy9uTafng+cGCf4mSlvC56PD2DPGGtonIKSb8FyztkssgQgRUB0sw6TM16R/ltvqlayXoLgckRY2jS5oqEylnugMh2pPdLJSfa4eFrOG3Ku+b9gXAKU4tiV9BcF41OVrJGtMo48SLxPe+944y4+HmVjr2naG7R2cqdO0KQYQRwRGeSordGQL/YPB9uvO862upMCtFgBOstaS/qqSrKRMNlQp59EgwEjP+fOszjMa9N2NvCSRGEkIqO3gf1whV3u84ftH0JOZbR4Eunc8Yqx1Ls/FEr+DzIBhmLZsOJ69MEJLCV95fVVXoGoZVE2RnPuUe/Db9bXgm28iICPSSNfiV9CEnl/Zw4vEWTBtdBXwiEpv4yRgjd28tSM0Z7brD4vimXTw6T0a91d0MdtHJ+4yQxunbLleyt2+XKNVelW8pvkdLlwEdldNBVz+lO8+ZoJ631N9QvNq7TqXWB0AbW3Uw93Kf1Y70XZdWOagpimbckQUacLyJuDKwHeQcblZ5EfkmaaRKWZS+ye+jveyfrlNvhrZa98QDc3tEnkR2F5msbA2+i+vOz3QbXWK6YFHzu67UV/Ie8jBAcGD7cTKWLrPPpVUaxwX6Vm//3BlgFGlroIf3F6N0yTUwz98nD66unP9Ki4Qk1qtWVw+2i2rBMG0HHHimM4o23DFWD2ZJLP0ZL2hHHTICzUv++Pi4qh6mTgbCotu7000rkAfeq6Mtaw77DLmuuboGPvbk5HwMhXcVmYf4JoWcJMEC9unRYACdp4A8QJfhK+uvYaFpA1Gf4CJkohO+to+iQIbPOScu1XCKH0JFTr55E9IHaW/JOmJA0jK54l8R9iJmvn4acbyp0AxSRXWfQNxGlDu4MBrEmcyFzfgKBTr1gP6n3jNJNsLgMiPE9o8qvuPSs5MFcghp+Zth8kxDiXXzaUbnmlMpysxEmf8R3pPLZTwohEnS62Pfy4x7IGi1s4RKwh6kAfqYBRB/gPe9wmlN+WEZ6VkmmTiTUfndLmyed6YYG/b9CmRMfQ4RO3gcPX9ofL/jv3g82+EoYZsrWM81UIKZzrSv2ZpcdFkghfnSNqgwWKmL5SYv4vlUKrpu1FaoZHUCPqREgIlT1pkN8jpOZXU/cQJv6bTVSIf+emqdtC4mTEwbhjYYjKAv8+WbrwjaGQtYwYoBXcuP6dSiIVsrkyzPfR53a2ovYmUbxFo5TYNa7RpM6WylyCe5AdNG1LDy8MDHl5r6RgkqfA7Bcq/JBykiamcJDp7lIZODzPx9hmuhUJD5u0gcrjYcEpgTqZ2JIr7ift1XzTBVrD+OD2tKQIjoCbXeM8zsGIF+AoPP7fG2lu61Tzeih0A+XR4dMfqvSTLewwErabZzIFmbEGrfHKIljt6VM5JFvi28y42gmzuuNXwEFfwzm74e4hKthOKz6tqhnOOFijdEPsJh5bA8AS2539ZsdxtrLkPx+eYuFBXpDGW0fn/P3gnzbX/BQpB6Q1dtUOaJ/CuRdWaJmwyHdgDEbXhE+r+OiRElvEvXmg5E5/HVs1ru5NBybjIPVv2NjWV4NAXT9COCH3jn6pHbTN7iwLOq+Pjj1SAjQZwe8rcyZbcFyQkdgNguhR284UR+OCl56kTDw5nwo4cbCzXlfYKnvUSmMPqo6cShTSl/ji5rIVjobYXej643DAwqlAj0cDi3EPfJn/XeDCvR4OwWQRaJyyBk+khj9FoR6ESII5myR2xDfosfkhBEpbQ2IHcEnWN5Saa8aeOBFmHKE1RzqNgxYs2/vIb8ze7VPcFT225rkvVSJsoegaelng1rZ+UMAAKUHsuqED1nd/x/f5kb1/BcSHK+8ZSVjTqHce4FxOw7lBrTLtRC3uFFrk25GNv2qdOGtV8FMKsrWU4Du8t8dI4NrdRYjhlAoCn55kz7TTs4mTMNPd9+UbFrvRvbL2hZbXJ7RCNBl7yknfGY8LVqm19B7Z3m+tUGsxUIR9bUZQNF7KznSc48qQLMnuetfyLz6uL1c+z+3RAMt1UrcGE+474LWdFQGG56tpYaHfKkvPr9ulyjdosGG1XtcuH5JSko2v9WDNjaY635z7xR3KKrfbieGflrJZcMeDytmt9dF4TrhYKpNssk0nhCvIn5Nc1ko41C/ptQpjgKIPnMOPNPSkv4aRaGJFvcSnxvuoYu4jZI1X85t99qpqfEHuXTjRq6hNKXd8NzFkijfROhvqyfBXpPDtGXn9LqovuVhx11lNwKgSw+r/AFbLcstvnb1sRkAE6qEk6AHk1oDXL1jsjNYmYs/R92TztINWqHX/H14Zr/Hy6321xlS1SSpRbzbCpjD9pnSV60JmaH0KnhAdpxtaXmhYVswKEzART4IegiLG060kiuvEtSNcyXkvmP/1VZ2xmGHd9xnlQldCnZiK2Cfjus/QNOz4p0MuKOy0z/w6+WQr+0q3O4gFAzm8B5fE/X1zjFLzFaA+yKJq+Gb8PxBljjBnVctN2NGBUoofNJWeFj2JKc9Qxu/4w7i4RHgZEYr/4Cscibp/4GNIZb7RA+x9kIzdHHNNPerDazDJW2qj7K+EHfuHEFmw6BPqHfNCIdxiQVe1FQvX9lzDWooqDWEovQ7L+LVvMqBG3zRxr4EqIMmBzFcmXjFS8gxANQ0lSCESm1An+0GavGepWMDOoeqkGi3xnXmNDfP1osFUI4afaxSrV5GkXA+jqsq5sOsIGQP4/hytf2LYLNMKo12pU92ZaFUqpnzMCu/9/xW8NKVnJtje+Dq68n1HT2Dd7emWjR/pH1dMPtz0sJ7GAMygjMG9XUyFsXGhSqChwtSY0ucjmXtF1mH0NX9pFe30pRtpQEIHBEMk/mmVbIWVL4Z+zDb1doCLW0OzeS5MB4w8q00e5JNhQTsp+wmtWFOg1b9CnEpMyKmj5CMjTWTgiytJuq2NcHVJlj4b7b8HSZ1vv33UHil7o8iPknrV6e/UUZWdpnWwwxZkFqQRtEQ+oFRTCLQPFoKmFl/BSc+lPuhobN9i+sSsODzeRKfWVAoGMImRLjUCPP5DhknQzu0/euFcGEaAfdQ8oVHEBXHr3cGv6WpFep4LIDP6jW6Jy4vfNKmuUAj25GhkhRncHNPStxeSxz0y9jjA3DkEr50s8UeRwROy+MkPJLPKaUeTxe0vYE8u5bo026B6Le4TqcZlZ009Vg+L+OD5fWadebBsKsXazNWBLT3rO1OaGKY9+HZDM4EsXNKhhiYTQIiCQRPb3j7XlukcjNnWsKla0pOffRoLR2SqcvOLy48jp1C+s9iIxBCZdmDvMtx4ust8dISa4M/NeusZ8ePv1FZWmEwvppI6HTrYvKQ0HYF/L23gUSlKCCSn2myQ5Sb5waCsFXlj2VfPU9pIrekyIXqVDHHNJw2vk1Cye3wSLxqfKqwNR6lnSoKA6rWBeHAsTV64krLm92E3PI0b45JGiewe0kMra4wLbcrT3tggDR312O/jb5YNgTEmTiPyd7uMCQP2OmPzl76SAA0XPvx1l6/03+ykt54MwclNbHN+bE+nCpdO74y2CjuHbZrraqS9poc5XceIZsuIxVnsURn1lXefVrAUgYFDvi6M49iH5G18iUXpv7RlkaBWhhGXxmqQCxu+A90cmInoMfFkGxEZFVUzMhgo8D3kyIrBGgNBZoGsV81FPe39dJ+N/y5qUrSS+Xkrf4rllv8VSVmwRHZXcJRFPBUiJvmyvwgVe/1rALagCyP77cA4uNL7wBp+N+VHXejDer87jCMQv0yO9aVG4mlrVgc3/rxtansxzBCLEOOj/5GM2ZnvtasTrZxHvhbkCdFw4zvZtrFkZtXOSmEAujjcHTMKTZ8kN8w6+YpmDTAw9HYL/2JkWYaUUy7N3WqnFW7iKegPg7Rb4UMDujiZpBl4Sx8CXv56i4Kz5OCsgODZ7HnZr7U2ZHBwEdOTIfMVw+1kmOR5eshyaTc+mpb4uzlx/hz96jDhqZSFV5lYgYY2f12eAxeFxReT03HPRBs6fdcdA/VTaUe1T0TnxMjplKEJJtQzO0GGZwcjqpJeOmltt/OrYSwfic99LAFFADNm1Us/JzTLOQcg12DpYFst59vHtmtHzLQy+gta3to1cEFQp+hXGP6Sf5DN1e+AWDHWU6JtxKjar/CPqMHSvKZt8+4WSkcFRLLIutiL0XaCoSgrC+DiFAYcFN9MB7OGiNEfayMCuhcbuZ0/JEeQfixj6E6G7ElKmjE+APMRsDNoznrUBKyyf+RY66K1au6rJ2AnaRQQ4cFuj8NSgn98+27K6xQ2oI4XYNH6tKHrXr9wyCkPAceqifxu0qnhjawbi8rR49zivBRbqRf/Wk/6W6CmWUpo6gU5U3eGMAKAAlTgTa3Po3jL723UNMR7JvnJOnLxIi0Qp6TYHO7idmhGItVyCT/C/po0HM/nX1mBMLBSxxgt/w+y6JyLzckuGyv5TeIEuOLl75+ABgpAfe5XVLr7287kQ8Kl+htnPYCLq/gRA7vwiy8MfpeQs/pLzrWxwNs1jpPeGpuOKQVIiphcfTdwrAr8EJD3GwO9rqJqB/yx5AuWLo0bR68d2oB2+NmiFqqnU2ji4pSi6voT/Hp14PoFHUiUDI8ZCMVKeoYQ5RE0ZEbMqZox2eJDrUqn+doeGAr5SeFDPmBwJETSuI+wcXy54bxydJ2bOYyRx/eSS0ARpU/+GFhpyU8P+6KIPNmq6f7y0/debyPHytSSdm54Jh6UygPPbHnSvoFVnpYiQK0cb1nt7FhJn3DltEOauoPNuF5NwmxspRMGphtyM/w6zJimr9NSGXeG2n1N4CQb45btQpYxKNBSZiQk7BK62D46y5BEA5V/RL0k99UuSzby1lFMw6l2Pfn+HDqg26Mh6OgCwK/+fMJ9iK5TVxoYXwCy0ZwzRhMTdQytYLfAj9fCqKt5XR29SYzI8Kw2HoWJmiRO/s3Soy2wJOpdT30PNZQDkbW3Zw6yQSb8+E4idG26sVt+vjaogz6SgwYKVq+pnpusEtq2XFjbCCOnfD4CEmTAkyzloH5B4Lf9kqNCgqFTOZvn07JUu39V/bXN2gFd/6yEJyiDSwBWQeu89Z+YmNPSyAt+BXyxH1C5zlLFq/J2XVnPFbU95YRLm34yv3CMaVxi4zlTgxBfWxAtNYZ94DKyO5QPWTo9C3Mwneg//0HgxKdvotU+ioHhp5BqxLh/qELlVVQLkgH7sYGTuMLd8LDpBKlt3oEAop2sQfV580cnV/wFRM4TyTz7LisGhOGlb/fj/aGrzDNyQxGMBb8PUwH6JyvsPSQxYO58Th3+A8gdMd6TQoBv7qi7q8Hhcfu6kS/KzXt0j9PtvkJ2Md6i3LbvkguYtMvnkHRiZY0GY+7y28I0PW7REOFQSQ4wLS4RQIFCxrB4bBav/dDdFCntwnRAArKHY005lMLfgJDKdiKgZohLounZBjm1pMVGRoJ2OYXmB3OAH7x4YsyIj3RLUzt+4srCWBnKfoLhfKBz928XPW5lCCVCVrKedaijGAuGVkpJV/MaczzBLsGAiGPSZgaDoN1Od6avcv9ys/bbi4vRlWlb2I7vLoIQxxspDtFJ8V54YO+0hfRBHK7eq3NERnO7E6jiM1d4lOx1XrynCFtGIJje+yBNVDITkmB1vDFssFeFMrvFDztlWhWUFccD3btknRB56oQBSE86AVyltkcg1WMRQKv+dbqF7NFd1l2d/ZTyWcLhWjFTU+F+aF/MCVOK4IULjPcwiOd1kf0WMJwJ7r+AQ8GxSczkr1tTEsLvtc+/Kzch9vD5wrbqNJ7atRT6FYNJLznXu3PmVs7fYKmYqoTRDpe80/jjV4khYruQR3PaP+mepLecBgMre39h021FvlR38QOJfqR0eqZhCOi8oTRPOW2a8JvRandSIlZUrKOpkWZ3D+mcsShgnO3sEod5TlulQR7xpCpPOQr2hhfNPHQdGwyGV0vaax1I3EjNcTOYfjFoR0qGwCKZyrzePqyTiBMXXrw7zA8LLSrth4ikXCqllTIkANUb3VfYhVz2aaQWY/5VggXHzbBr7X/u69ir8Gc8qjAyDqO0YEBMk08LVd5yBxxvT8SHrgrwI/5XjlTzgKf07WTD7nd6YX2Jv+fLVkO7bglnWVplKvViXVVHqwecYqADowMOjgs/j3YpYVImx35TUZHgndzJEF/+dEPxOD9H/viO5Ebk9OH1bpcrtBj4RNOJxqH2Yvp8WO+evKg1LXtAg4s4NwhpEUe4bvx426CWpijeLoruLsegGuVnYsCrOL3BsSA9yEFLs3dhToAIes3m0rYorS/hlbei2Bjjv1NLoCI+1iCUx9erDhrmV5MczREj+hGyk1pmG/jw656A8th9agE5vhWcZrvBdtbXtny3dYUzPcc+b3HZYczYVg5QT9kLrea/cSm6JS+tZlXqVrPC+yGksGKJ6L2RI54YZxUfJXLZ4lL9B+EBT7pkj1kgzMxs56jdCuzoEIghRu3JmC6semK/lazUdEs0rq8Om2nMDS7aVoQc6mkW31e3f5FVtio7VmvWvDkzZqew92aE74Uis31tEufZTTzxOR2UbWi52Zi/iYmbwD3y0SR1KN18h8MKlkSQZPPVp4dJcuyJe/8eWdZy0QhoDMA+jJtv3dNdzkBMf5WmK5IMlsLDxAoHVOZJL8O7cR6snQAokymGLRgJrHRCBBr1hbEnuKbC2Y3eEPlN1mdvXeEat32ZV/1lEcFV23D/LgCIuD1LJ4C+eMmkY4xaHNde2qCB9BLGiGxBz3QL1KNFeYDmynltdXRKL/jFBRkp29OWSmDCMbYa5z/Nyn81WiDCa8bO/JfHAOlRJlG2Z3BSQx5AXZw2V8UZYLOflpTE8AbqKLqlRqtehfRZltdO74nWdyejsrYQ1LiIR3vNofOqJMl9YWvvh2ginR7PmRM7H8u9rbRzraVQVkUpuLHxraYkSIjS40Kl3fqCpJcW21dCRQSNaDwxO3EU9/UoeSjgK0FqCNAONKAlRev3Gp0grTkPkb880x+03UUFD1IIAEAhSWtu6wfZKUN223WBg/uzPnvcwR68wjtC45+14SJRfX6ca183R1+vTOugPytImiZc/VepaMfHEhn0EdAlkPTyl8yiYQ+HADwCJvVlegU29McVoWopHRpj/aaVa2Rajmk0vjIMWEz6CADGQzXlEomiF+5VTdsZT4nLS1L1d7/oepfZFwNCBydNF+LEzbwJ7G1K5AhovoClIgrVmGlHWBHcCeBe1QI3DhsD0NIw65Z93QQV7XXZgkI8kLVark0lVlU7AtnFLpW6Dc4jYVB2M4BNYDjl42gA1KTtPQ/qXQoln02B8iuSQgSxyVzoMHcXXkczQPSWlSBr6xgi511HizWN1/9CRi1X2np3KcBFARpAHzqoVfmNPuptx3SF2t6uWVymXaTMT9ghe/IHePte9myg6Rer33qVZxQdcthUIs5Sb7Wx0pQ7jJ5u0QQkALef/Nj+FEm3+eP0R96OvP34X3h+9s6tfR8B9nVul6ka88Kca99fb3ykkig0b9D/XaQs2D9C4hq2EvTRrvZWUFevc7RUDfm1qGgN9Zs5THAFFXP9Dewg70GMk2c/QdODPIQ6cLDHy82JCUb2qjyOpr1dmCoTkTIAD/okReTaFk0ZrLJGSHzDZ9St2RLbUpdH1pA3T0OdbrsEEby8cCliFAUscTgfY8Rib5bk2KI9rie8znZqsaTXbQrvUrPh/2KjOIQwBg6DPOeGRZFOGPhQOJrWH8jhNnzDpADTcEAdInifxMr1uppjUjD25KW6zApJzI7Zfom/9byt0FeXIdDN0STu7iTRGRbEGRjl26q1QGIKIrF8quFHVpd5VbHYHuJ9hovMN8crMFaBQggbfPfkhQhOI1RKJELaSKrje7qxA2TTNdTcVFojf5W6i+SwPZZdyfIzeCsP/Rj4GIpSegVMWbJ6PnloBMw4Pb6U4HL1LLE5bh93tJlJo26QUEaIrbbcKiAWNd3d9AY9j0CAwe5OuU0WnzSpefEpZwKA9E5fCwhsJ7nudO5Mw0UOxpLHnqMyTQSeZ5kMVkLsnI7tofC8AxdOIgxK8hNjrR3xrxC6StuuKIJhuUiPLY3hi/xitNg0OirPiO25A4w1IwBzasxSWqRUb8/DdqPzbvzmkuCFl3yadyYVyniaiQ7vhFoks7nCTaSrGzHeUsDWhN9WIMvwdD0Kz3JJepMOFWs6AL+brO7khdTzT7nMhpt1yx/2Eptbc+fPRKdEKnarSCDCVnq+cLuzyFDayJ3Os5MLg/PxKHDBtBZh/YjXlWbZwaV5sI8EIfOQFHxw+U2pm1TbG2ITacfPI2XjVu6hP1m4+TBbjeSxqUs5qAXUE1rNq8zkFDrho9V8HKyviu2d9DeqQzHlSmxE5Mb1AAliM7y5Lmc+SIFEmhZZoASE4083ffZ68R/373gh8ywwWPFwovoox9tHST45iWhZ7AGy38mRkeRKhhscOK1X2lvB+m5PvC32yQDQuyZUC74wwRGCqwJMwWudDmJcEB8eX23Tf4Xx9KQUwzWAGqih6aP7eBNq7ZnivLkHi+btFvHjOt21XAKV/Yr0gtBQJMRo4Xyfs6+jojXBzuiJKAr/e5T1veRpDi8nAOUzpBaiigd7PJqb37jwrIxTVubk5T6A0x7N35rIodQNYuwLpeKcoKohPAGKOzRIICHhi+1Om7TfL2pY1L6BNl2vphld5Iqxy0KS2tCfLesxFUmMcngZMwSIoCB4OKRruAMsj0wfyATM9CaXTqJxxhnpUcjwdqs7IHeTBpKJsCgvFLjr5zDg8RO3h0RudXb1p6lJVoM3q+zkqyuSiE9Au8C5YqpYueLZw288LU9cyYwaspzw0mWDJ5ggEwyCT0nynPGhAT2De9qOqviLD7CUToEffmAiDw/Ywvdw2HzVQs9hg67cIA9SuY/frPZ5Mop7+6NPRQxa6lhOVyalCAox9g2L5XUHU9yrjhULKZ8UHV8EFRjyQKKxWdwMIdkwHNQ09peieU4zhFGMVd+zgYvQ0pHMxCQNfcEGXDwuDoHeRpOUnY7ugYzskK30TTkuN1zwik+owxXBp8c/3vQX//k5n8FCvH0f2OMmVBHYL6u5H+4xdjNk2PR0L/WNk6EfC4NfA7rkXl+81jt2l5hxvZXtcYowDxnLkEZMD+ta20TYx0qzLaKvXDTwmE/vZjH901KDahkZQjQyCv7dvhhKnZ3hBaimC8snG/JyI5uLxswxKI++DNI3NrWvjhjZzs6T0VambCav/QsNcMopvMyqg68pAQwJT5XNH72oPap/ESB54PRK0O6iPtcsaiGNzeEAFBJX0Aw+S9AkCfB1OMnNgxdlaORsgKZns0BkD+nUVkkSRP2iq22B9kvGaNEssy3kZBUGHqTpa5mWB4yjiAFds/t8u1C5CunCrPw/DGusfRh2sLEjESXTJRJDXlrJNhsYL064bitajSjCO9XvTomtxwdZT3WWowAqhnvkYV19k965Gi6LYk4hIrv3QH8YODWTeke7d2g+QZuAaWmfi4D2sFcxEqybg9zWsNK8cOapKWUvYALyZ35ffgd6h7ZtRfx7R6+29+G3V01wekNw+3AXATOi8duhWuTfu7B0ib3I+NRayi+ZIBbWCTD8hABPEyO5pVPrzasB4Sj8/Teg4bGCMvXzeFG+fk77+psruaSftQSCSKriKHhJLcjTo/YoV3k6om1l4J+AB9nXzb+vGOLTh4dOYbq1gtXUGqEhIsFooIR5rA64CEXfqrc2W8ZqR4wCT77KPdU8rL6gUZL+zthVnCrYhWhmygUUMtTUYxSoDZUxk2LTuIzqujO5fdvRmUrXwpIr+IASJh4FnAreKbR6DICUBtMxjPUMWEHDKdpuvec2PJhzVE9IW1/29RAvEl5U/BD/e9RtsiJthEMPlkWNwT2c0dtxVMt+6z+rakO58J6cly8Z7C71sPLkCk1CBcyUhpYuO+8cM4jR2nwUqLDdc2xKDG4hKDrgTzXn+lLQLl9rT1B1/4eFuxGkeuuB9PtHObX2f+jA+YimhVy16CzKIt6HL+PbWVAy/DUwWyp0CPOpbCo6s5OR54cP+i1P8z9JoSVPPMX4OB84VY5W1T0yXuqiy3nfbIO68Fm1hBJ985RPsrGhVfI0KMh69cnUwLMtN4hPzDco6+yeDh2EfxXWhDCWghnK+/Ea/YPAtM0YHQx74BcmexntxmtEaLs33fdLA6l6sEDNvpDUQ+vZtdaYVMIKqZmgUbidHidMbzWYPNXFL/86xBc1IAxYU/qVwjAaV6eV6O4xB3GUB0sEY1F0AcpuUKQUFNGlyTkbH3u/OCpyUZIwiZY9xlmYukOjKWxbAfgmb0D9AS/d7Gjs2ZcYa2XnFuxNELxJLUf6+ujTlqtve+SDlrexugfPxFCxR1/IPYyTOHWMwFTLTdlodTJQ9xANI3oUr+ZEDDqPhwLp2mdLdi05kn4D6EYuoeHz0c7YHe/5jTcWFAybVzoodcgyua+Zf1mu/xVcmIQwo9LWgKlB4I4LzKfBE0k5VvIQAaA7RvKdh3B/GXPoalXwbCV552hf0xJM3b6vqIkoLC1gaxoZkP6oSNetjbLinPHHLU8RAIuHHo+rNc/fyvlGTBaLgW4NX6I8aIyw8jiXuj1QgT7Oxi8gglu4nT1MCPDtEbL9O/jj9/6EgWvOSAzov09/zPoSzRwZcvv3P91OKbCI1GcMIa95fbbco/NEmd7msf21mZICtWzinD72GosD+rfsdWBwBYRIbiHduhjWY8mAbla7kxXvN2vDmFV8oTCWPC9tempKRIfZETTW8TzG9kEzHRrEaLBPt+4W6SJeAnd/BzobTtpN/DTGTH6kzW17rdjrLy8Fy7r65KkzjBBYumgtKgltEROPqkp0KGI3veCZiHpPFPhIpmsEveFjnierYPTdVL3PnmjI/gFGHaytm7DNMNX5OLNIm9RZhI36CknqNZ9zVtmmnA5zTFacdJkm8R6f6AqopInecqP5KZzQkJfCWLMnk2ynpmlCqCMUrdug/sgz+DHaS1stVWqKYzG1PQQHo8J0/hm5iuWRv6WNbP2S62ecjjbpVXt91N64jloGGT02e7ELsOoD+FyfmVTOfHdnePzOX0UAYDyvhBfA5QssCTPziNuUuFg5Ya6iOkRIDzQ1xSLUwuASjHetxzLI2MbCVtX++Qk5v8tlJ54qPeqc5G3mZQTdZ91AayFufp302/hw9VXDzAWw+Iuk0uvX9DiCLCI4/Rdrf0/RRdLabtH/o8kAbQXXVO1bYQRJ9o7gZxxHxXA94I8lDrhor+sZRdC4qNa0HbQZXBLl+IvETp2yYFCb0DBY8sNgInSQs4CDXFjjEcplR2Eu+zDT5ugDvbJIh9Uy0paRNeSLlwsvwXsgyKZWcPtZDWB1qIR/JB2Gb1+RNIocnGishbvDf/OkEYp6HLZNnqeBYBxyUBasIbNO3LR4XFHwiduMrzinzzhJ30hyW8MmIUPNimYfdM9Fdq2oMhouTK0JqvLTuC/n2hMqS+Skqwi3Dldec6dW+YyHOA20AHTniWWF0k13BLjy4lu/RADmMzZlOhLKtzDQoIUsI06jD9R2W6AdJ1K6Iiv7pbm0qnJ8ZeUlCsIIVp1JKG+QANqBwhNPoSGwYpCd2b3iSHooF08Snc8QVs8te6P9kcZ5C9t0kz0YCFPTflDuldz5vL1Xk7jwFoSgdbaC/2+mekXslmA68yTcTU66EOpGpVj4Bmpx21YtnWEZqw/whhQgfLD+0kArr6tK6gZajkx2CJaNpFiHJiCh6BB6vZ60Mg76561Fbx5MG5nLoVG8ISM8K+oOVJ4pKCQMM4ZPU8xymbNuh51Da1dmUei/KuUomJ2OnVY3z91WQ+pP6XZUm/rxjI+NQNRzQ1mYTfKUc48vVdH2jZI6nF5oa7ekvHfQzI3bU4G8NAtWFSuKEMUogSOjqERDm3/RLoSJg0ZXzwsU4YGSHLBF6kDFiS9bDCo03ReIV1fWyNAzX1x4k+ySBLAadFQdd5+SxbTcQ4a5AQWhk80MaWMhHOyun4PO1t/nGcSKoRhlODtZpMlsVXB9z33uhaZVEB//Pf+aDSZqu+LN9g+nW1E3JRQxfwc/Q1aKao/wrofJYF6LCLbkQqKNswFtb/h/lNGnCfGbMgpll8/7oJuJgY71NzKXxv2GwPK3KoqLFC6dLuZtfpxTFvpn5DIvYR/BSegNoXl0NYoZKNzacn/YSbpIcIidEmyKCeI3AhYScXjINu1iwIroRsZI/so3f64DI1ku+2+jxyVCA/pRRV3vO+O9xQuNm7W+7Uc4qvXD38gwLPnBL4I4hPi58IhV6+E/r+DQOcsREO8+o7AvEcfkmtzO39VX0dsLWvzuSMozCADv7flehUSOq1R2XZSaDi0/rmMSbL8aeok1JDJ7+W3SlMiERwAIp8mgHHrBSHlvypYA9aIVOycdiPl/9zGoHEMnr1FAyOBg834jXHALZB/SVj0WYaaA0PXOvDOsCEyQicFRFXP7OyBdccbEUB9VRH8YgUpxd+Isixpr+h7R5WphQVnkVmo7tid6Pi5rtjiTcwrY49d1MHbfIYk9WXzr0rpUHWp6+EJFGGaMZmB8YEfKb1DbAp6/8pTGdUpS7z/3+RXIu1e7otySopuFZqVUCMuZcPQRfgaWJ8OnkR2Wnu5SlbtM0H3jL5kRXVoVvlmHWBLmzu8bbYeIoMZv7KNnaTR2dw8eQJyNq0bRxjWvw9DgCeBo6BZskRo9x0Tqh3UB1HshQ+V5AreOG2CkV5ruD15wrlfr06GmxoKc2Xynlb/k7CFHuck/+xGOH8khJ2OtTowzAwL41d6dqyIdY2zS+Js4MQRZGI6gvhQIhD1McHoo9rnAFFXj+IL2B+eHrWCmd+ZSJyGZjAiiwWuxIhHhU73MtUhCnX/BOu3rnRhbrVjxVsEn1B51i34ExNm1yodGaXZ/uPkVialy3wdFjDbWaOtiEXKgIK5VXP8ZEExf6pwZgUfaIsRkNPNJputq9G91TLrBXxnU0+xBKItoxJrRYWdcd1lVZtkUOySVERG28Jc0lkqIGSJSANX5klJdf8CYVqYXNHhsdfszLTfGdMc4HU1ndkQpGj3RUGaQVvd8BdOWxuq9scP4L5p1NSjmy8ADCs876EhPQTaDfHGlSRW/uHqbghMnQajrxfuVNAGhn5WC55qAG3w23V9aLb9w5b4rKaxa3dqWcvmaoJ0i0ZkepHusCJsZ2xZsuPaIkjOG8+F4qbbGMWyaPReZlcvJaXolLcimn/QA7F4GyZb0AiAPKAKvQ7/f0Cc0AQS+krPQ/ycMcjtrjTACPfHAZFqyNqOUiidiWGkTasksqFiNLbFvOh8LeDWRMWucG9jya4gfgzjq+awK7UDZk7H5hFGR1KP+OUlNNpFd5IAPcOjL+jj5Af0iT8Khmezbskh8+CHdvEv4igp/dGt2PtNRmF8+lBf1M4jnIWVoWx5gt64VhblZDKm2OGmAZSUp4UgXw+er/QRIZA4Uz0fJ6/TOUebhOjvv4OznBZkMMejJ7BP6UADnyzzRQLAIc5IN4xBF6q4KR4YsiB99Zswn2q2F83iPkvGhrhzXq5987CFLcd8JFgK0Nr1fMDaAYgtyjRAzyD6XZQ/xnEWh8KXmlz1E/N7x79KNdH2RdEZlMPr6IrV7LZ2xaXq92m/BUcjZ5dF5LYoJTH0VebXT0DaTORKxGwznSw9RYwbNNwP2+AxPBKOuQJ7iwemZuR3UON9mmo4UovIfk5f5MrR4ojh6VW1y0HIzco/PZ33LlPS1y+KPtDtouWB+mQ9Go/ZR/Kf8jgYmdMaX0M1pJWxrrlWrUEwh79qEB8Qs1On72Y/Jus1GfQRUhUPOTKghdRU9t9cbo77dcrQIeds2AeeFgUWnmm34LV0nRw8YIG+pFtGPlgp52yOsFZxYGaMpl/0paZtvPddFwY+TLV1ySAhMDFeaXqSK4fw8QKGNDUaHTrIxPdMO8uKNU82a6SBh2nrOtxwqob9rG2WsvGbZjBjCjt7eQfsmNt7PVyrguLjHAvHi5f0JLEuybpp7Z/X9Yvf5bJ0voMDvo0WkyfceD7ra36nuquW6ZwRULfON2T+LclZS8FZPKzpNoLqNBo0YEHkrdvO/rJ7+4tsb7MBnNGXAO9uI88FpqdPRrp+L1k83cyzgWoyiK/SXAdq53chnYsfJZlUr8JMcuWnIU8aK0S20QIRdvw00/F15M4s6MAHNxQmoxqCt+bDdqTbV3Smr6KIKCtqW72NmW4QGrXp0mWrXKBYWDOpBdXZxLDkHZno5dDKH7E/BNkJS4o7fMEd7HOdiIz/RWaFuMkVxtbdhxwKR0C4CbdBVEWUEvX/nyDgWrV324Azs4ExP0/uuAocSoGB3IGutQCgsGj/l73KIOp/TfcTb/YMDQkOgNx3Vn3EooajZYbfsIob+98hmv7YEiUVr3Mr8FKN+Q9xD6rRNNiMJt9luEYRWzbBtR5OYdsWt1eMJshFDfiRsBIBDzeWCC1qIgGbNx+UQIwVGe8VZOI3rf2z6f92alBFJMVTXXeWFBm2Cxd7fx4u3rg6D5rTtzTeLNHi2uHjdDB9liMX1tDf+L8kOreQD5cbFX3YU5zBJKk3ht/h8d7x16MZqlOnTbI+1PT+iSUByCh25z28f/aLVqP1zFuwthYBMQiNcxDfjJsIWXtASkiX5g058+ge/xFGp1NUch+XFRx/Tf82SuJbQap+vsMJGHpND/BMaD1YeOSBukzTjqPsq1Eb+qddcSAWSYR3ASG+T8PWV/GsB1olLqr+oQC+WwlvgPoTc6U/6pQ2pWSr7HneVz3Qro8lcbfn7Ts00+pa0FLA/b7ZRfewPk2C5DP2xCk7c6OtCwX6504BW/dO1MYz1DRAnhzjiISqfU+lMszywcY5DFofoiMvZ2u4w3StXEKr+cUYkZqZkQ1vXWiVvePEWDcgmh/Fg4XP4TQZgXjzIpnJUVJX8J4ijEfKp8GlDGX0yIokZL3Y6sR6fYhEi5RWzuOmKZMpBS5lyoFmDiECLlvgR7PjHfuh6T739Pgqwd8SVHmMuunlWscme27VzS1/I7StHwNR9jFUzHA8c5mByzqSUJaY4g1nDARmV6k/Z8CMRMuPD/TrbFc6KYYzVVmVlEt/hf8g4WPyC/hDK5/CqNegmRZdXWqKnsM4HeSCa/vQ8WMP1ijWqWV/4B5XOeRZqORAMN5IKuoYLJBXDlpk1tTccjYzkY3JZ3/3bHvkIAY1AESqnPwfExwFdekEQu9S0oM+R6Sm2A1YBug8O/va7t/vLwxC5Y62sqt7m7B1+nK0LFxxMdaEvR/PMKH7oiK2KpENz1arFCLaB2/uc41+KhkPyFuMdwl0PPOwO/9dEoSRNNoefGrtDv/kjxyYkbMS+MDi5yOGMANMs+K5IIF27NITT7Xo+1CiCktHQ8uCmusgG7gVECY7D2+qbaFQZb7ec2eSduyDJWY8zMBYr44RNt+maT2mGoeEvouxAI3HdclHBTRyV2cOOKuVMX3lxMhXN/XbL9KfD711Q0bE1e/oGSNb2xtA/PqHJH+qcXcPtvTZJ0ZF7HRE9ghet+3ew/FpCuuOxxbSR9/7K+GtyavBI810kj5e5qcu8a79dc47Kx1V1QI7b8ZRWqhkm9Of2qExf7Q1bC3guwwk+f/bWTPufTGEHb41f0tAxvQeJMaebRYXlXqtB92DQMYTyOT7ugo61P0i0NlOFqfJ+DvlgklD3OkpJ8dsZWPNxQPzm6I2Y5aVRmElqNBxPyUhrN+lUgKsJ7gSLG+m88c7e4Qwcq3rrFYqh5PgeTo3+tEYsrOxPa3FjdSy3mViglIjWYTqe6D+iiIRfTMGu2LX5q5oVCn6m+vlNkTh01cBUNsUzqXmjetXIaCOELQ293mAv7bRMAn7QXQTgu5fKZHmeNqwsvoQx64vdCjjkFAO2bKd4dexHPtZg9A4dA0t4utsz1Q7RftKeYn0fmEOWUQGuG+aloMtekhKDFtRNgIdSttnFl1e90OYBItgFe2890kuKKz9RZBQj4WKOkXpK3wwihb8QAp7jRTrUmilDYYQi0VvdvguVLw8TpgfkiUe/Q6HDAd4/Nq239UOGMJvyUO7VKetXVDHPsl+OFqk1ldUfKd/b2waHLoUc6MwnDZu94tD7WoLkyKIl9jP1s/MKM4fzXx0MmhqDO5VE9HRj5oiFc7dKdkMD6KjaqyC/KVz7pBmaB2x/8KFzOZt+BWU+++5mwfyhxUsAUZi8Jok4SIpciLmZTUMcMwmA5nglIDVwa0OejrsO9Yj5kw8bkwYose4/Y31F6AuRKcDmNhLvb7lcvZkp7gEacnr9GivDrgjfiULxqCC9OIesbFQT1vLLGQ/cOIZi4Egn9yDcwx802vTCtPaZjU1Ff2FZ2RDYo5r69L1XXQ0ceAO9kVz6VYKsqp1qU+FrkJo/D8OJxEdycZ7Xz7zvxktPZXeIxmYynFBOFmP3DJS1oK1sdE1NJcTKSS7yYMEmnm1gcAbM5aFW9QSlOiU8CnMDG08/S2VA8OflBddt06Nt7fdqw3HDToxVMNCRI51ZMo4x6iYh4aFuVT4Ns/qxvxeCxdMo8l4nDsV+IZ5kVaIlk4HkMmsvhHypRSdVq5KTXIEKWvSkEpTcwyL515bebDYGhj/uwFK8YFZcxuSvl54gFaUf2ke93jYuaOYVM5l4Fbm9lEHfeatyVmJC9Xvdi5dZnbIxQUY/7OEKTDygTgV1uKe8V9PQ5k28QwOTBa3bUmAJOTT14EL7tRPxEJascjq9blEh25Kwx2jvNq1Z1deXJZo3tBw89YbIqZgTOfbpa7JiBxuZXmXE5ukEyNY+7eF0u6ZGkt3pIBx6ug8g5pM6NYWfH61kuhtr1YqCU0Yn+BWPkUDV3RnzHsiBcRJl9illoVgYNzPZJeqNiOffgJ8/dSReiX98MpsQYXD4ujUB9Ka726CnuZ3Pv/bEsJ8YjJmCGPsuyN4JTcxoXnA7K9otWH5wYObcKYcI019MHbRgGX12GBwBlWLamJe6yYr27hL/ZEnjg87pdqeReeXoqeiziwhwjWEA6P1kyHhxjRabD6ErGcOLC3zLHZow33ZEWwe+bUXm8fVWvSfYQJpPirE8ciA63BA2asIZqR6r82ioSj7fXYvYPtA0byq1gJXxsS7PLF2qGRitAFy3UcE7OzIy2n2Gc64cv6ktn8p3FQ6Dhg9XQocnpspY8syZs0zOurVkvqSz5fICMGINmOuOMUpQ0HyZVVPnXuq9kd6CTU3gE8/ZChJwvSJH6OKpF/N259O8XOm1pGftY8gs+O63MbyfUwVsS8VbBP709EROtOvidqW561DawKu47744fe2N6pY5/62fmG1GCn5rsiCpE8GeTvsTEJVqz6KsPxMB/VTQgN3LylamPjTQ59QwX4sMeayhKK5sbACGZvfke5s5gDJAyjH8WAw7dqTK3phg8MGjobCerBH3KL4T9oXczsv3NsBonKqRrNECjeYL7DnLoP3aSFOc0QVAmf2a1nEIqyScvTv78t1ldbpTT2osbgdBCCk9lBQc0puqMOqqgkwJyHtxlLY7WlkPurovsidAPzZ6iMs+GSVoXWKo8fTEo6daQTK1ZUhuH7w3wCvCrVkMge4YIBDosMP1uIE+PgGFiWI8/rMdLaf34CguwgxC+bSW0XH/W6Hl5xXmwHZ2NMDDCl4irlAwlwLhMq04D0pVylMF5dCTWsfvo5O8yJLHDJdRpsfmkdh7i+9lvmzN/I3kiGYMNobel1ypV3i0ko08K4QH3wK086fGxS4fI6PE6TzzOs3M9r+RuQ30sKiXWOwpwsrYPl9l+GpiSk6Fvb1qxz0idzmmla95tvPtFIGSpjPCncoO6OBuEYETD0jMkD2aIEGWqrlJX9zdLBCReU6pwp4p/2UQYyUproy3mOWyjxvRadI00CcZ+ScGTkamzzN5svlA4xJdsJVWgrHfW88LX+AAvrHElvNYtoHw/Z4ky/hv6QLaH+2Hz9Sj+4JFe9/FB42IzlZGh4P8sgIWXz3HVaUd/wCRc7K4jkuNze3nviv7fgu+L0pvOAKMGXIaPgc0By+4kzg2pzWpc7eteMEvw4srXSvUg4wTa1kxi8Bj1OSp1X3EGX8K+A3XG5JP6QIL4pPoWYh2pHRKXUuOhXE4Y1E+ugmmKQHyJA1qIl/JeRFNYwnQ0a+0NHz1rapjIpht5/vmryEVq3Hj4A8KRE24aSZkH9mvPu9YOmYAzf/fRVVP1i3gKGLEyavWbwfr+dT7IphFTmrGgQaaBDvFIllSV8F3qhAZ/yJ6nE0Bdhbkzccg+N2/F3n5pnuGrmeaNjOpHTRAAWpdasUUbqCZevIcUcDxfcocUP2Zv/u+QldG/QUZYzci0e6gaTS8N+CeSZYrRGneCxoWQqkJw4/ZU8IdiSlOYSJ5mK7zBO9mdg8p67L0hgqCqMB7D0BCJLkpJTclBreF96noI2TW+uBglt8eWobtNNdT5pq+q9v9MEzwdNQ7bBklQgIUDuiSmApGJ2ViBXKYUNvstkZGRjff5WyUh0SlVxJrA2Hb5VmCJFdZ1G+gSIncrsmDsYSHos3aKSTaXZnu/dwdUZH+1NXywIuiJKrSIMOLseN0lah6GBpNMTHSil1EMBkscDxtkxu9lPFmUSeV+/+iC5qsdkL1jykrPuarnNqqQCHz/kxEJMzormUjKsLZf9MOV6tHk7kFTVDiFr8QssM7+CVMsDxG+1SjuDgZC46oEkhNQiOsRoEufNsHfMnUOL/D+BgTpkT7lJlmPl2CAbKYx6aVIzP7jZQpQAYM3tBHCO9Mh1L4AKgcC7PltxXQQonPsFhyQaGgC8A93WKTwm6JLPME8t2YfrschnRw1IV6Br671Cq/sHQQPQfy6Auj/XJX1Phc3JygfKZnmsbtB4v7JeufFbMwT5JHj9NB7Pm2Ih4LaeK735/HIo1Lx2+yRJL+mohDvYT3f1uKLRKvPl2SzjsC6guhQ7/TyqQYs6bO1viZx0voinOHi2+LN75/FTlWI5fvHSYb4eICJiyqfjyxerupg35xDZ7HK39syM0yR/dUuiwZucPc62IneKBMIm90ADe8FQA/MlMpY95uWuN0FSScDcRJIQarpOjOxNZPgsv1pq3tWTPl8qNGxjRnl/HJyTyfZqCVAUUxBrm94zwo88+xNUiIRtbPY0paCQGjYdV4MyPq33MTqEAonvn4NrNGTnF9KXwB6t4p/ntas+1c/QTNSOKJ5LpcxNw+l6P764wodCYuWfmP5KMlejZP/cTY5Kvn4spiE31fzYFiyqhG96Pbub7GdMpF29394cxrJFlUDV/SX1H5REfN03rR7YLg51teR4oPMuLDpi6bDqBzLdpDLtX/dzCWzCJrYtmcBybUYM15WpGXytkufJ6op/BCcWSTso6FJUrARd6jNeibWxvY2gGO7hj6j+1Gxn8eVme7FUgWl/LtdJstDpH91EIQzd3wzI2oXyHCtjNuuP8cDKGqcf0vjHgtC486LMoqKsR70MtLbBRkpReJpafx2wpHLXnjOLyTMKSLjGh2QsHgRkErNNENkLX07zhDLPOIZisl9rlZp2lCRkNAnl/IzNq2Fxobu4Kg6kGeRR9/ZFKXQBmioJ1eJI0ffv8vZ3mPhSU4QDWWIJm1hj5/c5vmCxT539J5PiC+kqLt+C+ej7U0r1qHB4Df5S6ON8fuBDmkzKLC58nhH2obxG9OXT/Y0Qs6F9cqSSZoeDvRW2iFKtnvRXnmG6hLJkYM1qhVsLn3VZ2xFbZPlQ0DJnAZcDEUyOf+7HxhN5P6YMYgkozMeSSfJVwitGWXv3OmLE9GQRjboik8OYlZVIbgnOBFr9/Tz1RpEfSqAO93rMMyoAdHwJj0oWOzwjn19A5qygm8SUPYigPAQDidgvlfGDzfQ9Nd9+8FoznaO1LUHacfEJlbHF2ZilKTX7BC1Bz3x2sxKKMI7pLP51hdicAp5Xmxl7zZCZg4DosqrzH8HJ2hJFzIvwnECqlfy98DQtMXU0Lfp7tuI0P216sjS6oenibDBU+nX1ijJ1NsbGD8GtcrQLmQk1zvMq/ySkBP47eHVT2cuGUEfOUW06VweR6NqDgrycGAPVpqmDZYilGChz/cG2w51tFOiEDDn4P+qK5OagsfMZNIiqOpDdTM1VZXG9nr19uSKNh8gd66LtnY+iPXwtGP7cttYBk9I0gM3dGxi+D9bwle2H1smwYz1RzKldxR/yE+Tl5d4bsF12cGRls5M0F+ck/P11xnQFbHUJ13n/NcNH4WtM9JJeRJ95uYbo687o1ezajNQcVfR9d4gSelz5RfWOzixEF5s23XduKiUCC+SjSYI9pGViXYVA4CKYo9GEJZj73DDLz1ca/k67RvegLK2CZ/TrYrydez/bRevqrkvwHcZvFfM4auytuAHovYfQk9oiVXHV8aXhtF52hKg7jhojzchH8B20Amgv481j18pmkIPxLe0RtAIcFLR/ZdCXllZjJMVHvCCW25gxLtfGSvdXmwKNy/Kv5NVsXy/EmG8PQfD2aXGkj24vfhv79I+XxyGyQ+SwZuFxOoAeiDwIUbni1nMfK5U7oEV8JjpcebhDeiBgtuluSbf2KozGUKEC3eLz7GFZb8mgDov1er7GNIstLSCC84wQB8Bi66TFD9HqG12FRSvhgo5L/T1NAAaPMrtsKHEBYkJH27jxB87eXaED8LIUqfEJUrM/ubjDq9Sr+w7+gwomBvG7YW3O0yL+GNT4duKoeua+S2wFgpj+rQGil1YSNcHvBfrrvo4ZqtgTMqCbW8beLampjedCt6spyHknuFKpc4SInhxzBrZ4ySVibg/qkgv9qR92s/Jmh3794ee0zyRk7EjYOLYSFuEzEhexN69u1Y87EZ4dpY7TBgJr7an5orLiG6VJNO5YFdusLtBS3VpVWXjeB5CwcAQkmRm5zvpbHbCUtt5ZLzI2uoaifX1gjXmWGQJCRaehiHySTt60z8MaOePlvsGmaUL1Bl4+PKVw0ueBRHb3CJ5+s5/hckL4oOVHaezhjdgqGGCrRzb+nD0FZFw4qN/U0yE8JcsGMDtqvt5rJNlS0oH5l+cQ/2l9RiUv0S7VcUjkGY9WArl7/qTqVtXwAX0dYPJ8ObpynMXWWEpBShEw8AbSqa6VmqOsY6zl89HKFVjpaSp5Mt7Dgi2WU+gdbwUA/YQij8WKDvVPuvf8NhV60P8Wa4WW1HTjXUo06oVCricCoOPzC3eCsleDLOoJjZglEca4fyEopPMX4ripNiSzv4IunvCJRBAtuEuAboBvfq9mL7gIystu3mgUkrZlq7JskJgZZ3j9MM/4HkD76g5+jKYHzgaeD0hP/bOQN8t19UrdJH6XUlNvls1wuJjxv66/3nZz7LYGHuRw7e+haWsaLQxUwf7U4e0Cw29f+rVdg5CZKIKKaQMSceeKo10shE/zmX8EW4H53bpBjN0O/l70A+qCykAlCFDiHTI46vwXOYrsfk97Xq6geUhrbYCz0tewlXaEb+u30f02jGmewlr4CYs9TG7b2XQCC13c6i7tyTM/cjRfSTdPAvLI8AjatVOaFh9ZbFfQIkUUBla+FHlDFUJNoSF7ypm+iJ5ExsAXkYMdA12SZf1i6XDI193HejLSoYr0Ejy079nmBcR/QkQHJymZpl83gk/z8UA3mBAA5iJVkW3ODYE3aYBZC8aCgETcByl/lheBGMO+cKHYJV4GO19jq+cGijbbzSnMk+2y7a8DjM39i9KP8lARLuCgGwVOa+qkxyU5DXE+cBDf8CcObp/9zMx1WxmSrVQdq3c6SyLBEf/vbZlkW/Qw0mCRuHEoeSkzTVr7ygEIaGw6Ixc1ao5eBBtpEvDNuSCYk4LLixQAPCZ0/YGcVNubrpcXBcnlSgGkhhCaVtZFnOxWvTMG4vfoM4QflkoGxNoJPW94KjOzQU8mkaC70LsC0Cpxv7N7hmxzCIB/h8AitqWB8SpYuWibbo2gjX7vID5mzVAtkXDksIEzeD0CJIT1WeWYvE/+f4ajtgGdIdEJT9A6tHP3viV25ECIpMcy1c3PkvPZH0qKcJVMi9WLq66Vn7CdPZTJekfYtZhIrpj/aek6cSXeo4xpoXpYSxX8PEaw4exeqMeVgTCB7XQhIVpLc3scZgObGooT6qewW2qOpRit+bYUsr8msGAqIanl706r8SjUYWth1e/PQFKE0xFx2HkpZAn/cnIZ9qIHugHY2CnSnkrhD30rl7Vtmm40uFMwzQpZdLOE0YkEIks3awSzlvNkPTggV2ayH9FrhHdJe+ecvF/ngwozsIEiTJ/8WARQGbqB+uozkr150hScdc9JROJDCv010tFb6f+wKZzqIN5IBSdn3VxsSP2/A4OUsRGT5KAP/R0tOt1VwViHzreFX/hHDmbgeK903RJo4SmK9qS3gZAoBO81Yu++A/TvOZCZNOMcka4sjIFCERVYZPWNObPj5+u9dSFSHNRCEZND47KvDv0Kk4iQxWvaRQ60CUcaFymXm3ZlhJ2sntMMGqeB7slr48LA8AsHQzkO5Fc+yemUo2w/5qUuqtP26MonOqEMihbvKCFmMK1o2aUgx0FrjqhAcSNgRshTtE0PvnRWwrsmrFlifTLU3i8isd9TZxRWXpqM9QP8xBRKu/HHr67BXbVGkixm1kfTQyUWRvt3aHklsdSs8iYKEqDGa/B083mXD2lsOqyREiALHpEvEU55nN63311cduTvSoTx/HZLVNUxdKRHznAbSPhNpCHFu+PqABtfOB+ttZrbWV/Id1grKlHac/93any/oWwRTuUpC+kaFWo4DQzoxx2W4GwoY43Rv7ZyxSZ2acFZuMWInCSgVb9ypdOEI3Dg/bhCPPzgmyoib4DB++jM7lzzIj78/74NHpOPAWMu/xX35EDpCcjbX3u6he3kEiWwcX4eooaiVk/0pzA04dpE3xVmGXjLg+ngFal15nRaKim+s2Dg60iVXgWOeMLdl+kj4BhddVpBNedOgZPBh9LIi/Ia10LNsU9/1xTo/qI5AUvyPLagqnfuzCczGdz6/E2C6DjToG9nBkbK7+G4EGUMCrYORIkxQAG2USaq6Erb+qp1FgtEddmp6BF6t0bX79dAmUa3gq9O1d9sLWTGNOwvkM+3IVNLaR8h+7JqJSPwX0JF7kTGOdE6J4+4CbxyyJUk+vjeHjoG+/awQAZ4/l7A5jR1lzwbSit9BqbJop83h+P9eWvJ5iNPna+nT4c4bTQ30zQXkCKeD7QVUW6w5J/gw4umv9loK0e686MuF3VJpUPZldYnL4DxAhHjQDITrYMKiShBF+qOFnFa6QCDOSVNp7+tFzZqpZPAMvVz1uYmVxWDC6N1kJwyurTM3YrN6ZCidGv8NG82Mlzpud74ub+Tf6sU0YQKw2fwA2ius3dUJj8J5c/wZhOLYFgowj0/Pmk6PNwGvG3lT9bJMsqomDKJ0IqLQwfQxwv7mg3nwcnbpE5S7QL9srxulAC+2kerwHqW6gh9L4ylgCpkfksOnZGyXR/LxF7ZoTSdWwym4i49FBipIkE1rWReBWC7FmGvCiZzU0J6fosilz58CPaIXMLKJfaaBzB11dZ/dN13DYzLNZVwcnfOVQeFJfDPWHtL2gPH+sYujHxeliMtf5HAyH++0sInQlUF/Lzi52tYNeSapsybaWgCsC6B/j9YAdQOYjo0JEbVOzbSb6SwYD5bgwu+X8B1P3w0T4qhQINpNC/mR2zUdHaEl0k5esiS/bKHD56GCuCjX7JbydJsTKW13VZ20iN0/IVm8SfVk6CxyH4A6tlTOO+l1kV3a1aQ269/QkKGJfm1HcqCIg3V1REb2ZKJif5tgE2wfMSqZxD5/nxp5F9zISyvjKPpXcgcCcnN7g29b0TNpOYSsJ+q2sTxX9/ilZxtjzTZRDLcddc3c27cdiB4j+Ib6eCCoV751frzDlbSFWYyrOx8xk7LiqV/qCLm0BZ2qXOf7NmMsFO4SCwBilpAHhpZlDa+5BKlIoOt9iXLqCPRmoDbIBp8pGYADCCDsF4VL4UdX8yV5SuNvaqBLrCsNOepQ4XU70AEznrLUmofZBPV7iku3RBiHpaNTywT7VmT6hJrRucr+SQAjT7WLzKl/QqPNKzblkr/9Tv28QZMRrqNFCkn3zTzBjSxfNodj0gFxEbQoOV36cvS20fmvV8013IpwLbYUpY7YkxU+O87387Mm11ubps92mfTH4KNzbodn4FVn1MYf3OcOp2ejQH1C9kx7hTlvpfUpKd7LXXds2yauxJL7+trFNcWvcHLH9fhqyqeud+VwXEFhEZQQ/A3rpReLjhmW3Wonl6NRjcroUdPOYihfCkL4O5olxMxPmfWLUxVmFW6DJ67s3QCwFo2OBE8seA0OEX6eGLn6JwqQC28OvHK0ISWcAAJeS1PfoFMG+7I8zMA7gOITgbH6ZWsOomKUMIk6KYfy7uumaWeMVdYu5B33h4E7ygg1L0yyJ6CSg7c+E2AHDGSSmrfykKe/+dW/c0jDA+f1jgm9HLnPdjlbdx2WFn/z4dX66tmkRDea49gMcl9lQsBn4PEPsDEW24a5zSWFGuo/6b2YOqiQ8ZBVYpjwA0ZHJtqmfp1pzBNyITozRjRPNMS+XF4IAKoFHKHOvgde1yQDDEq7P2zDE+GdyJcKMR8YBn5eyyImcsv6tlkq7oSAfGNR+fp2Gj9whc0Nx6RVVIB0upl7Cx/Ma3NYdOuBug6gg9Xj0jOBvgESyxCVhcn0t41OlGLSkqCY0Cp7RBJnDltxJlFEINK+48lz2G+PNzdVKOV+t9hM6WI+cBrMCC+3moccxDOUGdhDigpHFA5GffuEBrCVS5YpMVrnUMjmQCcYWaOAdeSPnVzwKWW2SndgoVCKbPpDTVF50MsZXnuiyVYFhYPF1qDl/wp2oU9sffS9pJA+VrdgH1/TIA+kDksaCKWONp6U2myVrCJDuVWH19pYN3tB/9oAdRxx4OTdWCn/DdTmXBJtN+jeANX1Ie0hS6dHhucmXNhDIDRjOm/V2AM0Bbl2nSOa/xzWkmy4a+kGVldnhdi5vVZVFwMRH/QESIzymnuDisfzX1xVpziOGOQuQK40J7F6md7O0bVpjXFO4Arkwg9OnGLleH6vMJOcDidUluzdUfo9JpFyq4OxuPrevVa0HhQROyjGYr5qGUbkqEcGA1v8IDztDsw9YotuGdw1sIlEf5u693Qk6NsT63rt56DrRzGY2G527vGDveShyhWmjIaR+H8c85Q4SszJgO4Go70v0dSDftKYsu02GpxbRa2garLjtlsHGf8AJ2Jh0aNiBUicj7myqnY+MLjYxNR09U5DR+qJxAv3uRbTpIGKH3IcD/TbIUOMF5VJAcVioTp5X+ruzSgb2AFCITKki28EwexueWtY425c+fUhKb5be+8PE2CNol+bBRi86DN3ptRH2i1ZuZ6EvmEhpvPrnmoTHdWTHfvD9xmh87r2NODO82a3paBem4BXavrpy3V5nOHkbldg6wvI6nMOI8rpAVIRjZReoCkvteZtU4yTqIVqzZ+T1CZ9pw27INf6cXYEW5qGg3yeilmYjrSFG6A865Ueqr6p7ZbFn1E+vVHoBLbFdlc5IceNb2eu5YL7PlZWQlhDhX+auzuytvc474MV2+/Nwzzduid8/Emk2l0erRdLhFgRF6LshcS+1SA7WqS0ywbbr2MSW3a/ll5raKtukPDpj95KOM4V2g1jv9cKpyadjAS0OkoWHP2jt43AQDTvcqaewnvMiEX1Z64wlRi4Y/LzJyxGqr7bEx0tQ9tfvhmwBbkyldgrcL/+JNlyCHhnF3bS4vOAvQfHv5Ui0VyrWh8+HPYP4CCCUqQ7P8JopI+BwSPjhgQUKOr+1yGhz2mRoFCsv27BKP2qmNsEdEvuszfM2KmufiarrCuBXsVWqCDVtcBwe/Nt55TZJEGOWrANp/hpNhcLMKUMJMc9jw7FBFau2vUOfmMGiScN/SXVMGv/2hjhz8O0mhSZcwExBk6bUcUwDQ8Nv4Y2E7D43y37RaP/RViQymQxUfIjiXAxDdQLCKFjvetqFKHKMQe0kRnTR7SqxEqNztTSwjm9/PDVkhtRkc8wJ8xs9sggS89p9K+xZi62wbqChGWq6OnXj81EWVc4f2UbbDCBBgfZRpha4U/uFbhGe5IYqoYBbUzaUCzT70et2x4IYx67q566SMyIYAc7ov4XGN7Mov1CKcwE3U9PQa7TAyyVVLSRJjITWHc0+n9/XVXrNkEry59hebnrfU85vkh1e8GzwFCVmfeyd/N8IAQqrhvA6ndduGcjhDAEY+7R1QkERRFI9dKnXRb+JTUlfs7Qjq3kMqC7drOj4wdIzJGHAAJdqTqXYvCoXA2W8P6UV457Fy+LX9/Jic68kdQZ2SftpTt3VXHF6moR+m9yGYFmw685xPjj0ASg1YaODAr5NSpiM3cVJ6XWFJ4WYKk7i4iVVTwqe1x8qJ7eEQOvffK9MurLU/uIIAlhgUaaupPfwrm/jc8942hQIOYvj8MPseuO4XPuBsUuqW6/Sx+r+iF2AZwwcbB3LRAYFArVSq0nymYgS1HVcJW9/I2RhA+TOzFbPsBsvlgdTTjij3fh5mOpgGkP3yI/5xxDTVqf6GdqvZO4Wlj2nRyupQ6I5/w8lRINxGNxIpEVqWiCYMiU7VvzeSNE7xx4G9iNvk3wM1PzIzJK6HGOB+Oj1OhbLF7Zt0iOuR0NGfDzpDHTQiNjw2IpTbcYGVIJGj+ihaLcp0eVqFj9lgD0Jx7VYgBWGljzE30XaHEyf12j30XkwVvXblRGbZvhs9V5evhfsJ90x9kbY8WL4Jg/UXx3CCzA/QSj50a32bADbeSPLr3Hdnt7sqTAOqAzqjENdEoGITRYJRzerWN4QnkPB4adAjLEZJVTLPJl0POWMGU87UTjWUHxW7juyQIfTUS3A6rM5zohxmCdcV7iwkpUHSwvovbm4POf0Z1RM4/ue6wyscr/w/Nzs6bpwiidLTnFGbtXM5ZVJUVfMWiBll3oyr5AEMQA9ZiMi4ZVGx7QBQ4tpuUNE7viAJBZEy/TpZ6N2zX1PPo+oMB7IMnvJj6ZPP/82bqZwgnk+kZIsVJDGs0EL6cfPdj6u0oMUYYqp6vijNnz4nlwV6h86PZojTmgIhW5z7gtRhqw8xPHO1G2D2b4qyC2IHSHrGafjmyYw0w0wTovkC2EsawXl4kBQlqXg4oxVKCixFocGbJx/O6/v1c+4tSu1kTopfCh1DBlhMFHP0yRj+760CFcZH0ju+1mJGujA1JHjjSRCODmTmVhMzy74Zzlk+xlsFs4zUzYPFzeLCy/599fu7BC7pxzvLgcJPpYelzA5+jwYgfYabn7PXZQrh2eVgAtriNLcerl7Qk7AibEfJb9rjOhQeAxa5k/d2HcmmJq4m1uPTcyep0E/JxTipruBRQwe+MX8N+OskC9wUwVgjAQyprjJil0CdS0gtn7H8WGsfga/1mr2j0c1iNAdc8eV5KgE0J041/Gd9eqs6e1xMYOR3ntV3h3o8lzTl2HpRhRW9xdneDNONxRp2x8oe8hDvJ2VRra7uFBPsyJjRp6cuRLsdDV6tQ7VFtiynbHhPdUaCwGs36mDoEK9SW+KoRJatYNJOoO7CIYjL236DgPTLNEkM7QO5jHLaBGh7jmzDTOhOTRgrGPyOxi5f2W4qhBFVQOGm2U9u4QOTlMRCAuAk8nkPJgaSZdsaTgBpWodtXnotIgvPynDq9IP1chDcsDVwcinp2iOVCC8tVWatI8srbgewS4T01JhbUONYWqsAfyUZOi/1GupZUZWDL/PvbobKuXw7yK7K1qvcpW4BgcJaW4kZndIzgvdx3C1JNLZ3KRKA4rRnGtDnFO7GkZekDQtndgdhTC+gLakQ2zgtxl57Jr7DT5Uy9gEIZMs5TQoAtUcTqC6k24g+PXXKL0aJCZsh0lYew2dWozyK8LLHXcTEFCpv1mXqXTXZyE63MwX1PJwtcQ+IuZSre6DtvVRdngvuSe37GRRnmugksHZ0upLOdy6Bxq0FcmUfXgjIw0gxWpGZHvXc2exuSuLdVlBqg1iyMqMLPb8EzSeD0hNQHKU5UzZm749HsAUFZJYyCSCZJX3cCo8GXkswf0MH9NXUJ1kMWJMupwdY88d+Tc62KxhR6FkoS2B1PT3186d+WvID+pUwD/5XwKu+sqhs4UYqyynd+3oI58Eiq8rNzN84CcvKIEeqP9DwD3hYwSyMrK6hfkbQ0L0eyXJ3KZ1gUyR+qh6ViW3MpRjLCSnVRjClulSVxftvGyOrr7FJxKtDFs+3qjQj4hgVaBgpGKmbfrURvwPXMjtktmEMTw/VKI+6zS8M0B29jlE3MQTqa+FK6HPU7HcBPTW3BRRrY9xAUhDHv//5FHYo/sviVbrFiMfienjnE7NkAfWkUoupu9C91UYVUDBkILS2/B3Hgl474bMQHsE5zYcdjhUdIXuCnYzi67tvHM/EFYMtMJfFbAVIgB24JORqajc5ToWvI6opTwOOzM//32rIKEIocYAnb0Fg/4luj4UT6cLQahXGlK16MZ7j8SuacokH2sMTGJ0/hn/jevDuJbgrR2Q1CNZZC4VDLwvE6cyQrV0Q/QgMB7MokYSViYaIi3QbUu9a/+/gzFNe+HdUyL+Zh/M4lHouhvKZb6DB9f2CuZlifzJ4nafXZCC7+gOj+lE61iWOxdpvnkEk9DWw+vzY8hyT/9nDk3uBdNXaaZ3G9Y+GZdmT/P3GkiYFh6LdjTvrh9Xml2C0VgUMGaaIRDMGv1dpvAqQkBufmr2mXYYDkBofje10ClO2ZJH29S7cNRS6HGz8cGv7mgP3iE40HfstxDaMoK3i2A7Zr/i2yOD0EiOFNzudZj5Nz6crXjol9u3Jf4CtXst7HE/xtZphs0z13GT6ZEeKBFuGfSMaU3DtoVetVeqzh8FngK3Va52TIIcElZrTZsjrERpVGMeX0lW8ZJQANMbmDYTYMK+prnaa2sVzXNeuc51jZlFnapB40q29PfFCs9Iskt33rWgRCtF1K3Bw/X5jftwHe8aaNS8u+h8iYvNnblJ/mMkZIkcEpKYsfMqhDUq+Mfa2fTrmf1vEuSXMrM0yUpz9SnxNgwVrA9wxHzOCHQLG2P3afdkC8IwMmjuel2J/U/SjYRr2aAr0QCi2z1W3NLqhakAt80Fc9z2dc0Ltlv0EKqbpCzr4T9mxBRbXdLB7MaEAO05OicMLtIBcwTAuMwwDFVd2FaVr66LdCnZFON1tsph+XOWTKi8uwwQRrUqWvHGPbRqRZwTCJlfjBQ2abn8c9LUIC2ljG1WQLWf4zpkXjrlLqqyLstgR6Mrp8YybZKztpza1kiMCWJ484mQ8/qZZYQSGmErbOO0i2RqS7J2lwF0m4C2AhAhBSHVpgB56OjK6VfkUtxPNAYFrssya6GnC74ApjVBeV0iwwwn/dnQYjajtwsYKo7vBiFG3+w/pta1oMyGjRq6OaCz9tpeJU3rDKokUzcVxjxkNBTJaxCuvDN4WOG9t1i2zpaSz8vtGnq9H/SdaMSN0ymxsod+Wag6SxZigZ2KlFeGRp54tztB0oUI9TmSJow7YEGkk/AnlcuZeKdTfp9JtnsH7Ep9D8qE1aGNCyx7NfGDYr6GiQV5iVNppHf/BjMLtO2xkThd0sFnLCGJza3v1QNtvza18IEye9zT/KTpZ3lzdOcEka6M5vi0JegTCK+quK9GBS8k+UdaYA5i+lR/6dXqtZmb+OqiJ2aARgRuUQolhdR0h3hpr7cqg3erp9CcPz1BlQojOfQWs3nD/hLbNCR18Q89CR4Tj9jaPXzIFl1f2JpAiHTMD4YHwhMmqzSyKBpteTpEfBNOYbJrB5n80CZ4JWxUPW4b1vyGtT6ViLryPPQvO0mO+1enymO3rIs1Wp4LaXUjsjd4O+D7FgUag1uSAkycUL9OrBEsScxwJ+34eM3mRxe5PwaD+2Nrzhao+CvUbT6+HUjPWct8G8P2yfPjSCkyMa5PCSIWwhmFPHtjYIiVScFspRTVIoBUs7o9iT9RxizMhdKwJJCez7Ki21t5Cv/CXh3l+p0iXnmG4op4mz5pmq1zJ3kX7t2uHdx3DEMUoNIMqDnmlAQGv+6ikkgMcZeIbdxmn7YYgLBr5Swz52NgQ6cOYN6HnQHezbnDjaiqyOaO4a9XnKdGNkNBuwk/Gy9mBlx4lqdFjegXypYUDCyU4sGkLl3PnQnrvwVByHMY+d5o0bWhpulK1dzWlRHp2OL+ilSaZpiClJr74ZUCXSfSYusP0brqgQk7Z9odRpDksMLuad6z4ZJaCz1HQesdWOqPvMMI4sWp418m70QRbmJHIwhQP9obmbwXVCkR/SOXx0SFkGh5ULP+1UaJtofzTVRy67H4HbT6B8aGVbmEroM09izgjE2x6y+PoUqp0nbwffEWOzqjM+4LP1xoQ4n8fqXujNI7nI9Z6c9Qc08BctBAujgOBRI0AamFPLnr3m0Oj8x+rkVspa4ih86gJBonKYFDz2wJ42mM1gYbE57XvMk3X52Q/XK7S2OXxN3DmPMrj+3U+GIEAMkTS1e+wwI2Ubi83eDj2XcHczA8vAIMBrtUakM4MnIjLNPldQwYb249ZVpUv/R5aOWAdMIV0+xlTllaITw5AeC0duarsXSokCImoKACuDD94liu+paBQ5UnnibU7XQtBfK2pf5FE+syC3dbiOz942hzJMnt2jYTvLtd69TF3iZnzi64KLVa+hfg9iK365tEw7j6oOuhAYkfjhupbwFKButjUKvlAkndebOSArbl6j+OGmCk3ph8yEg6DPiGppHwde3As02nukEr4OOr1vKkvwTTGjv1H9j44sCAcxZt0tev1//BJfyyerc+l5vqAn/sGdf7q9UMtU/CKeba/IL9Zfl4qhihfdl1ODSCu0cO8/d5K/DFPinsYRo2hdtBm9+yh9ZvhytCodFsWsaIzVfb91BaFVpMaIx2TG+7WPBMLpp90q/r7XJJgnA7y9eDxEyjUEdtRaE1UrbAWzkXOzcT1ZIB8PzPf7ADcA81P28UIzQy5GL2EbXmEdrE+yfwktmERqMoAgQ1VmHOChyBt5pAcbSNea5mSrDuKh4Wpada2YsoGbOiD6CkHvKEksIbT5TqZ5a52U+VzTqxKnGAgxzy1R0HLuwD6XllzWCmi204PDQ850kzW0DRXGTaLuhrSo1Xyx3gUCbKfhwLPnVmrwNDwc67IsHxKPPyD/sSgkogYMiHLrK68SSdrNMN959wwT/g36pPx0CcuoLYIabrIFRub71lGIJKG7Gu3dMDIsC8NGandHxMAF4kjvpoN8HfuoUZIAKameEqQFUg/Gf4dgYiZm3u0xxsGCMYnI3aDfSI126U6I6Ntu68tA7NBVlua+WhvMfyFSvROirjx/AdhmZ9RYkVb2969SpmGTnqeWjNyf/CusHBdFzsMz/CXTStzgbEtaoRVqpBK8zIVMxqY47/BoXEpIer8LZRAnGbNKgtSNnD0MY0nM+iHTlrBEoI5sZ7BcnFf+NqWzh+ZsqKEb9KAX2YMRT7omrCOaOoU74OR36ulie3eJqnCUpqs/BNswOHyUZOfXly3E7ts8uQb0Bo1clpQ0diEfVtLs4HPYueIDdL12OAXYxenc30mnqsIMRzl+Oy7tpIZ4FesILVzGCTmfcrNT3eqYJI+1aMYD6Ph9JupNgMuhlnrdsULMvItUFjCwgda7hKDQrvTu59y6g4biBHwhMgOkrczlEV4F3q+7VKS6zj5GtqwVEIDRt8/Ql3sT1ccB3qsN9fgBETQ75xz9eIoXuqLQG/gmVRlhL4Snat5Xvs7wPgGLeALxVyiMhBFsCHYylfvpFsZRXFAeGtNN6LZm5sKAIAZktAB7A5USHOhAGy3hCNoCJow/y0Ejnkg9GIJTqZHcMuiZf+evhi6rKpEw9vpDIUkRRDcBNuaEwixYddSB7h7UAsr0lGGegpMTaQ4YkeeJUs6U1gcAEPR0cFUgQRuHWGW+cHKKo/jUBjGYhoIL3NUDW02V6IKowWWi74qOUno3b+z1aZbJbwBnfESSMC0sirsntIAIsTltUcAOXS00Ijs3C/iJiqa+kJYPghHtXCxSjYLmGFYDmuu2u/PuCfM6D8JjHRtICX7ZKJiaiKHJ2mEe4onHXX6c6xc9D4WtptsTs0z25m8JNT9TeMQS/C+cffyNexsLFF/M+cWF6LsnMGe2CVKWWAz1jt/R2mw2BY4BDY9g5sUWcN/rMY80ypOlS9q09QuiT2k/75BQhTNNF086QYPvGDN/2rbML188xKy9aV8BqFy447K6do9+JkUtPAHZxSz35t5BHXL0pqY4nGs03W/3LRS1MdcLcb2jeX7/br6pHkW2noDuOByBi/c43j62oWbeCWgoo6bLSBd7cjAEOr1thotaRl/oYeHFMmB5EAOKJVCizlZbtlhL6cP3ioBL2Aj4HyeU3JvUJohCrpt+byg35CBSik0RG4X2eP5NR0R0Q38IYOaGs7b2d8j1T1xgmVl3nwgIb9RSVJin49fRee0EYxdKOBFMu4DOelaAswuOQyK7ftGR0LqCZR4kuQppdjBGfrVaIOF4rsMr+vhrxz+2DEB48BOh9iGL9JntV6u/DAH0MeWAF+fx5mh04+5wTfpDM90abAIjy3vn+biyMgG+OEDkPZWXDxT9NuHjJgVcu/RmNdIqXAaBvI3NAJbeS3GAi3gPhbsy5FN7GLEmQ6Yqk2J2+PQkNA+3SRgDA9zZHdxmxuIrfjqCifHB5hDIf6FbhGYbkn8NSfeVB+1HJfwFT/+BlrsabzAbcBcuZG7BBU6sIjFFX4UWu8DY6NCgZANVYBQAagZ5gpnXLbvvry4FXr9gRRnkQ76XQxvBIjybeg8geJ61RQg+tPFGh8W+UTpNa/708afBbXD5mOEJOExt7mABWvkdUpdXDzZmNmtb2bF5mxXezX5HKkvAZh0xytYDE0VU3B1kuOhyPh2ctY7f3FoAinTGeUNtO20aqgw0bNbq4Yr4msfUzXsCXpYTFYWkMEu61KsYocEDJsMn9zJtySWYMKYqCxT++HFF81naRTa13z+6Vlb+4EpJ/FsxKYyZkr1a5l2XYc3l8N3vJGv4/3v4Vkz9z8opuqAdPo3OawLRLUWs/S/dwuwj6ZWdQivWkSGO3rlBy2serOfs1AENOn7iEiQDocXhqvVz62q6xgzrxlKW7mR4Kuwn5Mg51LuF5REX9a090k8Tx691TDe8+rUZqXRVFLj+Vq5gY9rYxekj1mP7ruzf8c2rWeJ6ILmsdvbvebosomSUpgNiqKcZSJ9aceGIxEfeDfG28jUz1700x2YEZXwHq6kUwtbhSjOVUHXMOWoOy3Foq8SKf4Oysayssnts4LoduUteozyTAkK1YTe8whMBylZIo4Ee7U7UwMLcuX/ISY14QbbeX5h/YY/C8YLlmW43k60zilMl9CM/2cPyJ2mRnamVTQuqzJ9o2Yx0I89ieuRIWfbmRcZcvI22jQZgNoBNAdnHfgpOXhh9NsNhq6xnBdacAFgx1Qhf1moS5B7SwqJLqd7ghiqCpSBOiHNsJIoN4Io1qsNp8lFsIw+UFt3YNQhYDQxLwilFRSoO5KA7TmuJPVJFGbwfMmVZ6c74FU15u3XK3li7310Z3pWJsZQLfINqKWYmazWBXzk0jxE0PaceK25UTWNj6YZPgh9azlXqDrbxYtw+BY9/+q0w5JSQLWaVcPqB5+LMxa6kSd7F+CCQYQlADsR/518jCuOKmjLl4n9EP5hnhJVjjpWUSI0FeJVAR7pIslCTqovUomRYMF0HVwuTv1Yvjw8GcoyPnuHxlG83qNfUT/L/rzKKwxC6r6w+uXJDP/jcEuaOzVCO+N2kCL4cQj3ilgEVAv2AWBrFiIQOD0N3OJv6k2bhCs/IBmKlybtvD0cl5tdMJzNUI0K514pY8aKYhlZeye0uDNyR5A1WeDA8yIZXz2d/TY26Pbpu6yWQsT8VLfCPSrkQT8JiqTxN+DOy1iKYTz4GrpluXxsv+5RTmbAuK13CDJR8wN9fKepRf5EdMOHo4EO52bkhMyl901Gunot6nM46xAYDN7h9o29qNOU4/23BPtlcW7KtAIR5yR29/uLtfzjgysUztOQwK4XK2thxRVqI9yd9HzN/V5xoViTqEvajEmtgi1mfjSJghfmmOoqYXqjUhD8HZ8rl/sIsoFmI5kKfAbvwBpxO2m+RUDP791P+GkO/AQcrSaiE0S4UI9vLQZjXd18GzLuSVzSicwAOfBh3+YdJQkhpbF5igj9H4FZvVJShvcav1F5ms4YWkrzW8kcuj/qCI4SAffgzCq/2Im+zglxOU/lMeVfC7wixijqAxAHpgeXxudFVph3a0tm6znXHeL2cFmmV9sFn+4y8BBhiTZTeLqEhGSDlfGlm7xIv8FhhpnlERjELDfmB7CEwpvdMx4xe4851NVrcYhWGzjg4pjvmLsterydXe1oLAk2GbXPVyjrzprYn8MCtkgYCWWHRQcU0bMAKXHOF+xBUk6L+l0xHM8dNbILnt7Z90zVPBQrIdj0i5saxiGBk4wy/weBrpyxJDdV279Q/aoH3v3zpRwjD+kExXBsGOzkKltAWJ6nibf5kPxsgLBIlPtGQ0dSd1y9/+aF/iR7YUCSV4e50JquXb1GVxF/iupCwHVS2q4DeKh95NeMTYE4/rjMux5gIzuCz444jBXZGZMHPmpn9mBlOfUJiMi6CqBftdzVow9BYxy6+bvn485o7QwjaerwZu/ShG2M6fpiFXbz08kGWVwAkb8+tjiySxg+PbC3LGOuihcxLaOUm+tEJWvVSHdvsVD2F3uWtKvdnSieUXxD7iRq6z7Zc8bDQWhG59R1fXL6on4t7RcVVkLoUshZigYa0kiSbKIa5xwCLcTT+sx/f8FQ3AOK4yXGhyDbEDwdHxi8viGyU7NfoPOi/YzQDzZGW1UUw04YaYiSN9AMxJKTY8Ids3M+txyrvbgsLBB6UfMWXCP1xsyG8Ie3CmyTRxdmwWLC6yd0enLsIMNX0RBp8cQIaQkosNZh2hyz3zX4Ue9C1Icvi7T5v1UNZO3ME53Z/vyZQ3+nzYakul9u8cXuF+f9TMX+iL5cTmr5UnP0GXsKdBpHiPnXCKvcTOqjRH9Oe2r7hN2jaPNc1o3eOWcgoVAOcquCM+bR/5AShSNu0cVapFO+7hAzmx6yKUkB9hL+dlvs4sZD9ZtoCnZdIZcUT1bGRy2L6L1JcJyGrsYEbw39tNvYZp3HsyGZSQDntGzaFzKNc3ts10570iwqLKPdYYKpQgQS/vql7hWkyJ+BnTint9THjUWMVXr8eIDgq6dpkZnnvKt7LzhDaFplIAzo5ga3b8P6ZwW++bF17qgEI2HdHt7ONle4lZ4Zz3AZ03WEfDprXQExT1hOBkvmjHO2OLGcUufdyf1JDRzcQAs6P9lwup+JwYWO9I+zfnFHiVvXV2w2OkTcvMja20SssyzE6exeWthF4LWEu88tMW+0pLwXzmj5BWKgdA8ONCc/NRzPyikhiw9vGL6y46pKAnLYYAC5JdN1Y2bY8XXDKTYykgbGivjr8cgZjid52nw9/b0JP6YwxCIGtB+KycDX4gURLzeFC0jR2bFF/dVj+Ck4Dv2cauTXbm1WFtdju/01MWu7Nkc3wowwQZpNK9ETnMEm4IGF7H3kADr0l9zl7pdhQBOlWcp6Wd9m3AtKJUR7u1a3923oKoPCVzu+fRLN1wkh4zAO/CRTVfnm+C+ZGHO7mPocyO56sVCg0ejY9RToXCsfwp/lZ9c/Lo+R/V3r+HXSeJzYo++Ev4hUaOwONDgLc/rq7yI9vjIoDICtBvmKAZzuJtYBHIXi8aobHI4sJZlUUCTxFanDS5zdulHoKCYdWMcJ5i+RJST6JPozjVylOzmEL5HodNAfiREI2cLooNspLeQVH+mjKuLvcULOuavPMHrJn1AQFEs2wgFeW17Aujs7r4eNCun5SieO6SbIJ6gpQCsPnryzIkjmXQVPHACzAS1UqZVzW407/nwtcRjtHmWbKgOt7rBDZqHjDilnGbL4XltjkBR+RsnsVVjcv2rdhcKjz/O/yn+PPm9nziAjWvoKJvV0TflwgfHxCjSAYf9CWurpAyeezzBsjbp/LbZZcDnTQelZd6UCRzLme0mD3Dj+hIfMSiP7UIcmNBV3qyS4XCTcLqANYmihlC0VrPYN2YbzPadjKp8bIYr6QjhgBeesMqW8j8P2T4I1ndpi/tWQYQ5dmkuRJQbXuiFv8A6+L78L7B86SCq3YVsL/stHYP+TrdfBNxmoFDkb3fB8mAoDRp862XWxUkgqhRRTGVMcyCm5/zKo6FcjqBZciH5RaD4dBkLq9ZsuFnsQL+9sDV8ZjtxgfYPSur7xGYc2ijhooGRMAQUNDoHp4DcHnhyT+3M1BqO/V7xzbBPYjGfh84M4L1Bb4QqhXxuqwEeoW9zFsd7Ek2il1n9243E+GwqIne/yF1C4XV3NiA2iU4Q42vSiNRj9iZXrmFm1tavS9RdXiRl6FCWzByHf29w+ms7zEkRBPJftZmkbFKjVtjaebu/J2pJTvEoSPTdjRAGWGaxZUrN6We4j9XkqL1131+E03vrEZ15D4s92gFy5gwSl0GE1NptU9Mlk+jDcEZ7y9Ecc1yxeTMD2cNvz8EHxmvMZ0QFA6oBkJHup6J5gMoptglxJE5Nisi5s/7CwVeLmhGRbh2gdQQCzHqbzpguHWDB1z83XyDoYwBcY4ompPxPqLtVXaEd7FHNod9YdlGjW3YzQuVYapY0M/kAC05KLS7dilktk8eapteoKtJW6KMUYlwAjhbhR/SXnXrvKVEMFFan1T7RWHo7T8pHr8GoCLbhyMDIiyoeLwMMFyN8+Hweh+8mKc/DEP53BAeqgMsG6/GzMgEx05GZ0QywlOCTU/jldd7V1l3lr0eeykYDa0BhUM7q7K+zx7RKQzFfKINOEN8S4uliacYxNBH9eo3kFgeL2mxt8Iem5gqtt6I3HEqRpctQNtzkiQmuTyZ7dWxt/k80oEcJl5z1bABAx3EFSqhBbMM9zKjghnepQNtx4UrmmKlXyy4EPUTYdJmNsdRhU016+cd+kpPy9w30c8yPBjFGx+OgoBpmlkq/dCEQ2mkC3rE2WCyoBK0dUd6c+IIeyguqGargmwxL20LWY/+48vuOnR6f3jIKkEKyNx8Uyp0DYSGQYJ/RpNgzBqmfqj7/FczkkkrBVJqlqMoZnbLjlo1BXFZmdKljlIZ0HynfpeG64m7xatWD7z7r0Yl4y3M3GRq5hW2xD/5c6MfOUunRHTgft3Jm/hHKBtqkRjYk4//GPDUX0yZYa6Nnc+JiBTWXKVzO1bY+16jCY4LGbvANHVnIT33KUFZ4b+GZYkCywFgWoXh99ZtiBxnogqjeZXhRK5bnz/xZsMZVX6TGLP03vDhSU7SFm2COPMFcB4ax70+nkHw7TZF5OGvS+obEl9YOh/tReFt62t8nuzNoY+naGX55RVvKeTif1ZQVMnvIBPmzotQE4zYzU7orvwVWAmhsOS6+pzAUhop5UxU+UrMuMiU0FhHcdEX1O7Rgr+mwHYF/eBQ4PEo4prkyg+VLUmO6DofuUDJtA59Psl4fOsFpOWMciwGEkneuF1LbiSGmpkwaWWn+jrRtbGZe54ERH9NmgI8gswVobdPXbKr6j+uXAGhnY4fOriCiTrgoQ06aAGs7GlFehGw14wgmZhfMqVNoXx1fy0nfDbqBQJqXXeykY6NjK1vueEZzm4UJcqefN9cLZ9SkJiFr4m67l63RmIQ05jRIvFCTxxmskHJYjWW+eOmdvUBnNSn24N6UgQtGBdxAvzHe5Q4ZsSiloxPkCdr3NmLjod54RBK1VvjOEgENUHU9luw+/LYK/WkgQpTrPfYZTVekLHeGsV3/TG0TM08TQcEpzeZ2ESISxO7/tN+qcVwjHbORHgAmHqlYgKJoIzdaKXn6rEu6qj7+FAj83Ig9sJ5w+KltD50KXwbYd+tkKSDDGdYMIhvhqtLz/cJjAfSwLNMithHJSXMnz8snSh65fg5bQ5P2yD9mFcaqeObFFPfharH0VNlYoc9sXwdxvWnWPxwrhar/6TP7x/bBnc+K15pmd2tP+iQ1kXPWqD+G7NchE/zdq5juTgFIGTnWd4/zHmMTtqoS9LScDHqmbOSuG6+2zRz+aFlpIzHlPmmDbypabygkY3BW6lLlxs2kUO+xmzWqUW364wKOPs2tD9ubFd6X75wXxBV5N652N6RtxvB903I29W9aZt5YiZSp19raakqo2gwWgjpRT/i0EO8xzdaDURTuygiTPqPPpqTeTWiVkmVH1TU4iaLM8R2VuVqKFvOniNIpHYjdPHYy4QEC5VxCze9N+jaGX8CbEGAImqCzPsXdz0XRSKlcbQodJp9w9wSA/FL+FFF/RQk8YL8w4wu/3Nw3w0OA6Oq2jmMCDFbY4DTd6SepoTwZr42pSRQTjjfqlePS2MB7L5ZwrTKBGNQjd1jS8oorhgJbmpUtWxRNAmXbSYFsQETuLCe/jAXkFZv02b5qn2qiYeGzKS+HLzluUepdDgPG9LIj3i9OXZP9wEbU9XoOm3/rZAOTuOobxL9YUhSP/VstBHl+Ye/2yGYeN1Igw5esMXhQrDpFv76FOzRgRx0pSWUJUlJyq1Iq+CbWBDY/Nhx2ZMdjMatIjQ/bEjjPH3rvsQJsYYEbke5kTLzjPy4rEe5w/OzzNPep/U+8vJt2DnOrsQAg6P2WTNUrGvi6rxPAMhSWNfltRGCHX+M3fNkH1gXCchfNwPTY2gDAQwVfnJEahj84WEpxriYqAPZTf3sFv1Y2/JmS9qXaenphY5s9e6MXWNra8I1OpgsUe1jxpSW+Kp1aG5jDw0nxiQdhuimdhlcIvDGND/zITv1aVFqmtZbX9JX6fzKQYkUtDp+UoD1Icj03Bc1oqBj8yd1qklGivTGeT5W93YoZU6WSjd8OfuQLzbPp7jWf6ndVm46eN+AP5gROWdEZIDg1AF/W1vOPveWwAi6KgQeDOQGZGuJthWpMES2wbM/iBUGSvjRx8mPhUCgYxGJqPwOZnsnFIRV7V+Dnv4LHurXtcUU/5WRhj+j95Ayq8ejnFo4dWGaccMkvlFSRBCFEUUkauF62tRvPyXgAuYRDqf40BeuQEUD1QQs0vjhWpz1il93rN4AtaRNLYORCuQB9Czh3RVA9eYCr3gx93zPDc82ee2KDiXQqt7XDlCTh/iWUCZMapA9nfLNV8zGqPxSH7cHR7uy55V12A98lsvjkcDHRUFxUPX6hVCOoJTOVa3hwZwN+FWuXtM6ouhi/X//N9hbN8+d9aUd1EC2QbV4Uhf3Cxe5Mme+PPlWxYP8vlJE90txzvaEvbFmosTbjL6ZXt9wIDcvZQJTZX/LL2Qatfr9LyN52jyR+0gD53tPYS3K3nkcPIfqdzFWKAR4bby9xSDjgsvFkWn4mym2Y23OHrL+1/Pj9Yzu13rrsyP6Xc5roAm9C59s74EIIth+ulGHYlLMab+K36LpKTAiH1CkEM7jc++YvMjBfF/hkWsA6vR/i4gRyDbROdnqEPcVcOylpk+dZ3jB/A9huQAQOKED4MnGLYWeYQ9IEM09VEofwMLo9HBmp/DlJOlCj2MENfGglpMUDCJ3rG65o8lHQ5t+f6rKqB7yyBI4eAQNxZIIemFiv0Oemqi7dCKZtW1jlt53oul/qnV8N3OcCF4bwee90hHrPO6qdZgN0eWZZpFSmGScfPJU/EVm/rAAUlleKpdbT/MQojkYKKfgWZRI9XdsBdu2i+aVs6+VUk/gD9/XkJede+6ya8rhVvdX+YKz9+ZAvxzNPiRZf7R7kvq93lk8/s47YAHus8//TbtBpb69c+UZ6CZpjSzie2C8sxNJFj3GI/S5nrjNRuBY/TYuKAxQ4lBt0PrwxF15/ZdSly0syQRiSPzKsjwVN9F95TbQtuQ23mU+tiqQKIAsVBj+gaKiQoXXrP9B9O73BtjLX4mZY10qeiaoIgvN1p0OBzbXYcQ7IYyBLARcU4NMc0ChPWgcdeiV7fBjDVOIrm9poCUYxnUpp5MQ3Och+0yJCtRyjn5Hfr3uUplaowLiXH/cNsQ5Yry7W9dgAjIzsplxq401XTL3ajGcT/LdpbVj37ab4Qg6l+gF2PB7RIvvYmKBVDuO9fdLZgMNMwYBfKP5aNBP/nihptlJOoAJRXdMI2E4eZLleRMTqhzfdLuAQiInrR3cRdar+Ktx1xMrZyn3g0jmC2JfdA30S0AkonGOfiGR8uoiustoy96gCjWrm4stQy98nCl38kP8rhrrBN9L8jfL3iTZ35T7bB08MnphBsEA6Sc7uhfzDk3dQd9FiubWW0jfcVgBFvRY0XYZoib8AVcbkV97Ram8Ta4okjD3SkoIVyqzd+ftq5fhw63EjpbPuA3IWAr2uM8HpqaBch8I+iqxDqgabrRvM8IYDuifgrpTgxLkje24lJs7RPpPZqSQb5WugIwUdKLhgwFjqRRsv/T3zrfa/lqvbuKOEmip4yixz/sdOgk24TnEh6alJKOD1/McZTB1rZks1NdPw3X3XvRzczGUQ30NQpYloNLW2UK71U+9dSMtzqLJCspKmfw9HV3OEfCfe+xt+D6jDCw/FBCrRBcPqpL3hiSElsx3tMUFPItdsozvvCarvYB2/qEOLOFiG0ErqikH+A3NMhlOQGcWbPb4KFkj5l1WkvsASNPZ09c5suCO+OkT+zYWNvjNrqwJ1QYQDVBJVddM0WcmEyanpopk4abtNNlplMwwsv+dWed3NuiNcnW4z1y3FI5ov9UVKRPnBL8SrFjqxM6EJwV80YoPR+BS0Xb5OKnlq2a8OT2x5RFTN3Q3U+jkC2v5OqSsQOJypWNkzqITrpGGnObEKpX3zZll/fNBVU4TSwPw+l0QISg2IjYsI2N+tAnTo+NgKH6LJjD/FuWDAHKvTGBBR3h3L7iKr+3Z5/KKvzNAqojVtshHg+XuI+9vL4acO5i50o6IlLa7a31P2eLG9+1R/rY8V6KT5rYemPfcco86j1/ytmBiBqOYg66T9Hart+EO8g1G0X8GBvBZfjgNqUebabo0ALrR5kaRGp1/PJZh6CeBaN43GyAK5PNge9PfifCjnc4aebtwU9sAYGUZkFWve4CamsdRzRn7+F3PHdWEgnWL/+nPpSAseyHSPyxc0VEjoYb2nS8/Xc07TTKr7vV95Z22tBzBC+u+Xj3nM+6Z9L/ZXy9MU9+JaQ8AZT4e6kedOGoJeh/SNORt3yHoiuNhbVTB+g5MRUY/DHA8oIScx/HeJgNQdfmUGWApDYidNZ1bWwBLBhyQb2WPQwHJXv07bvxKZFEz29WljGYJ5tqHAdWA85e3t08xlxQqxYdC3UkSHH0yLG/aic0/vpswrSDZEa2UTXoB5yBAXquXeKZxXtefWVUQV8W1wVadYZo4CjQeIMDou2ZTqzrVXT07gHvOGx+xh2JgLy3F4l0kK2I1a9wNNhkv0nbjN3uLXFVqEsOyP7fJFOC6epWlsbBy8/iYCswjdBu1f7Nr1tgYrF2/OK7V+gmcRY11/lQDrFhsVRepc/ozTNnWyVPoxJf+aUPf7GRknXtLK0JQWIDdEPLZbCNZD2sM9tryKL03WXpFp01CChwTv+haptmhDWXRS5xhUE4TuvRA8mdWACWKNwlftXoHNnbeaL7eoGZPJuGZ5nZHgUm5huTUsoYpUYPYuggJg60RJiBU0xOU/uMQVOa/mmliLZ968wC1Fbw09hKKMio2ZG7RlgNUqKWlgiTk2TKe+8ecGlLR7elcUDOWeFp2K0aj7Ro2ubr0vuCswgL4XwWzOL+2hPE+/Dm+3hFqyxt30UtKVRNwxKf/78tn8aj0+3qd4n9nA8+uV3zsO4bEElFXQ7pP6B8tI+gAsVjiFv7HvjjUtTQbwkJxPRe2wv1+/wIknAnEW8xqYV14xJY5FpcacTew7xARywvUuqSJXZDMRYwu7nqyQ7nAkikAejemnfXYXhDXOEPL1xTJZjLgaO48zZQwrL7evfKL9g9r0B4rmXweZ3jN+y1exUq9x8zX+6C0Er9CgQxBXDUQyug/hRSGROtBWvhHzokWeQDNnVDmSZA3Uf8Pt8pi0UVOAqbAOegHAVIVDqPTxwkMDz+b2rc45Qe0LmDm0jMWMQTADsHCYCsde6pQHFHDwLClFNomCrL74a6km6Wmui9GOKhAKYde32q121Y39SdKzxSnaVzjcXrYRyFJ0BFHZ6jUKj2O97gyDccnawbObXw18fkmpFqYFs18dqYzJkLuIGXfz4QWELYqBR7ED86qUcBlhrgfDEGBxdGO9F6u47rSF/gXqw3OY9YzCAFlh4FHat+lZm1t4UmSeDkrrPJjyKKPGt97QFUKQJ0jUokLYH5/9cLqO2L51oJ4t1EfLSfWW6I9y17xrmPsUc755EDT2On3TlU2Xwy0rZ4MYu+mXzc5z+oaRgl0ERucomiLkbMJTMBd+eHKSj097GPv2rY40Cu490ocdiB1870hhc2/M1QjMuWjoi5FPUUeDV4ETliZauJP7DQ1OkHXnIT1kBhsTUbf5pkHdlxzr/9G25FKwJdESyM1hZd/XJjh6qlyRPxOODBN1ZEJwhVzyDt0igWvx+wR8PU8xwnZXWtFGz5F7ncKW0tF4njrBmz46xeJcRaGIficPbH0iWmwvNG4vT9a7eh+G3tLoO4Dd6PnAYAh+G7cFFovurw4AYWDt9RyWVfmJ+PEszR6yOgizuhDwQdHtMqOXYyQz8gJJrOgRkDtWUpwic85xQnPf01SrLm1wf+Y0/7xVoR3aUHNKe9T+z+yRHOR0v6qzob+z1zNrwtbTNnhioBX4skU6ihSRXRaGzbTBPlFFW8n7UM3QYsmQAjLGxCO+4YDLv9sVPSEN5pnBIAnpVEF87nBPf3xm7wyWflwb14d/HxiQT6Gi+dcRNeOUESAGPnjkMZh6Y2RbDa8u2k3dUm+9xHHQ4R3+CLE90YaVL9JdlKAUn8wrWmCGlq2s3PwBM6gDsN6mS7Gwj0fYMAqc3ndWnw+Sso7SaAylWKc6gwSDi8863xUq1tAVtihEfvmgT4JUqq9zpPjMQg/9C/7PntyxDgaot4i/pYPuP6k9IYH94wpddqYX+XWnkpYVSETznF43XXHmdTPSLDlvaVpM52Kbc49Y6QYmoJlqa7Aw9VH65uyNupV4ep2IJk0dfZqhDn/4wUfo6IxRzXL0OcvvhLtqvL8NFauWt0YHL9/qQeYLCDAnJ8ZYj/ovqOtiZLYe4ld5NtuU7CDIb/ivcBUW5U4cafk1zkuanBzudRXwaoE3BRuAmmigvA34Nxq8B6cDq1rmy7kzRvlREqp+KxI99SfY2QSFSvoBJ0nlobk9ebzHgwvoDiC4P1l2z96jTkBaPbgD17vpkj5a/YN9KUkwd5tQ2Ll1xrktyYg+J6BczqLoQMTuF0QIgzbvsV2Rcko/vfPweksuDXIzSLGmu7IlTr8TIimScx2BG2IrUCC41A9ybTl1iEzK5Y8CNj+LYDe/Y/xwc6p1tNcI6ItheIT1aBx3qkUq76kIGw8SCpHNGSsb1hH2R6r48cgHGFFNe8HLk2Nd5lruYF4YvUgbeXi7p5j72StBhK9cHXvbYKSd+Pn1aQhNP1odADOPyXfyb5lUhPnmdZBW0UuxMkxc9Gb9wMb34u7BQ+JDr6htTqrYOqo5MzZ05w3WJ01C0SOp6h2T1QqRqJqnh8VoiKekKRnya0ml8EsKlhiwJ5o//0fvCfWV3wyC0Nr+nbyDFbrA9yP5VDtNlw7OzoCabGsUxAz4egqENriHjGTjEnaW7biGj2UD+LxEQJjEyHZdPF18BWiIv5m4p0rcapBaVqO7KpRhdCcmkHq98KxqDWaE9IE5Qqa2uBtsSv3jHBYNmyQtKmLw18FhepozdM1ks9yJs9G1YjqAeUxtPMrtyuyV9EBhPWnQkBPdQ+XGcKhiV+E4jWdpX1VCawGjDP0Sb7VPx683YdjO1m8TbSFUvSeGkJmZRYaUMqvGMC99IsHCdFGs4bDdHfkeRmxK6jzxFCmapUJY3nUfbQG73B43ucs1sBq8RnPRmLQUD9zjBnyKIZGFYdffbicc5nuKB63WDveKRW31ro3ftcJSPeX12jlSCGBOVUUbmC3p0fxpP5tTi98YGE7QzxqORpgWqiw84k1at5USce6xfxCsitm9L/cxue8zstaZ2ssIreSeCVYH+oIpNm7Y+77EzewQ7cKE1y5Obhh7qVh4/lQtg7vmFnON155Frf7/sVQvQRCvC9IRMBGjCisIVFLJVSOD/2nhJ16CZkkEk4Kj4TeeoDyHbeoyHoaTzvFnxfSMtzygsdVbmAkeJV4RoG2NXDor+G31WdZttfNmWfO0mq+iFzsgEVLsSKQRI6F2dPeeXjAgc54TNeyQGBK1DhsmRkjegqlFjjwbE8D0x8+UZIWAUfLO+KVLJhNwOGeP2dFHeNDhJ7hOfHuYvhySA7buAqwWc9G0GtZhlXPWiQQh13Sxm4RSHaU9WzhkpA4CLfitDxNptv2hj/VwOWO+ieML+PVhTUCeuj9qiri/fHmOximOEla6gylatkz23/dB+VzoxZVMrqWXGdG4F+ApuwsZjk601EAdKgybt6qDqtnZB/SAnFifTr7iKwtMGyfV5WME0gN+LuRr5Y8ksL+gh9n/GLUP5ab/EtfOI8hnSc3JbBFokurzM1EOZUL8ic0R9fGLurGqrxo+Rl2ODp4J5YiFjHVdWsInO5vWwQdcMssIiyyMqe3g+WQJYmP4whndjWCLlYOl2+aCwGNfVShfejaJolNbeh7diuP/Con6lw936hZ9FKLPzP9DFlPp5HJUQrk7MLDoPoDzUEw7BxLGaNnJvJ5e3kxqKujo0cr0yNoaAD/3jh2R6vBSnt1wk8W0PkI+O6h3lh53ThWrAwMkJMnIEzMgfH1ol/lxaFdZLal3eQhmVXWOkBkbTlKwE92MoU50lS+mreW5tnqTx/XrOxbuynveLyomcWSzGTFpvI+5z7ygtdRWEzm/dHhmzmfjqik+ZdC6FrmEni0yq2JzlX8iE/SmH00EmmVQzos7KpW7FnzA0jWeBcVb1f/pVtPulg5s+KxUl+cxtkpJxMvg6zq1AfMTUfI71wZZim7JcM04mFbD9cTcvaubx2J9NpmsmATfu2+9l3dWVlZFDoIZWNb8Pt7TPHcGzoptod5IU1kWA4qsYRR807U+0Se8co2HmDB2VxtY6ey7JbWNSZbnz7TVT/xNiOdPEzkxqM2wDJrMtbpk8waLqTxp0Xvop2kJZJO8m13cKgeTqDRdQ8bmCVv6x5jDYhcX1rikSQjX81hoN5E0bwG84mZzpQCHv373dwcWd930fbDh5cZBlpGdOj39X+jnxWBZ9L8xrjgidNuk9sfJtLTfNGphMefc9tpkWOfrWoldkj+NGbxrdYNsYJKUbXaACgLFar8+g2CTC1XgN9RRMYbF5P3Cq6hFe6XKnOh8LpFNjatceBy93Jfjt6FqkIJRqZ7bpB9gPf5vUmeTZkdHC27fQ8kjq/RTnyVuKdORP0u+uECGLCBs5mbmfnd5D2VU//lEUcDcSLvz9YCsUKsDx/oXZ+hK5yjoarJgHG28J11PSdCspz6gH8pxCL2qmQTztdnN7IebDigXAnCT1mtqmSVnVSYISkX+fTFvmdabsIdpnjjvV0DUo1ikTGi3H6YfYvRW0HwTUMoS8nq/MFEFzCrD9CvGxK0L1XO8WnudZFyxnzNbclnnoNJbybp+RbQDwpviR0JIgR8/8xj3JtvCOj3D5PVajJp2dXyYVelMY11uXDd9qg7uJXH5qN6BFdeURKWnybfDNCZR7XHPlSotuh39JnENaGTZpmjs0SJE+eSQz7RtlJVh9BI5DS2/3rLvYahungfP8Evy1cX3E17vili3uzOQS5KF74eki8tPFG1vb24skz/4vIIyBguTa0IksD1rhhRRCQVM/YQnKAUMuadb6jt4oTNiJT/3J0RlIPmF2rUnfWD8r33f+xKhtGb2vBRU298bEIigsaICxp9mmtUs2cGB+AZO62pwSSHMKLz1AmPFFf+sKqLS0lBE4pNVrGTRAVhfhBxeByPPwCIMQWtZ6a0MVt0CpPNs4A6g01NMT1em5pvjFra9bEyDMLcYt6ExDQ/PQP1A42+GirXZ8oiwFN8ruUjowmAWkwBzmOjiAHki+vKBV15ylJbN28s708z7pc/iDQdYLN/5rgSpBAgL7Chscyb2Z6G7ILziZCaSxiMbXpqLR7unBGSA4yoSB71Bje+X1Mpwj86kHhpLV8Ghei73NDFDe5OWfL5EWFvFJ6liUmb5a122EK/3yu+1qvzSM9dVUP94RUErCAzIkFMUx3Zm95aYObbLPROwY0mssZTo6bq9SogTsdLv5KumlMwx1XxBjEZxfo/6mhfou4r3aY6jnYPsr7d6FuW5EKErLI48nxN1/FgSzABdPDAHaYHw0FQN5iw6t1pz7tPduZb01mtcS5f1unuOmsZ11kEvHch1bjXg+xN7PauL4b5kP4nx89Dr+8yaOdtGXCsy9OXvMAIZZ+/DZHKDIw2yGRhWK7S/wTeoYd8cA/KsJ1jtf7lcTpd4bCxp0Mxdhx3zl10y2NOoczHnef6QXLjrsytkeeeZ2ZFWCbwHLs/MoouWwqF5J53KztBFlGklMmscE/+ZRhlDgoXam6PL+yFx42dyqD0XUwT7KSF3MjDKou3eT8C245Hz0SJm6vqKhkqfstZuUWCAojOfOENVdYBlcKF7dTmnEJ29VE8aQKtc6B4HfwFGNu2JFK0+Ej1eV1sQ+tfLks2R1kaem7+4n8K5+4L+5D4QC4vn9qRorplfI3YLeorE+XHjBt/p4LsxxLSLGpwzGUoeK720WYsdHb9azNdvvyjOTWSLvB0YQcjzjZJuTjqZ2q1Apt+HKjErPGGCUKLvCeUN4ELcN/EEygPoe/x+Yo8ujfED3RMDhDg/LffeF7la+pDTJaW6hs6FoarFKS4WU3ZdJCdEBARpKgCVwLA1Se7i7CyaLEN6azgzkDm9aRfWabyjyNVy9o9cSiddTuqTtpX+5NPir9fF3mU8t/cw8Exr0Yo5Qb1DS6/TmimaHA93g2dfYrE1XmBOGx/JboPbbTji1vwp+F2x2Q1xYWfckLFfarY86ZaByEZuRNMriKEuPxVwk7/zcFRjgdoYycOBNo8VMO33aC0JL+UPd0tZLP9WIY8BjAICeERkPjhk/dcE6xxttNJhvxBc1kRIik+65V6YXcKDRBYuZ0BFrdkKHDue8Iow4n2fXXtFd2rxzTdtjgJ8je1AMcpFFyoJummFWkipk/Ng40YMB3VLyW2qxOvzhx/RqEwtrhg484teQmRr5D/ROPJGs8dHvGhZ2xWvOPJ/n6DUseEYktRDpEKoRpfLOr6SwXPRfNV/jtxmUrl56sL1UQNuBke+/suYFW1Wg+WdMu9H9z4RJhpR6IqL4pGSUyrecpO3zaqm6zDLihSS2rbGcrnYsAlO7D6VbxaG9jwu9tMozLi08VmfKeot3kaTkLUIspAUDtBG8XPzx75c/CJZvhIOEpNHaXbBS5KSJXaBa0AGgW8HY+o13PqxgiuyB7r8m/sPF1U7D4cCbnDMVxD2qh2YBRmgtxhuV67OPAyDIqNRUgb4bUD8TBBNc5Om8VK8Y6BhmvzZu0gWQXHLRi1GGxtkFIROpVmwuDgrvsG3ZZ3ewU99++zcfR+ViS8Btj6HlTEk/P6Ws5CXQBqjzHn+ltaqBiSzoS9VA0IpryfwfbO8PXb6VZHUY/qQHOIOepX8tnNvWi81D13V/ZRDh4m94ItfEmOS08v6gaY+Mto0xNGfDLfoofxVzh90o7xsgegEHiSx6PURchTA6ZA7tzlockCo2i+3asXBBDrDqTmzBV/sVPip8HAicLhTt6IyoX8/CGTHK34oXRP9XrgNEk10lS6/KWGqoSj4ri1IY90mHzstxBzwSVrjy+EqFKV+NAc3anXMM+DJ1uNm9J+mBwyIudT8MeOqyektRqdEqfLoA+QzTBOK+w3oQgonmdpOrWc+hxZqmtga8nI0yNnkSQx8MprIjnWTZU5XalCyYX89JkRrYcYfNvdi/SutACjKFxhdnTNe5gnIMnymdh4fXYki8vcbFU6dbQKRd+1eTOAN+60Qa9+csMJO6XcGfL4LGuUAzPpvk3AMqTUlPbJU4MfHsYegLWKhgjClfVJCxdqGeZ8OB0TPp50vUOgCCe4nR4I4BsuQ7BD7mHsw7xSzBKf/CFz9amfmDU4C//NSiCI1bFMexBDZN3+218iWaV3/B6YBKaB069t8CgoDxpC/1mgECSzoJuttocBPcC27xmwXfgQ4Fk+20K548RK+o/hdCnrakoDuRD4bC0MvOzYLE6xAxo0zGiHOX9s9yRWx4crOpYoqlCMaRBDl8quaHbcB/aXOqWqFrup19yrn25HFoZRoaF+emKKFdVoK5v1Isr4dcp1gWBh4u9tjI2ZdXe0EmzsDGDEX3J/7nJI8Lhg75osowTZjvVYCMIOTvphRlJrk4hJfYiPQshKT25JTP/t/KASjx6mzAqTSWZI/F3Y5BR+L5Xxt5RmKPagvdLWqteyzf5k9DqWNQfwEzmh1GA2ozDJeFL0m1w/9GDkfs7e4i5pjeDd9RiB+CGzsrDmMKQQc6JdIf7aCTrW1RFnoxqI5N+1J+Ma+Qu4nKdSqW/7ooHK2pPSuOsCoXY3pABHnieOZ4iGkz5PG5NRiBPIcibz2DBycHKYXvPs3BWRDF5BGTWlwo7GpCLVaEWd6BQ9FTumO35w/hGd3oGvNla4LkFz/0lsQ0PuJFd4FXi95RJvJBr2KARNGGrLw2rHA7lwG1rMZcsFUOt07Jdo9eDtHXje1kfuHmpKWge4DkmB9n5t6c+VvTxhaXGScbm+zyAJYe9wN1y5oQpCBHvrlB0ItRAsvIGiI/y4zYBJ0SSJpiNC9lZRs1kaQgHOvpX737wIc6zOJb+PlV4D2Y6kSVzO6eZqHR3yOVmKAx9Pmlmip4xZ1ccxO7LBFeu417Um6mv4re6z6NYCsrpDynm/yUtek/GycNv2vreZCaIEoFPhtZoReHOQQNcxloYr6N/qqZXqSiemQcR1Ozv7zWwO0YAXtkHUUVs4JYUMzaVWE1CYLPeGd1ijvzEjUgnTcNXFJX/wP3JdIUUnsJtlqWOvKzRzTJ4Q0+k3d8OSZCLCr3R+ENu8nlF17EHM1Zmzxlz3EeCtResUe9QF06alVUCtP8wMPA6ykPYHJG0I6a1gVif1smRkfXb2aylrs/xKaelXCZ5PlfIK4/HBwBXVfGpSZarWs43apNxrBlkz2xIPUwGhBW6qYiV0CgrJMDUnpxJKrmA3AApaatY3HcehX+wwRbynj2O0S5ZSJv5VGAJxe3paQ0prECLbRmbQBm1zLjob2ydVB4Q2IGqOaUKDjRnkqWtEHhaMlJEYBfi6zV1hKSoGAuroIiv9tJT/MInRiXxjAgkE0e2wpxtFEeTV8084We/szpG6Tg6ni68C/SX+8jII3sMfQCM9Ne45T4imwj+DWPlkss5rG520CQto2qexZOnyfA1pKrQIGBwjBevYRIDB1DzX4fa2JNkcqgKJBeW61odREwnUm6ydCaM0dl7d1xFbnU7xvrTjxf2k3gDV3euzCrxsrPWgLS6GDnTpXtmKlG8DgPBdS9kDeirStRoH5iEAKjhA4T8K3qE1vujLhZ+wu52aqIzQfUeUJw5y+uZEZ749UzSGCdcFgdGcnmmOF31pVRshrvHuBGdvC9RoxZBc36xqEdWR1dkwIUkoX6+4agd/b+hUBpE/qoUVX8Y65FRFwWYUsmU3ElOvK1L3UB4Yja58e1/3cE1oKmNJhGTFsBw80ZVmhteSB4TzaIr5pdf9ZVECrAAROcH0KjNPM/r9q1iEpreOLXWZL50BIK9kOC11GELRF20e3pznfUIf+FzlD94N5wZOVL86tnjIq7kTM2APN/F8KdHyEwiJg31zI95SyV9OC2OLJDOtRg9h/UhfoFmLZeY1l9i8mzuTcl7wjxP9VRExt8U391zbTlBzy0qBsnzF6FXIOYB+tx0FCxZPxTfTi/8+9NYYawbYnZaQM7VopQL+0vW1DUPKAcLSizxMnISeiYydhw6a9WpjIBXnMKKrIzxkY63HxXwgTC8vRp0BUKYcKzMOMXGI2J0qbIRToV1BxThW9d5pVenv92rj413EoVYMm0hb19LURk+l4BNW41kdAq+xruUPmT7nchDvmSE1ad4Pg1yGXth3PuzC1CySz16l1xD9goANY6DmvLC/BISJux0cyL2H7ATuAkbYX3r0lCTBzjFcGx0X4VZnjlSCDGxFtsfOr+xg+vkANnqDXyA9+vgIZYGIJB+WTCVivdG6sce7vJRaMbzjwwbGrIBbitXfht4hrnhFAGEEPVq8MwmHkkJeAWEJSso2zWi4N55bTCnbMLqDShpwY320aSY1xfBaFUH/xNxpGA5+UVqIMOW+EofzWO/y/E0nusbRskLm0cvCHO5aamOgC+RnWEFftNSOdAd8IcLxKrJDCGjTh7qrZ8sIP2h2TE/XH6XdHKxGRqkIofpqDrh9dDDm0QI6TEWXqfZ2NiOTMY47+HxqNl0gyJwryaOQoKRPiqe+oanvHtMnqR6559Ewfj1V0E5+2vAAPj1Tp7IwMcJPy/QTu9jSg7w6fVM7Q1GgwSQY1ERp4vXR10b3p90q2yKq3cSpgOvccKR52+dN5BftcqYcNYaDRCcqZjOG3iDkzfR4bnDDG7Mat5JMOOnsNUFGStgyKTNVHruJTJPp0uel/q5FFEtiElR0PPtJ0TIDjbIRijFMGqoOgE6lJATEUDV4rTQsZ7lZtUn14ZlzdlF57zDbwSMsZcSgDAkw5lKCjTgSmSG71YCEgPdg4xEwY1dCij+uOOdANfYT6aUJ+2aETaJb9sZ+cNmXbeUiSvF6ZKczBLH/CmLfyopnM0KkdQjadG1X5oiPiCzsXKzAjVG8FXjfsGe/Jtwmbe3nPMfbc0gLawLPOVk8kZk5EIsQCedxZ9iAIPQ3pHT5G4jqbjiI/+n5aQ4HgnkG5tETLTK2cIMZsSHpxgmdWT8gomHWtSXbBuuiaOhDZq8XQNWPjSHZ4+MAeJ1MbqOpUpI+vWYuirWraHJjCpE2BUYmLysBWt/I5MBqK7q+c7avbgAKkhZzw5E56mcCapx+Jtfuh8Eb5b+fHoQoV+Bq0aMNNGjPRjlePxNtK8pBEZE+7mEUq109VGaCbk/1lHAocW8w2hb7S7duGelhZcDuC3/rQSmj7X1CM/lo0Q3PdEUTQotb7zCMi4APSPXsIRWxGmSw6NQeXHUVoabEo65bIAk6uVh3WmfrTeeeiElM4rdOkqHXvazay+OQFdWUdW38j2gYUodGfdYMLslgyCKuscp5e42Pawjk9XtPutSWEnSUYn892RW44vxan3BuVt4dPCSx3k3qIfxr8ZJXoa2mbKEorXhGvqM8F/kf1KsKTJTKSlbTS626482FHkG8fKCIa+dfUDDTT9DmYrO8bUyigFsx3/WZbMyzsSkbZBXD1j0C4NO2QI9magWv6d2tyfHRouu1UNkKXy0aCwzXz8iciemCvh56c70XzyuHv65KrpSP1m1eqD8kO1Yys4BdqRGeWGQFzPjf03HMhR5pz6nvQhxH2/bO/2/d1GutQbsKiazBCXDYoVJyz1BAHZlibDwjfxHiJYWVVVdN0GWSEwYkeQFqHYsitUhGrr7Jdbg55NxohZ85dTCHEVHpj2Q+26FPd2FKRGo0Rbjcaubze/bZefwSOn6UPozxnL9GEdFsa3wCXw8jtjKwxbihwEEbWhWIJUKcQQnx/JHc0FndqUdiG1FKFwJk0dcLQL4Ycmvzr73EnkhJou9eWJ9x4SEJOQZLID27UduAypbOdVCDFbFbbyGSIalNjZDvLj2MVDfudBVgT/+OeN7dQbROxpIqqOC9O4NCxpzNPziEe+2qFWIG8wlNAO/0i6e74iYWy5VIqIKd6LsIxXUjWeHStdgkTJDqjc6G922OTZqEbGMC4O1ZiB2sNq/Sifh/scNNWkmlAkfmgG1Pq4ZmR+0aUGQnRRttpvFPTzePS1HfjlDi8ts0gc7AaZSYdQwpxXZ7s3SLUM/HWl/+iExDQDp6/y9bEPxASHDYHbBlLzsv4j8LMVXbxFOcWmSbpqF6cz5C7uQRIo2kO4x3S3nj/gkjlH3NnbQgBna+wLyqLls8RfTIzeMRiOuvc6xwA15o9EcllSMHUmIjHm0xPZdx+ALHddHCAt4LFWdCEuwEqOJNtFhD6nYTLveO3+Cy0IY5Iw0e97SYX442H+WU3pHikWsDulvOaKDR/qwJLcFBi/tj7q2fBHfz/6ZaqPTTperOlhNamUqjsx0Ix0r+QkfFoTdhOtRkAEuqIs3VoEzypGattxOL+xIB6bGQ2xATlj56XkQaaGdgsAyQ6Zf1HBfRRI9TIvC/gAB4F9cB4fxoVm05uirv32w9hJwk4zNglBh4ZsL4qUAHzlwTnEJ0EfwhXsIAtL4wmTLSCq0RELMHy6jHQb7W1bxd2k0z0Qt2VxvqX13Uw4aSEKWp+K22AgtR8GzLECXKKgoxA/utIEoPbopU45Wh4zok7tPX0MAXzoJC6EXxfAhonyB8UWCsFY4adkB2rANWaBrpy0et8fstkBgMTZJarCGrli3xFXLJUAb6jpL5NRl8R71aTlR7VOV8IwydUJyJj84dLKEWmLocPmZxWmfKJcuY7N47vD2IBbM+H8RPNdyQ0eKrrC9HEvdko9cn/XbrpCqBUPVYcx0mtyJnXM6zDqzvHLdlR13w1wftsi1CrZ4tKCYV4Ve+UITgy0bQaRHoJkJ82wIeR7LGItBjsS4WTql/jaAFnozs5/jCmcEiMesQcQSbR8OgPYgRxo2CiMSSlnT4kRCQpRyyx5UyO4ha/B+hrkTf9uujraTh/F7aNDWH4gPkkxGzjSr9B8ar586i6ncizPftQUfNeapPqrB1K514TRJT3UacFwiG0IWgiQ0XNssVt4bMFidtWTLyn9LGlX4cQU/3UkdU8OFVuhJprjA0ERF2X+q4JdQ8buXN3nJHYXbzoK11dpGHek9l3DWUOXxs4hGEt5ncrIRDwsso6vrWabmBnDGcHNRMexDW+KBKd1FmozowI97I+XdhJt+eSiknJLXcsPOCzK2AcAdUlqvctKcrKKMCYwO/kFm/8E9Y49iA98nzvkNm2kBCUPdC/M84zWjKfonGELTa8yCQQFSeL06/fx3dn5jGRSfRsrvAGm6GVv+2wWLev95HFZEbV1iNcoEU723Cxi3vkJPirs/lM6eYzKgMsWQZV8dz8YQPFso/tOyIPAL7ULhqVyulRclWHd+STE6BJ0auE2uHyeKOcQnr9+pLKl3wwg2WZwnjrQdwXbedaDcuNtYKgSLnDqyzUorslGjApiNaH1ELlTX8AlLBJg/ZkSOlXZo7rTZxvMni8oklbFqrCxWxy4vvHC0DY1VlixGZlR4wwZrv4zeuAub4QSokXe3kOkaStu2v0j9JcL4X8QnUFCZJPkYjpOsyEmh8w6ycPpDW1myByj/rZI6a+rWSVwf4igy0vCeysqqCEwG8201MFClfaZ8PXuAcSJltLf4deTHt6SRkT9GDlcg5C71yi+gjrtZ0LXiBCrprcNl0foRrDjQb5AXVYF1A1tUwkm74j/mytqlvd+oQt79/IAvdbkwsUdWciaHVvHf6uWjdIyBEVHUy82M82kzpVcff9ManiLmx5NseYF4UmhccTkcrhuIyEKPxlF3trF/6xpF/UHDAV0wfU2r9f93hvtkwPmtFHjfQwot22pFTgLxmn1noKL116Sm9q3xHUH4cNLwJA2MHm7J5QMsLoFddJnrSapJYx0g6JyIPMz70r+zGRczw4My4VUnfiUivlho/AjdjZ/8iIgLIiDgLD8HHSskDGFCnC+H7Bx25obvEVhXypAOv3B82RercFtRw03kzEMA7TLNSZYmGhv2uyJrZBxZML73NKA6WNQ39MGu6yzxuliC0ifvTV57lc7zKDgUsdjOdjJjYXOxcNNhhWyZZe9AZ83Ho7e7qJej6oqSoMTe9qDAZE4fVK/1DwVqGxySvxWv5uC8lYKTKhbb1n0eFPN2eL+mvplG2VLzM1jAP9uqpyfvK8cv26Lkle5yrsjgIA78rT+UZjhBFaHkowqFgJM2F1Gpk0x9s5/sgWUg+S0pGueae/wJvL1fOAHKzrC7TGMOYbmqpp0UqR9lHg4dETdpXfxrukwoVNCZGaLhb6SJSK0DqJl8SHDkZzNmuyofU8iRUpWfNYpVtsa0AKao1X0vdF4eOrGlsoJ9Qiapb09OF8s/ySUM+EHEOEAQgCGwdG+jKikZhymieT7FnheecRAwbdOu18t9YatPbhapWnXFtpGQom7JRSwWfQIuDz0h2I4xqJpNjlo3megpqCHZ9tR8/t9qbVvJImWMZGIDvRQxIDhLx257udvShgrD/x1yQfIlALTMp4S8Gw0WKbvjdJSCrDwvZKDX1O9NmU39fjishYZHyc2ze8ZPFxkB7XdxrnpxO/TyUH/7tH3t4+tKw2CVqCeJgm0hPLJ21Q8ZRhXdc+4W8eDP1VBmU1Wxc83I2Ph3WduTNd8HTUSZ4KWwzWZEv2s+vy4/5hBmagVxw11a8bD4GzRZ1FOMEJbPVAHAwjkylHiF39YqyoOsVvDNx8HXmbbWwaZ9IYVKnM5g/eS6+fS/4335VFqv7UWt6nQx+KcK8JQEo7b1iBjqJkSTnQJx6H+XT823j6kdV+6bLObZHf9qpmXoYbPKzDYkvtQwBsAwdClmRSbAYaKH0LykyDtSKfaMsujMpR1FexzotJOzf7CWF8/uun7kpA65wSLHDtQa2aGH2MXP8LkKwUwEsrO6c8zrIR5+n++1/lGL4FKEmrTbTvgSzWxne6GuL0NpqOUKJmx21rOp5K7KCVXadGEWkywd4YB+CWBahDtqFJR1Lkdczt2sd1gBtmv7jOihQySWBIn0H7XOZL47IgF7osSZaaTHLKLhsx8D0e584VxVhskQSR1fTlX6jSCdn9Qbtc9FTc2Q5+zFUQkLvKM5nCwRc7LfbFzbSB0yikBYnlnY7p7KjNW/BrC3VvMfWJDHvNMXuBEV34FeAfao4ClbPFgBGilSKjIPPJ5OAdUbw6Dmo3gHvaMBHqw2XJnePbqg4St5lK36bgAuBApvN7f01N4lHf4RjoIvarb00xcoJazk241CD8bAQuD3Ajtl5BOUfoWtAbR3wm/e0zAODXLV7rNtz19uwc/Hv+RJi0602yJlibgKcDJwEsHKAvDWt6dIL1KYgH2ym3jHECtKaEz34U1fdgCvQRUP4yf8L6TvEFQXz5MJtIFSFjDXe/WujL+rJf56WVArU9LhYCdunxsgerSbw0kk91xVr//Tdk+hfUuSW7FGMD9xAUJdBfVk0L0aUsKp7Q9koB5gWnynsTDMUYndyByxjhN4pZDYX8x9uZO9ZIPrj80RpZFtp1dCgq0wrlSoJHmcG13ms4McEJoPuh9Nh6/clOE2Vw2UXik3xL2hnIhyRDr/Wm88q410W2DPJa6mnXwPqVvEsSf4UCbTUGBqAiWrTN7L4xw8qier+pwksDKw3+3hO1SvYsxwtA/4gY1IXqe/tKTZy5NJJ3GzAUljVJ/4fA8+ZxxrWMCul7Pq8NKrvIMejCCjo57wkI7e0CVfYVo0FImLmLYZWZBEWyYih+nvDcepb7cyrs6xJ2yrAst///+wsQVCqwwnozh7daP4KjHLBad5Mdex0wHzDNsme2alxfzUDSnpY5dLA9yBy2aJVcGtPv41C83K8i2S8B2CAME5p9lnI2pJzSslOleJODeQaAgU7UXdO5UnBz6AI7T4vssxeN9qN9f7FWcylNEur/xeZecaR2LDnmlXYyNWgbx7RQo8QtmLcj/mGA9RSfCZdb7S0b9QdvdxEnMN1QNGGb6LfSBEEeZmrpMauLQT9zv8exP2CZSKH68Het2aeIKRijk0U+ShFZQ8oxJvYErY4QIjOAYBOtyV1ROvHXqyeDiAF/aiZBcj+W5e3rM3/6uHFA2R2rTGx8XuP8imDoMJAWAlbKV3r0GdZwMBuN9JRTYLf6p8mR8gtIyXYfInBkie+BgJfQyFJZSUwa2LXh1uCYOmTNHHRRkOLb9Fy1afLIh5Z3g3KnmuDpo4Hr0qnZYtydsVaatJ/1S8UOrVzYhjV0fxuc7f2ZkphdtmjZqCZfr1ePjKSUPeETWogCfvLzaZBOdIXJvGvIXs15vdi03H9LbGdiL60pjBQAG//DQFfP1IjikGNBClJ390vBIIJCSZxtkZW9wLiSgJeIdHtYGHKXStFzLWl7m33EIrsZ+qeP1Kpop9wWZEe4BVieSnA4r6BjfTHbSeUiiirwC3CXx8z2ALA5CmDIltpz2/R4ZIKq3+0XTTRi+wxlr4KcDMa+CYkGN9ehp0TRkc3nuR4M0qBFHl+zTw7K0Omqjmy59TGFpzOZpGIm6XPBFvszSnegmsZDoliuiaM9WArQG3RwDah1l/bJZdSjuK2beGpVfwyzSWK6oo8g05u2BUdNstLphNFRrokS1Jso1vUiQrhiwTK+1Z9+rG3fgHy1PM4LxbdcjA9PmuZDZsqs1HZg2OOUWSkHpoN2PtOg/WnzbEE56KT9N8s2q/YpXYon7/qmnGbLFqlDyUIT0+q0ZZAUcpQIXJzlRNg9NVDrV8/EM95Kah0A3NHg1YTTzZsVH+njAEHccHJA3A676OunKxCt0oLOIaKt/gIXhL6TUCibGt+w/nhAArg6Ewf7OgiZ2aWYb2eShhjyrBeGE7xJXlqxmZAUzECLkSt8x71uO5sCfzvi7x6C3Ni8nuJdNgfBWFmGSy6xCgv1BEumVqEPcLX20/SjRUJ2PxQbE4mON7Bx/fPtc00KHKkbB217BSCSYMuodGwaMtahP6YNRAIZqu8At+RVTCu4mKgkZ+aNEl0vzCzqBk1jrhO3Oo5h4B7bLkfC82I3o1FttU+P8xeAwQnV31HZggiabVMF7g2XuDGuRDpgkCe5IVDz7FyD+goW6VDBr4q6AE0UzMvbyoXRAzChz1CpDi7i5jo9hhM4Er+ou098qjGpgFXTv/sfZc1gC5M3EP/GNtqldFcoTlNiv0hxo6WcRn9lxkfTKF/Vq19OQHtQp8fTYyzkK0ZbRYn8qUTu2FqrXH2621JigWkB218F8TWl1/dL9ZgklVzmJVcDvNszD6vJVjezMAp97DGFVekqStk+aQ2QG3J/1hboz0pyAcJ+f2fXg1OGqv7p9EE7kUD1i0L3bt+yYXZ8gTOBKy+JUY0D1XUK/iEm5KoRMRUuJTFO+jPFBEkxnHyyIRhoCEjcaDl8Q2c0ZnajQfMIgvaJKhWOSXlOS9hy7HixzGhAlOBd2kJsIdPMHCmQPomxUX+CCmvhlVcq23M7y2KAqxk06UafD7qQEhenSzTdPud2JM03EzWg4rbz5I8rK4tVCGvUr3ELQtdVvPtKu3Ne/F3KA72ZwRXKvwDMZjcUdtIEuwMkq46t0D7zlkQ/MILiVg757rgBXd5Oneq3GX1HiR2VL/GD46XicSUT21jokuF4T2Gm1DV5K6cXM1+QU3in0jZN9ouv4kOwOC9hR6TGBtQ3Hoym1MPJMmwQmYFEDKheGfPni9pu8a54yjTkTVLK+wHejumbMHoSPDg60JK9l5jYbDnq2/Rz6ikFWrJHMREuDcsCVt54E7eB4bbaQaDU2lZTmOSnrqi9j4hv70zUWEL1tJUpTz7K3Uzqh3EzmIJ1tDgvF0d922YSlKOLL2f0gQ5uG2gOCIO1e0J74A116TKpzHm8/+i1FhcETgSHGIV7QfCKWpZSfpK41g2TqGrxrYbFfkH2SfNup1h8eLrTjWPyfVPj07IbTnyY5GdqlNXzqfUb5dbpmDcsrgWJCh6UHKbiIRXztArG8gYPXRDFZ7cFxWAVoC542nQH7EasSxz/yTc1SFOFoP9OYqXDjGbAA2qSNh3bhisc+Wnai/RFfNBgWX49zzn7OzK5why8PDgDdRVfEeBw59OTVa1K5hYITkAOJVEexFE0nSmnz7NdhCgNgNsNPDgc6ihgbIW0G69bj7ZjQQTbiumyUZR3qWIM3En4HgIxPRZfHzL/rxoBtnEzoX/m4R8m5+8cTsMOcO8cNhjMlfRP+6eNz75xMVTkt2X4PEZlIDgpJTxH/7Ap38sgdoqTvglo6h5uGUKD/sTgP/WYiUxHdrhFd2qfIYFaQWGPcaqGSFRpj5PTt5/E7widlK1xdhr37SBIOftohSxzidvi3cXc4xDEAbzyqFLVGxdT6UqSS1SnIGTeMeRQJOsDHvNSZB0BQsjCiHiHC6LYsTiY4oUMDzusjW2i+L7tS3qwr0m5R8t6tSE/wDkzrCAwDXBUE5ka0qAsdaNgLVUOQrORjmJgpf+Fo7FwHkELpbv2vXQR9gV5eOVol/MRj/gJY/4gubRuIJCxZjkh2Vo9mxyNM7xqFHkr1H4zeqMtQny+65OJCI+COo3JI9E1Oepcool4TS4XuSPcsy3Aj3CYGslgwxFXCf2/S42RUf14k2DRsHPwHhpOyfCiL6pu+Q5MZPMj0rDYEmdNwSo37oD56xfeTSZoT0lKIfwgC6HdlRKVTtZSKTdeQc+UJ7MFnNpkZMXmd/9Quf4Xkb+U+z1DP3FdBQxoIKFPdiQFmxfC0i3JBuUCc5DeE4Xt600ptjEjESWYniQDWHCseFAETWMzP4LJkFMOZDpWRu5D8oDCkYhgdNBABZHIUb0b2kwHsukiY6hAuDAZcdVSbrGajoVHSPg88avutqKiv2VCwe4U650r28uHYS1WKH9NvAiEa4pLekgaQG3uNLoJmZPnXkE1lvWPpwP225KwZiunVutYZxAkhnabcRFFgDK3lBdc4CVrlBb0bYHw3clSvhxJ/tzc/VfOTQpALyxX446cF0ElnDLj1xDVGaH8SWYNE0gsJTNibY9lez+guSXirW+GRNJFXnpXEc8022Ghg8VIqbhuDC7tatNvn9YXkqg1ZKatYrBfbXR4CJa2pxlbO4R3rFBEu9dsdrN6gVVaI4tH1eqKaiKTaWHsEsIPGsDcgASXZDl6TopGLh3UJSf7o8uIil8LErow+6ed3IQ3rh/+SL5z9c5/WqnJqjjAKmLNberKJOXAavdgtL7hmLIcUm0Ehd5QyNjA0URP+BJCu/Xxg2YM0pEOFZEe3+WaPjUYzaUeec802sm8c4hFtFpVPHw/syCpEHI9KsTkoNgn/NQzAtD3LoTsKyFNtbesGYucRJaYF9EENFs14hU+4z9N3fOPQ9OVmWW3KC6PJ/UjxnmJcJIIPDUyb5Pd4s8FH0ptwje/rHybZ9SZ98vbw2K+h1a0fPMwNvT5tbfaMlcCHmIsRTwxdP5Fndd1LhqKkV93VPPJ4qV3IWpzKL2zXKkzkhkW4zcDhpZMWaImLm5BMwp9jA/EjUxcEN299OK/lvqaoeiiOnnH9Lr7Aq6anw5tChy8dpP4hi1JhaLRSf0M9h4uaJgH9ayA+hEySXCmxe4sDVpM83pCc6rRzroHL9PvmI6LQ/+wouFSFRKQfZfPduNtMYM54BN1tlROYHU4I8lkbtX5phcQ3tYueT7yKsmhNY6R1m2RYom1EUAhzwY+i3lkD9ye5pYxeU5i+I5Cu63/cuAccqrpW7V/KKY7ZMWGZ/7t4oMwOhw+jp1T5M1x5/pcYTIkv8rkY1161Y6esMUKUIJA39Cosn35DMcI6c5GdSAApNKqWN7wHEZAYuRIFnsjYu4uBThhd/Az6wqAS4QdJDi3iS+6QqIOMi6ZxQtI2OoRuNreIJx13MqW9Tdkp6lPjqxE6tZ8bgPfm1W9+8HjjvGxLisIr5XT42i4idyuvZYINRw6giC33tmWlCUp5vDiQZvod4wLX/iXvStmgFTz4mI2x1qi+eK/WsltdXN5vDhfr56ogPNc/NvW7lC6zrxJbuIjul+llmOqLXaK5GDEvpBWlH0ruApydPyK/Y3z59678PtHzaGktiAieyHD2/EBqF2njiqie3OGgtjUyt4NX5B/LuDTB3LSrBXcmDPexpJKZ4kWb6fbrJieE+97bxPdo2NPXuu4yLUn0MLgLu9og+FHM7aDcNCGkICOnAnULEqaZkB1G1oAaxLAkLeyZ169oRFv7qutqVmWaL/efAMfpq4wfxgcg9bT4SDZu4UZZkhF1E2LKp5XZRWh1JML0P/hG4Vp/DCJBSyLKWlpyMevrPVT+lvLfNrfHzs3Xw/TDG307del7wyxcKafWSDLSmMaGukdlTeZeCyiCD5ZopQWArisMZU5MgxndChzRHVcAyZ3eQ7f9qTuV19k5OzybAEfr3A70QTHZ8UDpAdBdOd5Ksg6DZACo20lEuH+IM3a9J28iTaUxVB4+TYXa64+RUuzH1gboFI9NWoD9t/JeFvWzRRZX1HkOHkib0P4GrFB8CpXdtoxZsg6CbedT2R0w/CkSnQfhwjBDU5kt+QkEbK+KcIUQ9BLkS1CLolIGUCQzbjyuGMXFpU0LP/eUcdQWBWBE7VIU3/LCh6I8iLK1CTzRJBnDF1bxhXU6OwXnH1BLvkL6oBiAp1GYOGgWyOI81FLO7h2GjFZEUcaqbN3AO1tIf/PZYO1zoNPCvAQpnWgDCSbCQEj82QCBrzgC4fg2h/kmCNaqCNRcv3RaKyDQPtmKjq0aRbXffYrlRs1EFOGA3AYeG9Jup75uOxTWcU5S965Z6v/kMG79tsMO9mY+4U3t215qYygmOudWVb7dwGILKoNL+VDF2ubVwnWA4NknQn/KwCvQnDUzU5/7umB0H1OxU0A/0Mf/bMdOvspdwBSiX16kU8uUXLctE0hpB2qkgYHwabLGydQzak4UOQgLqQJbLxFrbv+zqBMcvC3W1lYFOBOQzD5OqzpJgIzd1fF/yXaJN0KXbwh6u2HswC449+AXWANJrEh8W/68KFGtWTyUlp6louZZ7AN3CEwYjU/1IIc5I3mh8yaFmWkJ9taMAmAt7Y9cULvoeDCPKtoyHzbag8qkCVEeHZryoCZYb1CbCi0G9gnMpU9peHRIO9xoCDNDyrX2Ku3wVyfOJM9aKhORFA4t4zBcLSL6m+MfBZqTwTeeRaBFeiLNCmHpAKW2XnBjnMJp+0fIgN3eMw933tJ1Qdf84F4Be9lBaYewRLI0qLw32jQIX+mB3wGpERlgVP1gMNNxaMSudz3Loug1bgeREzGM1rMsu1T6sI4KPHdd/FPgANKkkh4feSeDTzBjgru67+EfM7CJuhvr1kslzSgvfoDKZC8Pxne9AHJhaK+opjvtDQf8gwZyHdcZh9AfssmWbhzem/tQVsk+mpRJgpXLoW43sy80DeE4gPh0/gK7tRUIQwl/RAxanvgQpGKxn+RZc9Y5M7m6SK90Bl3dA6c4yyJm4nSj+MAKrur4z2LxLbbVCh/RWDtLTHSwoaAS/WZIoqyV7ArMM2m4kwLO+vllqBF5rZRu1o2uysp5njhvG1Lg2KYfIu9R2iREZMcFiqfdMkOgizpSlMtwVj6mLpUZAyt5n0hE0H+ac6BCJGbNjwCcmEMk2b+Trzpem9/Vk9TzI8LyObzkJQsE7p5h+f+NNjAn+Xu6LQjtts2P1Nj+TdFa29biVAHSyYJ1RxXUDSp1k8OwV6t6IGnFFBu6TPycTH9kkiJguqfuk/9k3sUpgK+WfPt76Y4K9m+AnUl1aYON4y+XXXca1R/BCYf1XS6ED1giYOV6kV1i5ha7AF0iaLQZRq3I7nchZFhmxejymXl7KLAIE6iVMHkkCdUcBp+BZStNVbEQSvCrxELy9B0MorpeaVjAkI6/TmaZ8p/mUVdDVHYiMdSaSrAUAeHF0ChUhDX3Af67SxmGy87kAAjgP6G+Xdk2+9MWHvtpH+yObNO/F6H9POPY3pSrNk0dpWBdCPs1mQ0A0AmZccur1un5HGZar+6LrxJlrRP12tbGaoqdogcPeHLYuQo46Y+bZLJ5RD0lECrJYXD2uc0A1YCGkeDrWx0nQUnKUfCN+rJVqthvXimn/ztl5/vFOCFgaAf5XfkqLZ0uHyQnU27SkkFns6k0E1NFk3PHq0lb0IdMZEvP8IDkodded7JDcNCNLI9e/MugzaBEYIo84hhUn4lRKOBvB7Mjdq/CXK7kYik8A7NGDsz2g9267ICELYlvrKhbzhNMVFOkHievbZWyz1nn/2l5rx2exWVEiKR2MXfktbDqVeYuMfy1u/iuARMUSCxadwiAxRMhhrDdGuBwofvuyTAG3fsLxBQKRYJ2UR1hH4z8CNNIRovXeWjHdId3Q3By+WJWwP53isfnzoH/7WmhYtaL35gEbwWG+pDzoapGmn/QnqYNfur/fMQGi3eOCKcMwrfoXEyiXvHKQ0lfIDnE2r2kl/jrPHL5mhMV1fv/bpTflNDlXcBzYcwNKzUpRHSP8Q+Bbz3JeiD3jUP90rr0MHkO/vG8APCT3FtZIUemniuiY4OYkb5iXsN0uAeN5X/vo5hzptVMvDVULVsWJl8jjz8aoVNMUDnPFQh+Feu5ufod0TkZTSUy0+UGCErrmsu8ayhmneJfP9wjAMDRxB3Qp11xPwkb8Uak5TxV/uvEXqZa9Er402JieBmyx0TvU8keolruKW76XgRyAJsH+KesRmOjZzBciUsL4Ftmvi5EdPW4yeFsuN4NMU+HHmNDxU8KZ17wv+BYeOHLfRz6s+Ip5mDIe/xlHn0WF6z+kd56lmE0pCqQW7JLw8ued1aIF8EyTY8cZ0UPjNZZWdwUrQnioTRdMaVJJoGIP03fOI4K1iQiUSLdaCAu1LS+OLu/eTkiUEaYWvdvRSPU4sutTUWaC/Bb1twcJ5iukPbMa4CT5tjraymL74bY8TD0hKy0ZCgbXZWv0dAl6tahM0c/TZA/5QxiIzAkoqSwJbgrHPoCscVfKbrefUcyTiVzECGDi80ScNdRynVMLDzzh1uxH827p2BTBY3LYgrFVmL2dIdAt5eUpTGe2He6Yjd0iYzud/iJtQw/auUFYvPRAE+l9/cgknouSza+Y/EJlgGboIyIlmjCjboy+fKGKmy544N4opoA4iO05SZgAwi8U91QetYNN4Tku31EgKbczvC6059pprSsew2epYNFkvJT+i8UB8IkgFGOO7i6RXLdqqSNtGStdHZXxCefbqLdtk5M1IgEPxxJmIHcsrQBr0X9rOuyllcktwmWE08fyD75/0OWB0Boj24lJ+NW8ujuxmTrn1kxrS2SaCyrBKH33umJkYrk0tP3okw7ouhM1d9pn3W9+pXlN/2Dq32Ihu9bWe3/JLc4ZCVssAFmuaZ8KzoYGVuso/6J6OSdnj8ELv4e8b45WGc/FtLM3+deBwSqyvIyDRgOaaxkJjxNulfflWJPncEV5AVQYB9ErEdLeG66M43MBTpovkvWEiMUS2DHFpvA/VXaWAgETpc1yiB7xkVly3+bq05ipYUfwYxDQf4EqHSru1puzmqVnjV8RwMrhwD93L8NzMUnTU/QTGi7saQ8TWq+uLy0VZTCgub9bGWMGXALGIXI70ToIqP8Uz/SI11/Vpnm4xjmlLUyu4QoUua7ARjgeHiqAHRTwDBOsKzsKLvijP0hJkSVEkJCopaL4le2FQy5n9Rdt8x6q3e7Upvh/wvV9qcHc91ePWAw0ct/vMQVtwQQ4e1zBJ1mcmfc//uTRZ04KtNz77cNgyRhhukeRyFLX47HpQOWvb4VyiMaTY08iQFrKkP7EzOnI/syb4zFbQqn+8BRAm9B31VgmzwGYpXWrd81V+xQFq+khMjwgxHo8RAYilyB31j2c4ZkM+gx+JT7Xmb4ilviFvVVu5S0AUpkWM4imj14XXVRlX6IH4yUv2rSMA9+x/VeIxmWfXimr8FW7JnYorKYn7L2/Q+SzZofo5a+zsLAoANoNtu19kTR1noFgUwjZ48EOBIt86jWbo82xISmRzGYRuxLEDddLfEX9uzbKM0q2Dt2NSA+Ykwd3PRXqH0bZVhSppTsN/ZGnlowFTYlldphz4SgueZkXwDBc/NLLF9UZW7WUiVxD4kIz12oihs7ceh/vfIvYVCk2DfdYT0d089RKvMXs/uAHDgG2NTETYtZkqJhQr9/uZy+nKzoKZ5dHwtt/WeOZVrNVLKPmNWKOma2tHx8ZWV9NVuFDwbQp2gNVUA66/efRoqcsecWz9k46ybNTFt/hV9U1VkLGC+PBjzd+wI3Hpe6SNSrouRHcctI0LmKdfr/g2SeUJ5zr6DLxF6N9I9VnYoFkVTp28VV/Ef3S5842x87DHdIYIgZzgJTmI/xeOPC5/L2nrfDEPaLyiL4K+oqCPJffj5hdau7goscEFKiNxEeE8nzhn8YPuFP0LK1s5Yo6COJ5VeFFmdkcCFy0ruUDwGcoDsgkHsSX5M35Rtj1150PYTfd2JFiu2Gg1CavcT7r2zE7SE2KDDj3CjVe+iPb8UUJkO+ys4qCQQK3O8XH+vb5Kns/QbNou8jTtbWjnEhehRYBTGCrexqOy1vXmrGJmjxJ8ulFO2FbBKW4EllBn7yU088uOqlTAafvongiIHKyKc78ffcuhCvySmtc9izbcj3mpDPVVrkEA9PsgNVHGEZ5KcAnWsc2XcAcVGpZAoKEhd7HpyotgjjhmbF4kK/niEH1mdvM0+Yihf2DWPNo7VzyXRXUPDIaaX7WrCaMqpK6aghUjCrF19YL4MlPteyhqZJ27ingf7a+ITjI7BtzU+NWsdJPIvTXdJToiC9Do+rnRcXrNS81uwcEfZpajCfz14B2r2VUPqnpmWvDNPgWdj/ynhuA+Xgdn55kE2E3h2VGPIFIBcBLhhuJxsT1ox1YOQHEd+b8UFO3XOcO+/HTu49j/2gzIDa3rvc7HLUKaSAE3slYq6hDXby0cxF4Ujg+L3fLb5S+E+DWr8WDf66iXd64dvvOdDslrHUjgrXt3b9i7vXWzPFN2OAd1vYf9VHN4vvuZELTxoxl+f8EeYx9ounsUx5CcnUOid4RjFIAcOh2kx7z0V6BWw9svKRSN46WbOKCYJascYv9d8oR5VjTqC+gx9xxJnVdR3JnLZ0G/xOO+qQPDaVTOQcEXuynVwAKxSQ48TwvtVpwaQ7bvLpvoggQjzN8PER0FyMoXOHKoZDe7aaWl1UuaXcM/5+u9/g1l3n7wjJBOxDWk2cgAsGk+75IC45XeMJrB3lRFF8YMjjKjKXlOYzQx83yLZolew0d89h2TRhWFkqVgtvZsAJPXcAxjE0ChMS+JqWTOlhjBcLOK3T+iT/UsfIbvrToYRTM3y1ghNICFBC+j1k04psE9SBoKIGiQ2xQ3ml8rM1Ny+75JcfBBNMy3e7xhhE6pOPXcQ3qB0trb8DGvgCYhS2YcIwHNmkISxcI09X06RECfYPuA3ICRXVpKlzehtaUyG70u4q12kRCKxAP17TvsDkOw/Rl+MUnx/MKqtYumw/UynwkGg9cNCzalShrqMO9RaUOwZR81qlX98PkaFR5cBZ00scC4CUXEbtWNwCdJRIYjWVtOPJ/LJC4OHWvCL6UrjXXGAs9vOhHq5arIl09pbm4Exx+xmD70luIACxFLmrTeRsTfBJGeYVF2P7hyRbGsO1DxViwZKX72hsd2W7+NJPmO6uvv7d5+iZRCN1y4Zk34x4HrkUAMOAZ+7OYZ6EqkYFXBTt/Wl+OGUIKatwnmh6nbg5RC2TaZVsTal0PkK0bZweN9Xm7PpeTQS7af2zeMiqrEMgqMqIoKgRWlC/4t2DkvyuchVicNjkrSRlF5k3XVP6N2F+3msyzctRM98nwxa5Vd0LZYrI2PbUTbUQ4zuNNKW2caEa8S7ysVrOjuBBu4xTLOyOTvhEuzlBLkpfDk1Aorg3kQENtKaGWc5NBHOomFi5UbAraIPZUktqXSV9AJr0fPyd19o9Fichm0rX53w1JbGkz+pEZZXJG99bLwJcTonq+0YY4YcKeuVDHICJ1oQVmXWvSE+dYEpVW7bikykNsQ2udZ32zAalcCVJ7CT1IbFMXEvQZGaDeDw0Ann2Q5BRfjd8KkV7iFw5uhBom6wr17PyaldEUEb5W/WyVt2jDMhGJD2aS633LA+02l+uj9gD8m/Y8Sn6eDX/sok+5uZdUwprHun14Ev9nQVOZIVEHiU755Qu4nYq4PKimpvdIXafQ9W2DurEzhbljExrkvEr24WkMCipQGhQuT4jLAAQvue7rS8/hfOuy+DNVDDz+LDLoWVwDkS6nau9fQ8Wd1j0VOvt4nf5zxA9lRs6AC0DVFpXpdSZknzQCVUADLiaAGl1hYoZmkFD5fvqooGqZFsoYJDw8JiCEJg1D4t7df1XPMOEqFDH16eoVdsR8ushV7P1mX/xFYidh9IbnWQKFkogctoh+82j8A50RgjvuAjthr2QTCEBxHO9H3LT+7hvHTV5FhNi1kTNO377RqEVkxI0cgfadsj0uFBJfUPQO8gRuvaPWaNRIkUux0IM/6vp6TcIYR1ArizRufyrs6PxC1ZXvG9GoHQNhWopEAvW+FeOZTxPjeEusVz1sM9MQoWDXJBqrL1MsjL858I58AvVblaIJsN/xzICiOLvv9c6BS59HkJKb+mnWJyfEd/sHyoNR/Z6Df2gW37ihrZoG4jXqMtuRm4t74gAl/Rdtw8ceQxyo+TSGrs6Gg0+FimdpSfFRisG8OjpdZ2bIfBILx9A6h3Oy1x5uzGkLPuX443oZXi5RgDus8zRes2tdi518tTqGKgDgeYHCowR7oYtJVbsqrypVlS53K9gTe89pA3j10R/OFYvQsxUIlIFFNcx28gY5dSbPSAaZm1ZnWzfyDbUODVwAKXB79trvaE/EifbTO4GoDr/UjdA1l90IeihS7kcfkKXrdn3exJR2N0XXTEuNJ/jvUT4Z4u5g6kigBhOg0XlZGD2ehlpRTrf1JZedKUTJ1grzxKyFFEnqyyY4YS2JUm/WBg1wudBOYPuPzYQ1BqxkRc+SPtNRWTzpTuEiZk/QDG13zSaf36fR9zstVpdDJn/nE4hS78YZf0U6sq7T8MGxyOsMP0QxzY4TvM/PM2rG1HLfQmEU/jZgpcZ4YePsGI82xhgEtYyg8Eem6Cu3NBYJO9xBZ+ExN1UUFi1xCP8xYdT5bnwAXyDJuycyZFZyKO83Eukb1ly0lNJXWeGTUH18n/agzxkw9zCGqALZb9aG+qpGMjyXl+58zvEmKfSMytrLawYmeOZnBd1XTZ0zNyg3Ymu9N3ZT1PR3nMBvBdYZi+nOoo76VZgeoepGEag39pE9sXBUvavgr9I5ANBxQwY6ya+lpnSRyioGQiVvVcZOG6liFY1dN2JbAhDlH2FTIokxsvaVG/kq8YPwdoUmgmt3NDg4K7vmI3b1kOVZ13Q7f8KeWzWdAjGr+WCu43ejaxFAZgQwEj3qArdA7+1qvxTW1NzGVdPUg3eMvjzihe4/AX3N/qyJOdbwyzd3PfF4yX0rwoaK70X+UTDYrC7DNuAQvIrTb5Ye5iE52zSf/Nc1h0/K/kzCKlkSrq0Kst53kr6Zo1eEqhXOrMiwQj45CUuh4HqUjq34a/XUtmJ71zxnoaxSkzHiWF4hPKbQD5s3+JWqzwvGmJ+oOiQEDcKaICYN3m1O+fgqmxQHsDYtee7M3m2pC/B3DpGfiQBQOYsVsjHnZjRA1vsfUiC+O7/uWjK1TcfO/E2OhgSspn5moFTsLi2zW2zVJlAWYozqMy8EKt0GyYKSIDF2dIY4dY/I/Xa02VWFxkfZwAr7JnN6ZONLF3ZNEFbx2O0bkKb99FVNir9ucFrLCH/rhM9+6CxnyDafcVJ+/1Fipbwu5Q+SJEtKAus6t6zQE86WRPCgHnV4Hs+g+Az3R8y1cDN2XPvhSjJLJY+Ky9bPeN9rEY8NhArEXyRE7+s53GCUjIe0jM8kfsxSUzHh4lP1Lx7NLiXFxlS4fLMeLLbE5Q9KBS1vtu/O+6Mh+5e+MYbp2PERpjYkIpp3LHJ/KyBR1Nn9Lo/wHdQxjlVMcZ3IjJ/EPVc7RJAhYRoFGjfAd1qvsJDPFhFyZJRoQD021OvsYD4sBBIJOTvoXUYKoiF5uc3foGBs0RU6VwcqRB3h2G0e9f+9MGQY4pzCQhsnyLeNX2bok3jm1rCUXqqrijHWsZhB/WC39gGaEmYRKe8KrxyG154xBAKLsUA+dMnM9Z8WZwVnMR7tgv9LwTr55DhE+pnKw5iHxRxxFIs6km5OmAKrinnI+Acx193aWVfGO5SgRBFcz2O6x6ZRTRXEmwm9d+GbFDnwepjTMUYzlPTmlqPkOrUXUmupXtGhBp9SoiNiPZV/dfDfvJmF0elmk/rDGHyDTxMeY31UN9WeEn+Pn3NATPrFX30o0sPE/R8hk/KZMQAC/lh59EssY6n0V5D1uD3xtgRW26U/bVFJpXxtupHEranK018CQ8Ofgjc+uZaUpO3u8wXhjgO0cEHUB+c2vh3n6IaC6KfP/q6r+DMyvXg9IRq2rpQX/hPJemwfYabqTbA+D0CyF6/3SMFhXyNz28HW5HGgG6607pw0rv6t1r7yJtc0bhb74mjC8Xg7Hks9etZOgoSSHcfV4jQG2msOejX5sY79b5hVYm4HYLmtFRPFXsPL0ep9sWlmr8t9yfWOUUjzBeqLJZfmdUl3tfEY04Dqwj/xRP71m+k0cKU9w2nV/cpz66PwY4cEBTh5ZhKf5cLYku+j/gdCNDuMcnQEiY7j6IkxgowxQX/7dws5L4EelxSdZ1d+5ojgr6lGYmChGxRht6lq5MDYv2144K/6q3q7/qpnztSZDxpRG1pyCKl+EVGvqThHz8F3H6PKkhokPGslOuGLz3vargYUHF7N0omhcgVQyvYP1EmOFG2l5lxLmK8S5qKUywk8DW2KQnkvK/GCfHcJAISh4hs7bDcTVtapT8HWXOww4AnHWs5oUT1fGQi+XAxre7gjg4xG3dDAbdOncqCd7Bkz/0li8mDGrjO0DWLYI9RoeLk4pSx/W5fyxxv5D3TdUOBoJJahTyN5zB2XrkPeGoEV1gGXQihYxlgyq704QxwkTLqKV/4fY+ZBKzoFfQkTrhzxviGTZHoWlWfjZo8CDIjG/ddSAv8Fh5VQZ6B3QEIiiufjwGmyv832/bzc9PQQx2NUXn8eGWfF1A3SIDsRa7zTar2jTo1sxZoPYZTY++dUbL8oMahlvcfywg+c8jwT/ZlmShtTN35/UHbKNCjT3afJZEz0nXcwZ9U+h63gXdGyr3kY8Z/jQLEPqXCXUjkmR+oYenUOJshlYptXqM/zxA8poC5OW5sqHKjrIldGl5Ixw4Zn38tRKP8aGUdf/pSnflVOA5Dw4+/AQYmGmUFAnsGfPXYrQ5W6UJQdyHqRuja0kw7EoKNarIG41zpKrPaf2gw7CrLbKh3RS8oqom1a+0IHKeaOZnU2NKp2EPiFoOh6tpuVQsJEBE9l1GAt5PJTxLe8Kf4rwU2bYOedJ1FIbWDxtV5qcHIJ6A1Z3Czp3NRRrD3S1Ov+fHs0DiZ8nA1dLrf26Zfo16Xll5G8iq7FR4UZgOyV/M1SMJ4/WfL6mVYwAqq9Qhqy31a9iwe1JUjMmDYe1QkQ9WJjj6UcM6yBA5np5eaaVGU9OceX6MmXFaArVSsJWLLdiYaNCgbaVRh8VclWnG11GBqq67bgIB6p9+SlCMOKn81URLYgpFBtGbeUVAj0FZxYG+wtuXAprR7ViP3WsyVMgQJZKC5vik57BSZ87RoWeCrqwu+a8Jxwv4YaWp+jn5RMfHWyzeTJ7RW2Hvy3Up42diFzYVapqRYKVq/kK3QqVs7YtMkl/UHL5OqbE6O/mEf59B6jDe4+xS7NB3iSH0vIc7Ji9Du8s3eEqzAb4Hvjc107GQYFGlp1nYRKq2feR9KkAdpayurzao1Djt0CrM25bnepi1EVvSFAsTFcPzVWDmVQfTjzwP/PJc40V5GGXA3oCvd+Za+uZezu42MjK+d+VQ2QVBmOAOpX3An/J7zeOPQSHfxk8+PwulD/7X8ZWJZu311w1wjrlXRPnUlMtOiQUQTZb+md8wtw7pmknoA6334NgyGV1zmtF3j69nx/oo3StvD24oCeAbgfnNUpVOd32eDrS3StjcQgeXI3ftLLIVE9WaWKr4Gwt7EwbVeM1mwvB9hRFE45bWBTMc/V5g/f2Ji4VUbjX6qi72XZqUS5KEEXrWEVeSl6XXtirVIjxCKXDJl8QJ/nkwQjdQ0D4iU7bM8qhYXQ4DotQC0XuKXIGSjmpbytItX+lVATqOwv5BxjSUXFp1i+B+/pVFvi6JU/pGMeqCcTQ0idozV8uNOf0Hnkl4Yofey6UfY3ojzjkCKso/vegt5VB1nPliMwWcA6Ye7nn6AjQwn341Qd4HeZoRv2B+AfyVkHjza/pul/iMxewuQ6Z/CKq+EFHp/tiolHSeIjVeCUCwupk0JNmWWkyiYz7WFFdxyt8qY5G3oPnAOoYUEwJkCXncxDb0qczprvYQM+pSkc1BTltCyUj22wpJT2mMKp/p9LGwh6FThcbBIUp1/MhXcLZHjMfxsUOcX80TiY02ruihRwczcDMPnVm8ftJBj54ddhy/hqY+AXc/B7PxyIACIA3WQqW2McO1hXUk8wJy2Hz0sqZ6Cm+vZUwRtdv+8hbE3NPPA5+3lVlYBL1cFN+l1ZN++gB4AcI+Gl/HJo/wJvrlLnMmW0/Va2AozcjgYqA77AQaankc4PVQZPp0Juh6l+gHQssMMOEKk5r2ohjGnUwGnsV/o8IZ7XQJyCrhxvgRqmCxGep5qpan+dL36LU/G8Py1FPUK8Lr3Hpfdk60sbYWYtkVWH/fDXUYiQotbJkQvjXZUq4ZQ6cajad9EA/KrrsTyrDUWp3j9cCsPG6goA/G4iWKc7nGfGRDPOtu8bCUDGX5NHBmS6CdnWGDhG7MdfGtVS7z1iPyKR/hwOrkxyDRkb2no49O5xE+Ser2WdskToGyUGgi2IW9OQ7du38AJQ+2dz1PZwcvnwcOfkJbP8ElhT8/hGQYq32L8IiDaSRz41vBdSVozVIu4X14yC9QbEEGhMqEBwtEZrYGGjym2etz95WwHFVX2ixxM1C+hNx+ntnxKACBucV7dpSucoAIWAZx09mzpSeWuY4Y4dbPUf0+dpGhscvo0YAp5B9to+rxwFk6Db9LslKoLQzxjzyn2alkJDqD3DIjJD3W1Rjpj5NZzsUL4DUTUII6ldx8CMIRme+XTEU5yB5GIeB9swNhM5vqxLjUB4ewLufSkL1rqh7Ool+Zd1aAQiAu5r8EYzqV9zsLib1TiQMYw+RMgKo4mdrbnAIII541TlcQVo6gHlZRKOM9PtffuKcpRq0bIQgnw2CF9D4ub7WfiPFY3OfSjyo0v282SB7JmIBcB8esA2T364WTqhzmBB1s0BlClY3zZTRG2JyZsOBk4bptcicBPuPiDATCYoahvShUPQ5EA8T1n6Ic3o6FwfQZ5KidtTkKm5eRSbbY4NtX+FAkqgOR0UGIHX0vE4BT17Kk/H8lS2qLSUDJUwof5fmt42Ly1fDkj5cMXJ0/SFTBLpO3mAJF2IOhWTZjjj4unxiDdFFU91lH6dmv2P87FGVi/NocscPcgcpYMMox4Qa7kQAF8pOWzvHnxu7IBG21yLW9GJVp8AfAvMRSZfliIziCGeeQg1zF926iqdwxpNiopM7VL1cNbYU/i2NAWfNFeUoVS7yGw2jjPm6yuFH/RjYyBFAAJ6M1WpKrX7dCrgjsI+GWl5oJU83HIgczdNEL3qOBV6bFc+cwqWfkV2n90kcJwcUl7t8DVOTI70NTmssfL1GeeWmcT0RtOLgkGTt3rD+vdnmPYzL4Kbo2QvxN+lkeVyOCtd7M5r5MMqGwuB5ASwC/12k+m4Cfx/MCVKPpxBhi6XzRmctjsTv+RoypmfG/pxBSjw6fMASBAjhspWJa1iwWToworfmgFTFQH4847kxwSHylrWIWY6fGghF+oThnUtGD1qkP79CdkOt0cdLrqy8kXeCWMAyGw4d4uQjLt5ZWWXynOKdJJJIOZOBgo/o85fLx3LhvjZd7sDmMmsdm93Qg1IQtCbzDaCtkpACdLIx4bHg762Qq7aN/nwT/32TdEQgaR5fX5SNOGX/Huk0EhRW6ePSVYuSgCjVFdhyvT1L93f/uvSYqc1XmWicPrUMhvONi1uWRgCfDi/EUEJT6gLPn5aLMWO4XTs6mQXd7yWlA/bDwcgsw+qKvYacTmkg5rdWP8puQ/Vl9PGQ+Oq0YNX1YFyS1etD3JpCgMEwZJaQ3lpi7dwZ8v8gnsO+ez8vws0ZLJ6hDQMTbnID4YSz2vZ2UHCcGtycgMXEhdW323TAK01Dfka8VRbOJp25u5TBrOUF9J0dEsSmAG4PSx/YI/E0INbSz2eGtSpB18HrR6KVMHZ5san+BZQfFF/89bdPXE27+lD2EV5jtFmWeqH0e+YZfSkIGGmLVTLHByFr14ZjgOWt5a/xLFp0pnFmyNk+vR7YnQB42H9ycrAKts1x82K9ET6kfQ/zyb/DhN6MGa+lr1GNm3UQS7Nasbn9xoxWaUq9hBcyE9gWDK+gcnwBIm7pcRCzR+yxNfL0ZXYIl9+Okab+Jz46DRkO9hrRhvE9Xi+Jbb8vlj5+xhpaqHNBB8RFrUfGPHrq4d/l6HgCIFE8v/RdNe4minaFA3Eh2TwiHZZ550qK6oFd44/pqPbTIYQPf/pW3OXq3sDcvmavC4m3wbFkUIcSwgRaefeY+izFdGHKw0fkBR05gRJwEP4HgIZ6NRY+td7Jxzo09GoYbV1C3FEkug7KnCN0LJ68xNMC4VaQ29x3ciugPv8GltYj3JP4l6F3ui5Wy++EhxSP5CoNyNQ5opOAmLyOX2mglhGIdbxsI6GuSSft/aRVrAA4CNsTq4qxVYOHgC5oP6Qzsu/ctBGQnB3+vxCob4rsSo1AbQo+23m0nyTLUR3Tgkd123n3/cy9YXMaiDeQav/VeV1DYNimkuEP1O6bH3jkxiLw0RfdwUW0eGzxkn7sgdzWs464HMdHmoTQxDXrpEuoYg9SS97Lzghy9tOWoNLJKYiTiiKLYb/TQ5yVQA9S5ysLzjqnciKoVUCNrVjPAJa0YkAqukjbOTo4sWH/HYZqjf9Xm8JODcf0B8b98w29C52S+3mmovrc2A/tmpRyGalHxTlzw8llg26DaIjX6VnCICzhf4DZsN17q+HJXtPPscZbqG00gKuZLorW6sCKL0duUyReEjILjuV6KaFKAd1EGDkKQzbH8t/YyXdbppQ0O9AarlZpeO4QM2X4/3xKYUrFgVOnPEgDAbc1OQa6jQZdEGsOhZmMVcLCmDWox+wG/GCpXme4G6t1o9zIu8Fx+S5vAkQVtVHgtCJRtWb58HOCi9bK4YOjmMudK58zgi0Pa3l9M1FTBO/V9UGRySEKeGIbrfzjWC9b0YDKhgl0vyEvJAABogicnkkZ7s/Xgd6FUxBGCch+fG8JELglBExvIM2C9e1wT3JSzUk9Jvt6eod2x3KnccktHyoNpXMd12i8QmMb1nEXloBCnUWVavWd2Qvy4P4A8L8UgOtkyYsfm8iZJmcgOr3IzG/Tonv7swLiw3aK1EW7ESMXx0UhHny5qnY1JhusyQDbCxW85iH8OOTcJGjWWvnV6GUetT1ZfWOmDKM4zimkiZTmiLmnpkrzqKI3yVeaSBgpwpwKYogA+if50U2DXbjCoBLg3zI+YezVMmwlLLV1HfzFucrtHf1bDwKqfihEeCrMUci/feeBlEld4MAS7jqax3BoEF4NKaTTYtcOkDfFPGjKYKbvOVbT9nDIm5pOFmf+ALBOCbOEvC0GDXr3SCaN1kHMhfMGW8ihMv7SxQHH5u6S4pBDkRyKD4MQMcUzJ8oHtpoux6olPEIowvjZEf38GV9I9rKbvwAY2IhsNdeeE74FXLUfmt+Uq1MCMHnvHwwGwvgxVMshccNqXqQEVAaLPUpTryu0sE7+55bqvvd3iRpGtO+3rigRF6yz7FgMd1LM4SR2Mii0fsdoYHjmOY7UFd0llxXoyJ3+jIkTLFfhaBO4Ll2dsPPsclj9U6dyXlubcxl5X/qBwQEBEqDpySl/rnmvd5R+M6vlRYCqBPpOd/Oj55DAvb0QqNqspLDKz7ONeS8jtuVIhSrWFnbJB05DMjoC7ICXeuWcFt+bXuJMehai1msXslDetcaD6hZ5SabPWijWw6rcRiCvxNsTf8wyaIBrwyoJVoJ/UOXvIGtYKUaCM7vaAbmYC07GWzqqRe3otcr9fcVN9957R6hN//sITeww92WgcyVGzeKnSoswZA7VhgmFOC3J7nu/eHNHRXh1PR0l7AZD2E23pYK476zEisHElY9UZGPew224zkSbyYBOt3QkPNGFrXcPFmiEuCGW+NUSl5Hl9z/jdaO6LkcimSKW6ygZBuNTkjKK4hgoBCaCDAVjrwoq/RNGnIHi1kEltcD6YxkU8s2USn5PWRKkj1YXyogHYz4hel5a6W6j7+h6Dh1iDrGmwaQj3l31lmjFXtxB5gtfQzvHdK1tI26DAT8qbZUkHfF9gDe9Dq1CZtJK/IK9KjbBcgqm+lrBNd+n7yT6mU35dqi4DTGysrkkbx+RYnZV3aReHjn/OWu6BGUzkoum7w2HWzx+h5kBUgGayiKr2KyV2OAPqPXjNonn92tVx0Pw5ahu19hXku3yBRRamnadOIZkL5JlpBhVLXbwaNcy9VDP5hAKW5DgfblXkEf2bTnbV3w6F58XKBDXTpfA9fml0Km3Jy2XpcrUxzKy7XcvNEnvuEP07x0JDz9Rg88kHPn24tQtBxLnEXev7pbQB4V4jJRbCoQbDcGchURXqYudaVz4VuBiMLUooHcH9QaFoOleXWiSb6xIqHPRRCFprXA1KCGNmOHA3Yp9q/YVhjPp9cC4zdBdSsxgAXpbcokQeYs3mYL2f1fDhbFC9Y1SWs254ot+YyUJG5yvK0XfOJeBG/71gsC1IRg7vHxDTyvmrz8bgnSwEga9MzUzEs3qJ4lmz4qjbfIkuEcPO2ZI925wkId1N7sF+Kio8P3+joZzAmRe9KKahXK+LS3Om9nL4P3/+mepy7c8TfTdcDPBNnFnYFo/ZMD2yApfEv7gUfEZ7YByJY68m/ixgye7lUvTLk+nYjGyYPWLhcr8UBM0Ge9ceinpTx1Ow+fqYz+eWR3QiheFq2LwbGBEC5oEnzmiFVjGGDNYqVIcmDSIINVdjtIYoTJxQLyHO9uI09IrNDpXs9K8WXVlxFuON0LDey9MHy0DL+AKEEpNuaQnr+Hf+8Ue0T6ET0HT5YGWo03k3NqdeUP9e2WT9J1dDOBzH7Xzj8FzSjREqDr9S0WTQb2pyd6uZtg+cACUlrMbGMtTXdtXS7P4eAW29alrytR6GLJ8sQ5QIL4bnnEWKZe48o56qf5zWHW51dwqKd2Bs3pinKxKZ4hPt1pCxvmjTiuHEGgKHgPx40/lEM4dZdmY5u5x1U0Mkxc0OWbdpBeps9UZIXPjsEM3e3cgkpERX7UfM3ZxTuT28jlLO5ouB51SALtsZHlC+Zi5kiuFVphsljLCxxeL0FaoDuaJJMzQYp/2qqScd1jyDd5IrZRidKc5GnrUUo1SkulR2rP8NzomfRUon4P6nwqgyMsva0JIOHDWBKQhyl16cMXxjaEP5lmgfkBqSYZ/LmDxF5JsT3QWLmw9S7HklALCENUUmNBqxo8g4S8ik2oZWZp/KRqzGz6S6GwtXvkhvVxDr9mq0wOwSbTntd+fP1SbSgN8XyGRL2z5jcUAvsYSel3hQUEvJoQt0IF+BfqzF3xaGW9vZxkC2qnMfnj8DWgAU1WGxh9/NMt6LagLT4B23Xmi7o4cYT35VvLKu9EN6loBpYiIFOIZ6P3QRS6ZOBxTFBrenx8AK+cBAU5iC1HXHACpKRffsDCWtnN9+/rsxIgpgXZozrBFFXRgINRqc4o+YBNxkL8zhlJqeDIXT0PmEY4j4hNwCBMsgzB38IhXwaOvxJ913BRb6EqaL+1Yx2n7QLkOw0adPC7T7dhewPx76asipsf0B0gHeJdtbZbZQ699shkpmsCLxE28uTUPaNobrj4p2ay4Zbn2ngmfDgqTs1QgkzieX7awgtfFbZTr96+7Df2IsaCt1BWuKyFMdaJLLcF+ZcjKAxUOZwRy7l/bkYhAsrXJgaL87x663dZiIK8wUD0kXTRVhZOzjnzTYkN9M/4ft0aRjTo1V1jsZmGCR8AogW/5ysHn2wsnOX6PxmRZx6u9UqzN5fZkCyNjDd5eRRCWumUdy2gL8bIqPKVzWqyoJPweg4SB6ACFo1X/b/ooGgonAyDF5jPVOjgNbFKBkj0ZjrdCTRHc9i5MaKr+Boa/iRo/gUfiOrLIDPXjwCL1YbLV9XrVOGeEULEph/Bma1ElfLRbAMUmJNgI1or1IXsKm1Vs1QQR6F0hI1KsQWhK5RdfSNdX85urMzocHE91XyeDEYWLXmbMbdR+slvgTPC+dSdokRGlqAYidhqNzXjg/b9U0FA5u6rhlJfVtnFs4RKct89+M28iBuFQAMyPQdoPfexJz7iZ/Xwu7HWEHWMW15l4MuYRpwLCQo6MwL8yNrJzso6Zh9yy6D61LqMzh3qexFSg2Lt0yTriixR7mYJ8c78g+dpnbNsMWyd0goRR4Ikv3rS9e1oDrom4EJbuPyuKt9Fs8Lh99PCmKuTZMb3XSxfmBLltbCH/jd8xWL4WtilEOrf292frX7qGlC/lEAOgskyUIDfui5tlkXna54JqWqSr6Fa+qY046lSN27N5vo8wiFLl0JXYkX+lgwLeA7x+uH3wvjVNmBLzhak2VKvnxb9K44KQl8lwhiW0oTQsaNAYIYk963dZgCcf4E/5lS0/CpWU7MwyelELEkIsZnlqaca0I7OiVHnrHibyVCM98/eQ9LP/R3i7P6Ev9Ogox3cIhBI/k1lgccmy23X82gu6ypUw67aARmeVgo7g0NatXaHYKcViI+XHIXYSXqhKcYAS8sPuDw3bA9A7OgIbr2KkYuggdyGMNOzk6kCuvzMG73pXj0uYc2wMdrJIgDxA/GTl7eCD++4CNECpUvr6LVZziHHVkin24NNLpBNucSUNJFrMkaTtQYo3sJoYClkYISMO2BiW2fwCaRUMMaDvJmqxYfGsRWlXUNr6cr4dE8V+p/2verLUI6GHlrpK1JSPWOWbEjRUQMad9x5fHnSbWxvJwwS9LwjSMw80Rop2cRbUW1X/uMw9FcWB7f0OPnZxQWL/jblxLPkluy3e0LWWrSW0wtotMLy9gyiz2q/bspopI6TFREw+Gftfh1VIBe+r3t0Qdq0KkPGQov4D+ws13/vxBfIOJBdBM8pmbcEW6rPd/wZGR+HudB2I/jxfkQ8jOv3uvN7OsviH4sF48b/JFaz5Evb3fA/ttZbYMneHBqJ67rUNOSwzn4KhFz5aV14uPBprCEsqY7Hly3Jm1IoTysOjjHkrl2bO7pO5A9rm4j3b4PnllekLM3JpeRT0y7rVQAW9FLzWqio2+/PDoTkX5dG9Nw/CT2qtOAaTETSDc+fNcMuHop2jNWW6oILDO1bHkZD3zGD8d/9ZZYxR9Ij8Z3sHaOrH6V5+IUhMNIF67r+UlB0N/AYeAoPG6CGAmsqBx2/sgS8SEfqKoWKPDB5zSATH2IQUjP82ZwZjKImiCA6ryqVPB4kKZFTfV2EHIjo9NokIhnoLU9RGeCqTjmp5XTbSwAHW7hSHpHBiwFXAiU14H0ZL6RkEpXO4we5i8438nDaC7AgdoebChGdSq8Q/segBDMY+ORwWKkq6xyfaZZIVMV6bq1sdRlCZzB9+RczVTz9IvE7hM/PfDPk5OhNa8bPCYgRCT9cqvTzpi1O9kAkWRSeToIe0mqE36L6jlx9xjHROhbj0TpfbLB4C9fFFKYkxc5huPPy06Xgyd5hrfADXXbdRZLuhRgbS/yoiPIAGXP87zLIgYa7zYZ/oEcdiSPo5iux4JnyiZjs8OHX497ngUfiBlTFPQ/jNjiZUkot4gDGi4tg5YQmEpM6FCkWdsVNkY6fyhG5M++rWOKX+URDeU1FmFnLlsZNP0iXmXag3FgV1xzfSCZVvegtZNoKKuSPaTX/Gh+V6MjiLkgh4L9O2v1UcZUGo7JFiQidYE5RrBRcgy2occZNPqvyUmwAxukif7TPgzMdiu57OpLzHk3/dUE/k9SoMnAcpVIYQJGdb8PVzHgVjp+U/vxuw0UgjdpDbL+o8hpH67WbJ96pYV9dASxYdkV+RHlJiojRA0Rf4U1la8aQHKicCvrmHaRp6VK2pUtXtj7QmB23nrm0DlNNUERFEv3xlzRi5Wz4P3Fv69ENKtooac/lR11ybC3nYTfAtzm4O5HY9j5IissUcguumcRD0glzXKjZoU8hH3w8/IjMujtm/1HUW54v7ScDKqJKiSiECsHcgIf4yv+sETV7YydM8FzFSeOtaf7RAz0+usB/eEqwLmF+kC+OQiFJPyul/w9SexgPBBQEnakxOahTiK8V0qs0RGR+xVKGpUFiH2utv8TxKP4t8JQmnNo4t7LxKRoNyO/zlMamVM1lAinq9BiyEFk3bl5pEkrkUCneVT0ivyfSdhhWcX3vRbfAx3F8q+g2gTXg3O0i51RYZTMqE5JDFAvuEHhVwF6U75EVzq4Q5qFF8rL+8YtgwzZlQ0zFZfbmpqfFl/phV9qZWlLQIkl7rZM28DHioid1zTrXNYe7W+0CXkixjfqah80wuPWUizVuCowZsUzXoO/nwnh2/XVa81YL4Xr/llWr465qTZxuFQCK9Z+v8SdzmZ3rplFNgNtpQ9S6VLp5UyeEtk3gGgLa0qyZ1Ml+PXkq6e3ozAnoeB1Ttta5nmR/PUCXLXL+2OZD7tkAeq2EhxvV/DKNt2gplRC/D+1aTDlyaeXN97mDRpseeEbk7ha6uADRkqQbsL5qTC6iEy+UEoPpho0FFKgZBRMeUzJXfdd0ujI9Swbk3UttCD0f2YdYdVBhjWrs9MGdqr+1SMnarZcJ3w7DadtD4aYtNwuIjojcTiLuR2MH808O4/ZiH9R4jpJLMadHpZAmadBke38sZ14Zwq3FNg1nWnbFMKmgnjIPRQLkYBKGtl/gvBevLNP0l6TM63ulNmOss0ABn/wBnwnB3IbhPvNtUL3rOGgi92sbn8R7baUPtvkm/2xgmSza0cxEJjE33shURuVUCuuSTR1ICK2NFJnJQsLzZ6K79n+G5dlqf9sLVo2LY6HZNBcz1pgyRbBdB8MUz4rbCWYYVrU6MletyBViEJgL8w3fGq3Wn51J8XN6xj3qisfHrOzBeYNi+ErdGvxH8imhL3HUlsRBzePi8UIA++UA0EP/rh9jd5DBxVaRYNNLESA2sFeF3KfqIZJva8OWQ0Zcdz4Jgnp6iRrvajgYPaosFuBSvn9xKsgN0ENouXHNFbrTQoe9ylyMBfX8mdHMscOgUBWxythTgudhqLNPCnenGtWOb8cL5XmfEyDWX8tLbdThB3WAKaptv+ULaX0SDVi8YDm9WE6KCQTN4EzUx30SyIBzhhb+MO5XmoXwLfbdVCPykqY+RT01ClSDl9CFi6wRm3wCoBf8vHY5uityHv5i7McciD/mxH5WVXmo11GBfEQDmQ+8euug7kpJO0b4AWSdZIkE6OEZjSN8rgkMQJZOmlEEzMw9anqbHlpqRJlNpkq/r1USv2FNhyhsbwB0HdG0Ug0gG+4/9PrjGBkSS3UcTjfevm6JYjIIrAKs7QaGUpi0J0EGtehijGw1z4QbVevMXMYhjyLII1YvXMGf1CdEUgh+IfEov7zlL5RAK2pH/E4vgxO/nOoiDB/wmHrEHA1kuVPbib4ZRXHqRRn4knzgU+it3CY2XDfhO1Peo3OwlHSrtq75kGNat5eAX70teKNTjtGrMKEY1ASwQyLaHJpByXlZlZGjo76MMh2gslTZNcyusWLnemsaqoEvFzVDDadDKhZLN0N1nfmkQwdVWR4XAfXaYj6u6pg1vrXQZxPDbCLoYQhqynikUJ/7HUJ7Hq2292CIx9dVvgAlfwCrsq5u0LH6w5w1w16DwAMMzRjzCxQtOKTLYS+xffG2p1DrTo322PyrTtKw+2PSIRUGEiYmYGSzGR59QfyvDKr0ZjSh/KxSV/WVseSVJtQXwvsbFZzS4Sgnm2LtlZB0+YIDqy0TnkFnigCRzac0ZZ6EjEKZDivNU/zbovtet/7dM9ZYOjbGZSQWcGTpQX4r6enu+yGLhTCn31B7bEJcVqEaoboeRBN+N5JzPLH3WYZitlmGKrvDTWP7SnI7zyTq3UD6UxeSkVdfIvRqy1tLXu1gpledQRBnafw67NNkv8IGnkbBUIeNEAw8/9SGFneMyF1B/L19PPdYUvS7c0/M2c/3oIIEXlc7tb4JnumcHWSDt1XKCa/bhWVMQZtaO4CiJEG8+CetHuYDsBJJHS2UYp7re9HXSLDDNFy1hu0sU411DOpCYxCl3O2RhzDkD4WXyjoVUXiMT+WSE5MiqooTSiaXYVYw/dID7a8MIup5V76PHMnxLu/GnO/ICHG4JuIVAX0I1OZx1Sb3ayDi8wf4JsWAQFTXkM4WfOgLaMqy0ojKfG02Q03H/e7EVbxzeH5LpAho/Vp5Mu6QViJQZP/eCfTH60nUGIvVdsvw0rb/8+CUSDWVSn0DvNeHnICtxtX5I9rRmiGRrX3AWcHyHAHNnx1LRx61TR4xVQ+5FNb6yVGS0ZDx3ptqcIus4LXflogUX/V2Y8Ih9L3ayIYt8fyqZCRL9+LT+CbzWkJMA0oNu+OGSKe5Gntr1zpmMAclUPQPz4mce1PoOY6B1h1AxUERoGUkSuNhwSTpcyaYo8AyNywj/JMvdoe/W8kVmOex6daEwUofEti8AlFeJoTXymPADFOttc5QnpmJBklGhwTNLIV2FXT22pI3MLcAyhY7BJv8bcBBHEovqu3tfWqoCGTMbTXKUwxJEIXmP7rBFGteonTwaLc9dAwJVEmnEbi7eeu6pUSj8fP/TIh6zxspPXZekP22ruV1tNybflS0yy+4vnsd4EhqX2LkQJrhdGcHof5ZiHoXyDlq0GNXqX8QVPYtjwLa+qhhbP6wB2IJx4onWge24peeYATVs10SMlaq4AtIWYdqiMcm/61DcSM6sB58aIqxJ+QTYZ6X18+SnqeFI74pphnRIxYbv38HXJ8fyEYqsy6T360o6YEfwcDpRGVh/HHZKHu/6DkV8m9LK/vjO6sw9LvgKiLALygDnQYdyQCGFb3eHTQGjRhFQQuwdc55Z2W7+L5ptV5LLM59LYPmPAXDGGulnA2JZUK+1lCNpXuzREGNVX7VYFr2rCghBtSNEIDdUPCmqwyFTW3QnRNaODQRbB7f3/Xhrjy8sjQZQRq/+AcKrXfTlqsToV4cE0BR5WMzlA54ujgfDMvQPz3vUSnH3pupCAV/rBjh92kOAHrVs79KZQr34pc4E+Jt4wX33Ri5T7LPU30FpaNzhfGBy2ulsxMuMaik5B9bLh0WHVvMMTRH5O+LK8Js7g6XjNDxKFW+fKqDBlt2zS5ksaRiYqI2l+0cvgLJnmBU7zBIHtR9T0uR7DYA7HdMMmnD1nH5IbAKWT47PikvFuZPgG0Vmyi09gKcRzJezIYaKI6gLA0lFJOd2nT310MmOd6NNhr++aZIiBYDCegs1P587ddY1r5fPOA0xtzritpTXGsjRnYwdZMMZJFlAQj/XDa7Tlf8SmKlkaqFlOUPGrG6oP/Zf4qPW8sUiZn0hfq18Ek9Q9pMK38qfbWGMxYD3LfAw/H+ltB7O5N88RStVe9pEmG6odYHmpQnQSwWO08sqoIyOegjDDFM4Fufodlm26z/laJm4nmPqBs34Ae5s5nEmZ3g1DmRxt12vKh4vpoxvHrhzaFu0rF16kWJ3UF6xctvh8tr5FKMDeUaFih0vc6Ckk3JtkrMhCBZ5SxPdy/M1uLwIEJEmCbMyVEdVCJQUy2jkdY2Vu+VY3sXONi12aL9Pl3RuIyttTidQ1PICFL12EXDyQv+4f8ylBDPnCYdRZh0LFExnwwoXJFTtIyV+to1070g3uxJZ2XnW43LuNU8K1f2Snxag0fFHY7oGo6kfq/8guM3CMyTDmidSoTg/+7nqTeaMv6I450c+d07eUH6Uw0s6pBg40GT2QjDFg5JqS5JIHlXMVTdEaXpu0zBQ9nEipKB+pJJk1tOKWLiSFoXGWit25TY4wSWq95qJOrnKya7gnlYhU6ZfPmJZ/QITBOoPuOkg120jYpbLdm58HHi5M+17NDg5WhUpkQEt3/58qHCS9iiVLVvnDtdR8o8VXlNfAIu3E5QO2lrK3oug+TkYWiSrirSK5isJ5vhNKqfyhE+wHpSDe5TB/OwB/2PLifkPBpqK4Wxh9Cr6EdA2spPmehpt6iHbOCs8Wl0jPJME+upSiEc0G/7UMtfylAfLHPUlAtfa0F3DjHPc9M8xjF9YiaS6Aho7+heWUMrZESa4GaKM5agvtoRG4S+EykX4SoPcMTQ3qtRoPN9X2vZXMKnCoglpwb2P0dm0GFkST+o0DkvERV4VlXTAbzp1drrF7WTzitxJ3j1J53A96pcBOpkgNGs2Xkje9Ivzq/2CDnJ198QnHrvEWfEERNMxSRf2UpxoJo6vFxiGaM6cjUA3Wdk5oXf273GIlyHT/2LKoTuES7hLhEAQ5eziw0NcOglpYZZxdJ/Y1rKr+Mu+PR/aQUo+VyRA5DKVCwpkBAez1w1Qc0qSROEnadV5ghJYMlWbBxWfiMlQxfs34lPs3hak3fX09T0BxmMyZd9qkay/oWvvzl7sFXrwmkaFpYA8CDCQDFVHeIuzJMtKWzPnnyT4Le/QocBUvel/qK2zRCK1CUaUXcm6uV4ZkTgV+PD95v/2AlJQDYsN03+iw9y5W0vSSduwFSTYAK+hPGqNjOyOqe63NyiNFMV+ExaZp7QPCJiFvPJ5/ytUD+UuE/MvsUToFO76F/vv+ji4yEGTdevez2ZInv48xI226WIZzU+4b3+/oDlnylt7TZlHA1ENvQh4QB9vX6ySW9J3r//HLyg6iFbtkwe2OBD+IUx6R599ytGGUHRy/TTz/98z/uDzL8mImfoS+Qqq0o9i3xN+qbVq52szInwhEGxIrGwZHsDAqk5My8WtXoCXvs8C9HY1/SCLqxmIIE21tB5BWAn2AoTKIc5USqSJ2rtFDJh7QPmxVqDe/TBZqg3bMs8hm213YoOBHfIhb/u85STQF1fM64AK1GxmlIz3zAoSEoDGlmdk9gO5YtBol7LLzUdKmpnSr61rsZJ7eKUHiq3WhW2gfl5zuZBxiEic+y4LqOdPzT/m34yrHHYEvILuHZ7+HTcQgtEAoPmU/Tqj74rysz+QiVAAoJ5o+7+Py2YkCURMTtC+Rn67aJ60oE5Bz/EVNGcgSc2TFg/g1kNkC7yr3vdEXKuGXZ4InYgbHp9yJJ5Qbdcm+9d/8GLr2Sqo8AkI6b8oCBoHfFvsxvgjd/PgfuQW00F2J9tgY3/O9GIBOYND8M5/XIFSkxbdOAabs3UNZs1m6hEZeRhu7P8j1po4HWR1fHfkXjMGJ1vxStgdtHgfIeaoOjJAoy5+9hofhOymYFZDNSrBpyqzdP5r7UDXYuzTBGAhzr/I1yj76/1u8+Tc5zcniX4xlKXxVv+8D9J5ap+Ydd2r8sicMZ7nIIsFfsoabu07Easf2BQxixzsHBncZc4CwgVCfF9ZMpXZu+LC+Qd9czYedl2XJBRg1wFdddNSil1B4TV/t3d8MeYi4X9p7eJan8YUNUs6Kg3xm/VrE2hTXrwlHiLIC8I0tMVJQ7iBtOuGHXj5RFCSLWnyp5Nq5hs6qw/hOJwaw0MfRKVYC7Yr9TDE9nFCTsxyYqrubt7IbaCXLCJNp5oAMnbU0jX+u0La+LTM/n2feb4eKI84cRlpdYM+x+SwN0LbM/XJ1AsIrAeHdB9kE4uiml8bf3k/6rqQvO4us3k4XipftNFpcvnuSTnuRWKYbnZQKh+eqGqHKOGcq3fFEVu0ZuoTdkmAs7CL0nvDWIP4ziANtXb5qsDox3sM6FdZLWta4smPEDOjU7xNO7aHwrLd+C35xJ2GXrOLDFCYGVPsSfdGknRjORfT7JqXVxAbwZNGetyFSHD2TG9mDAxH5OgvLbf8hAdfzWqueDTNQktNTaKkasCCL1/TrmeuM6q87LQomr31VvVPgkZUJ/3ybE/TohAh7gvtIdr4FaA9FTijzNVFX+T/vyRzjJnxw0nVwh+HMXV/yWswNNcbznk9AwWMUAGYBYYQbKdyWrlUHY0abbJh9wk9GUq+Ou/F3SRRdIGPHWLLh0tFNEljE9vrTcyS+qWMMBMNG3eIyl3JjtqNwxwttBm0ZYGGmOYHsar0qLg50S7ZK0EYcwcMfoceE9hhiZVILRi81oMjf5T2ZySgIvQBKSV833LcO7IiBgga73tNovyfTUzzGJLbzPHltUX8mEslQYN2zg79tmVzFzCKa0Yz+uJKi2LxV3ceRdEgzd1wiVFkKnZoxdG2Zc+gRG9gyE9J1w7N6u9APO+ItL+BxY8K7uK0KSDRoIs2D5avA644SpSUiTV9sAufaiTOnQV5aA04gXyBfWpuGmGg5G/UcXFiek2n0gY6qmIELiKy321U/RmleHQHZtSsSYr0rRl0xHbYKj1uFHdzgu0Ke5t01Mhz+bShcRItgysc7/DlD3vk0+ZoJh2BWfMLP6ozVt//bwo3V7aAkd5f7N7S8Ujh/t/UZUSkF3xLlmArSPrAZLYAXFUqvjDLSJEuGM2PprSMYxbmqiSRf07PEu2EnafDhSfRKvSBLizB0oXm1BArwdmfK9VM/aT09C7szX4T+x7CRa9HiyCTFDuV4+y78MxWMF9drm3weg5qT5l7rVKPue1F3uJ3r6Qsv76YHpCAnAaWhz8Ihgpp+TeZ/7b+0nADEThxKxxxVK6/6+rM7c14y96z7fdBSheDZDr/DBgBDzzv9+zhs6i+zfWxm/wSYWf3BBT9X9b+n+9CCgRRc/wBHnJWSyWqaLnciHkW36EFV4eDNFGyMn/VfpUWLHXZUny/xg8CyHXNCng8RpjdCNGrH22vnIX+jgwEdYeZR23CWro+H0hWRaqJA63ngh/ToaTLeF7NUlwytUBM+vAaMqVVdiFSdABW68lo3ys0pJT0o1vev2c/yErTPyRtWrA3PfxLIVIhPhigwsEXUruT8VarClYx36UeXBsRj14gN1YpC1NM71RvHqOtrKsryUstL1LnLi0uuAEh31j1GmzteerMEgwriT8SS58lXIyZbnInFDBOIECa+Ir08te7y8ktg6mNaTbz6X+glBXnN4cV1XkotpesVAMav6coVzizJq/HmOpzbg8qlECIInFrOUc5ZkzS5ubBsZmRSWQamsrbHgVdCRDWjSfGaN0tlA4JDwI1DUiY/+MVA9wym8jBxJTht7CmrUmVBxK9SCORmBtjs2jfqMZztwOfoOuRgQWqOIS/xTD++XTQlFH3+xbcGdCxWiIch73V2z7/KTHkxUDXV4q8pWxaSZU8eeq/+xXee+/vGmQHPrP+PG6NRPNs4Udo/XxRkAdp8dEOb3GRxcPBEl6+HmptlyLBZZL5gwYmbvK/27srhyPCVqVG5WRkk6/C3Zn3BvZRvxmyvtBdS6biWo6gUJLeBVHgkkwngDcc44LyIE5QZqGWyfCwQ82RrJ3oh9+6A7cp/HY58zuk8f7W/wcPZG4z+uc7puPTPr/NJovtFDDP6JrdPCzpq8at8e2lnDt4DOMvMhu707Ka1Xx/G8KWqQMXqlC0+LsgaNi79rahgCdaIfpBWiDGOvt8mwCvums+JodYkJ8FL0nflADdWVbEGiHK63GDgEikcE2Kv2V3O20Tu0oIVMe/ZBajIY531S9Vqy75ZjcXZSyDsRvjBOuGFxWbLpARfWBohZKqs86CZ1uvUrAU1yG37472RkLcv1Pl7L2T608SXY2uAGAwOVunhgSM+qJ3nBgpaIAO8rsByjx0yOfEWTbIO64kEi/9YBJe2N6POiHXFekWyh8lxUJP8pB9iIO35poqd97QOjpiS/T0BrQp1Ob6FWrLv9bPknbxl8Q9UsWN+JtANDDfmuxenIzeSl5AphNGJy8bYJj/b/aw45JmGbHxrI2vGDmx0LYpq/yLgl5mETCO6IlcPdizT3ALxbixh8hYNA9nE2UkaavDgZMbNyPLDYRyMAORd7TTyNkQT3q1lvq8rKKzLjbN8OQMCTEqz2ZCv5ydbx7AGICOK68hJFsh2nZ2roZL2dqZv4wHK4BlW1mSk+9V2ss2+hMgK8lSyfJND/yV5qUXhTGlrxclB+vmqIRCoJJFlpkLIPGtwjU9UV+/A7UWzxPvBTlD4zxIG9Zqzm338b/p+DM/xJ7nQl3DfZF8OV7BZ2xc4ltdi1Da4n6zkQrgwpAtAHH9wEaqJIfvB10sKfEqa9xSqVD/s2YGQYN2m7MKZEQOLCTZTWTSPVTfHV16G+EpP6MtcezR63SB1Vpr4II9ijPKRk3jTLygKCIPbPcrrLnc7yYR3WKJj8hHF26Elz1mImUA0AumSBSWCk5o/fO/pXKLn12x0EVpBvxyN3s3vjj0B7DszHHSVhcmG3MTYAii6h9A7Ed2Qc053ZLaRh/CuZYkekFa9JaKtsLGaqi2Okb7k9obnyRWWESE3+jgYgquQmHmP+bIoyPCHwx0d6hLmfoMlSZkpfV89IbYR2cuSp7OVrV8poeDiezmjRSAz8GNn39HnEcXUnXDgChV3Xlfv2rMW/QYL7Qs89GsXTfQi5YjGC+iHUlVqNAyu1idTbbxgcFPZNbIllT+ukflKvqNtnEUvEB5qTHuRdNfsj5LSc/jhr5aozo+HeQoLLXtnCCADgrNr1tGcL4md1+yOJnOKtSYkEPXvxyJQJnen4yIXh645fWjq8ZTFQhWnm55V+HEH+u2yHVTe/4eCNaJMuLvvOIJvE/1zD7LAjhliT1piyWiioZZfZO7cAXaNtlPHUZI94zPR8WFG12G0TE+34svSCbAeHbUwxWLB2PZqfedIUi6Pr6enFyX9epkOsVw7z688gD/L4ombPBy7s3euqErnRi0CCUUbva4jTNl5u/jiiGNhU58Du/iKEMImJ7F1sawep/RObHu0WoAySCGW9ENy607wze7HMxw6pfHDxWDcg/Q8kcsO1u3Jxez8rT4y3HJZjxhy99XHU7Z2p9KlMbgehXngqhGfcLv46ykXbgE4bCoP3yc2Z0YIqmOaJ/YjwOIUIQNEqs9ZA0Iv/DiEMzcoeOl5WQZzREGa88PlkA3iLbtP49PY3wD2mVF3psbdx4uCIreWmld5PQDpyP29aD5Ls3CHT4HcjHwqBiJKY6ATvu+zEtdON5Gf8EbvceS9OPJcwYy9W8qzKf+EJGkf43Nsq9FABoPlm9X97gcoNY1igQZrTTICv0fOSfRY5vhhUfRkZ64AT2i7fLtDu1LNDEZuldhoYpMF9HNovZN4i6tpmg83xUC5G+Jj4FnNcqQl7MAoPEYUHJX6AIgGfG3as9vTxGBcMzZzfz1KRo2L4+l6lTqn9yE/iuFauM/KTovIBkvTl0NYBq6DcUmjnSMW9UtPLtluaRwuX9IWVTJYGMbfv4je2ocMPTdT4XjNk7BrntSaUNNNNHB3CyfYcfFoaxv9wb8pqArsmsRFGrLyI9m6vCrNE9v+p6gmgtFvGFhKKKi51z67RjRpCTYFl3ewjqasp0d7kNEIIpqtxUg+qSKOW/M/5U3MPvBixT7n1r2CAlyWDji2E4PwJbKPfuUJPyMrY7T0Bs4Sgg060xgKbrceH0Mi76D1bRUyB4QVIwUTPTY5i0V/XAiBXhM7pZT+HY+gqaboJJ4+f9AnqNHhXQTB82j0pa4DgZfahpIzRN9L2xkJkPRZ3bbcsv4wWLCcoSxcoEMEobLnmPg+SaC/uL3uf9RwHVS4VjnHYusNZj4l0I9HDec/eQEy6DLfPuRmJo+xTZDBOkEeY+BSg3pLN/widcu2Pba2uadYVj3DknIcZyLgIJZpRlB2X3eO1nCGlkNNVnOBm61DXYlS0+SPEc7j1NqQcyI7SGWgRCyynKymZFVtorHfiTSQk4z+TKr5TYVkvs11BNWCV2emPWhs8lseii692jlZxm2KMhjpGD4fySMqyo3JV9fUPw7Ja8KjfHAGda5r/MVKaKU9cr89nO6eWP7ut6I7M1Hnh83p+gFpo/UswZOfj7oMP1NzwQiy6xoK+3qF+jFs8QAgf7XZlcNzDRohp+9aGQwdbdt8r9z7tgUNPX4E48Yu0ZKlv4RM9srPOdOdhWzSlIvzB3/lgZwpGq1TsRmgShVFu1dXwyAW25Bh0iyOUWd/TZi6aTUjj+UXIQTNxJmqUHG+WG9aiScDkSS3hPGHDCylrDBoIEclwA805oPpBq8qe2ilI+jrMw/Ax6GRpg+f/MHz7+DqobFii00McvnfuyTcWxPR/reLkGX6hR8/8iul/07QR3tqQ7DwZ6wniWnYfO5rFMkZc/+/K5CVVeUBwqfYgu5R8zstHZ+I4d4ggEZUeh7lt2SPeOuYp6Ea3lDrSGqArTVMsTgBogeajeUGqGR4BhmvGHc5BcfklAV0wp3A5nqTNNBnTCFjIdvNVG+RW4vk+r3o/AAe+bNuc0I4gB6Mql4ojF75BIiUkQHjwHDG1ZgvOKgDdFkld0vfJSSg1PYXrkKMwab18Jt1er3dr2edxd1cU63PJ5VhULPjnQUOFcx22n+nmwl5pQ8Hp9stI0CufnfR69mKG7pBdVACtmAqzJIN6nOAp6dbtc298BiAbPyRo6p0OEzqqpMPugKaqsliU4JjtDfW+jHODgmNns3GNmk6zsMHPKiObKTeSxaaeXYTrEsNGnDPk2xSQYYn+wmeCBSfCxKsVXZeNWgRy12tJlkmge1gWcxnGxwponvV7He3yxxJlSFgnqaW0/lv/yKddxAX5jLGfH0+ukoTnd0Ga6qlPzb9n9IjNvDLgZXFfBJTsE77TYr6pa+ssI+ePRZrznT0voc0cay5SVdR7NQxxrc9q7tG6Vi5lZr8tKnJm0E4VRcvXkEjSV3dmf+fqAaMTd5Ozyty6RvRh2ayi61hindRyqozlT71OJnUm6gPAhUwoGd9XVkQTh/m6PsV07I2I3BGw8kKCOlYAyJdnN8JUi1fnJsN/wBLXsoPgRNTfwamGCX6KWhSfKZwbqVOZKpnrs9AfJeKYowEAVk85gjNSzgZuNGEfYz/bBHicxlVDru957DkMC9SZJFA8LOlFbpdbLszUD+6ppucGIQPQw2zL8si2X9muBzHyVoLvFAGVoCzd9g5R55BI2+90hYLVgk85mkM3B5v4rXJkC6cTYb+/AtsdN30LRz9Z/862rkN7Lx0PPrE8J2/WvCM+ojVZyiU+Gly1rrF3Kf+gNs5SC86dzolO4glKuznpnOfYabQ9QKnQULVQXs8Srfn5DpPdutH7j1tQqFSkxJwmrea6juytoOQ7QcoybSzPnULq8ndZ8tTVyi+67kNzKzVTt2PqME4MaNBxqxWwXR1LjT3S2D2TiYP2UoI58o6j6Lr5c0OMxExm82keS6p7hrlcoHCULTx1ArDhe/uN3gw/sdyOJmzkBOWqAylLJMlAjx63enq2+lE+D/sGFmW5du9Fx/dD8etj6ez2nP6fKrrWRUkHjcA/cYmCKKpA/QfMAiRL+hQtXKZiZbsaNJgzWkW8I0pg99qY7dYM10rw19KAhA/svI/hwF/l+9ptf/zhlGWZJ23fD/sD7CoB1MwSK/fZXohXGhQrIjIudfoBZqr/G9zOfOEaefXlaeZsNQsRwWeTuYqG9eZuBi+NCKx3I7ksNLdqCFFSebnMotTjb1/QqraxzVZM3q1GtMeK6cxAVA3A1q0cLc8gJVivkSxiCohsMzygW1hKsNryyzo0hmuqL3FZRV593s1qFLrqdKXUW6iDK5Y7sG4pKkgw9QIGwUUgptzAzID/weoaOWzBIFHLe7c0l5p8keE1Ozrjpr4CGNvquL1LgndnmEqADnfULlYMWCaIpcj/Xis7Vd78Z9dEf/5BtzWXVaNGXwacb1F1YzPrZPU6CkZIGSoCTdetBQ878BXrecY4hW1R97HxwTECVPtjt2cT9s3ODVSpB4pUpIMev+rOHk+VmuJnyCqlTfEhNZqyWPIkj0ZEYWf1lnXjWBLBy3Lg77NTXxpCtqr40KEf5j/6iwHdG+kJAgR2FFSeuIHAhHXubpGr6U2HdjOhPY1COSTdhQBTC1eSD3Syjgi5WlJQzRTNyHbtDc/u4vZfatWYf5We8GFFm1AInsog7Ma+03L+VhoISfjetmSkycvo0ZhzVBnjj/7hBrBGQQpI/dJKONwIOm4UOlbrzuBESXcqHZGLIGL/Yzil8R9oAGyNK3k98x+YzEHFYjzC85mu/vTN6/qxH0CdpIDNJNab4R7MXMfEBPJKJVS40IYQCgh2nRPpZ/IMc8O7rt9wSKOQE5TwVOr6sKTey5sceFtKZ6Nxt9myXRrs68aNXYqPHILqUmwhHCh00y0g2EzL3X6eF5AupX6c/bIPPaZtZ0Ij/0sL/Ikk7aeXDOBBeD6yVILzQ3d5WtGqoF0gIIZpjTqQ88EIiwTuGs0Lw43kEv3LC7mLvhOXRfZjUcZpEQZz3jjjDItBS9iU5foqGne9dg1PXg4COyjZbpPca53NwMbYttqm13gKr0riBiq5Ff8Hac1OsA/PQYXh7Njwmk6AtZC1ahWKO/APXgVhYGGiO5AFlraGvu2fQfvXH309mKfPNkicCq/tm4m+Np+OftKxjRMwe2iy486dWDEXT5xM9UzD1cTq72XDwaQkMcAQ+n+P3g4EDY93S9J3JT864ds2r8H4A7dEE/eYVM1rgc0gQCB38CESm2OdfvHCphKEN8WfCq9ZPOxuwHj3/3SdT6AFfzdvCtX0ONeSJaTGO7kDVz1y4W68Q3WmRiofw3p8tFtlj8vXi9/pNE8s9YBd6mquEMt+FpjUr/rvBTSUqoyAfxguzCJ8+5RecXYvcLNKLGUk5vOhJ2l/JJnmTPbGatlWuM9/Z2MalN6kYh7bBv3beE9MtlB3KXQCs/w2i2DKHcMqW3pU7hQ8oV0e8Vfy/ORMj8o13uGdRQzNMSD+7xVTWZPq5jC6jYtnZc74KfnuzlHQ/gmMUUYlPrJO997B1y3bIgsMotmkJijBUAzQb0MveWLaHtIqCOxtSYat8WDxxmnvaSiHdbHQ29aBLTSxxwEoxh7FoslkU/eqFiPCKfwLwq45/t0Tss3jZyZWpnfPcoahdHIkOYaFuhXUVcJQFka7I/TP5wWs/gc2ZwNjPYehL30THLTM5/bDBTOSBHXEx+0/9aAvT6JVTjd5q+atljXYJNvOEv2z2o4V/HLjYwlEN+UnUOaTd1JDwi0UebizbTzCIszoaRf/eOdwOojyAP4+XrQct7OA+AI9MMnXWtIdyZYPlAOYegajogWPBkCNZzZaQA8grloOBCuDsHMNkBu0GYtFfQ27le/vEJgx5wxlZ9tAPrXHN4d+Y69IlgHiGD1NxCxfD9iiLMPR2TPxFpTnRhJAJ9E9kFjjrGBFcWKP8RWilYVf00SeYPON2k1HB8CXjDY9wTniT15iHqC3kzogL1BhhYiODopWzuidoIhWkOwc5Sf37VTIbczZqeSWRAPxZAYlY1V/OAiMitdI+A5YixzvoE4wP8XxbAhLnaiIWkZOuBjvzV23mymRI3amEoRyaEl4iISm0BxbpmR/Wks3HLSOKv1LuQTcFC2PI9rrRTlR/XLpiOd1G4gfO7lgRrPJQHQyxD/XR1TW87GwNpSmsCiD6b2w7aaD64ePaTNN4dmh8rMQWz5MJZa9MK+bU1Wgp1Jbozb+l/pXD9z7JSPrkD6kthN51Q1/ibNHfsdsUT+LBbfG2jp3dC5Dc3xOyEQ+uMbO9C7Z40bwLUQk6k+3gzmJyCMWQdy7BdyC2lVYay3T4EpAF1DqV+fr3ClB7iH3DcA+D1W724Dt/3UKGnteFoizPJK6SjAGajuIs1jRVuqlOj9jbPcggD5TqFKW8i0hW+G18SUTYibn2yoqzmSZdHOlfqxqc7fhg2JoxCZy4XT1uNMve3dcnTxFD3ZbS7p+1v03RGy3ayPEUnOsY82XtQ2CpLCULuZ95BHSi+aCZHylbsLtCSNQedfLW8EwfYPTgP+4YVSXRdENN5euG9vqgRBAKspeBTR0/gVj+5PKk4gTi86gUmnGivY7RvAsk3JYFbbmrMn7ALqEBTmAD8/SmxImut1LkS6fi9Up26QvwqRr2K1/97oVPutn0htYP4P/CgL9qhEa49m+VR2+sOj7zsV+Pf0wrZZN3TdufLEH+lVqtQ4PadprW362d3MslPlFMRlBWCyL0YkTbcWzb7cw6kI2R84a+j3d+23Bau1diHLmg6BmHe37RGSE6Ea/emXqZtKFMxbK5VKjousQks7v03EdOEy02WZWnKGbL2RqEdOYt72o+/dJoHrJig70uBA59E8X+czt/JvfTv1RxzR5/vRx9meniFXoqe/0FN2MPEPlOLhry5hqawTTDa4gS5FSwuOeTSCGQiJjHlWqDxe1SjYKCiD4GHopstbKIwiuMVswIRq+fEDh/q4jx1iQydpeM0Kt6NHdj3uTEY1AAsHXIpbGevEh4vBQXbe+vyzc1zQ9+DpZB4zvZ71s6iZVwXSydJ+SrwwYPYCrV2qhfmzPQgicu7QbCR2uyhw1IBEdbj/LVTrrTdOrwU2FkaE9/82OWcFjmfaXwo+YMIo7YncpuPGWERXbDeGEusztxbZK+dkZ4lUGKCu3Ea93ZWWg9KF/LTNVC1voWxuTcl42Tg7b8MjcWPmjs3HjXpubfWtMYSD9HBu3t8oxHOIQpmRBYJTTqWVToKHTAiD+TtbCpHILccSfEGg8O/DXq2uT/NXs97B5Z7KCNEbE/HS/aeQDaEqvRceiWRwGcgORwUl6S9gdb6OeZA1PxiSwJO1y9dUoJV+F9wupLbuT4RYIa+PELb0071aSVzhdR21kxipwJTRfxENse38i1sjb6qG6+/KvaXJR3UPm175BY3ldhSVFcvrJjdKTtZYSQavT1oMCKGR9XbnPQi0BCp+9wgDKdUy6FQwqvGYoM07R4TUtMgY1v7iKAIEyOWkiXD6Hf1EGNk0j5VbPcWjanZQ+Qnsx5ya2rQ5z8kR+RkH3Npj2AulPrUJP2gChGC2xCo1OxvkkRC/q8fFymUR+cWDR7xB7a8HPSbB60Q0GbQTzu6JreGUPsAKv4LO192W72IHESzlzqUyp9fUeJxGv5VNYCpXMszDLPhy6Sy0Xbx2Vl1PUjzWxXtUIXs54T51WEXY+gJDCUFefMXDxTpxJNEhR+4zwOLYfr0VVZz2/Xh251EHKavWhECKSgm65e//tSUgjtqloTN225c0emHUHfwkkso2H8t/wg9JflBrsdqDL2DlyFFqRERtVJCNlw1Dz0M/vgYSzyB9rmAWlystKsbPKvNHZW9VgCKq3Y9uIDXP+NXKlASHhjZIzu6EH6Oi+zp6JlfxoTb92IACEV/OWUAOrjPNsaeW6uClMvtFSOc1txS1D00746vqopS18Zt1WrC/VfEERZWKA+cBG5b4q3MsSBQzI6WloQD3qfZBUNAvNHwtZQyPd+z5FX0N6iDGJYgFxqTYYALix3TDufSv7ctGtar4YtRGONX8J4KXMapAAnOr9YKHisPLqlojfQbzERIzF6SktezcT5wP4CFgO6DyIiHT6wnQGlENObpCcwmcFp/C+5Nl22fBMZ+EhEnMAymu0zxuTaZaIl0sadyozhwgaDuPRuaiYYmDiNgakW0m4lybIlJIBv/QGMnlD6C7bAYOEfsAaceo2mPPaCcLsTLH7cacHU/UCwsmSdwDqlbSKNOb7NFaF/VsXWn05BH+qWj5tPSt/ar9csgjENVRe93HOnHLvaisd0uUPY7l5SrhByUER65cQK/XNt5FtEycyTuGxW8sC18A0keCgdW9FbeE/PThk7LBdpoa8BY8HZpMUwvsJqQYjSBOtDbJDBMU5mULPEKQHG3U8oMKM/2Pw0jMacUbjaTpuxiX/Wq0KosbOnGrkY/KJ53fpugJwZN5VSvCfuxjnzkhMy3gaiiHZYYzgBOzCdpksv/FVWko9m3aQk2HAoOfniM9ALf1Wa6iDz8v2SjfiqEOn4CEFZ/qQuUPz7qXFfepkbmSMRR2Vzq4NGFSUMz4uXkCHw5Httb7Pn9FlAEFjrambOTsLV294YRzlmLXNYuK+uFnysd120eeGiNbqm12b+7ed1ehJofFwkdExvcECX8PxcCtezFQvB4glqT5upazNSPz0RMBPl3MSB5rRZ0YpkusU6Uj7tXKotkTDCqv6BjB8pLNAejuJtSsJiR1rSD23+y6/Odx4rr2V3gIJxz2HCWV135nPLhMESZgjdnDzMHXqU3CARVzHi9A8SwGep7f5xWIUCYNWDuNWrbIZjRTCggy2odzhYB6QUbwjKRo01hI5a/2QJrjeXM0skcyg26673K2OWey4NyBfKcMCx9T+s9q/LUonkbsEUvxzReviQ43UhO3WZH+pnitlkueJMoBXlxnAXwybAVhKjX6Z3lopgAr6cf69n2nM4wH35aiOWLTtUWvtZhXbjsQXK8/06r8gnvS37eyOyx3DNNp7W1xJUmr+UtqxlumVXRqtF0RaM8GnLaeRqJC7J3ztG9ToFwXGE118nmWWsCBAXdEFJimQJrcdEGVjWvhi352b2Hozs7zUzxYFta/aFtJE9aWX19zDJX+vhaU0otIOOjPCARMb+iRST2TL3Jvq4wjafZv5JUQpTYdn/JGpaN2eAWVTMAwHbloOn2ty8GxDKN2Q25ThJy+5XS00bWIhBb7c6YSFeKvCHZ4DV0Xtt7ZZHFzBk/VdaxRdD91zwF5Nj2lMZOA04E+PqceTQuiFl8tZtLoNQ0lPGcYsDNFtA7yY7D4oZuUViVlF2A5c1RHjqFsEg3uMg50hloM+PF4nAB2P1GKd3W82WGZBlkmByI3NaHc07YF2ct8SGZ46tbgTHnq+hLLdfHNfuaxrHXwDoqoCLdsJV0JNccbKKkXE16ibJvu1sK3dg5k4SDkgiWL2dfE3wpqB0ZGQ5odeJWPqNDoDvnRWnU9BaPkY5Luq7ipKRKJpe/6cyAJnzHdDg6YEOIXnd7kSxPTxIsgMaR5jKANxNAJxJUxAPyjLVx2nPPzCDR8q/ElOvBo72o/yh+a8RPlJpbcrDpvxqmFOVeSLaaQa5OygnRutpST5jYoEaKt73qCthRx19vxLpJLopM2YkVQdirA9hXqnyq0ZEnSjUrTGUmCBr3wA+Rt25ieLYSNv/CgvJIccDIlyPdZOA4B62rBUPep3KI/N9kATzqNXvMp9iaM0oordwWqJOpf9HXRkXTuH8WIJzC8RfUjNrBN9yA9Y1wWOZdD6FKJla2JjL5qMQGaf4UFY0UHKNGQNU0vFPwYQuBWNoMg+4CQL6fZ2CAqEivezwm+xPso5qcarvehXDIk3+P/8Murl62gljtfgUfakUZTKimioZl7QzvemxO5BkCp2GIn+9gC9bBgfAsA1ggeL+/0y571IwmBgcFf1OdLjSc8aY7At+JYVdunudNsGL4T8c4DDFKgWMO6MmVhZSGigLoYLX2aLUz60JJ5lohtTZbdQfwWUBlvQR8V7ts/trNyeFCU86gwmUaN9sc/lybcKRTPcTnHR1BwgLVDcK0s78NmofNR7ro/wO9o60nI9Zh7DL3HAREgkmm447c/BrcZREEoNQtv2MbCA7reL3mcvoyfo0VKBIbqtekvsmFVfEfij16IyyBV3nJZ2FwDfUGFvo5y55CTPtrfvHMFOZVz85DFA/MRrYLntfxQEDFPierN9Wo7AJizayrBLn867ej1fjuZUSmndWyF3SWUyQJZgFKDxASppcsa9rQ9FhChNC0pHQ8WlDTf1PDVRdfIFsXTU/GNA06ve0MGvlS5B53KWOpEkRcMR9t7AAbON6G8tobOP8fxam2+TEpS/lR9RTCzPH3nCP3Y1qSSc1vHXsINSPNPmpI5z/xnqtimc0e1nfKWfJGgmxgFISIjjYhw6oD5KYJ6nTkH6cKmXywmt1u8iQoJiQKu+nRXCJLqQAzK5mAexA0xlMFu/YTAw1JTL7hGCOyR2iPKLNQpLd6952E64z14LP8BUgeAxRa80Qf4AEuK8txSkO4cHcj0ZfeqIS/IeNGf/Atk5xl8Bg9JnBRcte3Z/EW57ULMQ5xeUb6mNyINazcu1XcS79+2CFoJ1oNGatFDZdIrIo+zETSCEj9dERCmBolkpmn6zy41t5H8Uu0mIvfbwsuistQSv/4RXNnQ23RxHho3L1o0w/DtPYLc1Zp5OKyu+UpzSxPektaGZbi6EKz5eJ+I8M2GTnaHsSsfzYVo//LNZ+Mr0Zx1HVUGCnP7yf8Jyr9USVMfzT1BwH3a2dDnAXkpQ7XeCWGP9nNps5oeUyG33EpAnKAgmmNfjloRGGPRqBPN57j4DR18Df4iteI+KT0rm64x7LggteKF/phgf0JAzRz1aeOnqOR30M80+pWjUdGraykZDJG4+38j2KC99Ir21Vv3OUzTeP27jGBmhc6QHly2D4w5PzevyZOr4j1D8Vu6oCaOcDTKNJdpdBbJ/+3qM/sDJC6jtv/2oKjqbPC1JKXD+Ua/N4Xw+k5iUWf+OOyRSclYzwbkZJG2kdWS5/Oczt9z82uL8qDpVsJ2VM+DdeEV0RdVhew76vm2EhWZ6nHr86vZgBCsAMiGLEgES/bA/ZcWlwvzWiBSEPhhepqwCJjdGEAdcnOFZIc4bmmNMnqdOBxosAC6gPx5CDRy/dND5k+M3nAU06jCKREHfyGeSg/027M6vIZVjBVCqkV09gcOvmxZsKS+NA0+MD59jjspmmkCT+TOgan9X8dzrpbINj8Ir/iPkaKPfHrbSaeeGtofSLnw6aQO88O5KHjkJl9GRuy3s6iSbG+GbOUJbSrIn2X8VunMEZf8cy7T0ptem76kOUyv50FfBkGsdmFzwYjk/9QAKeDbnh24GBDisxGpLk3AVruV4KS4vMm0lmNicifGVuyYha6ikeSg95d3sqtIVAy80FMHAAhK2VnHqE7t2wOo8Tm7K09ZliUflgoU9YzZqM1sgRQXU6T8DmgaVGV4Qibl2pzE4uXx+MXIjRydz/Wbi3LF6ZCH4R7OaBzOeAoCdGV/+G0Gcy07ARYxuHNxrlZdeERWWOHFJE+NWy8vyVoJE2lbmdErQh/jLG5sduhXT1m/iHD92hunOT3xbYtiq62vlsIjjK8iQWAUn0JcgpbSWkxTVDMbiF05Hxw/ng7KR6PFQm+L/WVKUs4/kNR9LAamVgJ/tINJkk5Eh3UcRw3eKBM3dwjXVPCFtzcFt4jE0rq7r2ZuQtowVt8nipglgHKtcG/y/IHeo3F4Hc8aBxa5AuHrjuFxPBrzPQuZyNKN2xbMSlCE8xcT2Ca4X6xjbnGDLaSD1rzynKjaJlLiPbaHVQO8ADNzhTeaoPerpKwBFRRs9ccWtQ52vgbzeWovorAJbcg88cq2uncPp4MkqZIsC45tWLR6Ip9YvvW+4SYT2B4/WYMm2vqy/qiwJFS2ri6Oi/HeUZTFA7g13EgdLeH6i2cwxT/WI32Y+MshITjwSKcI9RhUDUrlJzdmR+o+1FP4vW6G/RnitZfmQfwoR4y7chzs+G9lB5lI6YFvS20h145Is0npWUAlhlSpdKPaaRdyeYnmF4UZn2c97iBo7MuEJc3XCBgJo3MxJzLhp2neyOHHN0rJIiS1pQpz8wWkUojNA2+XKG1ES4e7zRHV08nC7RKaKo/uKlPYcfAJS0f3A2oaVLCgOiwvW6ZhvoUjmK6kw+PjFP9gmCLQ9P5HL3tZ8Vq53CqpSst1oE0KUAb54nUhigYFIXqOHo6nYNjjLoFWrQoLlZWciHy4CR/bYRAcqYfaqceL/XzEr7aOFve4Bf9Iwy42/5cL7YYYjDp7NiOhfahw/QM09+FnqxgdWhBQjbo9PdJDMbqCnGc0FOypQhQIzwqj1XQP1rx2TmbgfDW0NGAe5/B26RBG7HA/GbvIwd2zpF3flMgG4495yAjmH8cEmZLhVUH54tO7Fm3JgrWZ1HXZw34XgljtGGn612j8BQTZHX4DAbdLzJkOvu8HiIfHlEOx8SnzNiCO0BnmiGDQXmmf4ykVbiK5uUpJP2I1nddxWLJY3qRDiVZUbaSYQ7Ps4yfg5mJM7KyAwxyzSj4g/+mq9opWp33tXiN6deK1L/aMSB8uXIHZHND/dHwL7RwyLpGN7wAvzJMzj3p3r2KAHNVBjzInvNF7Vo9bOmOaAdjpDRPRQQXRCeUPJgumAj4JmE3E09vzWHhlHtnnfxNKeWdyReOHyqOBdTxoIDJdFpp+aTeyvcwGYaUUkOaTXiVdYGGqmTubOMPlsa8JCLSZLMm2/E2PxO/mOmx/LhTEvPRBEvoQb4paUAne50aBd4IYE+pUEFKf+DNVcXOcKLvDSXsMsm4LbAcLMPjfBrwPQ/N6+TlPNJWsyUAJeRFURVcOMIz6x8QA77AIcDRR0G9tfa4fhii322ICiuTWcS0ee8QsJqYGh+u/qV7KPf00bT6PdOOTnsZWC0qqbZgm94NarovZ9ZLaYRrmCBVa8NDzoRR0r4ttc0VcinRsXEPN2Cp2O9mrNZsGmsrP+3+ybTsR7Y32n0seDMY8lxbzBduQdM3ktT6LyPye1g/7VJNhk/t97RkZZ99DhyHyPZXBuySTSQVz5p9nacV7/J5xAw0GLvKPCoaRLmM1Hvraq7VDd/coXG6AyaPo/MFDhIkmfmtkumJn6nrI6TfZg5yBeGuOgVmrzAgQE0YMCbnL4ekJdWYP/v3ynQxTaiaLecCTqRmNM1ZM8X7j+EiRleCkIt98epayGmo7+ainKnv0D4AK7bAjqndFDOrC6BnrVWMKstJkdec8jIBU6Nvs8CSRFvBeeGxoJq1qoijZox/Bnjefq9JPbSGwCAcf5mPnjvQD5eziVhoUth8bhAvArCYe9CoXelmHzfcswmtstGtVVR7emx6ASwHVZQJ4gNHBloUyvOsScocULeuHhP88605WRDc8EoVwzRUW2/U5tbjJjQdrthH6lh2AYaTrVaBMDLuppfu3VqjMQqJWPGpJfP+TjWfoCxbYbl5sTi3v+it/p0FdT3v50yY7iwGaZ1q8bxWQvqeY+XhCxVk/sSQPgBIUx4eZ31VANJ1PeEJx1TYxaSl/cKmIboQ9TyaZ6R/bNDas+2g/xA59t0dHthgjFOsWvyMKfvkPa46Dj4pJntK5Mhk1+Cutt9wJfMGPOCO/g6el5hJ6Il0QRT8m41O8DIrYVv0qUsNgYA6NmDbMKQpUrMasTRKr6pH+rupSRgiVr7eSlHSoXAeHXTpqNL/d4ttHOvl7FvG27HT5/5bPPZAGMkZdTt2gabpT5rLUwdjRV8eewtcIhRfiZb73OxDhQeJGVgH/AcAV+VzDURnCYXkaitNQ83A9JM8QLdNsHzKbojiWElNRLGGNMaHThAs5HjXeQ+iru9vloOs19wxqcPmslv++AYl2aSbCloJlUlS4zzQ85Gw4noFgBRPlQQ/I5TLk/dr4LgkKCohWATRD/2SpGEwjB2Ob66rb3RFJDqzUM1mwZWD4NP4Vjfbiq59TXq+O6ZqJuL/SXaR7uwP0YawokwNDHSl3QpyeZWlNo9YrQhCpzjgsuhg/Ue3R4sCZIg4jgETZtl9gJFpvEOJ1qvkQMjGDN0zPxf7F+7o/Uyo+sX+hY+Go55dO+7RJbV8Um6iGOHFdUX3VpNMIX+E66jPQSF/VmDcnyT7dQCfCWl8Wc9l4mnI9rnwwklpK8xumJ4Wej8JN1aSzNR8s/7WL4yiIyjasdKHPbxi4suJHauSiY3PI8yq33w0siEKA9yO79A3SgXTVEDgs0ILp7lMyHO74t3m3+/mVtm/mx837EgfqufYzdJFkx1uWndFmNrszLB7j/VSyB1OlFYlqY+xKQuCJWQtXGvocU6uPo2CJuOyB8wcq09XP4T9Q+nvBB9IJIcINkFzwCRn6wFxqdJ19uSRbRLQ1DDlGL5h4xQ/kIALrU0AfZdc/HHyZ5KJo/RKxYdRWRddfVMmi/VcOcAtGklYhZqfsGIyPoQYx83LXJMGTiWEsZTi13p0ZB02wnuLev2IDvklxa63Rh4mTMI+aBVP5K0xw+gNqVVqYY+7MvsspoBaESrYNwlKwQSIjT0gQ4CrO9R5j98nxq5vnyeYqnn64lONZB5Vx0dpPTDtopTpNrMhzl9pkeDeQnItsULmXkyPm50zqC2NAqt6dyubSs3oWVWLID+/VhIHbsQtlc4yNcJc+AZOKqj6lrWrKienA+zAKHb6u+34sN2o0rFHwr1ErYOOqRR0iMa9kJBm1FKfCedJxPfrnSKJtZukErNe+iJHdFFMSW2wWR63AIHqkIazvMd5EGS3aZnr64twmEi+vRZOyHVkZPMT6vxRV6bo5p4o7t0wbMs70Kw6rO7FEO07w6hlKbdMdnvGkYYThxfcDDXjINMqzFvVhzezhZaCRPT6znY+tGnR/5AARSe3aB17V7J31tXCSObGXHWigns1djuO/QbBKCTb4ft7MvMzaAEANdRaIi+D3PlkCihc8KPv5tdG9GcP59gkhfmKN8yWbvBH3HPtBpxGqFzRJpBENTImQosZoOxQ7AbaIjbSPWs3EnXNvaD5ZLr3swtQc1V/n8laiUG8i+5i503mfThXF8/086O8b2N3+eFV1chLq6s3A9qT65p7AmrkhHUlh4BWJpwp2J/NFMznV3x6jXtknYGXytBMyWMwVCikrYQhqj7l6liy2p0VI6ehqy7DxpCFNFUZk4OrF5kuGb4ikiAWmftGuRJwxYSGX+bVE4QIvuDd7/N3bMA07SD9xmrAwbUfI5w1Mw5YArk1hPEeAkKj5QG6va1loC6lWtAOp/t1+B51PwpYB11RxkVjWnrBoyxkTuyLVvkTHMo5gz424y7JSu8MiGCgTIA0nxXpPFH6fONODjRfZ71B5bubFiz+P6ljmGMHBncSXz/za9McwpgwvrIWogmWCs9PGzeaOjgDGVqVkEDcS7mZO53e3tyH7at3bdRMGOcIIRUFi6UrsQ320q7u/Wmo1QhXp17oyU+nVqmET0GRmZT6fHPGXpHKkZ1yr13WybczN1PMwigZ9fNguHHZon1JmbRcavufDKsLKW+HWA4pzzWSBMNxwbC4KLN69J5nNsNl3uZ0spAe0ed7yVloXR6zqUZ9ffv1dhheP2IwMoK+ozUm5jCobgjHvnCWAh7kWh+JX7TlYnzxtGPXKH9CvTm7gfFwIINI1TcGBIAagoxxcA4rFoi6yLgbS0AZRwgqT6FscGVSL/SzD8AVi5uFna9nLdARlYwH34teZWLvpWnX+QdZESSlsgyN7y2ZQ11DsNqqFNG1WNz+lBBrQOdtxZaEaYlCFNyaVmXr/+umolz5JA31GMdRvjrWfZws/TeDbrlu4xGQcjrUPaIHlCyJwPvPrKXTtO6SnwCTEVTuBxv9EsfgNVWi1xfjHmxYvg40MJJh5/ZwAcp7z2J3m1pUCbOXIjSbxDuWIYwN+lpQIX1YIgJImCTvyJlz9vPM1bZyJ9S80+3Bw17cmBJOtSdv2LKp+ToDliOTz3nuPeBhJ5e/lABOADFPfXJuO9XeYFrneSLISpOVtNgISRmQj5uEDMn5f0SvMnacZM+uYntjZ18fFbmBU4e4qCV+Sy0flV+R/DD6uzeXjQt5G8OZX6yiDwE+m84yKuHAstmib2+b0+Fza+8VqOobDQ4yh1SYjGrtQw4qgFnF3Daw2qhY2o2HjTcO/s4z4r7bOybqVQGMl+mtDfosLvGZo4ASIHinkwN6RBHDPUtpALS8XiYXLp+i5JtbpGYZta/0vYhPFZ+jaUtgtJBE9CHCilpCJ7qrlsZYd1fULBS/IubMaMpOKKHsONF0Xw4SblcG03JAo6B1qKWb3JwsuRu9SnL2BSlGsdHIMAy20G4fBlZTkRMohsxtjjIgrKhKiqfxo2nB8zusEM/Y9Pzan6xUur+uR27UPZj+8hWfVIdNwhZQSJoPAWvgvKPwKLi/gAcOZLBvPm8KPudEIpaqbzmjOE/w7PeN4KSDFWCJTmqA9mgb+eEw/K9VeNoDemTbfTdgaU2iox+0kqwQ/OgG8RcvX8Vd2u4wQVQDnTeoFMPbJEMAinSHm3ofuZTWAUDVpKjSvTwF2FtsHZbjlGqlgiZZL9JMd3120a1Dmlfm8rz+KKaKDd8F975wo1bZRhVHnGsGbFyEoC80bsinKWgocTIpO4ojum5RA1F2YPw28KOqbnf3f3MjLwagqmSw7rrnbHdwRIxSbWKwonhBb8sXwAzkLEDxZ2pqMF9eGrKK1Kmeyy+kiIxDemw9LFNIgr4HvtYf/RSnGuKTk/zaI9NcxMRrMWADh3GoZw+yC/VLl3/LpWUjFedqIEUP6ewV/b1CIQuFfdSNrFx70bwk2Rprdk3sCNkXpvaFNQ1XwqvVE5XoR/Wh4Q2BdOBG8fPAWRVE9CdLLuR7kswLFpFvYRR9NO+hEHJHkfVqUQNC97JKjfkZObekz4RUo151RwYO5s9PuFIRsB0LiOttmIa2WxgI2yfoYOXKzzSkZkgaqTLrRdk9Y9fLfJWyy9Qhn6e4unYu8JO9e597YFEyGW8DqLa3oINgu+v/21aKTZgO+2EnHs8Ap9sUyUHl/4XwClYVAKxpcTKVxNwYbfujewiOEegCCYXJMrlVXiSXK9M5kxbNZfTW1CbFvcBdvdV/dRpDca/CTrhsnDwCZQAOeVtD5LlIjmrLgxhRsULdFTB9ERVBw7UY5fMvlD19NXuBOcHuj8qk5Z0em4cn8IYoCPrgoXZT7a+iRCUs+kiIR/QKsgmfyzueIBqVyrLMiX2VAALKnFHTOctZfLiPChYRwcuYU95PzV2TRIIUlRN5PhKgvA5LPYQ8mjdwWF7DiBLnSaHbpeS8GTOjFnloxI+mNL9hYGn1M8xsnva+oFyq8aOZmlRjGgyyqUGATQVkDMZlHO5d4hX7WyDWRW06XAzzDur2xWTL/61Gz0JTu3qE/mR0scih9t9aXQ2zYRb69gJ0vRzHHBeKjmnRIBih1R0K5/Rtq+ITdQU5h7AoX3EUI3VuvSrbRe6ghSpxmUDChq9Gp9TJAkZAdv87FyO+/cEnwDgFmpVG1GH7HqX01TS/MlN6Q/LUQ2LK+gV53L3swKHawIw29Wv99XYZ+jBmQ4qmLx+idpHiaRV0wcEQ/cM1gBl0E3VuA77Q6ADFkrrfGold0dlLEp2KeblNFSfNLT2Ejb1dN3ZN4n2mFE6ItMK0YO5BI1NxDuNPtnP9E1fprFuVhZPrC+VxbRBfERv0HJZsMuHJCibOb4I0hwU17xDtemehagrrXHGym89ZDGA0eZWj9YtvmpCYKwU2H8zE9IaSVzFDqlZyTcdH5jWMAWemGpVtVjMiOSjvXbS5/kPmhwyFiNcRbefyeXWQjqOzbRjOYXXEk+lk9q21Mtl0r+CmDycOXSOI4Ec7u5KEgG3IHXWbyZ27h8DZn7E2jwHgYvcXQLXVLAHpMDD152q89z5oaThdP8PR9YoR58G4mtFmkIy2gd99hSzG6PMD6tRzvdcTnaPi8R1A1tr8D1LD5h9eMEpAbZGZIxrkmIeQGyhywB+iRpx0GF961QJxZnC9Vj0tL/KsVLZYt1dDX46qtIK18cydt3kmXtqiiTFDEaxxBGAvva/qLXpdzNm4O+ArsyECvW11ney64D+FakIeICin57Tycpku++W6nw3yNwwGJ+bDr7u8p6KsqnzHncVts49dXh4lAf1BhS5AudLi/4mbKu6oTJePIZwF2IvnfNDgLc+6cOQzq+ClZ/2P8gxKD5LOaJye+SzuD9XoNT61Q0Gc05O0Ojh8oc8+1l4XaKkIJlKbL/ehI8eLprzQqKozeESJFY1CAZninhxDMMu1c3SkjT9+EFGutBtLczFpZM1bQZJy1KG+L0397gup60uEsGvDC5nVXtPu8XHSlW70qa3ipLZOnZh95fptkW6L91nd+dmVE58MhYIjm8vLB4iUoLmMrofkI1Uwd8LzQnm2/j5OTC/GVLa6wqDfDAgCxzN3t5E/dha6D5hcMJ2lmhsCR4seVcegOmyrJGp7yw/tT5mZXRmDE7PL8OIFDIVaYRwCXSu27gs3xT9ITvsW6J1e07QNTLiYo94TER3mqKPd56/9P+o8wlask60RED7GwEn2qoiOg8Aws8bQlHFQGPBqWJkgiizvgdi0TLNaWkyQuBDl4PpcrWscdAN538ihUvjTgrySY9uvXUuCX1T6ryJM6HMhB5B4DJU6289gT6zjgFSZmQoXYEQFODp1TLMjolYqJI/Eiw6irmb+ZTjGcFYHl+E9XZNIXxHuZyeK9KXdFAbAOprYV5YpdoxSLLv1bxOtqi/VFRw+R29cr0MRYtI0EuIARypsY/0k3MwUBRtGu3BeqUSvHCgiv0PdiZb2UG0ijSMPwDv/gBl5v07YMTIPgJVaqBPO+uM0Wnvm8BKpJbS7DtvRZUPH6x962FqZd4NO8JZX0AR8VcN5w+B9cSL2WyQeDN45bcoJE6lAZ1dKQNYG7fAp0/uKyoacHVWKCxbZAj7j9Wl2d4SrETWoQrWNi9NKMz5jVUBqsJ68+Cu9ncSRZTNUYRJ2x77Hr1h8UFUwrB4fDlEzy1qnXuoV0cB5DiOF7KfPH4vWhh27h8n+RtWFztNrbuPe4mmKhWnWO3zhTGbIrwG6sxztQ4igNfyckkay3pMM/nCDLS01DspeSJT8HZjsbIZ+opeTjky22nE8YEKC9Aw48vYAmbJyu5AJyyG1ZZLhXpNRC6BFv6AXkGmQ6ivUSLMvdo68D+WVm/H/K3uhkV1d+Vi/VbbLq31X0EgnYa7K7b7RExgCUmcdcNt/CMPzWsCVzP7XJz9fbLZxEWD3eGTkR+1YNyQYJQomL5BVWFkCuOEFVzWPtoQQlIubn1E+8q9fRcvTiHPB6s3nxME9HwFeEmUKp//3limXiuIjPvhgfBEuejpz8WQr4QO+EwnEl1zf72uoF4JHFRwq5bNwyZi3ImdcRRYIF7MeoU6QgSfF9dMTo7a8zW9z1RjV0vmni5VgVKvkc8HF0m+E7a34LtMPki52jPPgq8s3tZ7i+qFAuHQxJd8JXJPe3GqKvtVK91YXTF52S5YcNEcHAxNxkO9S/qnH2eFM7FJ+EgDsOAOGKrvJ7/SUUc3JesBYWHSgF/jdV/CUX1M0+gv2vPJyRCJBW14D/WkoSi0OSfkeMeNBTsVbS/Tq6MP4PkvttZSSd6NnjyLS6f8ijNsjpQ2jXeeVvQpD70hkgcJo4oDrS2NJFc5L26gj7WTgG8r5NH+XZOzJIBQIH6VCPF00WXguCHETGcVWZxWgrWzuVkn2J+N/aIJAzVxXtMmzgTQduMRP0+hsQSYWuvuYGjtbwudg5aKoBZljY52482nnkuzHL7bOv6uFor6E++XxHEmefX3MQOzjWZnNLPP5uRNHiimXh7U6yQIxlpk0lFq9E+6ZiywNEdK9X1QaqoMrIVp94ius4JZGeG1dMp0NRSFNPQoyIoV4hTus9gb0DERSHWCH22wHdeGHDLAkLaGer/SQXOHJS3PMwdtCEuW/ma7gH2nFQyCI5qCsh0yfM2P1hEYZ/CjdJjX1TMNlpKkQKF3pox8VtwZyxIMGXLG2I7zllG6388tSuSKF7ifZIjOR2oXrjAydA+2gLdk/pcxaDAZkWIvOnP/6b8eJFylnEM59FgPbszwkGAbVxS6engPhHJo4rCxSNTjaaVlgk6kL5NK1AAVSM1tN+ibREgd4EobXZ+LHJcndW3vfjJswDybCqzZA1tCIo5GKjOacRPdi6RH/xg5UMXb/5bP69O3AVqsmtyaImmnml9eFrqW3kLsZ5oNEnEDJLJvwareKwNRrdrD1TVvxtqnnVeFG2T22yvPNhVl18DAJ+1tLYBO5AUx6JLj8fXi/Hq6q1SDPHi7aJV1Ftz5GV+DRTBXOnSQHXu86feSCiM5XJeMkRFpW8SoWWrXxR4XbqUWq9WK1yTZqNIQ831iP+4nASh3DG+vn0DdrF7mLYPQHZ0lrW7mcC23SguSzWOoDP5272iBKO4ujAVWgBCTgm+RrRyVrPyhD6Ermah8u5GVElQWBR3kmflOhsq4Q4LlK7uKZ2tJcqkTZFWaxO+gUPUQT8qj5/bW5RqmRkfxpYj0PAVa0Y6aXbZeFB7decClKu7OemoTeKu8u0xHNayq2jD+sOvElhWNH0rx7xJkBm2N0ryO1pElUnAHZ96Doy6KIYZY8T74u5A32X8QWvWzu8LxHexqtc9324++kto9EqVv7GT3Gymt35ewNHwPM5pNnj6p71BS2OFRJl2oO7wqby5VHIgQZo5Y/HvFioV1eiLItRQbKMOzzeunyYRrdXUnKzGSQX1Ot4frZ7dxluAuclCNxYgZ3hkXPegasSk4cIrC5eCBdamkFLHT2IbEnFZ5QUl70W6/uEWyaAOHPynMUxmhiwSadqillr/LWNNlaPCGpan6HaVpTqSWwEYV8ULKeKp3dLO234OZNMvCasmT0tIsvVswEO9mU+lpl4xe7OT2ZN0xSBOdcl2X3aHcY3CQeXfT7SkZt2+69y5wBYv9ti4wUgrzsinNs+FLT3MEF7kJddgXiCLkPL4xasQl44T+iIKvzhW/LOWtulfASWLtjXNJM1rqfO1bHDKRxmabOpn37Onzrippi5K3E44vw8WDf1gR7Yh9jwxklv2CeDcoTgKZijg8TrY72miLnuLEc/gjcsliC1c9w+20+hCpzKiZlJO1e9LRjFZHxfAUUkXxzbPPfesrmXeiUKmJDJa0lbOCWTirbAn21eX6pwPNrO6wmZWi8rpDPt0ihZTEbZUO99PQOImPeFEVRtyjH+xqgl5Tp5u3EEJs4/ccm6AR1NP2Z4o6QkFDJp6mj5xa6dhwi0woxZk9CBknML21WmIHRWU2MQ56RH3+Np2wjRmTOGehNTw9ZoN5edWJOxN2uAsa3dm43E8ORvZ16MmcKjb9G8l/MMnbA/E0+5nKkcMwBa1ri+ZKgX8PVSM8g7UFhnrLdut2xgu5qgmfgBPHPSKDfzm3bme6gbK1zsz+Q2A8oOh2j8EcXYYcMPFTDZkTwuykeaeZPiwywJ+uOj6f7o2BbI+n6k/iQpv2NA7APTx/bPz8to+kitEz0RJD0KfMDOyDGiCfmuB1YU7mCkZ9zw2bZTIcNpYBtoMeFb6fv2+Yt+XlCas/lTUDSgzXciSfHVfpkIvhLMMcx9yv1lVjpgv/pJNdtqWm+BzUPXE5u/j5vF81eIilOJi6ZRFbbxqc08WEOZxLnNCGdMtkphMYipaFlgPY80v5WHCLE/91UbIv+o472CPrq3R/oWu7Iho1CWuSsduew3fc7dIKI40ljRA0+cH2Jwx9Eim45FOJYPFSncw7byzHr9g2z68zMq0RtacJg/S8syX2cCcnL4egVobQH/oNqLOATOG+G8xVMsitD+tvldBMg76lJXeHcw0uSqrP24E1omCQv6nAlGKyTIXbPm9VKdVRIOH8V0Ngmwt8fLL+X7oqXFXNqa3tUwK5ENVbAYlmNZPRks7k4DkmwyIARtxmiHDxy0rJ+ll2EPiFrPnm6EscXEzjNMETWdN3uzucXI2WWh30rLToSLhGxYu0v1wPQ8TFpCttOGLZMmDfXpgHB2jB+Vy/BMG3zZCX04yuJITW+DIzf7LPggCK5JhPQC9Gljc26KcWfbMk6Iabv26ApiHBVVOtrtWfj2Bassvrifs0NWhqQti+5G9LLTI0U2vPMSet5G2ZaEsvdjX8OgOO2K2vrACd3QZTP9Zlba+OwvbyEIfSQ/+5qgfs0rVLAXdpbHMwPYesiNLi3jYSEoCemAET9ZL+Oun72q99NudGkVlrwO5y1x/uTaQ6fZdiSemdFCwUHOhBcuRi1wZeOEyvq1WIVjjU9H2aUBPuc8iHwLNzcuSICpvgKdePBdzWXnqojNur7tJ7dImDhDzIT36SJED/l3qCrGSGc0DhXJRi7OBKfNjDeNnwGiCPpeCvTUdc0qR2PgI1nWyfyM+Mi/b8QTzXkMQ+857LCQz5LHW6q7IOB1WeIsK+tRwI9yyiidiVpPzCX1h4hfi0YxNZy9f1no7bme4zaOdqSqk3dj50qdPbr1p3opDZrvDpfdWz5/tYUyUSU4aZbiLOn0D/95GgKukhheAIGctA/TCMD0NlNDOAJum4WFMAhzP2zlpeVTSlNFr1upkWi2Hyxyev5HQwb5rFQYZGiKF6B5pZ+wSK2ctUH50Yrt6QwZanwJ7htX8UT4b/2i3nmJEw5Rmf+WDInglzFWfwWq/TBdbFsAXjz5vVjRxMPpXBXdZzApidazwR7Sw5Z0Zdg4VI9rrfLVbIo2VZ+lGP5yR3XLlxhmSeUzm+Z5UcCP4vbkiLiQBEIiCNxU/Rp//5W6nFjd1W7Yb+eQFKNyLQitXB8c3u6eYXUzI3ipgvmmHUrXjtEiWJPLUxoSZFsdzo5LgXAyXEw/VqKxg/a85NsHTa4MrsU5nj3ZqmONt/QBolk5eR8I3INwsXnP72QT+f/xmgs3dOVzFf1ok3umVcqPwHmLKX/8WljWR5GDIB0EG4HHcmJisYlcqpnmg9EvrPh8b+1fvR91Z4huaeAlxoOtujchfWbRrntJVPQjIMOZ5+buKQEylCq7dMMLmcmUuNxpna64Et7jjCZvI6xxwPdv/oVCMxFOKHX81BjMgNsPH0a1zqzwF8KjFc6/JM+l+7JnacpMhhlj3oQMKjz/5bx1m4Z20WGhyT4szAaPwnSTc8QzqkDkW937MhK6LaRx38JLbFwSFz8oxgae4Nf7I9OUi9WC+TZcc2u204Vchco5ubG1Yt5C0ihtgULefyqAXciXX5ix87ZUYJQBwvMBuHuiiD+Jkw33brn5yeg2P8ZSti3R2zEvYZG9W0apYatldzmW736tuI3A29Cunqd4iq1gpemCM7tJph2jVyHkHAkmZNV4nvJMoD10YcmVig1xgd9aXE9jfzyp6lKZ1QePhCpBAT0I408qw0+aPUb4wfP9Sa0WgpJQ8JqOAWLgGsHr1IhX59X+AmD8vpUPZnqx5Bqa2l/WJXmWePZd6uhmZfG0IcLsnSUlUiwtPMzRLkHLYMg3fd4GHTHPO0X/7kpqOCryIo1RfX70Cc/I61hmAY+tnByI/JXiPVk+LvnNWCK1dBV2yppTR0yNIU43RkNs8gbTZbBLPSk8COoCpBlZLY5Or+CeeCRy6m3q77FTMishWr8aBN0bwmJxe+KOGlNoTxdtQb/c68uwkacF1GGNv1kSFU6u59TmwMYQJw7DwHJ8U02WxBBcfdEOKyhCSPzHoUB3IuhaT3BpEr6AxvqCuFYafFwto+9iWiWS8v+bR1rcNSa9HHaZQ4OzQRtPp/VNuI4FHEVRQwZnRds/9fVy6XQ1ldbo5nkIeHWSsC5s3h+kLbxz5r4jMrn45WajFK2Kgf1oZoT2g3mzKstaXCVvgm7KEZz+uRz/ZgUFfgQvF1GvKUzGIydVxyvh6SZ0J/b6jiUGNwuMiuJD9curW3YkciwRzDEhaFul0ywGxNfRYyv6rBMRunAFeoutNk7xXLBnPrMweyzQjX5CjTvFneDG/IkxuPfrhuZMD6SgSu/CYXAuq9Ov358O9LvHpbUSqO9HqAWBKbNu/3QqrigRiEeId9rSvyMZO4g6tuLp4Dly40SASPYqjCaeiB+tINc9P8V9xMw50bWAWE5SaU6CywSvSZXojKp8aA4DdVFG+3eXLiw9QgRPfoVGnapp1S3hDsyZUC1LRSAiEky1ctobxIupioVTV7QUUbfxeykTRh8/0K0pYaWB5zBg9H7Y36ZsHc2p3HjVxxSlU2Z10MODA9dF0L1psEara4vTM5IvULXSvlf6JxT/iUcUFmShkdeHBHMJQCFsn8ifuoyCof8u2vFj5uWOovaZGFYasr6BYOofPBzpFCLBvMuXINqmrqRdakFH6ZNhwPy+DXoP07qqwXISmNmkgu59aaPXEVaBl+AFIMNco400EN3ewDMApNt9FoqggfVcBp2cUsUU+1RzwIpDfJyOpkZabU+Moj/c/2CYtrG8wWFDBh0qmqR2IVDVurmkfoT4lSExS/mQgfzXb/C0WB+6U4WY4TKYetd/MV0dLvJErLDzklGtEkeJZtlAPASfgb5fXVlf0okSQXWK3ccUUCyXsa8cm5vhU65EFjBfxH7QWfUOXUlCNdif+lTifrZrXWj4uPhZwswLtVBlTXOQgcqCeHZh8N2YFp29Hd6nyILMvSrtTkOEayuLlgkJFAZxDRl4boRHl4I4NRCm8bzw6VYoSrPrBAOKC4JlVtXeqfQwufTfGkJnNcmBuk5IM8unsQuwXgMrOuPlHAKaa/bwhjixPj1T/KdnG3oXTKfdi5dMptfqJQ03JggVQRIa7eEMFhYQCvtj4mThwOh1VXU505KSzd9M02ndqdSTl706XyzHdq6+PrmMzZduji9oivD3RwwGbQ5miFJa30IdlDE6MPFLL2y7Yezi1BNRufskN8OcPtE+TQC0oQBSMUE/BvSeVl/ECiT2Ge1caGr8MrbqtPQ8iLpzqVV4DbgaJGyI/FnvXIH2bijWYqAHXQT/wahdU30N/kjqtMbI6/2ynxu8DyY+QhqpS8+ESiMcEXTETagtrO21zNjoGvU+yqvf0rSeNQ+b7uRCXJZrvn/Wm6+FuKpWM3T1nm8hC/rG/hm0qa7KX9r1w+eD9GsH0vnKrKMmsMwMYbbw/Xl4w+Bqaf+hTlf+B2su4GI+BMcbL755EhRRTZ1o8oNs8kf0Lf240xb8RBllRVvn8cPzWkuHRFAFfMRSqaEyTe+fGjqFvOInZyq1LUhuXtJlDpjpbZhFT3MlI3Do3oAhgO9Wnu5h4/frOfvX3UcQnEtxcxSGQtHbK8oxwFszNtsumFmdfWY3+7z2F8GypOptjcfWphXiHwq+EtIZJVplS7zRjn3sHnY/W4EQ3KiwE/aoLX7OabbcHBblbLWE43SKG+yaoZ5Xi3l78JHd8qLDip7++uIbbt+6MZuUttVd3RspQ8iZ6V+B9f/2A3a/i2mdId29K7xd7InssI/zkFYM3r9yljpeQ/pJyJQ0bGnYs4+deFQFapEuCnp5JCO5YkTWp93+xaI/5kgRvBzzVYwpQA3eAEXseRyeeAOmBgWyIfiNQlNUZ+asxn9RBgSrhohz4zaOmynInald/ObVHWEvkSIkvgUmDQfghwqz4FuyhR9J+T1vpb5xL5di4z4t3CrrJfT7voVcbx/0xBqSq+LlzzO7qqCRF1ZUqCDnRCGgU4H4y806qbRWPWqiHnpkuYRVN8nrRQFw9ckYHeWw9ypxTYkKxX/cTWcfqjJoHXQG9oD6usfpXDRMANiAFTeSuI5XCpw6SKf04ypryq/gk6EBOeHSEu9nz2YbchrMISYiwGgAt8/zhsJ/rXA4MOLoyrV337frVp9StqVSweKy1kFi2jDXu5ElTmqO0JolIU+t+ofQ3tSauBLuYMyMWKBnZxAs69PGIswZIH4BSSVfRkY4R1/dndcnbNPJdDXubQ1zjvfUO4NhPJaqtRCdbpAQJQr85BHMfz/qNH380no+YF40BN5GXl3j5nOoQrfz2gWzzlL2sWgFTeEa+Sn5WdeQG/hcRfeiw1HAqmxmWIh0VLzSgfPJaJ2g9iXUz+tRGOWmUUb60kS3pmW71eHxTkz/3SRwl1kOqKT4dN8cvlzdzzteq8fY1BV4fenZKiLhrfb4Il6tETP35pxPk3YNck44hWgCGq5p+kZ8bH3aNDTuwu9lERw3E9Huv7QVVA9tkEFXWzQGj+WlkHweMzOTlVd/Sehe6n0iNhZpBKuhrLXS8BtYouQgg20NhnMr7OmqJogbn2mrMoPQCXGb+nxbzrXiCDHmVIcmw4R9lrZrr58s7qFgmL5YQQ2HGx4NPMeBZlebLrrbwNT9jySbNCPMcy7NUrG7g6YKuVD/6dmSscARhMgC6fwa6d1tDjosRE/hDwRgRcVxxx8dNuRA/ex8bG6rH3CHDVhXUKNwVV0ghz0vJRRPkynvqhNPqA5M3FAI3E3d7crnOKc7iR7CqROzTweRdRAwmfLslfH210OhF+sxYM5jdfiR3nC2x0JcI1A+RPkUm5VxmeuGvUUMkl5DTP73PqdFCRNEr//qbsFTwfizaWOzArlq29EH/+GvOeKrnAMMzHN5QSx7LfZNqNwm//ZXoei8PX1RXwbKyy6AupPAn377iNNPKfK99pL6IgB0a1tYuYpxC5aiWnF/Q/dU74mxWp3wWetIj5SZ62y/2grGGdPVrNu88e0wiOQJjdU4aFVuBXnUwiD+UIlyx1F/BHtoTOUYX2VpwXX+RlBxuJ7WOKS4EmqrxmMG7fmON+l1EGKddgBlk4iHAmyt+xUnhzbymhvB08t9BX34hoXJ3uh39FTKDZ0CKVBUHZh8nd4HxXpbcX7TOuettLe0DX3HNKa5Rbr0WR9q8bXmgc5h8w1mWwJHlQiARSy47yB+LCIND8Jy5RaAqwltk4NTmqb2VjbbgraGzm5xCXNnuSV3AN4PwaV2bMj8Cchq/lwNdrQo+KaC/ErOKq0rtHo2xHpTH5nbRcz++tnv7LJB1Jp3HgHIta6G9bXD/XnpKcyXKIP3l79Mfrm3KQl5TRHNWiQ1K3SVVKxAlzxML4OWKFmbRdS2kGmnctsM4CaVb9MgvjJoRRAkTpcBPlVB2mYaZ2428t/KDMLIKeUAMswiN/nKkxwP5atU4eLEw3VkOWqVw5xv/IQ42dAwOJcNNuvjDCeBd/FdRM8qfnIbdEvPkblf7Be0Mxo19cc2/6rfC8gfMakm+VEgtOSZMBjrXpLfc3hNu7GFP+RhF6c6etQX49iTzM4Y2HgASfWDdzUqrvkxAbm8W/x4r3dtfO/uIm2Ni4QMAHcuhRbu4azjIsbbotlAtwvfqmDxh3tBVTKBrJWNCVMzGPzoCtgd/L/PLgbcwBvN79SG9PWO5r9208vuaxJq8sIXdMsql9MpdILFAbQ+I8zej85cpBZQLvmd8UijA4ee8eQ7QYh52wS6q3vY8EznWZRovrxcNf0KN+A9m3dN18nHNtzKoI2aVJVoQDC3HT4rSd3gEaoOL0gVP7PCAcHDMXZllQaByNUD0lgNyNO+FmXrMVSFS8Gz4MG7YmOXZdJfy78ZeWL9hTgX7U+BF1rl3TsXtE7bC+Ql6LGjDI68Cxqs2/COcNjcfBCYVQG/g4St/uwxuVVeHTEkrpq0tb6gsDmb7eelrEpqRRKdRHnlBi0p7oZlHnhe3QYxs+kDbfIaWAWFMo/VLdtXoyBJ9nnr77lDKa/pAR1AfSjQMA+uTgNIppxDSCQCDqU/WiKax2quvha8MFP3ybngYKRRPHh8wZQssKRkmawQaKk2G1sIXo2usb1vMgL08joRwnm2obXhHq9hV7Zht72ryfhpjSvKViGMM3VOR1LNwCgEr88lJ2OcgM57epKwO7KlRIGSYqzO9O0XF+fF4Zb4gAibYv6j0D5EnTTGqZ7WLxyRGDKUDHoq97D/D/rjtnps3VSysMBFr+5JUMJ+LvA3QVbQflIXZsxbz/Yl+qfmG5Esjw7Mec6/51dcKYPjAjNuJT/aeEb5rLSQ5hLVrJXuxTd36UtBWI3hs/ssfGzKcfKzcUFoGOdHcUo2WH3NPGeg3KQTtj0u4YnQa1uv5IlL7TXBArLQC70arpL89i7Y/YCmArzrwMJTIIrFaAotyzFq/U5GpQUHS7dBiio2Dh08WQFuSES7/CulSaf8X1aoKTpVULCGWr6RwzF1nbfHg0jJLifL61sDWTGVL3Lb+BjMAz74y0BFnl8yUq+ZTseDdoxDKWFjwa0KROyjARqZ0BDT5y6qkU1fPNiScJatHprPEb8ejpO0U/l/zmNLwK5z+7MzicMAwsvoGbyfk2hrjogHPNfvdx507Oxs80xuP+BHSbJ6E0ooCC1/22WCs08xztsT3CF8Dh6zokMESr2OgSQ2tSmQuU86ks+lPwZ+5tlFqh1cb3GzkmCpzteo4LUnPWHRm/zxYje48fmsfJdXj3CKMvEBbj16rKG1iFuyv3UXIM9cLGoG1Pq6mAMMTG3ohSfw/o/I/mxW1u8CBSCoHmFbIdm6uJvHRc/nqxuD5tzwi8ZQftnsSLdfNvdKQWMjIeBdP7kdVj/ATg0bQm6BgKJgtaXdoK1ezs884xl/Hf5LljvlzmQvryXUryP+Hmw2QvWXL1egY1RCb+cy9gTn3PGQhbW9QQx0lBJic75e9rPOpPPamFTo+vFUD2FoHfQWvc4ujSD0ELvN/abXlJBl0TDdBUEPjYA4h5caynT1DyZNHEnDUXMrTqbiF7ooN4kHOgt9UQ4DMl+cUqWCWq+ECfUO5Z47KU7FPKCBzSubo5MclMeka+uUYmkjvxu1b36d2b6z2XAnV8Z30wGWD89uPwimcumweVbOpftLgU/Jg6R497oxVWYzpZQbnEfDYMyQvRHc1xcf7JmZrtpvNk0KEjo58OWuuQ8x8Q2qMH7DqRdye9w7S4pYtLwd9fBti/BNGtozlkD7uVl2DcFTBi6QxZ2QS/X+Q8mYPEpXcMaOeClPTMN67hgBTce/MclPXGY1c8YJIUcUI5tRW+hhtikWEUgpJiN3CDeWuqG5q7IqLhhjHcUdxuHM/bDj5eeCHYRt02wV6I9luv927V2aRhOMsSueLIse94HeqksNdbnI/dk068CXaL2kgSbXgs2X6obBa0pjzHXxgXtNM5mPYm6BG2XLTU+xa9Bl3M0OixGj0L9LLFnH6dNXg3Q4rC5CBoCdRLZOgUNSkzbt6DkJwSg3OsWbivoxol66jifzkEiMClTU0ThSJOCt9QSSiSPpe6s2dfK5F+QHUhyC2eTxdtygcfd+3NslD/SQKlvdUZ6+cFNDvL4sGT3NhNJQ1JhAGFdOxfAkyvtxseutGt4vaYfd+DzmpY5rE1K/Uoc/QhhPtz1AXEx+6zi3a7XeEJ/iTzCtL4sSwA7K0sRpDuhP6B7wYBp/TQnIkj/sfYE1R/ROFbqkdn/rY5YHmG2tlNNTDCNGc5wWkfHuFVYR0mhdkh1P9MRChc83Y5XkQWQUB+Te5btIV5lcCFQmpEdoh8pFN3LE0WpJEg5y1XEKjzGZHE8/9H+9CJknWv4ilE5EkLsxQRlx7IoJqXjyw4RruilwpCrOz1sL7JCnWMxcQyxs1wOtclY/Wif/hVS2Ie/ae7eN7x3i14POY5hTI81ztvZTCYdhE90gNZ3LurEuQypUEyPUjhVpN/fQFO95XFyHSWXBfiaN8Vw0kq5fpiGDP8R2gxmoA9r15TcakP1XPOeAo9pXObUbCN7uIszyEPvv/BiOyS04vUIy4luzcRwYDl6sex0oTe2xksVagVZs3lCrxA//Cl+O9SlG85lgMXhbmMDCk+zu9gWigYBIU5MnoRYQQKAOhnEBaIWYO2M/Puo+u+TWd6tO4gbVqvlJmaFA9DzJmFtULhWzecxn55zkzpgMvqCiqAkj1+bBUEkO+jjhPeRb73E6KJyi7dtZ66gWEGoQyvSYTo4zWifEq6JxlELm0k8vHvsJSjtYOlKY/QhHbatSFuRo6slfvw8IqpE5PgLPiFFqMXHZGeVclrYP0EApTdB9o0dOtwR3/P3+hrDKlR4bZ0k5J3KMZ9Dufqf4Vzyvx+PSS7ijZpfuF/LNLduebqv72qaNWi1UeNxNMtKYtOyqs+kkos7kqf1S7+/jHh5WnHtwCEgSAmJWBjOHuWWDFjQZ1IxFBl0Cpq17nU1+OdSjLkzoE3S61WuKKmXd4r3Kh2ZgY+/C2imU22oHB9kcYsTzXBiTMwMtH8J4BMMKnGXo0URS8PszzO6BvkMbH7iPMGtV0lTMPAMuVA+clCNjlaWMhx5n1jxbg1aWmP0vxFLOj8A+nwzKVwJQC0rR0MGxO41mECVWGjP/pg7XHFy0yWnazd591AqJIAkxzDr2Pr3BmHM/n8IVi9p7QzNGZfVQEtTdfl5lBOWNpKIUo7srsIb3V928lOl6mDm7nYuFzSPtvu1FEMOcruBrilyLk3vZ+CU2Zev5eanO41rO36GtaVxMuv6XKJxptBXiet/yP62nGHV7HE2sFMmWi1Y78JaaqahyVjDft2SkI5f17J+ogID7PTjD+InG0ozl4c25dNg8yBtMVMTVMdmN/1MBoK03u/R3mB8aKgtSSRAsbeFXOTOzTQTQMEmaTwlQrNIX64iHT8vHdkrewAe0poZ0zGeY8z3thju7EjSNO9OkdM7vL3XnFAJBw20E8wIE/USHpuZ5ZuhTcc+mekNgYtvZuUgwE5xIQdvfPOz5ssg4YKfvH7k6p4CfZb88l6g2Swk/V/8F5iDwNS5cMZr0yF4Nfbqx6JU4u3mDlhhmom0fMXxj8/ZPlry3reF7+NcsqnalRLXRxXKKYUHEzX1VhlRrJvEElMXwiR9JKb5tCkcqXL195tmS1iifjGRJjgqOrW1OMQd9ClQb9WwOdy6vMPo0AUv8T3kRD9oN50XjZd9DgXXWHvu62r4qnhRs/oANjNLks9QQXcBU4TzgBmplmtkC9vuUU0Lky5K5h5FKJQdCGBLoPw9GAd+p061rpIIOco+27h07M180n9P7RQNoXkSjtzEZ02XC4pB1j0/NtDjajVihD1xoJkX4dKSvnkyheN2jxNEVZnRl3vEfANWidjqr5+8J4nIrktkr9/R5sM21CazGXSHY1VCsLlNpnEiexLbdkznMdsmOoSItFD+JROBXFPIATF1q8WOJkrPceDjAG6TTBkaJuIs7Y2JP4+UHEuKlaiWcHMosoInUvsAmWhZT08SRNINT73zZxGzjnVqwtQOrdK73sL5QDIS9KgN33j22dl77juzek13t2oCR1fyn/7Tc0WDKZtO6rIefO68d6LscIrxpoS69XDFORqNQTTFYqMfFJouCjqfQX2mjlGy8eCr0sSzJphKlyoSZtv6Bqz+SNUWjJRFrPV0w4f+MCI0oxbL2CyA3OZMO4SoUlELt8LiFkUY/sKxySQxYySRwv/XidG17vg4UdLjic87s8acGdiDmOZWtAykb/Xe/4GcpHTFW/0YutgwAR0iAQcFSg481CKu4/IikSs+8GEzcpFKQQCi9d1u7J8UJdu3O2tAm9nmc6/ZMrE4w5hZ3H8T0Z27y+lU7Mx5l73cR3p8Yu+BUrpPbYqn/ll/uy5olAR80pqQq8e9bE++Ne2SDro3D12miSn7DgKKoWh0GduEMUU/LtYKXqkWP44wkRgn5DvMXpCHHSB2wLi5P3T8LcAbVdj5DjyXUZ60/kI55BhPhmpkw9ZcQV4/wiBDOTsAqss745FhxHAqWqx/s6q309l/jNd9TfwSmP3Dypkh9fXWSS8zsIo+kUE+QiwyNOX4VnCIzGoF8pgLKWBou8dQvTUvZ827laEo/nX5qREyaOnUg6sIWXCtuxOHhyJkkCE7PXYGwMy9KFDmnIdGgp5dgIA5YBzZSDceUQuE9ATwlzPODLtlJPvysTKwOmum9zUWJN2GEWPKbPAQz8kruX2fvj90EXkNwE8XAv9SASdBXr5X6m4i9QbqXP9qYBcFqxu2OKW5pTx6CCpht6Di385l08B4c63PbbPMhCjdmvwKEzzYQ7LQ3FFuw48WpO21eVKTmH6PhGNcZqDK1PqrHE0d0W8229Dxv3f2I8F+FfyIQ7CcGh5SYhhnrP7N1A4Zhces61gtpC0xDxaJA0wgVSUlRpcONLD408MCeZQcUxfMkj8SI+unzwXO/YRTyE1JP4bx0hNy1sReMQ7eT3+uKjCFIeC9Pgn4D0Cy2UC/wfpBaDwMiZBfzbnyfRzPrDCOfXw7qzk6aUHvzDHMYNVoKp3a8GEiB0R7eF1jH6c5PYLbiFmonOKvyuDREfUd19oCBjvkvRUGS+tPRtmKbZe1RWpez+fKcZ2Uu4iKMmqHy2idLx5rgS4AQmpuY8vS+beP4P7nzaSpprQkbgOmxV+WTFkk1I0kUTT/ummyaxxwI2g1AiD8RQpgS8Vz/u3x3ccVzOGIcQMZqPibbV+0dQBzJrLl8JnwwUD/o7Ab20S0RDXURUP8T6bBRPG52EYuTs2REGwf6Q/q31fuvCbo6BR2VDHcxPm78x9NUazJj3ZFBsTaMadE8tmNfZgF4gj+VHxg/5rzw1G5UWXvmOjUYRkCw+hnQCY1D5Fg5XPH7DX7OI9iR40j4TbpvH2FCSDb8DvXgdMWafKh8n4CI9yozY8vnTTOdCko8cpBxnCxwP4yxsMJfhwjSpOu4c4Xl5GdXbHZ8PRaqD6M5mfc53cjE2NbPdUivqLLm5hNKSFRtCoKCVHXrH81OZMLPRjsSufeCV9p4X5FdR8TyJHF9QQla7mmE3N2Hwh5q/xoEPBvs7ODvW8rHUwKGBQLd4N7mkbuA4wFzKxJ1o/ph9LLMgVo8NkPT1m/nXcqxhjAq52u9nhSdmmPKzgsKzgvweTE8/NaX7O+6zhKIt+nftsbKc0qkkjQaNHr61tk3ipA/xwvnl1Bi+6PavU16MV0sXZm4o2Ia8aEv0z342a44u8H6uXGTWvJO0ZkhbU8QJejXuqzWOcRu4Hw8MnTh1mNlFDLVbhFIMNy+n7PZLzzXErUU0bF/+mtmomfw4A8q93c0/MVoz0Lq7ESqH8bQMZB5+I7cJLZsEgAbzAXev9rI82Ka3puavRzxg9qOMF8650NSqqN8rEKeGYIsaLLdrEMGo/ER85rSIuNcA/OgbkX7vLXctxbq4oRLk2eyFGZWWDpxXTr1mS6GJJlHyUxmfNW3RgX3zhE36hW9zzRrCbKGQxeAvGBRa2PeNenJ7LvjASBcVL6hTTIeeFOi2n56NyGkdSwXqg5moAEkPI4YKlUMZTS8+zMJGXkECOYt+sOPtuYdx7oLxJyv0QFybgsEwziInkYTr5+kFQeF+U197rDUyPP5eO3FJVIlfc43qs6fSliF+UE2HYzBYp6QuJ4+B93z6kweGfcTqkFKsiEV1SKM2UmmnYEMQJqB+uOCR21dVmMQnFnqEcuUdATc2s96aCAb/4bsWgfKR2OGfRkX2CGsGCbHv86q3EU2b7gGKITKFHhBpjmMgC52wRqYNrOmE5GJ5X5u+kEUZC5SxHK2jt5vXSUHTgvZFcpx1qD2YSDN/e+CIhhp8Dh8wKqhWsa/DkS826B02qtORMOnWbMWdp2zxWPWvBobhYOzTGjpax1ev6cWdiNi3OoVcEP1s74DPGw5bFVinbrzXcNvdRuOL5DvP1sO4qYlfzZJFcHGgyZSZmCnA9GF4iskjcR95tJHT6o1lXzm9E62WBgYjyDYBF5lQyyXgWDBdA8bAlFH4HJ0uqjgrzFQ0+zqCy4NAavegmv41HL7KoXJaFnc5WRr0iSU76Ft4MybAb12Hl872Z/GoOLqiaJct+Et5tkzGhyisAwsC953dloNC44iMXHUDHXx5bIl0iNBasZQv12UXVXRP+bU7ocnz7UJmRy06HpjWVpBZPWVpj13evdKFsQrxxe7CNMP5i+2wWZ1D9PUWkD+7Pfot3bHz7jqV5wPhEiGI29O/sa3heF5C98a78mk5/JlBPIj8cOjVGn6Cop/HLNX4xmXMh4SWuAeumC6by/24duBJRgXO2s+7Gmbyg9h4K6Ml78h0Gq/6UfhwYEQnl6EFir8P6QFJQwVR7AF4Ytccy8m8olSR3PBjCDX2yOpYT/X9yqI3xXF6KllNU4D7lJTSIG7pNl5Frg3uNrSjjLM8Qtqn8SXIb7id+RHfUnEzJkx5KLmnzuBGsNHhClZzUZsZGiV91IBMQ9aABdgS30lwzOaGzBoLjg3uLIWFeqxC8XRpnB2c0PeZBvtFSv+vWlfeTjykms1L3hZxjtbecfTlrMKWorGNm6y1AwkxgHhJZ8sLYiCONdOph4XTOxNR+iRlKmOm52F7Wu8pJ62t3JI9w1FdhNzTgmaf8PXIKn5MA1+QIG9/W1HRhNudkxqDP4YXS8L07FZH+p9Tod8fTqzJywToRjptRFjEAVcz3S/HNgAK9WoZ1qCyqHS2qg4E1GcelqKupXjZKlst+8pnX5/dFCIBEnNhEBUacVmlJnCZHt12dhDnjH61cu49rintu0JPj3ebwltYn9Vy4YcuZjDkSGjT9DgBRJcltqfmuuHzWZSt6KdelIG+cbxMX/7KoPLxRLUTD2yFbG5Vtg3Bw7BLp1/9E6szvMihTJbF2Gf8XvSBp6+LUkZHXyBdiH90T/k1yJ68ex1J2H2k71752ywbjvNGK8c5cv8doYp+iotlO+hThVP1VsxJNg7lFPANS/Vo0EicI4f9fASUee5jljBAEsdBvMRP61wtBkYI2BKGKmBY6GVC594ENXt/SPSZM2AGz1suUC129+LB7IZwGx3MRDohV18VUbB0wM4u9o9lkgrtAVsjjWLt1ZGjQInDBef++UeVFdA3Sh62C56YgnFnQSITutiAoJgNVj9I2ROJEUlPav1mIUkPqgGw6e/77ld0btvF9ho6c5MkddHbnHb5I/8+WITkgx8a/2EXL5Sy3CWbZTwTsv6LT5ZDjsREJGa7ytFqbH2frCwW2Xcsn01KdUkBGkaOPfECkx35zM23+1SDZCpKiFCQIiBEtng5hz0viJvaqfKSLAxF3a8mmTB7uM0dic4ObIYDfczngSIwmenMrrOufD+NCDJFAjkvD0yTTK8pRK5Wnlyru1d+DJNJGXXt3zg4hBA97LbPCAH80FbhfXQ68jXiAV2VH+/lJJ/8A5Z+Br6STZRoFYqApysOCHUFgG0zDJ7Wy9KD/7bOmj5ixZT/MOow7CZx2o0krKWZn6jfqZ76dJF9AKY25ire1+75TXhby7F6ByaEJ7qMgFpgB7igkP8L0ZbysRh+eKfbEgt7j5og7XFoMsCHWOhJUgKn6Oos8z9NcgGBNcX28K80RRHZa78Pf6r5Ir0CSOvAjvTE8PNmf3L22vZZ1gfxlnT8PbbFkfc9kT/FlgRC21VmOwdTDo6ETOUtO5xMyBNdhtYfb1QUvbbz3IMJV5Cnoj8oaLC6KA2twtqxyw0Lnwl4gyaH/lgcOGSkcnLgjUG8Z639tMsc5FsmP1MupRtoAoRoarYCjglBaCwNfh4QcQGtZJYi6IpTV/hVLtcSBAdAtY5RHBUfTZcbyylB+kgk05/BRJ6cu5NBtaSUrBdW4h5mYUdw863YtzS+yXRVY+GsxeonoGcCHuhDla0XciaRp2Lupi+b226VCCj7jCVIqwUjsEFf4mPlWuGEq/YTAK0rlf832zwQfVc7wYzQI/FNO7VgK1GEdyZ889punwBIOin99nm2JOCZEm/9GW+QKc+GYBhEdgrYyP6mg+/jRwOCYbsXrbWGZZbxJYlYUIZNWyrc46on1zlZbA6eXwGbEOEvupD5vg/Aze6M0wn4F1/2rhDMMpWAvZEsd9XbebFS/9wtSqrUc5FLxhl8hfZHGAY9o4UJyh7dALMfgGLiCx/98enELyNKBDhELAGJJqHDGp7Sq9rOZuxzCcQixyjLXbL+oAa4mYYfs/BlzEgOh0bfa9TgynKItXNJCBPLOo3AZD1KKKjoHSa2j0NOqsfIbFxOfrr8tmD2ltbZAILszuTua02P8pQ463/LNoIdNrAITFdyQNCv9GOITDSkUc1fP2knWnGkjIYSOkbsdcNeBfLexLmlCT7mZZMHj1jPcaphcLT4/lxuTuQLa0vuqqLNFl4UC5QNGXD2RWNm6EunhWCRKR/zoXsrFv/vXCLvoySMvvFnZpjn+uARkyWMQ+nMd3UqlIiuYGSPf6YnvtWYHBtTYpclXsXmxx05j8bfTdCvsHAJtS8nN1lLWpUzDMRRZtDUYQO7odUilkPVNq+JbVRAuUFQh2hZrziNDWDYomaAgp61se67IkkE0AeQS1QrCi02vX6ZEl6lERwPixHehNr7vrP0ffnyrWFOmGnqPSZJS81uY7KNDJ5jTPjvGUn072aXYijLjZHsZMnMkAaSLA9jHCWsVbY0cCBhXwDo6qnAa+he4CEH3CGVqfArqmR89pNH2sxB3Zy6rOwiJxh+9/owfiPbjjeEdd18E0i6Up19C/YWg81kob1vVV0r6EyH6NpkedYR4XiWkYogEijClOTmMrfyB5xI8xsaFyVF/0jTjv/ysVBAPLPHYmXtGa3rLJjeQ0VXomUw7qrWNqMhjrrOBtPkK2aha9POxDaqyKWLmd/xv++YdZ4NOkug6/U5h3t9bQTyMm39IDlCW5yXRwgJJ1HBJmbopgr5HTJLc6vtob90ov3HkkojoVIv4c6rNbbNyH5Mfrgl2KTvmep6ke47UGGCtLK1HnV6V6Al4rutnHqj14T8gFBlhMNa1MRaqjv2dFQIpgctUA7yVNrczOVowe0C5eQSYZM42nSdQtRnoYEAFs6hFrhSMzU0VFzWR9yGk4ePW0MhVtuYwf/wybY7l4ewlUy6xQFQujNJahvvHv2wo3Qq8O/7QIFYjAsKq68YYQUMFjxQVYZVH4tgf4NaPCsW71bvtWLasMWkYHCpN2BshuO06dgUN4XvJFnLWI52lRlXF1JtTRaU0ATN1u1tkrg9dtY49qE4gNYV9tO1WIXH9TG204clkWlLIxZEA/qLgYxiBmL1aIXQcqYvHIemH+Kzpr8Vjc59RwqAVEOqgClFAAW6/6KneqSAUpPkq8OUNQBq386+ur0OMJa89e8BgILAkVNaWgO0kxkTqvuWhnTMKYtKZ3PjSV2ifl0wG8fcgIJqcLoH4JKwQ8acx6taZ8nimyKuCp6/DgmppuVF1zyY1z0Pj87rqXuo0hNm2fGUjTgxXauOTDPeTnh37MXz6cTm5M/eSjtBzJYDKngNET1Lsyad3YD1S/bBuJY+hKjYavAPA0efVSLGlYYmV/LXS1yHGZJDKdboxikYGaIPqFdNF+3/1cgMum0Ozp3OMenSWuFagTWGNLYGlhyBmKgyWu7tFs1q6ubIplFG7+Wh7YjTQKmJLG5JwK45YtLuubsn6m4+fQY/DYKM30vEtZD6l4c/pi5LdLkST5EvfNHZ84NTpPg7uy4GSawNvxMyEr/6ANlCfw/CVUo0GpwepexctPkeel2yieMN504KFBtAHARa/5h3N9ofwVNrVb0gzHsR3Sdw607XW/EA8RTkAfbVU3t0kXx8uKe0PoUUJ2xonZtBm9Op9K6UGrXK5k27mZRNkC1IFwaT0eJjGMJs9WSKXGwIh4qbiTWlaxaLfmMBG/frZlb4fYuErsmpo3ocW1B540WBp6kVPZfg7El2q3fHALHd+YC6GWpbTCmelNbFqlFZ+QEJOXqcWRlSyuusRFyktYePhDR+97H4x8saOorkmwrrTI16l4+37QAN3Ql5Wy0svDb2FN8VbamlwxN+q5jyeEZZpTMz+BAF/MxX5H+KW0Ycg2d3WIFaCPwms+/IndAgNVidvnK0g18dnF+LQ55+aeJUz/ULgpyPKmmSBZ4KUXqyd2pJkmkbXjMyqS+mt8sZB2Bon+dzMyBsJrbq4DIVIQkoX2AQBuuOau1wkapF9kYprxpQnBSxwQ8K+zACwxxlieIKfZ/HO9uJ8avvpFigY828ILy6dZph0W1HtTgLNjFIHYjYBDZg6b+/MpKAGStMDdPOVjUwJsq4tiQ7PuOmbzVgResQ9PQKVPR69O2WIsveL3+Jf5Wadj/a77sx7rIqC8wrdD6x3taGiubKCiTf9sDlOh0DAjayxst2PK/04l2f2Fe9H+yMrKyTQ6C6MRNQcisIP5aSdddP0BmgHGM6WjNTRYj4uWptUplVwG0kMg8hMs8HG0ZK01JPvYVdNuvfgQsC+tVn7ZWxJEY4Yjl/ldidOuPZda13r/4d/DXrvQGjf/IKQz3UjCQ7R/Z/xJf170mf115J18LO2DXHfWPEKxb/yNyAUZqDpkR4EgUbIgvvip4GaNe070/oqQt4mgfkZ8/QQAZnPhdMP0b7vCA307YAE8kIaIcdqO1ZQc5YQG3EizzQGgbPhch5x/yubzqymuOBAHgo6gDm+PJ2Fxvxgw7Vg26RvDEAVn7ehA9jdJE+jZGYrC+ksPFSa30zE5jV4Rd9q/hZTTZom92+J+4uGpA2CE5PHAvmJUbXJYiS9m1xUreXD4c5DXoAJ9Vxx6cEnQIl6e+73tn6eZOGKp9HxFFPo2YlSoSqqGUqwpwpP2wvgUQlP5UjD0P1xxl1TPG93Ypbl/m8dXijZe3ASM7ub+bmv0kXKHfVS3tKS8qoU3pgwW5dZyNWkmK6rQ89h7BFtCVMn6SP5bNjaLYRXcK1xSzm11eXHxanSXEV49iFpq9L7f8tchOeUuw5e15fRp212klnBh1kLOpH6WfUYSOvMpUmImfMwmr43by9By7u+Q7kPwIIBa+NrKFHavsY5TwlYaCp2MJhBe81ZCjbSm12FSOzl4n7oU2h84SmsWxcNct9ciQHVsX8nxL8iNXUeljSTWYmUSvSlEv/cW6VZe5KaGldtjxE1eJn4/lKgELrS25OMgH2KCPBJ/xeFinTEgy+we+tfCfkzTsN1PJDtN2b18lGRoOyxpdjFZ6Rv+jRMWHWc0Si5pXqp6q5zfEV4t4vDXfcosAwOXuZXyhD6TFOVxzBQEgw02fj5oqkh9IQT7/xQ+LC6ZLQTX5GFpGH5Z2cbtsPgew8ZWZfXfZC/oqw+fAbJSACKDcPvPIANvbfNLwPzmSB9iDAVxXM3XRj/63kcuFKUylzq6QNLMDcFKzT/jg+kd60ER3Tg9s/I+2nt007nyhOqjqVWvytq5sAvHni4FqhiMz2sE8vfcbOtL6nnR8arOuljSJQzxIonUtM9jkBfzh6cC2El4zPZtC4Qo98QYSpnmAXNFD0cg4vR6K5FWD/1FIC3ClHA+2J1lDO6QFiLwsNRVkedlR2Se2wkBE8/KIOxKXNpQTTHl3tODVndGfu+vcUkisZiaLPnW4cpMpzvNhwi4eQxm66TUXe94FgryhzEkYh1i4K01neMctC8M6E4cpVqR5IFte2snSUNwG31WlUxhHtAjqq6ZRzJBxThiP3FAk9dR15LQXfxJtkiUlioV6YwntVF+QJw0rN/ld1cebsST4noiO5VM8CTsAm2gzj8qfts+ODaNlMg5Ei31fr88KGqGz3pUU+zEvk/VcWEvA+WEYPpMet66ki2RNp0LL68g8jDnclUXdY/d79UtdKGUC/0yc1nOnR7WSU8QNaWCWtUBWuFaY8PC1GEaoquf10FgMNregMXo9xre7Jbm5jC9Dy1enu98KklrV+cv2Ic38xOM8xXdnwZlc7uzHZiV84hi8iHS7Up6IaN/TJZHmFRh/We6j6wDV+MVVoxkHYsajA0JAx6sDdVc0iDA3IvIZ6Y1uSV7JNU9qfoxURKGm/KeC3itBY6mLVsIgoCH8nTqN6TYGWAjwdQBf/CxyFk4WvQD689DSoGPGHYJ5mUUdBb5HrvD7BddlilKo5ak9GPWRdnOkBg/h9g9plXSG75fKZKArkAXZkZy8MPQveuHRqDpPwdHE9YjfN0iqwp+wwcKKPArCDqKnA44eCzJgXn8uR3EL8DI9VC16miB62lkb8PQB2HyoLU+tPiOtLsaqadWxjqSbL72o/7TK9FenDA2PvD++rTkPw3dk5C+T319fnuDk4ih0vINQaJX3rJhFn3XthsPQypaEHOfCnnMp6KnynA2DdW6icVa6p6+i0j+MCwswCSlfUF12ov4bHfJsbEcy6KbfZ59dwpevZi2k/5I9Cn0PiToNZFrNxDSkTfYB0lv2LhBmyOg+4INzvMoM9Q6q/z4kTThajvaLwXIGVDG1ioFgdG9gNZ8/dnMFpz6mMRU+8Zmc5aJihDwm4JahHCqxsTYxgfRxfArjBOMHIO1kVnqcRGyMoZ+8jqd+wtrFc9+PiLARtcMYEeBYAE6QIjSI6XQxmbVXux1ukTVUdfqetv7FhMFO7L2iEhWbF9rba3uZJbC//QrsQvPPE0i9MdLjHOEryl8DBTAfTtwKLlvVICP5ElEGnCyTvZtRbuQhrnGy/PSxmiRGTeJ6nYKGAEY8Y1PeJa7t1uNKmPQdRYmMJPtGr0c3FQYagGWYTy+LLy344r4sSI98x9K3w1A/2Jb9b+VqhJ4o0rUVr7fqrv3i2x6Thv50zr/LFJxW0sYoqKHwnLj7+soR5ZEE/JIVspA0Rr7YEqferH+7boQuKwqMRReSQ/w8P7etRom4/dR/giDrB6R19GY94j2fCi0MhPyMHFlpdKYpqZrPKKz27ob4eCLAXU9rhkR2Q7gmk3ygnu0FDfs01IEVvslJfdnDj4kgEIpZihDY6bSrikFIP0ZVtI8VgP8V0mO46Z7DrT+BTJolhMIt3YpdQcfE6fH+tTAe2mVGS+fDUaaTejCSOYgGFlqEryCgKhLZ8/tRxksMpqV2lRvupr/RBs/S3UA+xShhDJrTmNhvCpsIwcucVywnWz9WmJWYyo62+D2k8pf322sx+i9jNFVQKD40CX4NJUdamqnVGig4Cy06lfiQhrRLeLFm18642+tdUoiX/tD/dXphA7EWVLAGIkyLsv1x8JIplJU3Er03eL6eMzQhXuv3ukNIet+HUH1M2/jyHgRSJNGO1WrD5Xnx4aBQNti7qt90hZIKGEyNG4O8LOY7wc+6fWDVn/GGlwkycTZIIr5nBEeWjXFKJo+AHwoEWva8aeB4uTYUIJcb5R7sPt9XDu4laBJm3+J/pnpGMc8symIxRMLH9YbVlZIMqnN6o3yUk7+MbEQiHBWywk2ktevbmL6PV4xaKPVHJU/UfvWlN1HCvhONAFZK2H7+UgEid+9KFsVn77Cs6Ou7a9zi7ooyTmYsRZ9YGNkwYrNFXAISKDThQ8mJ19Vqtnz+6I4KIkuwWvbdu9I/HQSUPXvwDOs4XOk1g+9BaGPU1K364evJ04+edYSIJtmPAdMD+f+XXyvt8hqpEAzRh4hqq/SHMqv8LhCaQ1OZfhI7cK8mh8y1HI4cDjdwh3eYkQc40+Y+CjwW0Y4jqN2xo/dhvKbLA/ST6vXIgC/AR9JPO+0oMTrNZQr1zgcPq8HHBLf8D98OJauYbwx+351L5+80DhhZuXvH/jSIJ+5bdf3CyyRyLFBD/HECGaqszwCTQYl8oqaemtICabV8oMu7ml8gZUeq+Oym0TrECw9+PJgEVp5YVA6vm9OPgqnfyS8Q1NaOhlR/q6G3O9BrcAcSgIJ1tuJ+UZ/Jnf1p0cd8Twi3xJh1Q25EJu3YYZOdQlrP4fIjZ1Lt44ejfEvnjU6Mmp09e55iqTYJyAWYq8jrztBul5+zaw8l3AChze95p8Pnlh4UNkPcuiuEgCY9nlOC6xPErTxMtfVOqZT1nrjGCFSZJ3zhN9I0rRlERRTthdY0cs59kSZIL4ywygHgmCUJz6pI4xm9dwqb/O8EB3dr4P2NNTGWRzOOkYu/I7ik1Ctbda/MLweSu0+6+iMjnJbd+MxILisKezoJRT2VGKyPn7Ll2k3H7umuVeE/BTc9dnD1Kut/6W1R3r3c3cbDj0mtvb71rmEAyZ274uERKIJk2fPiTtGI2nkeYERYVzE3NYJ1679ZIp/jf4ZkSLxOXD5imA4uj0GXbvl9+0bCttUYxLZmVxIlDR4yD4V3Sm74i2UF86x37ltZcyiaGfR53t8xSjFkrtQu4NtEzPoXzKY3wcp42rkGtZ/BlipPSX61UwdddoezYOOOzzlWilyDgR1YGtkQmscvxLYyPRkTDJy4JvTi6HKflJVa88HdF2bGy8dmJdkzPH+Su6UKWAHni/rrNw1t44dASSf+jkgGdPquGphY9Gyj9Jgfmh+S3jTAA9GegJTD/6fhB7xfRsXxAVz4ParLH0+d5jC01BslqPtwKZK1IGFNYZRxpxaXEUnW4AG1m5/WTS6J0ZxpsCt+mhXuPXhAboV+5ov5wFgETSeeeXEzD8Hhgu0YVvdu93msoVGjzDCL0l/8COTwaEEPRCHqsRjsetly4jTTrPFKy8Zffg4+mlwBknnoJsJtn45r/p0X/W5m7nRVYEmrlk7c3VSK5ypn5cfoAPe5kUIyrRzczTobAqZcyuAsWluUokcuDzRltC4BcJjX3gY8mVws4caupY8VMhSTqgQqdh+CgTftAJhJDEQSPNKHObjRsN3yq1RcuI10Qj4Hwtz4fHWMXV87SjjPRJeq7l7ubGOFhUdZ9riL+8flc5nhrPI5WTOYK/xEgfg7NbrSpD77bJ/ASDUI8p+48rWQyvA+V6aJEu7TLT7H0KsCFnfW9dD4Otz2se+vWqZ3OSUkt/GnTBbr5CW0025GcuVVCjdcJi5cFKsjbSIQqcmOYuxmUQnCZl1eFEFLwoxPQRuAwK+EmI0on/t0z9qxbyIYc/iC8aJpl421h3a5cLEFH9W29q/TYHM0AHpLX67fZBmfRu3aGUfgMBZvMeNIgInZcfzThNWSiqihVg2+fudkkbhWgK1vPq09BrgRRpAdF7YU1W0mWsNbN46RB/IHriE0CXMFCTX4qgv7P73OyePRJxiCmjPuUjPON/72ktI3XaYDcoUJUsHVVjic0VXrfWZwOUfIbm2agB1ZgJiTDyW6LjyGQIg5a0KaqW2H/Put7KD8Oi33McFTYa1qtY3q3+l0RadEWL01ZOEy17vclVecD9yqpdPfk+OYo4YA2VFV+Y4L+jVZUgRvN/Fq56GRcyN5Q7kNFLp/lV62PXNoN4hneDd0h+3Mo8XZsBHgdF7Jh5+6cene8wTQcF3xLWrsVJfvcyFbZNnZZ74085EXhVDDmmVj/UAA5erfyS/oilE1OG72Oi2ZdruNEkkRNMQyopDEwiYinnu/jKjXQSotTNkOE8dQfg5t+OIDH4ZgtOG+fyK97hIZ3wlmopIXiU/5NYrml/0RnECj+eMWnwlxINaOL9+XUEvPl7kEZvrxKm+MsLJTzymDzqfgm8TFro+Kw2LuvuysSJjsLGRT4GyMX5AghYtwXnP5Gzsx+e4XvGm3aU/9/rhyh5+Ot5FzexDoU/BIHHgS7CyXl16YcNMApLoA78MaoZkAyHFFHZcGqnEtMh4Ha2dtLiMOdQWLjkXrZVwoJkdeY/v4xoNHlhlWZ431oBRdTZ5FVjcdfJTfv1oH74u8rjnugo4pczfos5bnG/iEVVnTwsc+jWy7i9A6Nvez7ZuIiHo3V3uAQ6PDx93oE2vDeokK7ueG2juoqeLfxTqUEUu74WMwVwbhfYLBnST6B6ZzwfnBLJE5jJHeriZ8Q5+Q4++NP5JUOcESnZ9FZgzjzWNsdaRZ+LbX204nNN2rXFzbdqDnECCdUwlDQXiTfXPn6ZtiFIRxrQxXQy97bQIg63ULKgMqkmJjyFhHMlC3khOlek3dtzZUibwy3arn0tM1Q6wFLCK/PqY+TqBgxT1DIk7okRoi16MYeakbVGZIRP1/rqjD4vjjMSC6HPPbSuvwK6RncKv/qmtmBJaUVxO4arfMn2easssiAXEIhi1cl+s/ICkyyuzVQz4BHGTXE/kIFaSKiokYO6VUlGqS76VzKmMv21ON6VI/ijczUxR+YemxD4bc43OxvA8Sq6nzEldvmZJFG3e1dAuV4YHTlj0D/2e1vdiz4N+RVJj3tWd+SRYhwSgWPJO8TtMymSTG6irIUAkVfxu645T1yioaqUVpd4nBb/YjQZH3JGp+mOig/xaAE2JrubtGyAkYl8t4EhOyTY0295Ek+beaNSfRi/Xq3sQPiwsKFzQAjU9+MEZ6aJ1ig7L03Wx7tHyurS/19m4iD4MaAXL/kVaZENQFnTk6T9syOy62ggZJ7xEUz5vrztRJnswZO8PIBRAJpwtVEZGONoyueo6E/bxQqj8MTQmfY6A7pvd1tIBWDsE0WssrN/ii1+i0ke8+TO57WCXocUTOCfsZcfkROl0tXQl/i5AOsLpMyOI4iSytZSS/TdfAeMz1RYngJNH5qlhB23CyH07SvhoN32KlJxNGaIb1h0ZXM2FiGxd2YE0vhwZGPYmr9AIF4juDiE0Wdv6iq63XFQFVlU+Xie10BXwinlaLS3gzjF+91Q0Kk4YOTFM5IVAyrEbBYQRtKw8vPfc0kdTqhYrr/WJR7A+S2fB0oDrZtLhgdQRmwbUWrfQASmj/A7RUELz/qsniCsWdJ50Ojjd0UdZVpg4weXh8aXQ5mnh8vuUgtSrsOBZJUjZ2gShf/ACvtk2SE+yfsSY0Jpul60W0QJhjHQQDoDeWMbcVsRNUcJJ+cWQKv6ZgBIynbyWRsUWIwzbuDmdKRYaROLkrtjkI34UuXuOtqSpK1gNvdhO4WJRxnABmbr0DgTA0PBVjB+Z+5gyM1NgxOCJjdHGVXig3oLcejea0/+wYJP1niMW1A7fp+27qIjosZ4wt1i9YSyLph2GyGSJ1zqsOupkFaapslSsyZwbG0n+gMTBpzObRjufnDpHNV5iS7uKmPdQMEKEp5a268XmZxdKd/oTg70xRyYdpnUdYieVnsB4xGBuQV8FURTlqggzM6hRsD5s9URZGgAJbYG7dUubsWzUwCNZ6LCWVYs9DxvQu5BsBeYIqnDn1H4fFk4tSTxygO+ifk/O8LlcS27N11d+oN02BZcnyUhdpqJYOVrlgkKtN0nXBFnA5RaxqRoB2vHUwuzX8E1Ayx73gry9+sUXF0OG5vFDqP5QL+IMIx6LrK2PvRlm6jNcQiNSiTpP3M2WZ+1nXlIkDiR5ySo8Wbf4j7Mv7PxEIV68JQ9D8YhQR3hDJ0mBFOeo/bj34wgiszQ+YPa+ka4TmNBSNqFFYMogvzBCIQ6DUHHqW6FYWhREJYwQ0GWG7GkDSmpV8yHb4fZnWIErRhbRVOplXNl1ktiBr7WhzAJeof/yw2WunxEVa5w+o3z153Tgk2DXZ/vU7QREfGlO3ZVw8HyR90NitpFrSeT/RmVfJ5STx8sfBnRjMX01joH3+IOxA3QIP7mcx3034KcGenPcGLnu/TJUcWYUTsvnW7su8j4BR1KdJrkCYPz1nhjfHxrh6mythv/W4zWctYbJ9ccbOWkOEdxG7TDcxIoYtMrr4JUu7q3kb2al0onywdxp86qwGfYigLn1d7g1dwBpeGauHCsCfmrzu3FXqMbBrdKP4mneG6uXOMpR44h7KIT3zqhZM1+CVJ1od4Li+nvmzDwI1vAwsDWhi4PN8RODQrYp/mNe5Tao8vIx6wdbTL0BI6PeO4AFclErWncfMTQuQBpB9NgoJunJ9Aqky2ZGVuYoaNt2rqFHgJmNDdzui4/FHU2KOTUauwgVTTOSvboYC8ut4ixtkxkgwSQixAs34BhCgB3aum57ejpta8+0jrKxzqoAReo1ZaPXEeCWxF+Kr2dP5/l9+Nq46R6yjiqLU3yCqMz8U6dtltPZup3mGu7yO3lX3hIL7+0OnaUHijk0yBl/g2/pLcFSQvgQM9JJjPbSKwMcnQxSaPpEGI7mLKIwsUYmLg/WLK5YqDw43H2lT8nvfiST3gPWLB8sk7zEwlKhoElFg8X/sxgf1WJKwD0PcNSQHunrtccZQC4LTohadns+DixJuFz/lbqlMNXXviohqyZQPZf+WtUtSkj4Ivhfh7WrvogiYAEQcBdIBC7s1phdtfAsfwQFV4tB68F3YWgGWwju5JF8GVfvCLtNrxUEqsVqktNzhI9um6x1FAalg8eoL/3wUrdGOFMJinFyCQSOMBvLMbjNTaXGZcCxioVDcR8Rr6XONI0EN5rPe0LLO0k0NtupqSxEL5a07jrYFOnyUKwDTkZdSntB6Dm3FLdyozWE2rap2SAsh4SCgdPwlAwWMJxbh2rVdlKSvpFsZLIAKbDmmyWPqSg84tHTgGsOCmIBRqOh/JeggLKfGESbYQ5zN9iXHupaIy5E2S/i5HfAOewmT5m/cIMMpwqPWSX5/EJefS3SZPTC9o3NCyluyuYUQ9RKA8kly3u1uzP4qeLm0wm6vv74+TerGLdQozNkcoLefPf83X+g+GRudt+Z8+14MMSbbASydxMnkBbjmdZhbl2PtWXBMZegcOHBtZpv7BEqKZnbnm2GQpoSliv9o4KoiqT2EiRn98DBBeNZDXNSeFjbDAzlbgVcg9mM2OBSUqeiiQbrAgWERIMrvfG8TiIPfK39LuDRmWHBoZXtDEwVLzUaHn/gaeF8uvVYi66+z+lGQ2YjxB9jSxCcv22SJSDULASUQdtniAWOIViyVAttyC+iFxGX+kb97BPX8MMMjgvPz4l+IvzH4Mq95QlB2Y4O/Sr13VAFYw1bVwFh1KGq7TFO2uyB7jXDdPHSfXjjF4jiy3Q+9YSWb5DCfDyr4yAXnRTPsJ9NegcPrzjF1PAoTmRUBrnGoIbYJFPi9AJEvsVumysrdRZ08JAOtiE/1/9YQJKUgdsWJL5pXhMOWtgibn+iS+Ib3oWNDDf1ec2UDi76r9SXa9j2yUqGFq3/YipSRxfUWSSLGd5HMrib4sdMyaVICYhAorlkbyXEtrrJsfLUM8eVgD3rgVjFGoLIogWuL1z9LzWaHzHUrWAe1PKC39BTABinLy2/Gq1OEG8BQgxhsuLCpIxvGrYgeeEckczPe7L6BGuxP8exxk35d8oFbKhA4zaSObxhaseRQUeS2TXS/te6jJH9Gh+JoKDAJzp7AjO+4PTCUKvgCpU5O+qhnaqvq7oG3OxkqPwF5H24Q2Gi3/2xEgKecuHqKK7d7sj7vlkMzqzhe8BVy//W5YVXaDNGL6GKpgg4bf7uiQ4qiz+MGEAnJ99TKOKqIoHHNrhP6BQLMmekqt3+O9V6SpDgPsJeUa5V7KFkGwjtzLZhBo43Ojy83hSHIqfwUmiFBC71qEESdWsUc+uo+27G+zcDI2BTpjatjx75zbEth31/Y0Elkk096i6PI5tteO6gKIQ3SikcrZY3SlJWI/B8IVKAkKyh40KcvjoQKokLDY/a0mliPmbpvAmfNotfcoMBIxJWASTtXXOKavd2JJd/x/ro7OwAqqJA4CYRstwJLfAh+Bh+suSCbi1pMwUI31EgnhSykxNHZH1ZIJnGh6k6qAHQG71mOarAh/wUjA/Evgh/tA1MyHNEygNOgwqfr1F/lUHBYnE+1Q9MY9l2m80WJcvWlmmUcgg6FO1cGO72aPrN/p/va6zZ7H4+YiXmQjyGyJfLl9I4e1XC9rCuYCrRyWJxB5MuvT0x51dP5Xupev3jGUD15gAkJJcfmvSx+G4zB45PCv5y2XkNAqNf0gDj8JL7V1soAHdFUzFKYE11xKm1my2S6uRcb65tlCudtxZNqs4IzLgFmm8NrMYeCJ5Ot3oKNb9CdLzCu7qVtUGu9jvcGib7KGa7QYkeS7yLz9zF7fMXJUvWXXytpz3otWLOwldCcgkz/WBIPuwWacu5Ydx2YWywvaW9iNzbT75rKqs/3p97nlGDxI0pfSvCps60hsm7FNZwmh51PUfDcdyWZ+EZkCDswDrW2Cq1jWidV05cH5vY02g9WLDIg1gZ6Yr2WfUeYPwMPaCY29vyoj2TRTe8G8VV6UQEZlQieb0U3rZ/2o07l6EutdZAbTdKnuvIjD/IH6aLlnKSQX/TUPyocmUWydjhyRkGUMZ/+eN9FkdEgfjKyVGp2bldakL9DCAiGLCRlyLZjQJrZqovndsmBt4tTZ/e2HDncnq4K6x2C4hSrWhCUvytHuiT+bH+sSHWxcUPw2JnR8L1GDWnmaFQ5BntDMGDoQ1bbzdsJrD63mSzlvb8MzM+uVK93/4CpRwuDaSaHlINNV2xjZ/gr7QFOj+nHOeZ61Dh27QN0dOXgAN/Xigacvqu6P0zo8A1aftYmeAbthPj5sHbKw63dTLW9INaWDueIrao4g3wjH5p0Fj07K5+FIA4s/oPehrmNW92DvIfNnIc6t5Pb3XT6l96cArLMMxWJvikBG3ua9t2nVAnYxbi4iZl0Ot/f1onPy/9+5CSbw5DZYwNnN6p0qVRIJ4CeNyCGrkPZYJfRwpt7T+urufoSYgFL5ZXhOX06riZqxM4kbXdFXG6oaZHUQCvTHuFr6YhTW3GdfkikZslqdC8VqRf997g1uYQamgFZ1w+AMEqGrSx795l5LOjXY+eZYbN96v3R627PDjTPHRk3mSXsm1ADC3i7loEDLiXmonFmM8a0v6BQWy1gObnxSWqzVcHPMnIIj66sG+4fXGYN9OtKof2YbNJU/WdCFeTnPfB5cw0AcCI+cTSXvnR+np17LRc+ZFybr0eK+RhrWbMyx9eT3YLm+872z1tyjUBSjDCgb6yQH4w/s24jjqHa5Fp1f/pMpPB8coLjLkgvSEyppcAsyMcVLhZTBjOEWDRSmgmtrIuDihG3eR6jtf4vxXAhL0cOByssuJW1BsZeu9k/b0xteMHPzBcAXJGO+vYeYc1aU8Kcz3MURCJQK5HIMKEHeO9IPcu1NWdmtNUvDUWh5KRsxN1iaN12U/I0wTJlnSIk778KlFjZ8Olpn6/JH4EQXME/9en1BMuNmigWoJ/w2OSkq3PEphE9K5z7tB2Q6ZLAt61K3E+QhZzcYfvZhd1cCPUFZ7tuBhH1gieYrDt+09dRTEAiqAK9zrH4JJJiWncOxCdcXzNFpTEJipncxGggfX07aFVai05A2ihvv+nMroIN1b/TqOu0+VQS34YkxiPcTRBa2gc722/9e1gsW55jBKfiM6F/tHXNpNoDTVosgzXTisLDD8rkfvBF81s6OF29obwrE3+M0iy3UiOR0UEDp+5xYTbhISNEzLmM3q9/SJ+tsSHlv6JZa7/AG7R8TcdVjJUbNkBUm0yWMHkYzG7i2SKT8z98JfCAqwKyjKKmISGVY+qn0Gl7V/HQrxhz49SGUHx2z8jwOXUkTGRpxSxgyWXFGga5c0lNDUWQzNuV5Y536PRYbfje9rmFgKsB0UBrfg5AR4c0qk2wg9wq7vPs1RiAAHRRrd0E3lbPJaXal0CfGLReFugtlPQzRfJvVCokRyURKAa30oImS74UNkiv3UBu4A6nl+TtcB+3xmMXOLTv56061h71g8pfqnswzGMJxPdsjfl7xvceLgJzwk5K2EChc9Y4AMisOiAg9XAg3ZemxIgP66EPPhVHX43NV/i73r7BxdpDVeadrEtZ18pM9ZhubYII/GjWlrizY62U2+nwRfrMCm7AwIhOQ2Z301v8j0sulwj9iTrFW6CkVBHq1dCMybsW3kIWZ0Vb/yqdKcIxnUkmosSxxjX7UlTvL+mLWvuRSY+bzPIycLswp2lOJdUZ+cdPEPQGnSfOVlhg0iITT5ZbwVy14xiNDUb+2gErgCkWgEff9O67raqRupwyGE+VpVeS+gCVPG5J3LSKsrXnUq1tPbH0c/rbbG0u+e8zX8QU50hpzmtySFNSbN2IPWBTJbNDizltRx9KcV4649diXYzwRDC/DyydIORJYQYCCr5AOJC1c8lSP3y+H9Oz/v175d+kxT9GcRB9blDMWCxBzejtoYAd0U2htdw1vHbbGHkrwifVreHy+JJCsWjol6Oxd6Rbx6kBZO3LgQDQJIj2QkX5p3AixmiTmqw4srZNYPzzUhN96aABAVigaLh6GXtxj6dlxG2wt4NuTjvACMDnEFJ7OP5RRj3pkNUq8rrNcC1l+x2XKrajlNeWkSUdYI7hQSYUL93MKlJK20nlg6OGrmrR3hzucAjWzZ56+dQKc1eOhJFD/Dzg7ldFsntd0G9KF9jZGngzz8J4iFm/fcZXIqRVUiKqDmWXgYmIOhSm7WAXA3wF3zsaWOSMQJ1Dv1U1v5zbpBXtJszlGeN9GOjULS5ZFY3RswDOMPgUCpCEsrsaJJoVz+IEUD4rEQn/IJ3OYZQ8Y0FNB3gVm7T1c1odnLgx+Fo0RylwsLseS1BNIDizTQJgJFj1kctqjK3OJzcQ9Wp2UHZpzkW9rxptgtOT23kgeh4791jbPc8D4GjeBDDWUA9Czf/GzQ1k4L60H/MjgAuDlSeJnor3zrEA9jLnefuSHCh9++7s4PEyQY5eujCbbRolVbuYcXq9ECrohTGlHDp5iiw6wR4g/S2sUN7pR37UcWhqVnvWgq+l7gP+gRIWrnHupd6SpdqmT1L552/BgVzxu5qfEXG/IJZE6L8kUi3QjIbYWhcb/Q53q/+j4HvBZB52M6pvfg5WLuPJjLHKWcwz7LnQxmsjyABnH4pmOspMV4RPCQeveahseB9LmnQblsQab2iyDFtOR5szFZaqj05TStFTt4sF++Kmbe/rjYcMmb2HIrwq269A95bCUqbdagxQD8etcA/YfCYZTcIhlOZg0dOMncd9opzVgRk0Zd54Faxd8E4F+N1zMczFI67fAys266/aL7eEy0t5JcR8i98N9j1Ia7SgXtf4P93rspASewAFlQ2uWSyripryd6azTrwAmUKjza6IS76JReza5eKE+N/hMxzXzGTcPkmOxAhj+Fn8h0VidakhCXHZXsKfT+S1M29PqMXquQHx+dNd77958DmiE8K2NXhlKjxr+TATcvZbh02LiEbKHzAOBIRJDJiQltkBkKObQs2ND8WHq+rNdhSZ2voydpTyOOEtvC3esSpOefJl0CAU006Hx1mpK1ely9fMODA2ZKCxsqwhE5TWgAMsd8Mk3Jr6EvxwmHgR+JoxmLxQr3TNz5MywIakazC+ZUeaef8c6C6YwEEuwRX2vBOKCmZBWtCc/ui09ojsJrMPsdMrLZY89ff91vMqAvY4HFEEv3fstlugLG2llbKzhdDiTU71AFcnFPcypTM/mqVkpYJSPF1F1W0h/TKqTMfHh3irLqiv4/hr87ytwmbSDcv1PlxwNakXWv5mI9qujjuEbzOU5m8IA2CJAhzE1omlRFTWZckVI7hB5VSNbMympsOu7o27ATeb2JY2aFQc5c3gwVZLMQ+RoZcUIKwbfWujE7D+2fs+0Ip6jr6X+Re4Ud8N13Gbe5nWUXxQtZTKU46D7R/bm+hip7nqTCz1is1+TqWLsAkA/1NLcFObWQqnTKt+2uJlrV6R0cQdJFbmlDSBNfgh5gGHCf8wURMV80hnbDMUR1twOqjNG6zcQO5SR48rEAVbiHqMwzK0Y6mgvZ5G2ym0wCgMlg7nS3Qrph6VoRfsAvrNzilC2z51P2FRcknMaUxFG/quNdFY3ApbUaknUJcoyG5tdwdgS/t2NNZYo2H1PzK1fvhzefwWQ9S1C8pexP1vGrrq0NZySjCXR9tcLUn0U+AMbVZLh5+R9aaUWFowPl5OZM39gvnXivKYq2PRSLgotJzUvxV4YWkiOujzx6mK4dQce2spkj/VwBfpn1bKikcY0uUV6zEQi30PBOleC9gykl22P0d1WAxLNKkssjvzNb6TsQm2aU8cDQLK4UWbiGg/im6PMSIjYjvstfW1aI0DQjvO3wR+KlvldzavlFzdx8s05SWEkyNSxHt+X+ar2M+ctTJz5P2bHPCsWl3D6S6/9pm0ISgSf3NavWbUmeypUQf8RRgQonEdFKYovjNGO2XFIgqKDOstaOafAhtLqEujQX5mWej81C7Vm57g4sNrJfrYRwTu3MNYf+gwZ5nYh4NxVf/nqwf2Ug4h5eiC7CP0he1U0gQYln7a39W1NenbT+OwqW3lAXFEtYwWMTffIhAz13hXZv5G73jKlMuOTNnJ8lMrxYogQRSTUK6GkUG0TgtbHN9NYptShrLY5v7lTM7wSijiBtwnQN9bFOqM2Pu+5kbWVeWxgmNYFmUd2ZLlkw1vKrzrET/3GsMZatif35DIMxQhOBwtb++ZYpxqLR29pkp0AAU0oQh+CS3bZ1l+K2gBhpBNVyaB5jqTkhKwIsQpjSBdHY6DvSxB+uM6eEkT3wOlE96iuVxTIxw73toSyTdy2d5LFs69T7114pAOgojiMeOzbqX/ZQcqhEQJWnHmtIl3V5IfkBx+Ggsc3Sik5ITdxvizSpPif5xhSb/XVY4geP+sqL/f4ttsbawjShvgjZZwv0Qgk8yvmKsD+bMqHhcHnl/1Z5aM6algDzLRIQ2etDFi7iaCxtNWylhFXaNzSJAlBXScEndds4hr7jx1wFVYRjjPqlx6NMNicMXNzR0yQe6k+PG/wWdDM/JvRyoPEfXPjMVMbw4VdW/NACHvJUj42rtbfBHCjJ9B8kWAiLfVp+HOzSqwx7ZPg6NO8KYFuNZefMGZrWAzcf0pxfi3ctb9J+ZKtNMJuQRMkKOYhuWjAMl/oLEFm2vw+Kb1g+phJd+PrfUAf0ETO7ucXbVTS++GPXYf/bmvzTM+aWL7IqI4eq/hvoD33mqEVD//Tpw/YdMffoum5qN3MDsMWKiGNlxH6RsXrdYNQTh4f+l97FojrlUDZHgxlqnazF6nUPcBdjIPdIGBkip+M6f3Diz0usiXRqWKEXUd5fUQBg4V8OzzOO0GjKvcfz7yl1da9pNGZR0YhawNr1iRbWHhlF0fmNmhbVgGzlGznycqTcCAs/Z6KYJyAglAfpppGPKAaBQ/t6S14RsXEir8jZrwjomfvxhnPDJte5kap2chsjhsYXE70A93AfB5+BELIWU3W6zk3JoivZ4MWfSmbtVQMWgcgmu4PfjnVE1bUlgQBDUL4GWy0W8Wys2sb1q49PFYC/rf06cMO9OYhA5vIRGt+MBDb7KTa+3SK++9MorQzOglhHzh3I+WQ+/IOe6HcMPq0I4mojg8mfwXE2nC1dOMvA2TvQExtVM1pa5nZqhd+8Hm0R0sBvngpzjUKg50e7UN+MRywSDplAOmRlAnlvmsL+eR/JXOf3KjBXrCj6O+I+NEWBFKstooP8FV/SwFTQLs/snRoDxdSHCINSJn5K8Wldq7YkT5ujqrBukwHoX38JtpId9NSKvZg6Q2QLUrbP4AoUqcSlTfqVJ8qRqZiyr4CzLy8tPo19k4YL8VIiY55eJ/rBAe6FTJ2WbCsdzbfTFlYi0FrQGHB9AUbu4syd0o6T1kbHNnTazZdphcF3CoFxVMktCrpZULZLww5iOP6J2JXXjdIXD8ZFjPJew9Aav2eUQZLP3ZgyVgJ4sMZkNgcDLq+rou9AMQvAae26ut49RJnG/JV6hmtftk+gmOOHX6Vn58C6RnIslvov63SiJr0qA+sslHWte/jzAOIyGiIEJ3mE6xzDeURdpFsPiyrkf2Yhak0FIqtFVLaQJA5GQBqqIQGldRvPIluo56Y9i6uJYCrjOCzkRM+xVbjG3EspMPirCHP9x0JfCD61RWJRCjZ7jfVbmgCTm4t9u3uodp1DyAQPDiQlHBGBQsZthjwVLdnHHvA4uxjyTiNfZfUuVC6GFZ9Eqwzy/VhsKVoi8XCVWoR/sNwDiMge4QQfGuZxbpPZm7LxXnBXp12qeWS8MaC4kXjcS8iuifn+6LXZSwBgOS3llnxGoTW83ZorYisOdOuR1ENl2p2yeBDNndu5vC3DFr3q8IaNVw7kHD4xIcf0H1tHtrH+B3Q851dIQTINCtXtdNkMroVR3SMq+hqsIh6dhWnNIdAQU6z5KRAnsCOF1hItxkYEVNHBEW8s2EkaLMxuBCk91nkPv711hMnDHPU9nnwjK2LYcJupF61Yt3Ekqz8BFhDH35at4x99FKOVyB6KN4enEa4YzVVOYUDFsmChGh0FuYlruh9ula2y7ldoWM6ABwkUkvkDA6BoW0CYbC1YaulGKORmWUki/1x+TuP14HBwE1FoEg8rYpwroHZJpj4FngfYZelufGw6z07mxMkGQR6cxGBXjl/mi4OAWd69CP/4o7K2p8AWqO47zk9BXoJRowvr6NIhT9vMVBEAgNY0CJWqxUFcP6BmuN+cOKAjsAsjOsFv+DtArAQdkHJRXh8UAAvXyR8FQNiI4EQoR+Xh56ipKJ9Zi/uDa4kmxMQPdWV3wfZLWkRMmgy5GvNcmmIAaus0fbnxXO8wEhjgnpQWOcG8qBgKw8ZYIhEOtoOobGvYx0XNvKN//sEwASffi6G9E5MUOtvSsCxZBXUeimDZgD+6H4/vWv8zSWWpqXeJyWgpL9SmVKSC2CeEpYtGFHlCxce3bl0TEWzKh0GlcbwcvETvRXpgbK3OV1ysCeSboPImmuWeoPbIQ0tr6eNUH1OGGVr22HHDrAJeeWjJ1mE3vzqzKStvbkus7L09TacHzv2oxkrC4u6mUf0xjfOiC+xOqtYxfzTefw9S7xiwqfElqI9dm7NqzOJ+VmeHv1s2lJcRYM90B4pKoKL9vgSaIZ2L8dIBrrqjWpC2y99xa94lenLiKOUzPQjOTd88AtAPaEVB1SO5UWv6bgDP3zn6ehHBxicSUDnhxtBVaeRrReq26v2O1tqWiY9MaHpRZRirci96UmKWp4iL+v1Ktg0yNgrYF8UCutFs1DjeUn89nKOwngyh8WWY2iiFkFsfP119thgKPkv8/9yqPtp3M4Aj4ugqdcb5fF089PFisYaAD35Ph69HGpBu6hBajlrFSkoPfj11qskOid+mUxw/RuyBtcSVCyc0X3xmlP8RVwQyYErOk+/ENHLYRTTS/Y94e2ZdmeY5sP3Qwgff2j0yaJq0xQflU+vU8WtyHp1uqj/iUCphPFv5WHnya9Zynmt8h4r98Sq90SVdDJaQDAZ9tCOgSzwmgRxEWuqX2zFAplrmmm606zSlhmmqPU1K02TbkN5sCbAIdeZ4UKREz70PReVgjnzzuWiHdszmtG22ZQOws97eE8CdGMw4M2IPmcKmPHLm3oVho2ouETTIQErlUvdPQQJZ0jW6ZCXbaF4N8MEATepkIuNuU0czgsR0UXcBkSpYnVMYgubG01Sif7gjQS7K5PknNoDaWFVi2wsg554QFJWV+T9eU7UMvbCaJt7GqUbIQPqPdO8DA9/6+jUq6ZUS+b7n9tk0JF+MqAqkG2lU/BLk/viVj/qDucYpWu9T+8UeT2olCItv4ap7BrGYMwgA4U6L+TE7jrxMBv2pLJr7wpqYJHtql1e1OMz47Cn/ZspH5tiLhbDnSvHF9OfONLcscXvwPZ4BG3X9WOy/IiOak8VdMiO0xbpoG8EaiTJocOrRL2TvcMIQ4sOSJgTd3MTXEoD7m+wdO9sgH5YJlbj6+G+ZVNjOI1pkioIVIORzDZSweBgWFVWW+YBkZ+C4xa67+Y5qPiXutuAjEiBg443uNNHsVBXGzeMapWr1zg2fwQH/Z5EB2UiG/tF1TbWuRoKlkoREash57GUB3dZCWCvUIw8c6Gr5kxLpK87CJbJxGXFL3KalmYG1s/Q2F+IdR/uNzIMwwbssYCXIiJ1j6q3tbbszJrKxCxmRIriYrQAK5Yn0XE9kg0vi/tx7rJum9rfJUurtfNx2nBgES08GVgWjMVhGX13QQrEgVx49bpF3ABR20PSIz19nrUnWr/9VUwwGE1H44OttXffY3dy6ruvd3Hrv3xfBRaujuv6VDeoVpCEX7wbDHld3Tr1XAm0XoSHg0yhbCRjsEMnwHVyTGjJtir38v0Y1HNNuZQTZb0tQtnDcFsLAou3p8eaLuXmOP7sIIBjxWuc8W6JPGB0ABTH6oZ5gxA/ocHHkCAOW8upC85BvsTfK2fyDWcXRzEgXnszMHUoaqnxntTAwEl+Bi/fjEqtttE1GBdFGZ6sSkLHYQP4+5VbFUcu5v1i9RimSSmEnykT3++5qtv4RikYqBxjOAXJyZzdysXR9/kyU1ud9OMRJ8IlZKYqLo/N3KKg4woZyscwSG0UaVZ/uob849AOjfVeAenvGItRGrPWetI3/KBF8rpAqE1tYxXtCKyIxgVCIjJH/6+iYxJtRKFbEY7L53pR1toRRSAimNLxQUe1POA6FgiYtEwPmRVCTzi+FHAKJftCpyh+ujV6rleahw8mafAIK+Ro42arGcNyDUOknSIzpZ0BLslcocUaJ+53wr/V75oPnY4QXky8dj2VGjuWvoDXbJDnBToJ2UB02Dza7dhLaGKGA1PggYFD/VvV0O+oXYmHynmP6vgBYQAJJRSVQV6zsy5CPrPexAytwn00g4QxtSpYHyUNlGOtESHKavuOW0cMQ2bgxV+cigf+xfbJGN1xwbs1ZvnI8zjNpZ1PDjJqzucBqDErGyzeEl3wKT7tiKmpx1nWxwCB2NXBFmvZm8knHqqR5PM1PT9GVziutsU1QSVlqzaFarLmxK5RrXAyQ8nAonz05n/L2yPSWm0AruSq9lTv39QB4Oizm2RkOQ8cJ5VCDHcasiUdT73spZOBzSDDdfZcGbsieFO5x4WwqrtV7KLPo/vgbVm3S3k+89SKgqQomJpXEaWYJIDTU7c66dpvy8X1zRT8jqj0+KaJW6zQeD6xfaNDbCrHcEeJCUCD827m242LnvGzgnYDwLNvZiP2roeXS0imeGSBHlj9y4/2bw7WiC2VCzahB9/J1BezdS31dz2SD1r1SD8iaGO7BUiYfoXADPK1jE7Eu2BSPXQjRqovr2gd2fIlUomqu+R7+/Vp38Wgnz5hTWN8pCajCWIvsMNuOSznqtNBtaL7qw1YrI1QiHiTmfxflRqBCwbVkQySNThjll/JG+na+n4c8Z39ss2QTwxOBVjG44eQMBf/0f0Ss9GJlawx1w3y+zQcQSF1vmYX08AZGoBJOP7Q534Deb8AiLNl0SFZmJTAZKv6tKrDCWpq99Zb8IFhNlgcAd2dJ+iCCqsEKyYFMEwHi0/hiM1DdZBUMuampIZ5cAuVpEF1HZ+t1nn4e/WpcDtx3q3cwL5vLMewAkp4S5pLt3CjfGVn+xpIpp+PgKnTTNaM6e17tEdzYIK1EdSd+IDX8Qe/LDY5PDnTQLSUelROrDTT+QiWfqrb4tz/37Zqfm3hdYmXbYFWm0H6bEedTVybqzstjUQ80iYIfv5REgp3k7lZ3Rjz3hKftmxnFLQtxtAaLqfEj4iM3ElE+uuoF788YCOKG2jGyiqJjuP15MuGIU2wkiXl1vwk8NoS4puZ1NGct6tQJWFlc1LJ8/kNwQ37amOqSORYBAJoHWb4Sr9uV3jqsq+DFTsy7y8qvt7LypHoLyw7NX+h3qKC/NfO7qyO5RI8L7raAeTtwUWhlBaax5kO5kbN6xtSjCEADuTWR/lvZzaLSQ/wM2AvtJjZ/qpN7A5YUbE6e/xR21+gnG+HvjCTN3otP3CObVCK8UtlQwZKEoKLc1/ky09iReyO+u/l6Ep9Bp6tcAyyz8vZBaJ/RR5gQ9JWpRQdy294LjQivbKpCz2jXcAZcOqGUPJoT7x+Lzue8Op+TJQQxFvNo8LBM6APAvZV61fXz3bh7HqDMtzeNiRhd1qab3tZT6YB4gQU7Q3TMBQdwTtHrMs+0BzVeEtaSWZnntFUVWqZtpcwSLfrJmFFsyNOGHCgt1z+E5onliWqNXIFyvOJmimM/cd86/nv/rZAolAxO/vc+gG8TN/P2+BTE5fYU+bAfZNkVDmGTnA1WVxRPt0lGRr8DEBEdommq2ZU8RJKY2u+y0g25y/yXTqsifKFICqqmSozrfD5xoPrQ0wbBWdn4KMPt58YX4g7PwWse2KZswM2UOJf9ZysQQJ6wnmviptfiqdFontkppa6klKM0nDd3VdNJ9sfCK/qpgxNCawIsVKt+JcIuZQ3mu4LtjvTp1MdmIEOvNisNuKei37gQC724/9BcIyqD8D6/jKUEx6TaCtY2Vyj+xujneC+L9Q3/hLp1vnn5CXnPja9MbU71bGyEQst2aWNk1Lh6V1FymcyifhDfUApXfaMNsMrLxlK4FFyQDIM/jFvMzMQ5NRWOI6UlSlIVhnRZpRS7ZTYTsbWZRNAHSAr0LozzlpKhWLxEbCwD4EJE37jMagTwijc6hQNq+eGh6j+b6T7ZXIg2ASHshFwGys7H8y5Bpa6L7/GFXCYaQhDRitomQ3GCGLWxX7WG2XNIDLLnrR2dzttB+isy/CkSAR/P06o0190i8EOggAbETpVUz1fm5Ik5Mc5Lsx0ZA+osvpywlSuK2x0BQitOc5MmietuGCCgdp9HcnVcOJZxXLlPlrMeUhU8gLUGr4xUP0NrGu7xa3YB1qHOJzON89k1+Sge6AHC7rt++t/THxjLbwQTVomwPuaduOyvm1ozOROALA2zUhQNDaW+yd+2XI/xpu5GvwZLJTqO5fzeW9CR/lD4NzfR+9Gmry7ke7zu5RCf6dKnl9tk+y02jIteNjrlfQ2p+tpMz1U9tZtLzqDBWp8raEN1CjNSmU+c5UauxDnnvUlBzQ8LWhYG5+/OYkWJHBl2wotnJI6rsDWgXNWkYLJ+7XxKdJIg1JcS6zFZZSNXJBkNPN4ukGA0RKibtqHppuA003NoewTMJyOBlDfM9r8DHVtRRIOr8PgV2w+kksb3jecU0Ccjk95Z4gR1JddVjDQZUzT4Pyz5TnbXq1WK4LO4jFMO1WURS4hF46gz6k5kR4ECl7ADBS5YTlZZwvSIpEFsrGIowFeh3xMifUuQyozwbTtMH1YeQ10NYjyuj1obp25+FYC369Hn3mBXsAD1h2kffdDZZR+ltYmDA8YAUNFGz4Sq0FZNa5nPeKsHi39tbptFBIrZpNkw+jS1QOqeaK1vONRdnbw/9F7urMH4UUP8ai5Gm5zUh9JKhPGt6+TIviyb5TlOajzazRXBNsSmc2MkywSCnJW2zQV4xTLjUUH7F+9hZQcrdIwbB136QTVfU5J9/NXJw1e4uoSNazXgMRY36YcNhStFA+PJR5+HWefBvg4Y+dzLW7XSTao1+K5GiJV5PeTlSoywB9zRmfx5dlXqUml3TqLmsZbIVqzOaUjgZ5J+o+tSo5jkFtbfBHH45gWt8vIz5DvxQF+cGU/d6o3Mr0h2j6P+I9D3yFb0+3gi4Jptk7pTuX/0JyFAHW/GJset3huaRsTfJnKh4l+3/E69iuHqu7F3/L6nKcb2qTugIOl/0HVYSDR5eRzXVoCRhE5dnjmGiWrng+fiaieJK1xWE5skrd+s/luSDOuWcFPnGzdr3PcsAQRRp7bWIhvFi9vFAeMsFLzrQgDz5Q9sZhC0RlR1wPXeocs8tUU8KglF7lnyCdy1qqsTxolHghXGsESIj46cSOw+n7w8b8NJAp/gxukdiHuOPH48Atbu0cHc1PvTFg6AIBBseZSRQeJ+RzTA2QWlwCd2uf63ur098+fjgrUto5xI6KfUq4yeFo//Nt8Y3+rVPDwAfQbYYHzGinU99Ul37PAAp7afY56j5NizznBvsGGs2SpIWgdWXEbjOiJ7V271G0kiZQ2uLiuyuyrgToSXP+2a8dj8mvq8hd9h6r8V/9yNEnuO1Jav7kxB8vJPY8UuayTOoDwyCyVdD94vGsz6StFmv9QCz88NUrnrxKNPJ4a2CGufU/LQ20vFH6v6kJuAwoqRzVZqzcBPBcO9VcIHdDMqdfD0CAc2qyCigH1l8y8CrBtnCWdcRAY9iqWwjyaQUGC192qm6+sqRkn/fz6B3LJen129rnp9bauRP/9Vsk90uziL3JQlM0pBBQ/r8Rb7aL0WCekAxDgsOe8WXzR8I5j0o2aVrXuuYhm7rLky+ZuJmPv5NbUpjJy3zjh4P0D6Hm3ERo7Ig+aD/msWLAwlIsI0h6WjaO4ZdjJh/8/zrHqU1jzI0/xhrmXpas2QnG8LVijptOa76ymzsVNSOk2pzx4xKvbXHCCNZD6NLhRH9Jfe13g0f9BlFt2xbvzFO17C9iTiuX0bQyoCvDwiSGZpqQNHHmTX8Hr4RU+RCWe8e9RLS607GBqQSxtg5F1kmM3POUSkpzybLP/ObLccGHNsRT/XUrX2ymjnMEVH2s++7sPYiZ3qa9cHH47957HNqrIbypBO17Ksz9Cbwjh/DmdZ6CgbvDWAUrQAwdNeQBEDa4VmiyGeLoMC7Dihc4DLlUBoA7AMwa0YsGzZ6vAvpGVXvQKBy4pAEYnWOrkLTGSf+5baKcYQScrkd3jKe2OK4LhJRsqxFT+7jSYQkDvCPusnKgF+5lraJ53ht2hPDKuOp78jvl9R4YF2wXa3sycWoBAtDPGHA6CQSvaBbCeG+z1eS4unjUbC6y69PqiuoA4PP0ZE/Jr8bJXf2hwCz7Byf9h+pxAY/41UNgMypz5g59FeHh2kmwy4jOtNl/a74OoRgZZj9A9OHyEFeq/Dsr3aUzweFWLRyTjCwpVhWpfbh4YJSojjG5e7Lry9U/mzHUQL377L6/fnbvxgGwqTQLlMH253nTZ4L+oYs7mx/v0CIgW3pO8Abw/1zwa0EI0pIAxtqDuLiCnMQWEmmYqjeax0f9Bft3j8ogSaWRtYpkebUP+AIUwNGmoNmSxOAUMsFKe5r5vRzYg600APcc545M/24gDGjHUCXp/w0DnyzYApWQPWLpA0suCPr+Aa00z/j/QM4SpXtv/muEdWk09oNMkekZN94KjBAKyRxNIWlPWQNasZOIMTTmkVu0eKyOIL52tCvLJJ14vPxhQOa7gSDhHHQj740GtlEcCEdJhTI1mgPNfkW9jTt7jCZex9MmdMtGf7VXW966uAye03feF+XeE/pZ/AkwHbISz1fX5+dtz88B6fAQOrqNw8VeeFSPCrC18nrJC1jttx+AoO5ksDqJ3otSuvTtUPKXQSNPDp4DXoOaz1y0UPh3Z36E5BiWfHHJ6Y8P9fFuGOvMB35qQshn/U9Dt72kjDC7ZLA11z6sJG3+O+UbJJ7wGkjLlUGn/s8vzGiRM54EOW/WRkksJpLnx2slW6DvKCTwebD7pprcPvdtDBkUGGEGFP7OqyZG0YHGc7cQpRchT/LSGqJltp57TpaSrJXibd4Y+kjYB516fCLsCN9zAtNRFoT9wTkOkRmohbxF8NZPdJAZt1i+/V9cf/XHBu+uNXIC9ef9MfjOiGJl7KmMNaUNHGdbX5vD88n6iBHN+5T8B1IkZVaQprv9zPYKNLdtlhtbm71QgWoGcwWgxPr9KtGmeHF/shxP/L8JEQfnW45xSPNnUDl8CniR4G5NNvc74ZX0sF7ehWLqv/4DPT3yT4Wt47t0NiPdgLRGOJ/N/68mPsPwhTGOoXeGw5w+iaUa9Otq6KWPtx6Yz4qA5+rm5a/0kz/f85kFBC8zEPCLVY2rqBZW1ni0l+im2yXkCkrIAMkjBpC+3645aAdG9tNUhjMJoPkP+q6yZMmJNTKAQ4yqK5daB7ZCm6x/61WmbPYDUfmR8/l8nH254hOqv/Lxq5dHxKkapMeURlKqSwnaok2HS5GjhDQBLRkoShlQTgIG+9LEBtSmUlIA47lMLYM0hSp+OcpRCtwKd4mLZvZlRBn+t0wTfkocI5MknPWSgv3GRzo7R+2Ea2l4DkklmiQcRRcqdE5jmCyzhijxj3XSnSbOY5TtFiCuEXte4s0z+u4lyysWc2zObbGsakkKkF5yTPGRkY7TXsWzdfCDRDkVxm+VoH4ZecYl5BE4UMYRYiVwhm5DJ2oGXVOyHviqgqWGJcSnhY8QrANSSTX0QwmYzUuYYqOM+clr43k1YmhkZ+lZs7Ur9VLA5MXZeTPgUmEkR1Y7MayNu6sAe/Q3prvmxuXPN02/swyQ5yCblJ9D5SU8RgPS26KHArc6foVK3FxCSkaJiNN1DKu1OXMlXn9OpXUsOv9Ihu/RU+OPWIA9GTaK+exxf52exXPcqbJM+Ig9I5ZyAwkWgo124Ri4gujaZnOCB8923cLriPb7Fsvk2YNLllifgtdoUI/kxP0YszCz/d8hv7RF/+6Fs6zMnhlElCmTA+6zmmEgjoO7KCbWO3fdT497+CFl6IxwE6LHf7YRrDpFDEs+bfVCP/5JWGnkH5vs5KZpcojSF19SIwtjEpMCdsEYe+Ylr1SY4MOVMPC14lA3k+IXLg3bJ538sL/LFyLQ5FosPSy3dpw7fach4/olMW7gqaFJOzssgAImBnjhAIuEBJxKxncQuwrFz8veQFsFsXtthfS9Y8X/Q5hxkR21v/4moQKzhCJwRtBgXveBZfvZhXOZjKXzDf3LQ63ehSveSqSnWMWVuFROQNdV0L3qBHvNX992lU+OikaB8a77FdtBQ1jNjcy1DIFXbLPu+CBQUITrChJTsR/8iLK/Y+G9tuAF20QoBmafzT2+lBNF7nbvqmrmjAXQnbxOUom1qvUd8QyEv7tPnbyrQkMeSwy6oClZswyY0LUx4xN4A5Ac3tqWXwr7j5/D2Es4wQfyHfFfQTCQQr/xeNb2gYkNKrDcsLGK0H3nRoIMEPo9B0J5En4I54V2JREMg5uhChz0REPQTTqLkRn6OBd6hexFF9/8RMyAGyjwJS33KyKG4vgNPPuUOburls+sof7rS0SX+JAFAjX1Wf5NgOj0ru6x3NLUAniatlFQczBonqjEmqvIOccM9i1vu4eCQSR3n8k5sDTy/KPdaLDS9WCptJriO70WPUte5my78Qb58c1VDgECmCBO1o0HnPWA3ZGk4CxQqb9Gh6pmcEPV5k2OhVB/IutpuVkOn70liyDX5JBlr//rQE5lyoy+sB8YlxSbOyDinrl0GhIzE91imGpec/FWYr8BQmtxuXtD5JNZWC35pZXI2OpkOaHxUbBn0I1wdWzDUdGM3F5fieX37Vdg30/cvFbR+E+u/5PVuHbCDArkYIXtN723trr+9OMLrseQ/HzvNPKdtUjt/moJj/qfTVq3buUF1lZ+ieL4wJSwxY0+hWBI5Z0r1rm0dsHAuq7kTtN40eSbrQUvakew3Jv0lUp5rLcpz034/kf0qJlhM3WFcFxu/u/rTwHFE3IEXKE4EVzPGcFHdiS3ptMByeVEpx+9C9gnXzAAbX89bf2vVduZcE/H2DZr/5d1WUj9VVz0M0NyfSWDxqQlxr+fl9Ad/0E1n8ef6+I4x2rWaNB9M7StBZeGmARNlIqH417qu737aKBaeUwliQYkmMUUAF+I9gbbjY92tfquXNxWBHx3TBEo/1VVnEvVw6m+00ZW6jJhvVdNvwJ8j+UgpjKQL8/kXLIoi6w+zHouhG+Y87Hn42On2P67y6Mz+Evo4g7ydTDz2lL81w0/AZDwEjxcetsWOqdOBwq7GO70THn6gaPPjNbMJjFL9rd6Tqjf4LSY8BZtu+6eWY8BhMYP9scHAqg8CI5qXgtGlByBfCXa8uDrdBep6efLyaikB3xwCy+8wzRHYktRKD1N/6rQHqpc/kG7PpmMBawUhL2+sn6vLK6Miv2TV+2tyLvbgVtOX3/0daoN+vNiMLU9rcfvlAVUxHkMatIYlakVNFiLqXKjyzvau/2IpttSV6crLxanAPKhBAunDR8f+9EBL9xeg2uy3rs1fIDQ+RmFNlozTtv0HP/epQ0V52jQEizi9OR3rIqrdaVst5FXOQJP5wnGM0IivmLL57DiAsktnsnMd9NGm4O/UrEHvMFPVEOqkD3IniNWj2iEOCStaC01XJb2TeXclK3xWgPXeIlgWl/rfQVCgi6eF7FrhI3UUoaZ6bdzZlJlFKVjcxEGokz4Vr5V1zOBmJJfovwr9GOrCieUMDRrw4BNb+qWMKRB50z5wf3+jzoaha05Zxe/tAEhUjFsZs1wuJR8vMQacGnDhnTcanChwUp7fH94JpLlRU3Xe79GRPQZZsXlrm/GfdMx/D2Lxfpyz0AeACvPBeyvaA45uGR+R6R3dKCRmxI/K9CZtY7wa4BhIUw7wtqTUw/KoOFkKD4oTiP35X8OVqA12uCC69LMx5/YBqzOJ7MkFxnHJrDxDS1EgDFe7HOxY+nGolCQTg9CcO5QqT81Aj0iKs/jz9DbKmFN8Ckc2kN3OSgHA01BDP9zUDwTVRBntIDb+Tj1E29BMdYk3+YdKkCez/dhocSYRX/T7j9s9xc/iaHd8a6k0RATFcj/VD2TKNi4m2Zid9OzcdEFi5uQ+ppAVsu1ojwQjFMq7CA6hDYqMKo8YGM9EOtMv+E1I+KaUnx8b8N86cte1oW2D1DjSZ7hPsy6MX68w7av5SJN80b+DLUFZS3eS2TvRPwYKT1ebBL5WwoOQ+ZCRkOI5LWAX0zKcFo+EnGdEAKU+7h1PP7jTrtB7iQ57lZFpN4o92DaZSxmI9SEko7+OivBnHHhToFKPprbLDHqoGUqNQz09fY9JkjNjHDMQlAT4clT/JWuC57x3u4QrGAasM/eUjq9xqt1nrR8r+s6tp0d+eYVgRZLaOaT4Ek4AmYViKlc/mDQmzzAc0dwWOyYYekp2gIzoVHT87I55PguUjlad8y/AXZ8z+Kq2TypuFHyn6pmUycgmXrM+XobMTWrFTEvsKV8r6dSeXkmH/RlxeuVGsBx8YjhsaAQMuiWoxyZNgYvgohmE81SSra3sES1lyGQq7qx9TBWqrJflqw+ofxPdgYzoFfqFoEBafpAiT7nohgGRETAHux6BNHQAfxiqT8LxJJzoMi5IJ/LMUXPyVqQJwH+ZzniZWrjSNJxBPnwr86xdhfT7cz6qo5n10uEd8a+R53u0XvGoVL5vf54BXTxeqr+DIO7rARl+5s5DRKiF9CZL4NLEik4DzVCxtNXJdFFrSFemLFOMFTWy+fJsD07ivbzzelPRdO1wfmK3AVU6d15SDW/1VqkHAywkydiZitcnDROT339B+crA/RNVzRUlzfQVgowrSH01VuQJD5/qRLlL0/JG3lj1+2UptQyjYpCa1ovmsDJIn3y5rPVKkJwWGPsq0gT++dTtyD+nqpoRqQktWRWJSKBx86YA++2Roun2ZqkO0XT2+CuVsCKVx15BE6MiOwp5EphIuXrnCm/RKv8WQlJR8ocUU31F8PMmUHidpnifwRX6QGNh2RlZkxtyKHL5n7EWuBGO7fR4KuPRT+oD4ubxMZ//04z8eUkiY1DPrrqG6bG9POOzzgwidAz9BfUZSHuLlL4pBitmAU3cPkx7sSeVV4mFJn9NEFIGwCSWrTVq1FteOicYIZcFyrlRxooQscK48IdzUnqESwrRxG9sJ9IvU4mNVqQ1kDK7AyOsUThf4fe0hFeIUOE5TEqpxOrY7wxPYakIN1Emu9h8Bn0yQSuAhOscY6sEjQo92nj0YaBTvX7UsuKC63NC8ZIEaL2sUOwfdTF3P1k0GedHSMasNnktj699rEDX/q1d5U2gG0uNMFrk1D9VL47ZNqBx3xuMYaQ778DEHK3++h9aVlCOTajKGyHVsUrZqYFZVfZPiM8He1EzTd9pkszcs/9t4xkLGtGqqteEhsbvgAftAK9gMr1V2OuZvOSxFTKkk4qqlxWz7xlAsqQkNNCDnREg7CzXAeMtOhL4G7zfYOAthdBhpd6w7E3M9g/GwT8A+fyH31AQ7qrRt/jXBguzyxXpAE8XcgJPhHNWVGEy4WIfitQhj5ZHpMZbABD5Uts45nrLUzbdMWGLNXw+gPVr8D67p8Z8TE0t8zR5jrtUD8MKPwUwFf3DWB4o8cQRtvntX+2pnxXMXHUz/N7zoj1AEBjV789LWZZPZ4BJ4ONQrt605xwpnHOUiDwCdzfE1FvD8kWV1EQyQU+wq0NV9moruNW09M3VTGTB/KLv5ws9lOze12Y/aoUG/HP5tqWsf4xBX1hC54w6v9yjJcQ+VEN369yiO48Z9sExFSYCcKkUt/prQoF4fla6rp5dbw3AJtNgJulQplfIdfavO3eCIDCyshv26AKk3AlcwMfhhj0d/HQw9oSz4v96Ugx6HziTRW3LcE/Fx6SBPp7Kj0OjjXnEJEFEZWL49buxE4conKb0jaOR4XQDVEY6LhOfhd+39hPkG3gTn0lewIC8tobRtCM55S6TV71S6y+tlYrpayN/1aZsJkX8wSF/e+u0f0CSsgm9Cica8GfPrHtan+hgMWVWO4RCm9mb5S6UVRTXHgJDWQXtPMOzsbLLRkjFm55u4qSHfGq5zs8wg2afjUD3+f2FkFVasENUEgmX2LaId5OE2u7Gbjaks9TZUEVcUpmfd+U+aB6N8l/nHhX0fFzWNCpfTZ0vOkBoxGRSWDg04im0qPOL1/EcMXZx4olgAO/V76Ef8/lNExU0rlLftiMPSjZhvR3QCeG9uYIuEgF0aYeclPn4DD8ILfLkgjXfwBzgv1PSEbfTpbsld+Hcc6XXsRS3u81NzIL448fjVROOt0MoiyhL9ekdHASyrNOhXDwmuQ72iM11vo6N2XAmYZWuMNnfyx6bQ1lE/bkfnN1kEnb/QLvyOpGlJ9i9g1waApgn6pH9OIgEMOpCba8IXpvVJgy2OllRB9SyAKZJ49giBcDqDwiIfuGkrM2iNgQNHaN9qIyPzOqsbAjiFYI9itAGXRvhhDAbCyBdFO+bvFCF9vo+dDcHlqzEZB27sKWOdVBAIA2zysG97VzBX+KtAv4uCZlX4THDcqqSJIPnS9E7VTzO6KuphHseYtwFo5WJNo/J/V8jJIVt1NijGVgGtFpCI1CVO+566Ygp5JlIcDwgaFxfoe2Y0xv4VeA+CvV3G3twHmr3tiJwHS8tlu82Cdc67hIRqG7/9GeU6UD4w+dV0MoIulV+fAMJBxZi6LsbptgObyPQXcpkud5zwqwlVByXY6AAMmLcejWDCBWhmQzlRjtd9IkJ96ElCMBvIGxDz5Xea9scTlyPGlG9DCZOdMMSc9l34uE7Tu5ByDc7rDzrsMhkbSNEWT4FV99ORQDTd0PINBXgWB73dyybStlYxdV+G4FrsU7ZBFgu8Bb5gUJ7PZhTM7fLTikITKXYbDflT4Ifxg/McS5138572xd7mazsm7Y6lSgee7xMh+8HrBGvpjXtmQ4xMHfB31K82XyHaJG6D+pEskCtska463EvZdkx8sTwxth+nakh8Yp5LMsTWIyEveFHfy+Et4CDlbil0djmtjL4IxmlydVmMkyw1lmeoL25Ijb+9JPVizt8637s0ASe07NqN8v0G2KIZPXqoxxswb0BqUo4oA9y4LDbGlH4W8dm0iJQqwWdtqCyHMyFehlR8fx7ZW2khpLEXmEb1fL/ej1NxdNpBVvatRwqR6BWbhty3ihJPIrRVsPBIj4ENK0LUr0Di5WDD6eG1kYffE0h1AxDBJF1aPK+qoQpGW7svNBRixeYEw0usU5fXLLWKOA0zeAGsV616uS3eFBFffiJd8dzLId5iRPsZ8cndEiORh2mlc6zG4rAbMaBaFBSEja6WwJI7AJFxRACI01v74n11A8hjFD9QoG3vTAX85Sr23BFMXZAOJKNuv+/oFDLfGLVgTVxYe7TjSeg8UfOKBfA7k9GKYQo5QnzxVjdnPt93CKZlWzHoVQmIu5+DzpHXmdRXTLVHUdcON9itDz3PDtJTfArx/6XTSkdWCS27CmCef94KwZaADc9IaFTv5sqjYpgdRnT7HhF9QJdEyM8C5FZAIKBETnM06xUdufkCMJ4AvskNQekBJWU82cY6EtenouTxKyxWpPlLikGRL0dW8Nk84wgc1sX5HDsH2vKKbNEiPKJfGu5G7H/dVi5plYPzUSo34vBtY02b4lCR3EfsJzLb+2Wt3WP2PrC97dE20eMRXk0oRbYO0h+DKtUc+KziHK1kr7AkWo9rDUhnrsi5QimGMLd+fnGNk4dLCKMnsgQCYbj5KCNkvYIt3m5bmcM5M7oIJCzyEat9lhXlMaE42K+IX3Czez/F3SH9sOOybYWNCA2UONAxgx5Ky0JbxDQf3yMGTfCFpRnhgDmamlmYdg7bp5G/HtqookGel8CeYtAOjfUgho6KEdfeSOm4/+oPfsWHoTB1LAR5DeZlnOAJY6Di5BnNVBKLR1/z+LTNkGgyo0gsG8AGPMWMtVA6yhYye4jPX0+1xzrtMhqP+vUKLeZd7oxQ8plcZ0WRdnkpkxs7RtjGYNe1yB7x0mk3Q/AqNkUFd2hwL7YoC/XwOv/Zb/SV0yq7FA2csuJ+G5dYxZY1HQjc7uMVYMfFkvBhEkHvnpk6dD/plvIxVDHu0ZTX3qk2Ahkmjvm0Nbx2wtJFDp7NEoJubId81SmX5trwqTeOliBpyYl5DAZvFB7uV6qnNJ1xSogNvFRRxKSc119deeUdhtd4zVtsGIWu86eP0c4ohUxXtVI+78zoxPI2ZEeiAxJVYO1qP/FJ2NLzHGIJOkRMCEXfjpCCc/x3op89dhVgBLe1xn3BfUzH/46Ld0+JIK9jOt8bOvKGu9OYJTYKwKqAHjHPqFLWMzlAE+3IGhSq+ezccyr/d/fabZIA8ar/MbFhaq4rt1fnPJuS0tyOHQrmO0yTPxVAzyFGPonTfwzF4ob3O3HcX6lmH7Hz9OlRc6301jQnzJwwi/mAtBHEj1y3JL8x5TqxAMYFItignYirGlzEaOXwNUpojAzl3D7vlg2sRyn2o9ckdmfaLDeZO207PCVxnpEVlQ6+pB4oKut2DhWbjei1yJTUcB1v0bhzPunHL5zCc5tWxG7Fgwv5j8sxVgBrmIr++ewifPH1THsh9DG03333mjxvhoKwNJkTTFFnlDGptiBnbIMopegF4tCC3FZBdauLtG53XL8gm7hRKpUo8XXixI+tK7HLuzp8usCs4evAJ9DSrIiZo1UwEdZwo9EeS0zKXpl0E+cnYv0G8kUqhKL7P5goGmLJ7Cq2+U8m5SjiS3rSOCCSEIfFN/lOIMWJ7427dca7zOYWTlE4abYtFdKacaqwd4el6/tjyJIQOAcVjbaPyATqj10TSrcavrS5l6yushXTmbcuV4yEmAYlQOd7zIiVo+2FOxjFYxkC/ezrGD/SS7VMQgK62OJC/5KodVh6usf45qRqoBG2ELu2odhAf0tBiczJ1BYo7utec8NaSp9+8R0/m+7JpZgFFbVFsm/BhSG9alLymCo1wAQd6lWKpY4Yd+ZPwSaPRRwg7X1j4L9UlCMu8NqOvwqOr6apD8cOOAMb1iH25+OGSCR+E1fsBwBSCTLnIyuobAJKx1HLj3eZ30ya8Mmc2lz6cFEo4DlHb8WkdruFKyFgcSlLycm3+qijVEdrZ6iP2SouYTVnWiQDGrpEO/Bsrfsrr2Xi+GPZlNoongt26y6YTtIo/nXgu/ekJlNNoNmgDy3pQZYwhL8KYcnMWPoeNNfTlDhqddrmS67iS++0dkU7IyXmzzHM2TcoyVE1px+W8vwYxsjvMJq+pymKjKf3mNaD0/wZebXVLDpRffCnMUGReqPpDp5FVAShORrogbb9l7Fe60ZcB+s/FqI80eDYL+u5bOXpvxBeoOgg54JK76ArAeUoXTOvF+Yw/wYA4WjUZ4y8Zx2z8TICSEMyPiwIAbb1QQMzMFe/Tboagr+Ls4Qv1btgywpHgMFNnzngxrjb+PYSM3vNedU33uynUi5sLZkf4+sQA6vaHcN4jeLCMjxhnsF0G2xm7PmKbxq5bTxwJJ8SM4LbKA5PGFjkVthvRW+EyMQdbGkvjBED/Fxb2+kj9ge2CdDSj3CVSnIgBc5FXON7ItG9AEzY8inxl5WBolbragAth30uN7onRlzi/iGtshwI3AQdBHd7VwFLrIansqEfNOoiGfGM6SSoCeEXO6fIkTzQs0F+8RLkHdIaU8OiAVHjPZqXZm7YackWgwyTpKJdPQys5XFXSbe69vHMVRP4TXzmIiCWbQZtl0MqH/CKrmRqlr6tE7Gt5TGK7YBHLeQ+yJhwcJym6xuVJWlKHu519P8ZSLe/ioz5wJLWVVwOgjS3GPA6hpfB96DLYuAa8Wk0kN4iqXVX24Tjsg4/vXuWCQa/lQ+W2X2x13hAL1Tk1/q6UxWL/nDiQ37XFhudTZuRKbZ5A/Z8NFTv+5lCsYrD1nogF9+yXKTI8pj8NlcF8rZbTUK0HWQEywg4SAoWNSojt2v1QfLo/iWgUnQH/uBTn9ZLtaNXjkeYihRJySAqBs0gLSHXuvDnFIwoM2F7knbfLSkbyfdRR1d0ERcx+w1Tu2XiNMLDGCzXmnYtJmOlS7S/sOw/rSj8uIa5oJvI7GaZWbeC8jtQZR7G+o8U5B7N26ng2lMkN5PG7BT2V8ZwL6igJ5V8l2lCavXd2Z+zFvXAONxZSXtV52G6Pjd4u5XT6Wdv11hZl/8n2SSiquAKmEy2XgdgtaPL/xddrpRQUnytur58oFYQepmjN0JDhzbsXqPSZsXYF1NJUr8PaGeKIPh5MzFFeyuqvlhhwFz97Q0yYt7XA8AfEnhMO3OEHPNSd83dKRI2K528xgeDZtQDZXHna+f2mhlsc7cwxGnrCtVfZghtL0fDfRmomywxHDAC0b9lwmigcqocGzR5jjXRycZWkI4ku4H1ETCPhIjeIPPqzTdQrWUjsVwYWYhAyNCezx44k+0a/2NrZX4oPBGRx+WYEko9kvs7P309pbcHOSDpbpfhefc9a8A1Gnxwn3sR4dBfEPF5u+Naij9G1Zhsbnkhlvv2I0Rsy4qWQYXgcMmESLtIo0gRhRBwmT45CkdvyP2Tco5UbLoB4NgesGK9dgOFrK1y7HyhWH+Guq9ts5EWEVrkB32RuAVemJOpVvqAPA8cJ07Ey7/sNhDSYqVo81Tdk57QdRw8ztbbFSMTrvyByTw7epEjw8cKFj3z8GiuHdA+GZBJqjgfcpN/Q6OkmGLCcZ1KHXPhQFbQWiIFqqHz/HxB3hudowo7cMDQvbC8qUgZ3t4pstNW9YmbqB97lskJvYcOmgwHgefGNRkZpC1vqa2CrSmsUhyIPMP3/Y1IT/lXPVmU70cmLjeBCtn57qqkzm4utRQQbf+6gsD8uoyXj73vCbiUlG/0Co/9fkQJjHyGXOEWjG6ixM6JIsGDwSHDgBai9N1GmGCR4ft+xgrhanc5rVQtidiDp1PikfRaCzJ/e4/O7+njomyg/hIJeDtRgvNXW7bLara3tJOwzGo7J8TQam4ZY7Fv7HA2wWrAfMf1y3S8S0JK2Jzn6nTPAfS4/Dk+dUtDHTDDwU561mKvm+lRgKQS/oEeFXf3B4e1LPRqyXP22bilZIQj62C/AtMJyCNct8Shs4F0vJmmRm1ledD6031HNkkZ2gTewvl6k9DsI+fsuBETAIpOpVGGXLtAzyXluwogXhN3/dNv9eqjQ8VFPE6d7QZHQEjHSFhfoqShyYOyFr5EIp3HwvlTRPSI8x95Jad9Nrz4mqO2Br6aacuSc7iFYBt7qTrMmOaQd15YyofbQNbqVgEgL8lTWDjVZ9r+9c5+JOHVY0p9DwCvi13Q0lc+wHdL+p3WGXOeJpk2MALKZP7ERoaXy7CHcbCWbO2+LxfB8W6TNCd9tIsPTDaagmQX1uyw9zQWIrW18XhVlJCZvMDtyBy9esy4Okh28r+HsK+v4DcVQ8uVc5y4VvkqJFH2DZwzK8WnrRvFTGm8oYwC3MFiE97VR939cDMlJ5Sb+MCYoIqTxtR4bQ3A2G1MbCgk+9ccN9auKq4XqiiTNi3woWfqwTJgbalMel6dtMFLYSD/mBZPkYCISTpWtZIntm6FVZbXfrgbB/g1nXz2WgK2RnvHRGbCMeoz/HNPBoQfTnJpnHEC/KzVBwSQLw/UZo34lNPnOljFBr0xbpq4lftIdapDMAqgyWIsZ7Y63Uhl5bFSefEnPDd6bsiwfKneDdOy3qaOj4uB6E27kLcs7n6yZ2H3RqievCkrEGgtxxn1IedpgBmDPCj+UkHiECItAVnjc7AmE5MJM2SEcOrCQ7WHyZuWX5Z8KrV32iiOuudrqIlOy82xwaCNLC+mtII9aOTlI0okJDcR1Vej+ddmqQQenfqsv2YtulN9nlmE2CWAfnQkuzvVzp9d3OBObx8VJ0n7yb/0lGxRElyIGy8BKsX+INRVjpZCUEyNWsu20qKKpczqzoLdHYSfH2JgsboLHfrw6b7bpEGjxHGnZo6jZudbD2QMSEP454R+YKIvoV0MYn14nkF/tJLM1cNuKmeIRwIdR+LgULOktZLdLXKTJ7kDXZ+jEhLJEmZbRzVAfMYjkBTy4OR1sgn2tyzFoCezuBqD7TW2bGejQXN6KVKOEebNyw41oPV4Nafozy4gYkTKigkNR/NflSdCx/G6CrApC1B4FsP6S0z7687++9/SfO+5x8b3R4+2YU16LFJrlOJ2IpNf136xDg3RiT2SvMoxn9xbKnFZTo41Jnwfa2Afe3rIyvLJOKPs5Hgyp+vq/mQzaWLGzYg2Iezfrf1Z8l+MPh/wzXXukDQJhycm08SdrSJ+pRGGhOuF7855IJ4YZRhp9txUMcVslA4Zq58LLyTlv8rGpBs0ssVe7Sh++BFO87SgWmb4mTOi2hLWsXQH2SYhLU3Hc/qFcNCfT5ojIFjzM+t+Ibyhe6MAvEgk4ol2kjV66JhX6hKfKPAQDAKs357+igI9SgTNqtL/GRnEGgK+du6PppspICp9hiAK5psoWaVwleED683q08/55xtN04gK3krQbXfXMcIGw/vjIWYtUjJ0rwl5ARjRI6ipnZdS/4IvxAqR0AWnK2uG75NWpe1BjjAZQw2XQjTH3asnROSYBrDLldYxh85S4KmWKR2zK18dMBZFzUSwLsmgvibaTyqOMORfTM4BMgaJVHROgOv6W7sG+5hXLcaqvytxhbnvruLPH7LIiO7g4ZcVXUNeGzGkIftLsiKwwY/iuh5GOOE64+pEbZ2VGaJrf5KJTmb3CzKS5e8RbI8HefY/+ziNoOdPP6GsEEJu7T99Yj/cpAYhgv6aDb4KiVf0vBww+rC5boassjFB4BaqPwj8tBfB1KIaJN81lM/sd1AYuwhs04V1tM1tthhiFQnk3Zyk2wDi17VHrPZAxySOweWFlvb9bhK+PEXgzCshQLQ5ihMVtdqkHdmqfsok63Cg1E7rOXjjN3y7ELfjVM2LXgiCBXaWKamwfYZTEBqrDn8VeW0dzT2Pg1wHr70UO7PeIqBBjn0YFRYAL4uIhLsvY9gjMfeoVth4WHWRD495Irzx988AaT1wwy2VGrr8ROX7WiI9uL6NugbwZVtmD+FBGtQMGfGac8CPfEr4EhgYrFsTf/+GUkLR1kpioMqK6hjuuxYuFcBxHXjS7oyW1LJzbrDqHO4/17hIIbLiLSn5kEfY1ojpyvJjU0Fr7GvahoWkprgNNg+yQWa3wpKOQefKxYyfilENvK22/qLq7CWgfytGrbPfnTN/OGScJtP3iVOcw47N7rtkapky/TsHswAA/ztaeU5J9+SU15QFymISFbjdT6h3vQdv86Bp05noFhKL51jGl/UioKwGgNVfRNGFtpeWzdOre8LTrXizDC3Rc+BlA+QCFMRpBiFEkX887Ojb316nMMzSIRRxykQCMYj2JvJcc0aXhgmr5SVa5+T9UjOJ2/o5z+HfKkwQYfr5HW3KeNSoslXAldbwz0oUW3x6PsTBkQxLu9b6WhRuUynUSEjuvCOvnKfAVgO/4W9b47VFzceC3fmWv3sN3X+QyYB8CYUkaeBM//WIU52XMiTee1LCwStqXKEJgXtRyASQZY5ARiHrrDShQDGc+UzfD9UAtSpyOFQHTxPFrf6spKmCyzIoWW5XOW/nxWhcZFwatDGlo0vX49zs4E9d8PIzl5b2rtBN7E0YK0FE+NDqR7Sujd7EabZyKeNfNJkRxvaa9OFaq6ME290IyD9oDxmK62dQf96R4Uj0Q44NkAFLXpDFR5v5/MkKLAP42zgkmlGFshAluCZKnj1pPEpnrFFXBGgT9fOrbWnPf6hp7R8r0HnpPBr5HuuN/u2riRU2lESm8kpRD5aP9dKfQu2uGWl+8GwPSrWzCEC/13GspfrzFJPEX/PI/sz7dGEktvuNQPN6EDrRF8kylaEJrHbig7vUcAfLvs6Vbqit2yRBWERTIVfV9esNWHBEkJMXMp2tY14qE59dFk/4tw7riSQs8MbhHKytFEV7VaQYwK0FIIXsaGMERrjUX8eHkPshtkGsINiJ/qiYR3xLPtLWZJNieUFB1H5o1cyI+h/efEP0LVop/bka0m1BYQFVTh0s5DykwJqrZc2sDsilc+TB6g3BkMFUkvKNWkWVgwVGqA2MJ7mazNYzLV6uG4utHZttdfG44j0sZzDSYE5RCEnWgNcq8hMlICeSyDVJQWz5EZVjJEi9nvJDujHeqEmcnav+cRpMlopRLZlPUj7lws1IJlF5qznEwf194AyR8tJSylYtMIfNtdqfw4OW7JvsAwLnl1GUk3epThpMc/bJLysE51nDs1832IniJUFkQZhbabCjOXaG/kefCG7cvvU6W9sPqiJ7ymsjmMf4UOrMGGvxIW7a4j6bOIBj+gjzXNGzCxFTkAwnllbh4lzV4lVsUMMQTH+vzbb/9lfo+wMRC6XB4r+/FPnRcQq9hbISMSAbKh79N2Kq/pcJQ1ZWHt0KJ1DLB1x5F+SK8NUmHy80nuJaUElT0lJHHqAL27Me4a1Hy4OW6xfvkcQCdX/idNfwRm3+jhlAaRsMl9Q5mYkTfpIEfSx+i57fgoPgFpvo8gIGv8ksQnHEJba27T6lzbRQg9r4N8+iALSyYCxCTQO/n5gm+tr96gdyJe1LdEqLwEZ2DkK+LCmC/In77Da81kMYFS2DWjz7inP1s7+zSLHvJ9d7DqSt6C0lflEsYKVzPbmlPkMr6J9AFxJBBk466Bg5E3z8wNKwq631S5LiVO7gy6/juXb56QIef5Qg7yH2s0HWJ+jqmRb2PVPdKgsCSw+O9RXVIvFomL1jQlUhiFF+yrLvHY8/9PfnQaLAM/HwlX4RwfCtk2mDK5CsaFKD1wY+BtaZCRRyExlCedeEGb+EawbsAib5fh6YiufTHX90umwuwZVWNCdjyQviXpoVQYFHHmp3khdZAAvMoFs7fsGQdKxeTXn9CfIw6i8e5suTgrtF6TCF34q9ksAifEmnY6wZN7P3QYI7u4ZSDBF+YotlMAUjzBhVa50eGkmw93wBA21cCykSH9lAPklUXsDDWSh55aknebipdxxnYWMsmQaBAS7x22FHFTeQBasYgQSodWGiod9PJ3B02lol+P+uYbALxp8i+WW1TCbx+Ax49Q2FgsRQoGRTnliFhrN9WjdN9EhZRkFyOX8vYRyNgPWu0aJpsp/UtEvJgRD60D+Kx38Feiw/Pv1Pc7+fcs06O8mGYWFP0fYpfBktRGgeKgm5pimCMOKhK98ShEPvjpRIGnBf7VL0RXDV0tbjeWXmEoVJgVpLTEM3XooYqQzCGDoH2bj9h6BCOjXqLVPAEq1qBDzhpD8RnAsFiRM0nAdyuRkDxTzTxmL/XWbno/rvJN9TxgvzI7y5JQaAPTPjwzNpS/qNhdh7GpmCYC3ZLjhOPwapQ3wbHrtPVM8/n6gxEP1iNrqmSP9uqTZaFAqbqg/KE6ctDMTfmY7ccDKpMhpNMonswsHkwQh3+nWVpc7RODu+B4ZG6N0dZYcuPEWyU5CmCvYnUXRajOrmh311KC6bs2TZUbP4gQw/GPv69LTMnX05tR67t42soScbHd7Mw1/rTUpjJ5LksqrrOen/23jzY8Aa/0rDDLWYMiellrK3yMHU4V/SP9oh5V6tGSdZyTvSxwOq8fXbkWSS+nK0ta2QPgTuelDGVddR8IKncXTGP39aXbuslmdH0ZF3Gty0nyUsuVw7rvI5AjacNf3w93KuiuZufmHXH7+GsEBGkyqh+tWDWDLYnVAvSs2XESQZr05Aq2s4FO69c5jQPTNbpEvtxhtAtsWxwfg57csWtZQPRFK+RQVH6cd95U0UKJ0ZX7I6NyWQtNN+YwpChXnb8MEC2FeqQnMWRWIl4oPjB7LKZ31sziYddDAQx9qqVthpeOwtxmzftm0Ohe6uYWU/zA3Mxc03MRry/fNYlhQ1jMzHk7thXAJWoXGehgL1tHfWqIFII+cd6eRXM0jEfW2I4FduhqsZFOwHOW+fSfEIMQvak8mG1x/V5UZJ1fugygdN4a72IsDJ1LqCVeo/HJfxExe2VeGUFFcttSiJqmDhOkVCuVFwwdAO/9syFWLVW69WlHtKJm6zEjCitODPRWwZxDC4E2RSt+jJ/pnl017JepS2nvyaYaSgRpzBNc2/v4PFntIZjD/DAk7FhhKmF2Zou4d63XegyFEW/g8MMb4fay1/5lqH+U35eZxzrYY1dVngpgs7tsrf+J3IOSLDzO7JKTb23x7RDZPB285ipVNXSXTz8jVNXwcFbj/YVm+4zUDwW0qkNWc2Gjw9O9na/K1yPxxNOl97VRtTyKBECSUwI8MMlA6wzQuQ9lLVboEaFoBvZWL1E3rpFEWck1CkcpF1d92Ddh/caDhMPpIPcecWjTS37qnPOlJdC6hj5JFbzjBRAxZgpn6yhiKWlkdSsm4+HD2QEH826vzFkvPKWqJToqBK6UDmVGzEyp1SNCnbJtFbPiz+j2prrPcLmufCISXXQlOt3SIdIoNqWzyB25832b1100l8ESdr3mBm9sdPS7MafydPyxKVt7MffbQJ+JudTjiPSxmZIRsCSmtvMJXiuRFaS/3QUS6ncMP9KnXnKPjXlLOrITJdyF9yX2tLQrvjfmhcD4gfUtc+xFIBTxTkqYDEdcoNgJWYg/8d+6Is+q3rAwS5exyaJtlaG5hiSCacrlf+zSvHDFe9LXUhE1gF4MwNd6N9d5gI6D6F6anRRp+bK2sDbmV3q4U2j9yAilz6qr6/k+FkG9J4HqymcHwrCPiNgkzs5zpHnfNrCTQ7KzfadvMyXRGKiW5+ARB/wUnKL2zLPQJ4jOzitMOHPNt0ofo2Rt/iGmqe1qbxHAhdI2H3b0Lrk17c1uwWN4HBoRstCRMbpUSx12Cwc0UGQ/bENzkJiionqNzO+Orw2koGDtsfR28wzz6uQNf9jJ/eJB+UHI6J/hqj+ivjYHX8XBPdwDIE4oB2lcTijDDTQf7c2PI7ZqY2OcoP4iW1Uopyir9FecN6SvFy5PZbRogaSclG+rXvjuek3tdTfd8xHRp6OlZ+0MIIqEUMCP/fBOMs5ZaS17isdCGxRfDSEpwNOIugdRuZ+o7za8+SJAzC5e9Pg1EhMF2EKRGvLx9btfyWyPocLlpGJmcKlid5Bxzd6cvzc1Qdg+OLnbEBnrvcG+9UmIPZt9WeYZbJaFIJcPNDF9ceeB5q0pbc8kPMA8HhUQBNXMODZeqX9q3bpTvTY1EvzH/iKLaSrudaUdfu0hXFsxZFarURhKV2r8NvksaZP6Qpx35Ho+W6P/QWyMSnirVlTTl44C+FNdvXoLiTRRkQt9vv9kkybzi29FK4h6RFWAnZQ8P2T+Fb023uoScOROJD4RiZ16byy4D8Vb8C+V1r3yONsooVyKIcEHE1oh1gSCG1x0uVYVmHqN2l9+g6brGa5HPssr3dEnQ9+jLl1yCwqgS1xa8kbJn2lLkOQKfJNI/S/E5RNps85tTq/JY5DTXMTX6GYgvGAVXFwVK66ctPbjFtC6JQMwvZCqk5bqH30WrgAzdEinndXS6Dl+aUFC4MDUTecw+aXlCPdk6UZSad2COs7IHUrh+Tkrjxhpuf+RL3Td1MctoqnwBBVHxLYkSMm6zusX5e94vp95kycQtTEfpJ+lUqbXlHX/+/pTqxOj8W+rpOIUo8DIKt39piJy+zmjrE/9IzofIoIKgIM6oy8gtNthuc8HtADpd+9F5rwAtEmgyKQcysUaxruH/L+0LXYMxykA34lIlt36lHzRrAYU2XOm8Y+v3ntVdBWqz//YyEYWwv/Le6/FJhx6X73GVhrMNKSONw4f5fAzoJKCTGlfVMrODcJR/teJbjr2PuCv99/4sVyjk+TPMNzoAXm1H1f1LcCQrJHxhxnVLbCACnQ2mhpyMaR7JS/Qzzs2Q1yzBwLMkGCDn/44v2QJ5iEj0iMHWh3bWefVWNY8IA2dNo8ApyJSqXD1agNJFo9HkBsqGdn1BDY3bDGpI4Ojuzm1597tpWoi0AwGIq471V7CQFYvgzSVhoiGw5sLOqPXHATPtQI4B4CtbO1vF5H4EoCUkm5r4DdnA5GCQEmpVh7iMHTLRDcKvlnz4gLjMTeHQyma7WbICBWmSpHwM3lvBkIKSvk5xuo9w769U09LrahYT4XnEZ0hwCqfJBqtEitBA5UqeJValn7KzH/hYKLocmWBP3cjozk1ijZTnOBc/pFw2QwJFFdOc3AdWNxzdjRzjBz9PT07HjItd1bwFzUTKhOSyCncCqlnvTTpovyT1Lh6W1Aj0G4XHs00WOnYNFm/6s8Y8T3G6utCKX90u7A1ap5zDuLWOsDdHTI+aFxBCcQmpn8q+bvhbV/0ABikFMGXiaGzyJh/tLaQmn8A6bc2nzMjCVCU5wHJfyP+A6+N1KHTzf83vnGoCa9Z2/e5vWDxHTzumb0B7C+dp6sw+btBZNBWG6uRTpWnDGR/3KaOrAxn9NEsvrzj3wM0cUM2GHFkp58fHK/Rmy4oBoVa9k16td8p57tYRTU8CO0qyRKf7ITxySGm4b2j8dOv5vfMuFWm2HdW+NTyQse8AQ3wznm30ucmTzaFMi6/3TdlATPIZ4frGQ+gpqw4eubAN3+5PE7IIIh5hp9Lzr5oyMooCeaAxzPRtcWz7p8jK2z+rtQ5ZDGqeRxYwXX94ArgK1cf9TbhNJh5pj5IgcIl0poWGS2WHUepkAj9o53Q206CuM8L0aEi2mo0Xc7BrVlQxWcDK1CKLLxHAnuDX+2ZplcqN7UJzmSl1wPA6EAU4y2QpvpMcmAWRLAZqdmEvixmhggcX0zFI7MHnhW0efi9QDHzolHDiE7VgGPSMUMZX2tJSea0utphdBxZia2/OX1fu7uNKG6821e9mkZffC3sj3BbNBtjPB1nMgS7wFmPaZduXfNW38NUaC6kiZqG8YCVmX1c9KJHXi9T9nQOo3g31z5MGUtCpiVewiMiU8PzA+hCbs/KsT0ibzGnf56y8VXbyUkeFSGi3dkzKAdQuygjZhPUf/DGcAZHqE7sgvTNtF/9in8P8Fes3HkV6dqHmv84twahc93lGxJZrR1yiltclTzctUfBZZIpmufVr+eZmYevCQ2cWSIqGrKZF1h8+t7qpFYDCwFD6pZoIPlsa83bT4sMpNaNKr+xEDAyZhme444SGDLfzk55altpiSHU8HlNHzvOOgDULGgxztGue+yT7D38NmiYZOdOWdYDlQ3ls/9S89ehchtRW2HSB66baj9fm0w18LTQjbRxkNm4yfbadOxUlybd6ldXF7bkpyEVgnXyyPdBjUH9TMRtJ0JlLLofsGBlg0DtXMVTuaUZyQsA2CCUgKwYWtIXHphiv/UHQbMmV6/lt8Jd/Ge8DIcgZgcxzP7TALdK0P3YG+4agaumtS4a4NWq1f5KdWMs46n62GOVBKra4FRXLn40ttwsNF/6Jd7nfuroxVX7aOEr6JXj3D2lgT9mbWeLfHXSdXNdq7KV5rq7frRv89hzEZE30nTtZVgnIolgGiiHY9lKfoLKywOggEMo4WbGLDLq27jFMwuWgyw46WmTZko0rBDqU72K+g44wzJOzMOmG4moA2AlKPj5lsaDGXxY9NAMkIg/reKjFmUlypNwuv5CzHS50yalDL/iJvZveWHRZoFOSA1o5pTk+jGRlaUNNO66Z6WTt4qSIuFoWHgwaKYZnmL+CcOJvk1ADUYeo/wkJhwQZOF6ibHtuH5Y4vYOdlnSobj+cOBOvvMVAIDUmZBPzoFuF3q+BBez5Fbc5WDxkborS2vYj3XBOYPzl79JZDkcpzm8PJcnKrlfVu+E/8M227bu35uPZBPNe8/t8XPHbon+4iYixVtL4u7erULsTEJqWp4VDKxWlAKXg7tLUgcbsWdLmuF+2rsMwIkwX2hz17rnLK0V/CVcUnvPly12g8JJa1892RNJ7Kr8V59dMiL2LP2Guqxaip2/Aqo6c97xOolVvqSaTPBae9ZoaVjACwjggF+nR35KwDy+xdXNEkguc6L+xLBEAjGLbr6o6Yw+SMawQbVIfhWT51GqAsRsW/lbfa0PvJQiyDL2HPTFDDJiLQQZ/QqtR3EJk37Hos4KCdNX0ZjW2Hi5HV+KRl9NZXZWNiP2t9yXw8ER6GtxYN6+kRx4rHjXRWq6noKtGXNFK/dq45nZfK0YaTwmqLeT2OhJuoSdmbYDpAzR4xv9+s/vwkMzYSF4v6wA+Uth23K/Mf5NanTkjJd3QiBrrCeOBwCov7Ppbii68XWwWPdyZYp4LG5cQM/TRTuLvPQli1N50Y+LfapTVG7EbpdT/RKU9yUGjlGLO6scZ9zSL26SQJzo7fPpR8XoLvx3VQXVW0VKWawAGudTcGmkaNkcJex99X4RL/69Zw+MNebW9Q6wdF2Kj3yaxabFuyvkXz9h7HIw3WXvP4AqjUpLmzjAJ8RIO/MtBkIsYFuQ/zwt1qAXo31z8TsoPIi/RshaCU6K1FBeTyCogpHRdiCviX01va/M4i3a2H1Byoqqkb4yc5lZ9aLu9TzEv0dLd/lo3WygK38yBF8Me7iaXfhiD/v/1+QYsFZrhAeGwtWmW2u8ouayn+taots3FWBOET6jfETyjUd/47/CXIDZhwhnDNxQ7wWGgctOZ+Dtdd2ZGrNYHgDXkNp/rtRG9ZmNdD6RGnmNiVmcztdL7IOrj5HJ4lab6AFhOQEzmiWf14z4kwIxl9P+LzUi/qyMiNBf5ePKknXUKVPqoGXiJxo3dyGy8QnzV3hWQzixEjmrscThy0LU2YhSSWBZ8LOkykbJ85NA4o96jjP2gtz9c7rGYQsdkfjZq0kuviH40CexcfIIcY9eUILUyU9VLudr93yzpEwFFlfjrBy5TmIu/4VOlWTCv1e+EKpJnxDEuURJhP69en/yLVTbv52mBJRlwEzzysmWvApt3DdX3OBG/6T2fdm07feaVvWCUgmP1ddTnyqWYYlF/65c7KHlKlTCKHU9P82tdrrlSumRBpBBUwlDkd8uAIfodeLjbMYMjBdYzeI1OXdPCeKbxk87hda7TBYS+xazeiIgHj34OXQpMjziO1yEjPHSjcdsDLsBk0y1U/zeYYhagDq3e0p/wBftblCXpOZITOCvLjc7SHGnVck+sUuxc4wZreTnGgf7HjnQD4W+1SsWVXMSkqRDSvsk+bYmYEuujWajK+tSaBzMZCY+1/KXE8zB8oI4AzCQH1nspeLgyE5ooA7gyWo1LjqjLgIdGsVU0Jl2AvEzqGxUmK2mZDC66d0YSeF4onheJ8fMPVCOogP+SczsYK3kXXTjDxPpBJoXlG03gTKcm/EB6yUs+tyPN5z3omaaJrqbz4kPxuLqGOoeT37Q80AE5bVqY/hSdssXN5smyul+ZjGHLtvlb8RNk2nJZheCFpz72QdKuA6krTNpfjIqtSRGWNR3nNf0YGHigl+qyHU176xwHdEJ/JPWEWOLAxALWUjuk/yR+XFrlMZP4OERAqq/Kf2kV+ZozEKa1Rf0yVjI2tIfucU75+bV/tHZErQhNpHFhLiC1dOFBE46TR+CxJKURx7GqxXhb1Y3Zc2ZaYW6ShtOSAfLYcByVEH2ReqmwdTxj5XRT0Nc3jhJ1HugEGaxzHEjiYmuw+GEdVM0sPEQRyLsepBUfbxtY9xRDkG425qhPRteCIaHhkmcWjBiM1IPpo9vUn2A/lYQD1OCQnaQ65wXeZ200/6uQOZPtvn6ihWkRxm654la3s4gikkXlV6NfBPcuGjDdT+6T1BhfxD5hqLLTAc1i3wDzq4LeYtJ+nbyekkwXMYKO+pSE9mvhQEn7h22reetsgmuP0Qs9kYS8NFn/6hMg5ICGq0S/eU0C+gVx18f1EXe2zEuoc1fDua6Wb085F0uWhSCf369Z8N8J2pX1/EOERI2IHr/Qqk3k8/Id2v9ZFgJiKc7AHSEBNIp+rc1uAh3OAHCbiUlVTFJtom0Ce6W4aJyP70/TGPDe7VAiMhvSsj5mKzxrSr7wVApsRJe0B8AaNyKcildLRkzSNhd5Hdb+k3xKkYvqhzfSDtHfCJNswDJiywaadkmVUsy6lR86st5jpj8Sbq8lTYl1OA1j9cPXb1yYI0jThwflVX76GtgCsDhBUrSq1Oh9+Wd3/fSkCYusMK3sGG/ZA1SX9i6egm1mNcQ+4ifR28Fgw6cAvwdbrXS2SYBdMOfd9kop9kZgvVAyAUT/t/LR3zHqw3Fhh0wgTo17AalgrUVJjYQ2zWTT/5sndXYqKL8HPVAnkH2f3nsHXPUVjMxlTJ73m69EEbcGtOfh8M2iTme1WePWWwLuyvq3a+4mS0SU9Vhn8joXOs/ojsE2FNoMcnknnGs0hTFt+Yav00TbwREkTKeTpj5AZfOT8s+AknZe7XrzTukqg6cBapqSFL7B95Vo2CMULzLz/iKjvsrU8NQ3UwWDJlo2fU2h+CDkv+hJq16DefH2ikliteaWW3gpvD3oCqtpnB1oaNldj1tNjRYAljPSLKx6fhu/oaHXOHQEm17BJkPcZuPHN0nMRygw3ypSLyP9hgokD5rkkKvTdhSXlg/7T6gUlssxALcR76panxVa3LiZvOeZ8OM6bNUKD8vlcHkg8eot0wPO5ZonMYr2x0RlbFjjQhOPbP+Vlq/sk1U6V8yysS8658ZlYnBjL5Y6TWssK6NlJsGPC6JyW4Sh8KjXv4No9uwAyNDTWwp43lpGbcCUttMEFGOaWwXv9BT2B02H8YKwPJHSei2/BroeB08c7j2pDeZ0w2J16lems5uGn99qHvsk2cnBWo7IxlWBi5+LMVAodTz4vfD4QkWnqASlmt9jt6x+0dtyLx0VkEPdUFTn0SUWmSkV3L5SOUmZBuHilHxneVgp4/CqSTJ8iVILFHoeZgFrjAF9cCgQ9P9OW3JPklPXP+TKpJ0wSqBXn+HhedWsnldVBsNWxsmkFiYpYnhVMyrkL2ZMO96Qj9LkWb4/V0kK3ymSb1Gt6vunnSOhcupZfdb8mEqc6yvwWH19mJ7dyJeLoiqxKM3MyAh9AJo4HTrJ9pkrmTk/h61wnVZXQF89a+7Tx3HWPkn0qmzx/WgMUWzj8yGKeXzkrh4YyaDIHQJTC7jYgfJCjyK2MrMHX5ZdBIu5WcmcEYu1+sNzhfvDzgafi0wNSEYgPy4/SzOi8H77eJcrrL8DyZ3ZJmTF1O+ngH8E0xUc5pwIkFBe/Qs9L1q4z8Te9dD0HKm1cDOdzc61dElxocrv4V+rZeTsg+XMPMcsoG0MxgMJB3d6qkyGimOr4Fsmg/+tZOWR/jVyoIikQp3WnjAKWgBkZj9+IjMSAIyfDO1oA8Z6Tft55GkHUA93nPq+TyiPzxPL8j3cOGjct5YBYSgTbPfSDZdh03FzwCt/UIViC7M87BxJ9chIarkFHWwnOSZuh7cIi9hHhD9hAtJ+jlPnGOE8VLHiYjKOHf0BmiRGQgvAWwG+AFVKTur4MbC4n3sfATUFOk5sXsgCvisIgqS1/4mcVRddMoczICeF5rteJF1VNIxOGAx3SVKoAc0WbwtvIw/dOnr4PoT5zW1sLosKcIjtwmBF6coPVxiuHylm1tbOFJsKv85iip068Gl7E6Qkayk9Oee9hgOoQpMzQpztg+Wl2ou466vnM0bnxq3g28Dh822f7+zCalud+2yvfeuMYYYkR7+WkrnywHe1OmupgSAWqrmxiW5oc7HCo8/EEGefTnX4HaKNJ08rENG+purnSLwKOahmnerkcVFSto+4v7CC12widtDqmgUroDniFYdliH527G8IUiFl7CReqQ9nLwfgFSeHGqxh3ZkwPUnt9giQynSK8BAWtQAVcnBq48ZHAZTRo6YSZ3iod8mvQh+8O9aqlmtiNO4m3oeVNQWnzsjk2xLqvzUHv+m29U9R9KOIKhrVzE5C/s15nFZxQcqutRnM6xBPmF5SE82vNC9ZpcDNJL/QAiQ3pfpxTJLL28HhZGRie/J8L+lq0Fg5kKl7kNaedmQVkKnFkL/ivFZ5wS1j+XXEDqBMebqL1RWXBqbNvGjFP215Zk3Snw0quLfPlMxI3A6VyrEvTfQUNu4P8wCoklpYV8P81m5G46A71NHbDN7b5UFTKWtiauR3/yfuZO+yj7sd84+jSu0eF7NLxquh1T1kA8sUGBFoIZM0bHB+RvMpxqqPN/hTZ2L+zaY73qXVpJ7NKcek1XHYTCyMmK6uose1hHiWDtTVfNCyC35AyAz2OnGYcsEhLvcqOr0/gQFUR2h43IdmH/wJZ043ZZBfU5ipyRvcFDl73pyP0U5UdjZfqGvo/F/qJNnkpCHUtOeqk/NMhpIa2NPfzd23dMwnLVUAAOw/UhLvYLwzYuw1jz7YM9NHSeXVTmnoPk3ySmw9oG+gSatzEwbsHNRQ5thOs4dNCz1PqL1m/VRPLWk1AJlJpw/4RUwJ+GC+DdRpiWhVGEBSF2DJpxqQr3fuzgOKq8KvGheKjN/uLA/wfhUr6ZxmuZYMJrzrfAk/PYqYyHS0sqVelSp1KnKbmnuKtXN9ugJxIDgx09P+O7PzcIYfdkZ8Tq5CLPo8GAVr80FNQHFtFNdbeL6DqLxLPlv9PQgmoRJUf7l9xMg0aGQwSZC0HGC6LnU5q5+htgWHgx8Iat2636g2u4KWfH+vuCF3G/pNoi4T3FGZDUZ+Ls2wgAXIkyPZCRE/MxKDIWv8cHhDJ+VrpEE3IKoQalfzSZ+1XPHZ5Xd/ucRpjkFegATqGOHPXT1tVtBgoUhg9KQlCsXcX+sO0+xPBVbnZnCntoKLp6w2niAfPTnMxEnacLSbcn2a0qLeal4wJQnnZ+Q7kfJgExr2cTQjKHkB8cZ1Y3hqgaTylIh47u2tV0wj1j0Pun48O2j/mxY/qzz+Q3Q4WNKmJ+CobiO4iJDAIj1dppX0fUhvNuYCIWJ64oqkf19wW6ny9G/8Rf6a6Qr8Ak8a9xRYauVBIBYiYMTaQKzwTl3NOypRSAzHk7k0PivHfHbTewByu9+WJJuc5qAneYr+fjSzhVoMoTnewfc5vVE3opUFEQGtLrma4oiqBesZA2zM5j/nCQD8qOuECgbmpP0BL06FuZdPJrvJ9sa3JOzL0FJhtbIh9uc2r132ycM9fr5f8pbSbNQAlC3ko4EJyzxvIPzWOgUheI2rMBskqbbbKY5xqcrcW09Hn2z2x/6h0OJhqr3IYggSAceXHNzGU4M3Gr1JnmFV2zK8rbZifLz1se2vDvSGcTZIANwc525UW0gfvj3vRD64Jok26lzQwxCBrGovwOfQTXxpNh3P9GFs9uAq7znzViC1+bqpOuLujNmc5EAVNhtOl6pjTKEqTzACylCXdMkiaAGa2pD2h6tfBTe4K1YIBjbbJH9zoQ4mandH+mzw3/E+YzcOylQjH0NnWarlG/1bNwPjfGeqzU9IXnqis65s3MRtgkHY+MZgHhwix0GeLoS/RI5eVfmiB1pHe0csZrz7m6F91xu8wgVWzFn5PzVTQHKBL359/qapCiDrqMTozXTaz2EPM5FfTj4E0tRv5FeiDE/WGYqxuPYAwq0KW8zDEodpuurIL/zF/kjtFrr3LxN0kI0QQrKMoNg4O//N9QlxKAulyB+5R3s8a+GbJaHn873u4mM/2s6hkgfsbLfiu7nkkqHxqepg5rLmi5MRYxnvusqfXIGKuxXOQuBIabksY/tjyjTCkY5Hl5t4G4qJXbrLfypdBXesIEdUHkf7BWHpBlT75upPR+Y0ddlr6qAr0KAaxaEUpO2hACbGdEre23B/KKxekL80CAXJeN9ZsqZn2iR/IE5mFXX4Mkr4q2/q4tu4Wd/uO4Y+f7eaqXeUJoMhMWT3dO2NjhNu+LpS/xVTBPy8nGIJPoK0gn2OqqF4AmWZeQfUTIDyhpdXaw5TUwmf/dDBuyV7CNODKVgDhp/8VG0eMmIHPqwZq8YT5LvcRPLelArTzZ7tX5bo5kRY6guVUgTlZsKCPrUJNQEdRAPoclcNfjI3YWSvFTrVbbDl8KKu4l8TjLETnVwjxiTA8mwWol5mwjpBLQ8eyunoFW3MfsofVNGWuCfFahELDxHl681MaSkTYI3Ov2iIfDDBCxDa40e+mLti0r1GHsohAd9323XwAx3N/vg3B1CCB9u/hZNUFibdsCPx8FtUeDpI0wUy4aW1Bi/+ucdnQnWrVzdmD9nQ1rI5u8KHQwVHHRGeDCuEzrZLp5xp+r4P9WhCYZhqz+msYPd/nhBQVGQKYtRKd2UV5Qwapi3LBO07p83b+hIbQrSD7DZITukTC2l396qMaIfUPUViCECKpqgG/G3W0WE7luw20azcbJL4eUOXTXvpWwh9EMpTUEHA3zxgYGs9xkkZK3DPbSPDKrJN5ZuQE2OYhIqK99AvYwkv64gbqqagvgll39JKpByXITdnkxzGBe5s67xDeso5twYb4eHTx3oGH5Jah7z3sH1c8csfqaACUb98askMtPAAypJ/U5paACrSjKj9jf+431VslWxf+fauvQuUwCdn0kvZ0sXJ2bS6QjeOOpPr6HBplAFlpudJdkAaJT3wle5CecvosJnpxblLn6P91LeS4MnBfmL7Gj0gdXKoGCcZnunUtV6XhEs+oLni0sJ0AEYKQKqizydPdIvR9x8AqbOjTGc+gILIjBo/wUF0Kza5Uu+JCt/VdmUyeMT0jdm7hiRRiRbhb145BdIdYqb1Z6JUmQuhNbvCNzfA7WsOjEPD7RvieTGoKv9Oa/QcefmcbpGKuqlltqhGD5BpXL5h0XCL54s31QWivFh3E6ZnRCbFbREAhvkPv+fbQYkIgotLfJMBkiPQVGu3jtLzcTcmIyOx246HHgqTKsXqODvoztUsqnqap4rfOjcK4B3yK3vI3/MnfXvHxET8xCOXX7NcnkRAOHeMmX0UW7p70X0y6VJ2sJLOCHgkUvGlrES6wki/tuIQoGv88dE6DDrAsy2i18DYWQVJ+fno5ESc+wKYcvKzYavHS4wsSk8c/XCdXKYso6L2xVDdlwR7d4yFfK+mgvUy/AnI49YH1c6f9eoS+JwYKpGt5q707kxZ7zEqUpwf+jmqkfOfzJA4BWYdgXTFKD3QYxC7rKJj6wpeDsgf/vbV1mFjgj6nml02Z/ostpBjMfoaBqhwGBOkoxointf5PYPhT7qexOXz42730+0yZ01h+0sSoPadWifP7wuifXbrzxFYIZNKWkcBI6wLKcOE+gOO13oRW3870XNGJFhZBdt/fQC4sicShBBRCHYL+MbJdis5KrgGqQmt8QRtfciRxG6JlnYdS6O1Aju5ztDqWtuUQ1qa9HK2CFnPKx6FJszgoUZ5UaSBakeRMxBf2ECMu5cxrXpP+zt2/Cw9drJhAUsi4DPCKh9+qgT76Xu2SIJ5HdplCu1HyM7ioV7uWim38AGwXK4KsARxW3o2JcIjeBMUdw79ek2XQnXzAVg1LB2/8sH/YVUKJzgyWAyIcGn8eUWzEsxPfdJdO1dgGxzyefN9zRJpTw/zaMbX0rYywQD2RgMlnr0rVuElQOdy8UlLUkqHTCmnhC8euFrKWwP8meJ41/1IEbtZrcZ2VXQtTPIp7Njh4MAAF4mkuCCRSkjMmSbxJoj19iZSqmTRjnNpIBlD7xklAS5EwtofnLmMTsd2Ri2KcJtsEAcy8vvATIvqsmRZRjVeqZwwO1pUcYq/75hO2L3UdsdxmDYnpV0De+4GkxdpBHc/Lg1tKNr2/VEx16HezSUSEpdcryshVhgmW/JWKiLqE/nMJ9lf7dKSE3RquoFKXvE0RWFvyW0fVC9g3V0bBYYxTOC+uVi8/ia/XDVYvUUTbFyMe3pEkzwrjn7JsuZHEc2KYA3H8dDCv7xSBugunt8Ina4vgxTPzUCiiR96dSshdr9TzvXNlIL3AT8ID/rz7J1jB8iMVsNRfvVKFVioNrq6JMv7LF5U85v3v6FwjN31qYH3OeWJzbrc1Ph/z1I/c6xjjvd1olLsLUUP0aioRedFBj4YfjHLJJawcyoo94DW8vMX1Emdvx+wWzXrs9WRFHMYs0kLRaOZsvAmMHPhmzGk+t6qbPhhXSJnomSrSXCNwlu53W/C+E6MT6VIxS9zfI0Mw4GUiPj4oQ0MPbIE7J+dwg35yOx5FN20+onUhbyxgHlGBcuX2ffb/bP9jGTL7bR2gj8fBeM0frQso7vRM8UAPmQZXlpmF+cTK3JwhSCc8EvbUxKhtK3rgRO5jwtx8/kosSosIOuH18Tb4raoYvE+D84DnzzODga1UUwvQtOu8yCm336+mfH3SgVxcoROFJPVuLaV/Z3AGs6FNit9zpC3tAQxT3MgmFHQBYYODGf87j5GLMxsLPuacG5Vdfktl9wyoImu1nQxI0yANMW1lZhqkBydR5SVamZ7vhYv79UootLRnDIxnMgxHc/Qz5xiw5qqvIg0WMKl9geD0SvDwce0czxiuaaNxkPpbZTQy5PuA5ojFRJtxIrd1ISG6AEnxDeLKZcmMk/uSp5DIjMOWTPp6/4vyxKvaUnnYoHrFiveQgMNnC5oooIVfoi8ez1doakJYewk/N8CYcny+RxtpBcf7ktX9wcGh62Rl8C5pcWuQstmjNPz1YymfXc+TlfcD8Bsw+Xgchi/QFuCY4aBh1PsLYSZpRuQycNHkoJeQxIVMOW/n8bscvHAnLzwzuhptjIrXwT2UkP5lIbx1yIyePZKtBNwfKWWHA3xhQGK0P2wpPlrm7JmP+M3Ge3I2U2EuXGGImfX5IUod+PWiS1YEOPCUajEY3L5ajiroI9rRAVfM05zcdY19XMlbCfnTqlX4s/UMG+fftBqao0mblpLVhA+y9RHG0OW+eAtYfC0uDpvqy9nHaZl+hn9FeAcl45B6GIaAxyKA7dgNDbja6Q9ykPunQ9H6qlTAD1AJRmA6GhAKPI7hSbsxe8Tep2eq/VLz1Kg8cOio+BKotES1NjRHWlbeeaZ1BKyJAVB2hJYPd3y8vyGbBUkaqDAIkebaCB8npuWlmrSGD4P+gtcY8E4iuO8Ii3dtzPnK5GWZ0kc3CAWKD1PdZHk5foOuT3xD5W6S5JUsg7c3tQdKdqajkh1u80g8aooByrDeQaaQth/mtiTWBHf1GkbFW/Gi5czReTcmvYwA1V2eaiwcx4GaxKYnjxrj7XJ2uUUJsMXni09jn3wSmNBjT6i0hrtrJXKhazbOqV8lIqGh0ZlrbdyCV5DZaW0T4XDH40m36d+nhIFjOjzBqROIGMS5IVHjaGxl8oIjxjPtsu2fqx4HtQNiuVcEE/ReoDtUn145OVRZZoc8fv6sRFKMUOGJ4NF+QsiHJA06PL+U1osljWH3+mvqeWbj7uIo5TYRW1UiRnJtI0F6noVtVJGccHKaTAdfX2VpGO4F4PYHnpviY70VMPyTgshfwsvDdtrsLQwRoR/7IfLqiqm3pc2Eo5RsNOTtE8Jifgw5afoKrArzWmNtiYA9wh5qddISXw0BbqR0kpepTmcPb7GqU0aUn3AARFAV6826MNPE6YXaQMv3jVmSxbTNob2pxA/oBH07A60SXRR0cjD6fXokkoNuS8pbrdHB1pwiSdAliGEDhVkLmvV2rfB6wdgykhKI3JKTIoOEycr9+ONf+lDVn8zPK8uQ6sCLK22pqAfcP+aQl7mrd59pYit05aTyIy48rfICWEk+U9flshdRCQuW/XNSppI/7EbLfbF4sb8kIJ85A+JUc5hhKcLVnef0ahgYcsDViZxPzp/yEuS71j5OwxT5IVZIQvEk+h77tOyRFjNpUiiuaH3Isoekc0hzar27Zw0vpQXqxA4xOrc7X8PEe+yd5+g7GWLd8dwV4i2Pb/eTwF0qXpKmx+ZqR7Iipz0jHgWKITljhmqrD2AwhX2izuFTxfzHCExRlS0xlwkotJzggAojs3xvmNPkC2kaIuVmz9bhqRGUVr1siiDpM9MIGim7aEndvYlCXkt6xe0TNVv/z4mAf5T7qdwGE4gzbsGA+U+/MLAJzcZ8KbGtKqGLjoi3I1MvZxf5Kljjqc47SRZNpGC6LVG8guWYPW6icT4h3iWzdGl3VlbAqZIv74pw7YagQW9gjQdatn+6cqwoi6MT53hfbyqnGy/lVC2OlscZOKQadrrMHPvVNc9SW0JPkzYMw3w4wb9iT54q8Wfq5WX+nStlIAYLFvGnI8HBc6ntc3x2jWWtslJbBSItBX5vny987R3kCdEjqF95KB2qlJoGLQY1GhOO8aoWDbvFXH1jXx/ndqY5o5FqMGTftug4bs0RmvwyISUZSycWpVyGj+6CHqe2abAPMvSuyYberFMaHmhhGuOUAWPMT2BtU+32R3NACDzipl4fQhRG6okfEjtD92+bhX1hMyVHAbbf95G7OvczMTniMglYMpsk5QmZKVcV5vdw4RF5G2tvHLsVbpnjhrqh6vP285Ql5lNds4/Q8x8lTlmk0UuBOaFHCWgWqRR7T4VRb38lQ2g/MWUAhTbAkgaGgTl/aCK9ioSLXqfaruaMt05MAD257/UShqE5yFsn1x7ucODNqwhc0b0pEWHSX/j8759FqRxK1V/zhdEQs5yJCxN2lE6yItlOEhOObZz43+L98A5WoEbS1x0yTp6Eie+M3uh4Z+Sk6hd0WTXpim8JWt64yOwcPogo3y+M6Lw99DKOwbYW4yHhepVkA4T8oimH6UeHUOZuYo3hOTRft1kSfB/4iRj+BYt4jscHWCzQw074daVtou/9G2QoP+iUvXnWsp8krmhFpc78TtyOF8GAltAzpsfCRZ6ONk/hqC4pAv4sNZBUEfegSaEJfDJL+Dguvd7a7/jEybPwnkKhHaW8wO8PyE3jZyd76XZJq9dcRYFV8lBwGx6gOhFRkFyruczyJrOBgCXD5ugiaeuqdUjEj9EpM6VcIECSk4FiI8dREW6NX7S+dDaRbwKm/lptV39RK5aevkOwmiS7HaY/Guq3cH/RI5/x0B5wq6OIAOGtn5YmnSKax6TiqjajdypZ6jVHG9wyPuCXWe8upzSL2fp7WzFofFdWxbXR+5FiIq72wQ6Yvu2nax/3oB35IdQkZV04sju1ATnrXa2cn8CwQIA7sV+asjF4GNjCCsXZTiP0OxTK7alZeeKUjYDBH70bAwEMsZ1Mh48eRgsEfLYrS81WuAlHlm7zG0jau1jvSNNlrrBkkPwM9ITv3xrGJLsa+zHartuWAAo830gz2rL3ukusw0QtUQ59IxrhKtj6wUGeyIPSaz7H0zqReDGlzD5v0eVmXQ5CxWKvZgWY+X2sgSzcLG1u9AJMSbHY1qZUhf8UcWa79sbCa1rzf3fia5jnPUyuGI2tPORJ/hYpIBksuWHhBnMQgyZu8e6yG20ys6oLBmcbMOkA+NMefFkwlEoeOs05+KlGl7zgc24X15NMy1oZFdd7N15OnRf4F/cbQ8469JgYnuySzZP3ucrydC3bJHOC3sDAUD3VOANCO7RtkCI1fqnlocOjIpySSG8enNTFIHlADkz2hKL/JPWWz1Fp6ZQJxQKLj7878Etz1QkTkkIsrfetsECaleXbXckU/p9FqG2Mm/BCgytSl7gF4/HF+Wne7hyhH51dicJifjCysYOXI/8aNh4JHO6lqjaY7JhucznnD1J3cbncZGLBGZXzElQkxiPvHsYVGGIha3wkGRfQX9gZZXdy+boO1MueKCOVcj2Ws/7jox/FdQr6fiOcPKMhjgE/UEpQXpyOgSYNsp89zLfje8pSA34r64YGdRwIKnI8tYM/2KxpwLI6d1pW+DeSBvYNcqbgSd9rIWvTDD6yMez9C12bIXr6dPkUR+XvoNeaTcHqahkBmgoFdjaY3OgGuWmF6R/yPIc8SkyToPiDaCCMIeQHHAv/J2BWAVnSMQClsqXlg73UdGXxt0zFtjNyxfRedrXhojAq4+Vn5uWlMhg12YIk0gnZNYjRt1VWWCnM6KG5wgnweutkyhY2jJDb21sK1iKCu3Nn1+huICwQycQad1KLuuH6wS3PAiGX5v3NbvSAp5eAu8WmogiP+R2/M8Z4oabRg41Wq66nu27znpmABscPLgkGaO5xi0noPGUtUcCcAkIfuLeWARFm9bLT1QMuZFQpJc2HfGJ8QBlK/S1BR5vBw0S2yVBItwk6X0Zkw06JcqiXt/clbYdPJBLzY8sgIjIfc4QQo8UluollQY9coFwqYbDx8mbW2Rw5gCj3fqmSVcE4tFXgbV6zb73jFXrxzzpMSsKENouDEF7hXpy+txOwgXBljFMFoDa4noULbXn8wqLcZHF2Gop1G91hj92gecVHOppvj9ZreVTpWHfXWtyv7iXtV8dWYeqqHuvBqpNWZI2is5A+In7yHKrK4wGLi0a3YACbJVo47+GOl6/TwohHX03AwmeWVwrmb+zVaGLgCGMCT5FatXj/Hywkh3MaXm3XRYwCNxXT60ynh5dkN+XG+Q8pdZ5ruMmPjG26uM/mJt99GiiDgoaeRXNU4SGkEvgkEvKGlb8dNYO9skJwRPmUxBLoj4QTa8kmrpCpEeL20qam7ei9Mb2r7adJroptnwhS0UXSlKSNk7tquhf7f/3f7Zz8EWVIhZuoFlo2438w2KiN1l9qZxA3IekVYwKuhg3GKcVFUFod6OzNn1D9S2Jxm2VI3VOhch1k/uNv7Ewy3IhSRUxY5RDEIGZ3g/gqWM8pV487JZapMoMW4YztmXdP3l/awy3f9nHpEcfHkaw+2svEykuH21wxjA6whGw8i5BPqlbaxqUahq9k09tKV3oxu33bvV2jNITq9AAM68VkQRVNy4X/twQ70goLh2YEQoiqyl9YMpMPT54vWbLhTNYsFUn6hYWHDm1KQYG0uqD76yDDy7rV3spb8c+0lCiUsalzSRq+dbz9u2DS+ro588gLV/QMpYtlwWxKvIZfqx83mv5/mS7BxqrT/gsBISueZ9VZeTjKrxBZ1XTjuT2pdiFRxRUcidtkgBKq53O1cc1dUzcuR1DxILkWd02lCAvkmPLe+TcvOOD8ejl+PTYdUHID4zX5aIjSHp0ozqjDh8VezRW3Wre/sNXtUkOWYxNEmNu6vE3Bl2NuXOR+n0LhxUxwuIPwhvtlcgiL/hlajPobuIAx9AoSpNFfutSUnMd+rh4hgC1wEqwXfTREQ4lKmlrlHkyI+jV0c/E8Xj+Beld9vHbIOLJAiy2VuFKGFhSxzp4Gvbl+6Aqwo3fE+QAJfT0KCTqspUbzpywPcqqRkvP+gj//hu5LbxJ02QGWlAwPxbiAhgzFNBdHSKTH5rBpofN1b0qzID5wVqMJ2wpQ2sfTYIX5mm0h7ibdNVPAv3O+sgnOGhL5wDQqXJYva3V9zwGdGHcuCkRynTANkhicdCbxk/EolDwiORuOTQBQLCJKDli+hlXb/EQVxUzms7SVeCL1ii5FGP8e1PUEwFZX/7Gl+L4NOAE2Axsal32i/8eURDVFtl0X3C+SRk2qz5VLlmDCZ4vT86WTjINXayXY+Q+6iHJAWLQH/HhxS579LNuoLo6DqXHhfk27ribgH5Fi1FFDCzjMrX0kgZQYRJMmfMnkTv75SlU/MdPRyU6PEoggUbHSuRBQ7D7aGtruzZ45CISvbLdQcVN+6Bu/rNVXl4bIcN+NXBcp3YS+V2flQ9QM3dbEKh2QBrzOJx7DZHUY3TYaeMF3Uqx1BV2TQeznWSgRrIlWFlwmBzfbKqFAmDvA0cVx4Ba7ba4/hoeJZokYcBJzenQ114WEImY9OF4Zkk9GK2nZrbyPF9I4G+Ox/8dAmUXuUDNeFOKLUiZfVxke+NVDZoasKTuW70FuazHvnpt5hwMy0/YiYVfvJ/bs1mp175gvbWaebHqisoBz+Nqeyi/LmpXtmmcNkcVZI2I1E1eMLfUvJ4kJ9o5yziN42Oqhk0P4J5wBmi9IFecv8hMk11JjiYZoZ2XSEajASxFkiR0+YAnILyaUxXLp/3ncq+njstIV9Rbd73mH93frZgzqot9LgZ1bHLpfs9H+/jXa2+UzBsq7oum8pU42DXj0Hz7MvQw70MFLCmorpLz/jzRiiX4dMZZUwVzoRZxiQsyXXwSR/8J1Gh+5PT5PgBVnTBkORPHOY9jU39j/5VwgmNyy7Gfm/5hK7f5ZTFMJ8NIJEKp2dJi7PfBdOvL7xt1tyfh8xzpm4zRKUSzvqpF1bACpqcRw5G7vCGr5IabWEIEwZG/Yshn7ZYmmoAerSI9roDwRvVqzM1tZNatsBYwlokQd/22Df5liyY8OIT4TKklknucJK181cOpE7cdGIbV8jcSWoi3y2yAfFB2OFiRRhRCARKetJ9km7tpMHIpZDzQg9VEfZJzS8WO4K0cxe2OXz8k5KfV3eOt0qzj2pqdvcHP6MX74TX6l0krVoozCd7/1B2rp7xdXQdqGMlaw+GV7TUIAlGzKkcJiSrQfEyCWn9kPAVIBkyBgqAjo/AIFR3kCm0VSZIM2CGM3I1WFnNBbRp8TxLl+cA1nwsus5hzBu5itNrWkPCc0XCJd7Uo74A7ugv+0kDTyLJCM08Bu6n1S76unYe7jpVKUX55QgM5MDMWevWGot5q8A/o8ucrQOZIMsxVXUgt2H8TXBPGErmhLujQzy5Nn8Fsz37MPfffaEPYd8pcOWfQWtIDvkep0e2qddTDb77inoal8k18hEqSI02X46nO4rH8y8GNP7YQIS248f0KaGHvBhLdnlSrUkekigi7fRvLyuY/+buR0IwIUh+AkhplJBSRjcMIPkAJ7mtWju+v1GtTKYd8j2FOjz/Dozk80Ir27XhWJ9duDAtgqHalMjQe1MlmZ2QyZVhhkUWiZm2vgykRT4pjWjGlG2GNTxhXvR2sziPLUX07twFdsieXc0kIVMGuwSrDJOg8po7YEsd74nX9S7NXP70PgVeDQ98+OpM+AV1ViiB7LWmwFNleJO2MaSNitoCOxxDrDLBafuYFKexnM7JMY6PuBfaciFhwXdVi+VkmjRohbhSw/ExqE80o+6vJUK7RHX0iV2CUuTm704VTj4SbKPWdaXCDnmULeYB58GOGD0NrBFrSir1OvdOIh7pOO+Y++XUcbk6n6WxdqeJ7MVmz5Ekvsb3mmxW2UmAJkkWP0fnMMPMQU8i0Ky3Ef/yMHHm2hIRyaUvU/FpKR70hlpxyyX7uMeb5gju89ftyAJAu24G0wzRW2DOPkyeDoon9yZXOTfLeFFXSNJW/gHoIXXTj1ZGDhSaIZCGI/bwN4NyUgOCK7KOGvxiBO5sGxMxZ2fE5jFcblJPRQ5GXBMKfQCmxwCaHXJ8YkY/dkksgTP6TFSDifXMUhoLBjhMEU427PZ56O1rQkOipwbOaWU0RsteF48LR62alvch0NN0mK+4mXCHBGLKQSjFjeizbJkv1/NDzJOYNMH1P7NPyTPszqy5DaEh5tiJ2WHdQK/6XRsi9c3HoW7acmefHzuDbYgmMT+IFdzCEEJ2J768sezfoYNfEyIvLDA8LoI3yTdMC5HSfrsTz1FXGPXMmwXRxFe3C0xG59GXo42l2/kuL/DjeCdyQxnHCoMGk859aUJz+V+bZ76UgeD/zBgb01uiARxUsOzLOQFdOvO07a0SN9bNkRZv3MtZR8VEsDb4JkOxxD0QrmCZba2oaRqLfqanJ9OaEMc9N5lUPtvm3sQOgcepoziTR/OP+/1j66TwTdtKdaVUSZayDg3ScMpFp1afOFLw59w34MO+PVY7Q7qAxbLGrjYN5UZc+unBNAtM/mERZi68z4zEg73v2LLv/xitCn9ecCiK6q+z9H4sTiqCUa2HOMhC7ur1NAyna1t2jU3T3dSRQKRhGX1dqx8Dvx97nGiqn/6afrPi9T30xaW69BP3rGOgCXwxJRT6CbpU2KQLUourffAAQN24P/kZjBrm6WvQv6pwhmQd3O5gNu06un8yrU4JBQvLyDLLm5tJlZno2emxDsVOiUGCUtbcji10+MVSbgzCBSMdqISljqx4bvAxrjWE8BeYKbms4zpWO0malIdrg4UlXR4+y2s1W65qVtxO9hrxDiUyKQuHc3RdG+/4SATGfdz80lum2RZrBYDNjqxhEaZOR2i9Bs3lUCThPSQxzoqR9AUmYC/NkA2tMgBSzj0AD4MqF4sw4agSJUUUxzAZYb9CbKhK2qY3O9vz1p1PCmsLeZn3UUUk/yS3UTgyGDdYxngKVB32iToZYvSu6GKvS85Y+/tuszbEQ8vfOwxrS+nvMS+csCSbkNuJ/dtLXBJvZC3jc4NmU9XdJcIhs1Ce2YadhjKUGY0RkeFWsa/NWQUfwDVgttWlIu1ldlVz2XLO7Xc8ey3ZG3qDWX1UCRqygoRQ3SkMO8cm1h0yFd4XVhdKG8PLzR4LZz3CqVS1J92wa0e3+rs5x02WImRI0OBJop2wkxlG70iEsuAS7wmTT4hsGoscSVsH0sWDFxbXGSZe4ffhEXP4uqpmj3I1Lezk6NnTeFda1PLLN9qouGjRf3oNVfMJnXX9bvhKjUB0fADYdMKrYFYG0h4KvY/r3Lvzy1LPUu+3fIve0Ta+DYjz7cSZtguGYicsFDAW/D2r78Ap7FAQJIHRMnASjYyqnpoYfGl2l7HWUzzggYC6ZG6m76BE+IklJ4mWNVg+T2NGJuKJP0vYgga+aVbGGJ8TketocDcrZjhOfgOyLsGQKo36RNJisB55uEkg3vPnIOyvqcpjhfgvIaLMx/tPZB3HTbFUVNiNw22K+OtcP5bBH4JPysbZbBLxzb9DmNM+VxRF4MkTlp8dqMi04N9ZTtkjCefD+yoLYh1DOrFYGjDV5eRU3mb6Pyxty+SlQamcvNevaZxG++IhqE3g2EjcFBgl0kPsc7Jv8v5BmtKPV513wDQXGEElh3CGpM6enUjdZ+yjgxuvDKussPzPv0Wz+R+A2uo0ow8HV+cUCB/MDLO88CwNxYmdAW9oxe6sJEMqRN+J1sq4lDqom9yZd3b9ccEhygSOeBx2+gBFvwLgwZ/MUl02jh0RMHurKcM+z3MJgig2zdqipPekfYAGbsT4+0yQk2wRvrhoOM0o49pkagtrhHuyzScjg+AG774Q1KntslTDHTBnQtlxy+5GgjzNphQZkV+SSlfYucN7Ent+2PKawmgL+AWUkSwHG7TzWyaP85APfNYrb0rz89Inw4DC9n9KpllyEAtJSJnYLhDKnthJVIE6UAlMVYvy1frnbxqrmShti0joLL0obuDEIrAm9dyj72l3EtZlERxTeAGBwJMXqVADuLydSZCgFxzG/sGukJsYQ92c3LdKrJKI0vr6Icsqqk2w+zrON26X+go0FGy+IrRVgS1iBqyY5dwTk3DiaExWbiDC2NcqrynGQafa7hEja8EHncoFoQi3mLTESIafppacCJFCHCyg+Zsqny8sd4zaEIrOHOC7V+MDZk90TkOWNzgTbQezyZt6vQAkDCPlokhneIx39JCJ0Dn7DntOLCt3UxfFhR77qi9/ttjOnvYOYw2HhQY++2fpY15xCSzUNAx3J/AZy+TdxpBU2Sn5AwwovcO4ZUh2GOMbhXL2UxoSatIgrSuDYOEeo38RcFqiQjHqGhMDm5gtDx3BdQzonDgoUDxhzVkLMk+rohGlQKxRAcCQ4crbW+oodzBI6Kn7/BHPnH9LCoeIk4xOZ9cKkJvRd53LLKf7g1Yegsg5/N3QkwHMhuAFjMHuU/mQ6dvFnRV3RVCuMY01Gq9vWekZ8yiDmJ4SP7DE1VsgypVJJFEMS+8F+LYChLznfsKfTab4Tpq1jNwhOln5VrItVQf44XNWGQ86f+TtR2rQOaxf8A1a6iYVKLORw9IbCzNLALhhu40Vd4J8nHPtCQKKNEtgL1XDIomvko1UtTOWrz1x85pwpc5+1LusgGR/1I83u7tQsf30+qHZOhbD1TjXE0dOD/Abe6yhNet9EdtGgW/Hr6MPZDKVZwgzhHvMAQrpudqY6mxIn+HzWJzvbRPw9w+fMUgizoT+p6IaL5dDch7MijV3b//Lnsz8hO4bqpaJPkcBaqBm/gAIbg8fumROHo+NXdE3erbLi3ln9w7tC80uRWdEn7n2HYQAwSSGB/i7xDSrl/XxBEIf1MjPt125pCpK11QFYgj8SP/MdDGaTyiqOzkmA5ITyLCmHSaGnPojoA0YtHTv3b/jdxzOuHZtzMJ/U1+O8n1D99YX3t8DvaFJaceF+ySDgAYFkeKLSxzikUo96pP1OaZzV+TjEi0pQEOWrpVGwQtoGX88O4BWvzWwKt9RVAEHdEFg3wHlQID2lzqRkllvMjXkUhCOv4lk3h8jWwl49XyZ9sFI5t8TMnkwb26PRXeWsfRmj6+7mOKD9P3Uc9kedBdXcNFdXLos9QOP4YuKrRZjmKD62BTqEh+k4oBBMjavXLzbo5fy0OBqX4GVmVzjrydqkORQ/y5ARYFoNBryLvrnMuC+Mixdy4YD36flrMlNiU167sS9Omwzs4ccCOP87fIuyZv8ft/mD1f56ItbembSWatmfN8z71JfIa8g7UJDOaIQJenwtFZqZaeEz2MTMIPIIyfk+p3vQJo6yvXo5p6PpPsAGvaZ1KWg+EHPx/IvSUpfIaphyXfBRt3CjXkBokiCyBQcg5Psn7ijpB+Vzrcdr9KApeTW6sz5UFrAYa639CsmGoCh35YUUU4mo9oEPPvpNVJt2CYFACbjF5heC38ItlLkOF4GAshQDVmJd7Mnn4t7nihy1lycJHK6cRtrc5BKJFJx2xWrvT7/ALcv8oKgg7YzHPIBt+oJ0lExSxFiG+nzpnjYXgjTq8KSJNAbZy2f9ZEBDV0e/YfsWGyj0g+6mdMzJVXt1A2O6io/uK400Z7GRpAf3t95GwjMy9TBeRpzaBhm7AOfB9/NfbqU3N8sRqwD7MeWAq2as2h21e29GOM1KMM5qyVx2+DhBMOK+75p1WWAzdjj6fCrXhvOYCf5FU2uNMsiGqg/40+RBHfx1O4VS4J4Pn2E62Q4IiFrU95HyiSpVG1H+w4NwcdpoH6XkfEHqoj/Do9QOJG/Y6lt48NEHKFdckUs4w11H9YbZzx9nxNQoJG+zZsxx0YaGxiDRNbJ3+l/CrrftcDGq6FeAch88ORc4jtW9Nyu7jPWwyRy24UVkVnFEyvh0biY+sfxQBI770U9tXqPx9jFBUEmztxp6iPoXFa4l6wsA7tcsG/zw3gqrj1VPVFtdSZD9XMsCHaYGWxHHha68mlIiuykDEC5hRtKM0E5rJhtbUpcdlIPHwT5FCqi3R3L/bDXA8aUnNF19xF3AFSytDKSevQOA95Pzh1Zz7H1AQtD/uY3+YwRs0uYrZk+FsCUqX703raTkkqeuCifYXHF9R7aTBFIHn+NapZ95wFudGtH6PmdzgCe80BojSdi2xVNEywQmvI9xFzjRy/vxAMCx7XTSQuvPPvpsB9sJkpfJ7AoNnSScPmFs+swX32PgWt5HY1NtugQ+ZGPjFY8GMGhmcnSuJoawZLnfIPSbCZomsMP5bijgTkA3ldX9SVwH+fFIzFaAud9ubNdg+qw4MR/2xjh1deMX6z4+pt6aAX5HY5w0QWGtafJTGujns8yrMvdqWy2SbcUB8kAsuMAosp8bxOKeAIsOJPRDYI5vdfmUpVR1m1p/mo3YfXJdOsbF42rO235ThRCecQSpyg/uCKIB8gKbRy98sgVFht2DprYRVpVSbod7wNI1YwaGbM6qbNMJJsKFgYdMqqdqV7O9RPcL9upaqEcfISI8uQnhRD36rQ5ZkmWBFx29gQ2fX0JN1e729l3Vp80KgHPPWLApx8MZ4Jl9VhNwLS50QMTSgXcsdAmUcXAP3g86rlxDNqXaykawlXcv7CxkEInGtNuuC1tPqTeAT+264/ooM7FcdaPgsTqTSZh5y+e8m1jl/6Hyrl5GUpeWpc9j/IaNAOU/WrZANKMAeaIK+m1ywGR/6Q+AU+8EBDnVtDMTG5jxnz+rE+GWSbWgroooH9wKQ7tTz3za3HbxLYJxq85hOgzQCp20yDNItDKYhbpwp1KEkPHJ0oorV9g7JViSKmxAnnu1+FTz/eN1dKZHejiBExRFMYiDdcwLpWqciKWtZYnz/A8UyNB36a+f4k+h8iYrxTH6bR4dHtWYJ9XU7IRZ+0BcmfXI1xoNhxzY+v5/eaCsKd3Mmdrnpkptmn0u4Jp6a/y17kIY2k4y4gMAdCHkAz0amHMdw4xSrKrcvMP2doSBK5Ma8DQLE+mXlMSOOo0ufUlZ4tJHePDR/F8bgkx4Piy0ey44Z5cdivO12TBB3skkh2SztrgXK1VPJ7copIiU1FCMy7qD/aFZEqKZfxx2BKTYy+HtXuny1qAqSUpH9yyZST9bSWlSCSgmjn9SQnM2UwcL2JGsSXX+R9pzb3lVr8lk5itP+x4mERqKBlsrmzCJ5/xwvue38IkP8en+79DlMJ9J43fsOkj8NQV892uTLiyPv5x5Uj9+dy8shHnGoRRu0FQd+Nfvht2YX7Ei3awjU34TP0o2sHnxi4gAuWkfcu6dg/G4QPG2R3PV875zy5l+r7JJoj0twujZlWXO3DuVpcnvvBJCbRGmQywMO7oNhtMkjuT653/JhAupECGwX/vBVUT+TBT5mDbPpnzuC6RifcNKrmL9br9XRgZgXbYtekosRMne58sjq2w1hSGo5cMbPkd364as3rNwAjWQMvcdcdh+hQtwIglsg8Wtlob8qkHrdBi8olzJrhVw3kPMcVHb4kHz/g2WrSqKUvcArQkre758jNzL4KFe71F1TRuokc3iqOV1SL8LpMvvt+eYaSz+gdMOaBSSyoDXUlwsgdzMM9G8jyM9Hdxdlu83xGe65+kWa7Ad1ym5G8ALPJaJpmYTHNJ4Dkl1X90n1SctlzIXUB2e2tCOFKcYtRGMHM9/ngP1qMf5crtDYIaSDM9jg72KgA7TSC3PJEIgaOkEtVCuGTdhrkVCmypTH3tjRGro8VkWQNMtMcSg19XLiBUDVLHk5QAb3AJZMKzbKA2jL0kKCg1aAhTJtqo9R7nxQ7ZiigUtxIlCzl0gEkv9jQuxTxmoyi1/mZl7AStlnFeKgOapIsnymKCQXf54ABATSa9u15qccxPiu1LB1G39K2pE+/XiOy9Nc7ITYt6dEQdE+t5w3xmuwL+Sop7BPCkkKNHSvhhmyDp68BmaU0jA10oI/44MtiwvcaikM8JhUQlsqHNuFXgc03UOf2pql59GnJmseC6owXjN4JPOZkVUVW9QEQtFBKucybw/K7Zt7uuxRa2mS44Z5eNRlJG15rhItW5M3kQ8QLMXd3SqQlcIfVFHFwpV6fC5AY7WuWqjbV1TVlTxH7m+wdT38ckBC1KFdKM95B42Jv8hxDHYYkQfiLnT3oVyqbYzKZXioQOGdeYhFCalND/sUVBP52HEzuxZI3TIyOYJ5jn/4ijWL1jzN050koXimX8/qV2w8F7+5/5mVOl1518NkbCw+eruXDuSs6n4v+76VCjB7XLJoIfOgZCX199gvzAufrq4nsjk54s9EIPrmXI78yW92YrmTOtT6zdFSNYVND5SBaCoK3Ihnfw8xTzg5YUIfy911DETJDMfcdEk15TdRFxRLU10Ne+d9nHs7h3YiUrWzu/mDcGwQ+Een9rSlMbNtKe0voU43z2HTsM9YIzA8VgpeNANgPikCNetNSQgCQdIksvYG5P9IaN0tUlNr7gH9vqMmu3X0cuINiMR/x1nNTF8YSloPat0Soc1BmLUi2jafrkQtzKkjJwzZmaPwAJFn33SEUTsMKee19ujDSffz5Z//yAQAT0OX1bRQave2ec/QntlK/mHFCjDLEsnuTE1tAquXwaup06ktm0hZX37LWXLxt2BYuDGzjdGV8UTAWjFSk4at9+WHU8FeDzD2pOaJ7aGNpu2iySTJ0EFYlFTOUqz68u7LqEFWx290XmZjB/krOSx8Gs2gadGsl0glgCvDVXGf+S686a2trK13rszsN9CuvqVdr3yhv0e8+hJWvcDJK1vPhKE1AXIkaaTkDDWC5dm8Tx6uUPvJid53NAHf/JY6XWuNPRPsEiTqQzMqaoHoY+n9amRuOHwQ81OBsPEE29wjnGtm8EsYJhdQ5XXKVmeARkAkK/FOTVaCX2NTXfjFsIsE0R/B3y95vt5Q7W7Xcx5vSaICu1RJ8BW31UXvL+ovd1qai6t47R7dgbxOw+sWloUSWL5A4wmMSalrA1Nez2Ij1bXJQt0dy3zxB5Vc364kEmTBBvK8hPNZRjHk91O7nPvanOzj0ftYvgD+c9JJo1lMdor7pswwX6fgr5sC29TWresN9vJyaKWsm1ZR5DyAoV0oKH+G8YXEh/6HemIVqCoRLUR7w5OZtqeZbH6jBI8/ogYKvdDjQw61aWCvu0g6lMw+yv0UpbbnhaHcULGN3kooeNMJcq4Ke6xBKcS3VjolXxFuaFz3UXy1SHm95VA9HHVu+FORYEoW/zuSvQn2Dxp66a0rFZ8tnYlL+l5t8ZycbdPagH3wUBgilUxNqkF9G9mAhKeDehnPTBUVGFqJXDGc/oyANvsdkQEtkpDTLEsXV8kmBiftWkLq6aSV9Uw4OO2UljQkPkQJDDNkVAqifYn1DjBX0xX9Tf1AJ5yVTp7X655zv06xXdiFNWLPpedo6tyX/+UFNwU8bnBpSLu2Bflwf8CkMaehfovrXHJcBeIt/LtYNv96NbydJMEY41Jcx3EoGB72fgBrdLG8sz+rvq+wH/YQ9XpEEe1rY/X+QTkQo6Mrrvi1ZSJisRmdvUFxpRJso/SHtoFMuGOPwHrkS63bMEHSy2kG14lQNplkI95dTaRdZPOCs/6BjgoaXjbzMP6xMOfxybbXNzJiQW15QbQo/iCTzkCiXaAGMW7OeZFflL9h5nxsKBBXDMIU1FB5dUKfSRAnJZv6wK39ipePRHi13PjZowlQlPjpkp2pVPpIUyHDH+P/+Odz+nSsWtwCBZA95Pb9zLc2s5XGIvJYS1adY76gCYrZhiAG0zYuUvPVP4F8eSYfdTgdbjyKuF91ViUjUkhSMZItXWn5lchmWGgN1/F7kFngoJEC8s0gAlKKAPgDNa3MgvfbnoT7svGG7t0Mea3WrJ/P3GDTDNPYWEH3XCsAy6qCRIrVrrmMmW5KotNJO1B3i60TE+iZ/q+g6k0kQt5DPu8gMqtV2zbgK7KcEyGdB9z43bHXzy6O94w71FIp2C5k0ZEcfAcrVg1ny9y89Cn1GFyVC0LALyeFpBNKFGgLgnz/2+iPMDY70SuV3wDm0zwZv9XwCiYUvmnjuyuisXaIw/sXo/g2W7cUuJShdNmfSSO5TlsL4xcO1A61Wk92RjYJuVYlc2E6zHSngNX86ZlIa74OmX5057FmiTYV6nZnuvqRm0ftA6YfU3gqoc65I0i7f4yzgbqQU0zRQwhmehXlY/FX5UOszvMtzAdwsKayK8UHdj3eNrTUKtXHVf9Dq6qLyVEg4gKvNJCykUwxgabR3ayDPbQ7dBxFAZMnCp5HDFeN7jS0pAo/5G+9i8omfhgk9SqOAhEnYw9+gpjq2/D/rOqJdtRxPHOrFd2ijifwy+TkWXWKiKYGkCdFKhfpNF0JSCUl3EPJsblrDzNznUkZghZXivtx0vSKmHbZpn2yr7rgcMXHdm2kyKOamzJpQU0I7sUM2+0XAIWS3ECuhbMPsnYyXApARSqIqIhUfKXEI/xWMyk8W7b+pMJtHVf3vi7DB2TFWaXlbEEryZXvKTbxXI2BI5lb5DUyaliynmkeDcu3UGXb0anB1BsSAOLoQ1Jbi/Dw5BXA63p65P9idse1MFdxZgajyUeENs+EIk4i840VyEzV8pikikPclN4leNGWz7gXszcVZp6RmxpGo7oyIjkGZVCGzELgdiaqR2/kcT8/b3OH1PEHTveTugxlgtH4ELgLq8YhR7svmyGyv/KDgbzH6Dakc5gjcl2CC29ijRGFNbc1XfJnKMbJTor4B2bCDgY/iPZIxq3+97/zblLboG9MKky6bBYsbNKJVr29rF3LO+L8AbbwzWZ/JVmbObHHAOX7JX+thKf5VrYiY3hnl/ADSpOCtsjjGa+ZlWibjjgt485gQ87IrfF64BGLY3k9oRYgv2cmuS4uvLmEHNIwA5JTfAx7ULZ9LepkZyG2L4fq/9JKCaOpKx/G2lQGmzDnOVYCMjLFaZ/mVqfweNClk2J/0hEECKK1gPhMUrXEeoTARYf9WSsMGqsP2A92vmzsLyzrHhLxp1Q8Br6WTi/A1XfVPYnKFaagHEfr5zg0VFerzCR8FbjdvOKhsUbddh9B1AkAwxdgSKVFo9VaZKaZafc+q5KnhVf+K8Z0gE486pcl9dUjOaTgW3Fi2j0GUo8D6u+TUu8MSpoRrmLOJW4tUPQ7b5leIAFHCWYii0EjPBsdGMKQnAKucPnZ6ZrjHs4rJT7shQoP+H/WBIXMZCyrb/5QTbex/4VJa2S5QSuqhHhH4A8mz24y7pQaVxSsvKBy3Xz9uQzZFo1uEmYH+/TTXB+Sa+nOM3xaKKN3y4E5622SV6F9vR73FGgND59G/CCcI6fzZMErWO91WxNn33iZFKRQQz64sKjHEgIFN5muAjoDbSc2QdKuQnzaS9PNGRVkIOXSSw8a/dij5AH05vbLPPDOg8ZHdObQPggJmJXgdurU+hZ4KP0GSDMfgKWV4k+dfnX7f531w2Jfmj5e5nknN6aOBt5riMUW+MbbZ4NfCvhx1zle6VOhcfFu2RFIkeD2FqZFjIBC7bgIqJe1GxpqU+i1zJ7zDHf0bhao6LYTBW+mhHz0rvnEgAaSQdfBE0ISjWaCm3YVje8XmkZ+DjrYPwaLmiDShhjKndbCmuQWAhfzgbp1fZf09SbSCcBINLL+EWT5zoPJ9VIa+72BaVetbCpgNO4WAqTP914WOysz8z+DGdm+5vcVEDOBcT3pbKxKVzH5S6Crm0Ob0+cjkLY8pXTomXE11P+QcO7k8iyA2EMgNvXeY5yZp1cBmCuF7bMGTKTUFEAyFBvKP3SRDOiBQAGfFmczOC9XKGj8dG5mMb2ipafwCWDXLjH9zJxRJotAtLse2t3xqvAZ++uW/IHCcaOLln+cE/Blh4C9MOWiL4eJcQ8zLNxNFyeulOlsFLcDrXOVlTUjk6pR2XNswHsyuOO/BUTthc+lXFkcXb3HeWltb3i0iVlT7n9sSz4LqiK0hOgSUENJjPoGLE7pcYjqQ2LXlRGHB4fNevrBA0WB6qzdZs1gtz1N2gzKanvyhF7TWH8s2zgZVHS25wBc6CkhVVdJlkiQBx7LGXNrDDt94JcvH9bWZRRo55kVIyUEV1BHPtuivxqO8VW4WiRsFPeMwtNG3b+9qv6g1cmPEYZLS1qm8RakzK5Ephx4Ul+3BtR4GVfAf59MARJ/nnre0rvEKPWa0rbW4aYcAJcijbrBP0qiqDnJ81B5dRMoN5AKPW78bY1gdUdNl7GpUeAayH9oJFLgJT1wr8JN8LlWa6FVdyyuj6WqNZXA8KNCZMLYw0+CsC1kIUbB67I/rkskjMIleIbPuUmP54Ro1WV4o628QhnQMp96+kDfj1I3RXvqoRrLjV6J6SYWk8Hhk5nQkgVkdtmG3VC+mCSf2VvYzo+FXVr6QMdV1nxoEkO7IzpOOPWg1XjTYJ/38iPc8vaWAW8jLLbdZiUx23qqCd34r0R2LNl/jz7GzOLW5f53tuhdJRAoWFK7s9cD3x9VqNiobf4AJdxvMMHpipdX/CePAc0m/vay1eksx10rxv8/Ne0DmwJRzPyTbJooBF/EZdxuAmnTV0tTTXq3ASi5JUST7OJ1Nq4txOrQQPwBb4GQ0ppmGE/+Eb58MpDPpoU9thswG6YRSsJCRucmU351Do3pIT1m4C+Z8bMsiVlsRqQ9dYFI9n1KR3ZMO1RQ2JcXv7BZgWi1cTqCVMG/J0hPYuzCh+KZ8jv0hFWA4uhQh3mixtzs0ceZAYHJSpTz/s8MaFbvrcZOIEAsiapFvaVWiRXsrIce1nNlT75jzFIMYF+3PB/tOozsn8j4TnUxcXoOfptKQG0p91ZTdLVD3AmsowIt1Aby6JBkXckv18fb1I6slFQ8JFBT1wosGjv/22m+/SapteAzGgJDp4KEfXY8uC7I5ulluuu+agopbx/G3gCSH8RUfQ+Fj4zrCJ7LBp5px90Ma0Alu4SipJcus2GmXxPxzbaAJHbVaQvod6Jh6iDfXrS4PPwZWpxcsbxuywNyRyaDKSiJrYlnSt9WVoHFqGWp9eq7QZEAIKLeKmEWohYAe1OhUQEjLYlCU2lMicjpdyUf3xnvhGobpI37TFsRWwLLUsii54i+tMqGML8XTMHhvwFtSLKaFT6+NMyYjXqJJcQfw0DweNc6FogQl/fecE582INpXOSn8FbUrn234wjVtk7TQp4txHDTzC5fx4h+EsElanhkDmc9uZM2brXM3ZH18BrfS27/rwt0Fr4KUujyk8QUKjonnONc5zWFe5i5qJ5BV+2ANaYBOnGKqlRaNoZqeCvBAvm4z+VdHDRy7Lnl+EkzpTBA3RUy3sWScjMTJGeoMxvAa51HPfFsL6j/km+pBu4s0IYJABzjmhkm1auzcJgQT6RZBeRToaXdjaHy/wTXBksgx5ZSKXy/K/6lw21nthvU4z31B0YXdgEfkJ2GMbvWP9xnRvhwL013h1DylZF0lPNKqT9Z2RHgLdWkaoN8HQtd535GjI9nsPyOVpRjtTme1VljwjJmMEkpZW8DFQEFZ409UV5hSRu3VqRC4idvjaOlDI9CArSxZ81bk4WW7hb0J4Dc/nNvdI4hC1brXRCccjdduK5TU0XE1MhrMqyb0xWdgVtudngXy5FtlhXJHLhV9ZiGTuo3zmPfE8lfYfTpb9xL0OPC4vPc9XaJjzK2G6ye2d1em2BvHvP/Y/f68FFFj1bX94AibouGuxG0TQwXwMO9UnAYWXlQ83kLkb/u+o3/q+c0Dkw/fGEbDlsHrSFcXwsMeES4qvLHUz4thLwAD0lCsdyUanLDL39n4q9mKghk1DMH/f5VUj/7cEieKzVNcBft+q8bKHRpGPXgBlbCa6QMb352VZ8w5TJJn/G/azC5F9ouECghrq4tD+aEuFUTmL/ejnqrW0LLf6Tz4qm+n0kQ4McaWCPK34ghuwiGzAOo2CS1wbX3a94F0t81MEAc3W14ny537omv+wyV991Oo5REnc0uZ7dtm62eZzWbv+cYLB4XKw/OrI+7+RmwChM1qza+ZSBxaXQv4VJvqyItIBVGfmNUeBWyA9XLbBD3aDE9qk3q8uX4zM96LtKdrkPW0Y8Tqd7CsCV9H37eSEHFTVEEsIZ6grSV72SdgFs5CkrTeK2D3MM3y0+yWv9B2/m3rLDSnEbi68oYd7QHXVJa3h8t3QpKKXFYjXFY6PeI6Ns9r36BKIUN1t6BAm82i5NaURK5jgqDK5kQwIqt9N38xBivJEBdoWHZglrN1wri1IHPNNp5ywu4q4S3VE7hIFuJ05UbIguil+YhrA8ZUny17mGT01cDWDwMC1MSyvtW3LiVxJhVA5f93e5bbpd90qi4Wgwx1ChLkGGb0xiDSybMQma0nSNwaQ04nXkLSHmA6dxKJul2Dkat90tqkkoVjXgP9J+1k9DWBQbJ4ITZNNCv2VpEvtkIixZ33eU0pBs/rmPRPQZ1iCo6rLBoPX6ltcKsbbgzsMAazqPWjdPGk3LZi6UGfH8Tr04DjG9sZt38rirn3/gvEN9e2L3obogoj8vYmQIFkPdUWy0M930mKZgTSqM+pWHMLZwU40TjXeEi1ZkUuZwRHPL7h0+WCi8NFb/tkQQvK7viU+lHuc9MEhehl3nEpKGkeuDenFGkyQotAjgKjlpHCqpfi9RCC5nG/e0nrytgRJ51uH7PRdgK/khuw3GaRSAFN+BTqDrFyOalTGeelBLVxsXiCqlQpVs9wX05WeFbZBFqqfKtI7cU8Mbyp39ecZOLSv+ObV5TA4HUBEQyWQUEGL17dhvzf4hiYW8hPtRjlUf892kI2Nefzsh7bWPWfu6E/lgQsJaexs50MpW2V0pA/cL4/cE/X0Z300Ns+52rz2498LBk17RZVc93+4x9Gozq94M7kfx1DBi31UPR9L2XnOzzKgFjCsHt/nsmqhWqJ8uSpEcgcMmPBTvnIztUwLeUjO7r5L5QII56zAjEAv6db7XPqr+y5tea8tMrwBisPqmctVLbWgyuOb+EO+HIakUwZiSDDD5LW/xuhXT120L2YvwUBBgky1qExIB0Tt3lyvJ9JsGUycp6Q8zbBA7Lqk2kYd/FhLz1D32hq1N4yfeTK3hOs+u6EwvK3t5yP4Iw6HFMNJNyXDc0lspZ22w4Yv4HGUam5EgkoTbuf781jUEM50FqnOgxIS2F3obi03FW4R84Rt98LHpyQqI559LzLJLnOpkD3JSTruf0CXEMDd1Ugwva6c4Hgrlr4NXx9L+JmUhqJH5PWJJaU8vEbbpVdTl7UsT1GVHGBpgd+DGYGKMxvSGdyLugxocVDv7jsVFPMnxdXkJ7oTUOEUONRMBfJpUGDc/KViod9uS58+jzt7l9NfOJGzHwNVKuydG8OlKXh6dAmBOvVcEs7538jc36EGWtwTRmRmJb91tMHyr+91smnd0u+ueCkg6DC+t7XMB9E2u18L7+91xBDRp7uOM0u4U/Qw5N6ACpC95MsxcxXWuhM94P083u8g2nTNQfNIFPnN0Tm5opy6HREhHWuAh+gK/6pYo8VX/qe0imX4N9bRxcJLSz+8vD+j8hqKe7dNNKIw3bU9mHEt64GRw+q0iUZTb7DfFb96cOMUCTZqIdQxeH5JOXMJ9xCSVa4MsxC3UrWYnnurgwHbb7rNhAcWMMkv8fDvE+XnXp1VB14ppySZMqVMJogh8HAMIkqQdrpODh8Vm/pAVEIeA8g0e6VzGrSQcqJJwbd2RuSHuItBOwi8lDU+A7VV9+NLtAF17vB8hfMRymtI2CMt76CEid69DenXTdA+W7Ktt+RRsup3LzKphBfkVaKCp1wqSWmmRwi2NA1Je974OFRYkrtZqCXnws5EkW7ZOiwVrYjEmqwaAAp7U/HkDysY6JS8m1rihTuIIgnYUF0Hygo1KOiXk3fBeDKadMjaeEkrriz5phxo6XZ8T4g9xtlHFTO+1Gv6u815Ts/V7RdEVpkIWvAhAY2bEwP8tlhdIrfaXw6XlN/YELN+kF3I6ipFpsLnT8ecYaRDXSsOi/kC1ZxPm5JAeSJNHWp6yy5+nJTtRLc4P+LfOHfnGdYajOgjF1OOZh5Ksx4NcVUeAQQlnRLnUpMAvFiYBXeFN7paijcztnkabKFbWoFrP73tvj02ZJEehcTwuR0uYfTdrr7sCuCzp2LqlhDniay2tNpmFBIigAiwT+mk5xWlC67PYNfBcxZVcDRjYYqjbiBF0A5hEbFWaNAAhZ7XmzjeyhSBXJJ/VXAwLf4nrBFedpoSiIE3Ju+SyI0CNKx6gq1MR1AZUN6OOdrE1zovtGzNnoBLBssJpBVP5oZy2R2s86RPUWc9bEIsR1Hy8+WGdXIhTu8UZR0UNqL/o/aOZSUqgm/oUbwX4dRYobrrgEo0LwE+yPlb9V6cOcudFFEGt3idfe7C55w1ZFbo8HYijsU9FB9rQBYZOb+hJ7Cry5gsj3DLZ0XZbbO7G2opQcn1iBC3wfUk/Vzb+OAPW+YflSqEhRHUz90bp991nMz54r0nZOS9D8Oor1j+8cqEPgI2CAq89XBMZl/ZOGRFlX33LHXpEAKNB7oBtk8Fvp4dWQ45mC/OhzG4gvjPYUP/veakwnexvqufTLrKm3rf1PEXwHUG0JbPDnLCHRhxwhevXv83oJQl7l7hpHte1nBA78E5z+5AdqSkvjVu3SeVd28JEaCMxI1ENM5igUdKOf7/PaFA9X1n0vSsBdKj4dslK0Cah6lXHafhEJlOs9OrgXZK3XCqvmbee81Z7a5nfjeW8g2runzEnV//86ajqig+ubLWxXeXFNcRb2GbJCnDf9g1wrbyP+MYTrJogz6TgPa6wmZQg4iDwtSo3oWph/qmKVoXBVaLQLx9go+0uVR1ZENThjok401/ORKy7qSeCX5q9VEquHD6ofXJHertCNgFCPu6tj84PJUMRy5bI9Iz5uuD1El4dLqsvFsXD/EoUwTwV+jQ46jBQwdEJ/HBMNcLwAmIIo+VznxYf2wYV+e5AkxT/9ETtHPChVoFtk+oTsjZd2P3AuW5p+vG+thxpFTlsPGOuQoHcijgbyRh0WaoL5hu1GgDD2IJaKBlB9ICKi1ccBnOWr2WONeeYUCVbc5qxnUVMAj3jOOZVj3g1JrfdQNcYHlS8bDXNoW1JxaKJokJ0KAq90mu2x7DF/q1D7PGs8ST71RiZP2nfKmGMtOIX1JNAfvhtfrOIE0bDpZC3tPaKIyALaJw+3JnDCavZb+4R50VmoHHIDydOqiPG6M9LKZ3J960288WqyWaul8oKqlB0Fn3+sKIjQ35bkT6GBum/D2li9Y76VHuruw4S6JQ8xIVOuusot6DzPpdDtzB1uofmzjho8pKxTXlPdQk4ZS3zLivKlpJthyU6IFHWPVmli8tphi+uMclr7zZPeEH/CSQeREnYhXFT0ZzQi+Lr8YH89/rzd1J4u0990o9uOmzQomEk1mkpHtuvTIt+GhO4YexU0tW2yiWEgW8I5FM0KW+CTglf1TFwGNlgvFRgu9eUwLZD+q4Yeozb0l0Hn5X3UTNgvQDi3Jcx9ROOgduxbN9Nfbs9SCvxQ4UxvSM5eEfR2gf9/YOE5nLgQ1YyI1xBrj9lRLzOeXvRSeUoM5gOqhrhPtGfr8BZgXSQtkb2pDaBMk6eXjD5S7aDZBAIVX0/qjWed3QlvcEdaVWvHOZiNIY3DJxmeyf+hfwVMqVeGmhQ8CBk0AoD4fu6MAgcIgo+mu+gyYx/2A80F0u1lvERjfNiJ2rZ8GxPeYKlM8rgnvUTiyQRKMGAD2OPK4cDTqb92UuNWJ7/mOl8tWyO7RGtYi0PUlkYX3e3/BwYWIS0iwULj7lw0tr1StT7k2TbIigMxPY/a64G1ZQ+SxJ/uDeJsK2kiN3yLDOW+deyDFIpbSvAsXykOuJJqxBUwLLSgj3TlpwQ7ao9tEhAF+C8CettaDTRXab3q7ohWj+zrj3S7cQFkIBx8vzjm9hgYy4ZFYL06KeHrpNYDRFtC1S+57RhLYsfC5LsyZtLg1Uxt5BJiGS+DUXNvUSgoWI+at+nsG144FOsH6mhG+109eOSdusdrE8f88qdu17KHi7v0A/MsyPz/uzrlkIikXTjFax3SSL3cskCck0xdLIlKr9lKx2P513u23MZCxyP5TKKD3gQyew07OiOq9UOSw6uVtaagR0Q4AeLw54rUWtMYHBjkyC31NXBmzO/Lw+xdGrKxgcxLhwAiaBAUIrjepOs6cr1JXL0RyKCkI3QxXfYlRW72zm1aYp4Wuidc4bQO44+e53EC9SuOQPWZa5WZNeBGr23EQuJ8HFKHP3epc/pi0QH5GaEVyEhltnFAtIzKQiM5Hb5K3NzRhYzp4vTlWID+d/X4O7J8G52X4/l8EWycYUMEDzK3Sp+2uUFeE12xisPVmdNfYBAd6W4e4lS+h8/f3B0nK/XFQB9SrJHvbNRKbuhSep8wG7Njafhgg9Ca0gEtbWJUXUpL+ch9oKyQkkGe05gwIRVlBM0/FgpfhPo0Kfd1AWrk6dZPBfJl2jRjbveP+pROsRYLk8/HpMdq4tyhXdRNh7ZtkmLHvnvGZ/ehpLj5BBjRjpSAPWhCwYFcFnm1RF+11eY3N53rXdxhduH/tvqO5psb5wK0J2OUkIj5aY03MrT4QmJpVwvH/wSwAoANU+oRp24meWBD7RceR4Ae/GIp+ei+edt33pOK/5/ZPOkT0cgUU7GJe9oHBpRgGnFjZNlPklbkHnRpa+TA0WjCWs8/294V09o5QMQA51MIB9PhwzyJajfenlyh4QhhM4kAurieyxXxd+xL0WzQQUfonHpQCUMrJ1Ymng2ZRcbkG6Z16bV51uf/Jnfkw2YhHumE0fTBR6jSOsd3hKJ+Cl0okyehWHZsm1jG+NZkcLmT7Ye0Fa4MCVO7dPWMYRWIfDDnjRAEZy/iid3PWmmDN3CRrjqX1C6eOaSa+++Zhr2B4x0E/+lffLIPq+QK6QvugU0Z7/6lc2i39+rFX7Ul1h+1p0bytj7su+1r3giXqjfISX/c3g7osOQx1jBO1+lDUCbxNywCknqjmJV11I2W9UnQkkrUH3Q5PE2D/42K0Z4nM/MlxerWhC86vVUI0rzAqBJisc6VCJpmobp8kepBxgVm89wW4tavlZP/mOnWoZUHh6NadBry46HQXpbwfyNY+KclclezmHkCBTaDnBQyGD5TQVJvmsbQWs4p7boeg0EALnAzoIlCy7FQYlDNDRDDaciQHFWOlY+MRi7PQJ1fj+8T04hmSnIbcS8IuEqxNYWvlm/hHH+PaLYOEcxcMy/m4ja6dln0AZC9PX7DQmnIg4o0LfRYOfa3XbQGVxE2o4Nf0n0vfP2evgJHdAXxS2657eDS+pfdIzgbaemDpcsPpVv7be8T7X7F/RvSiViq47g7+cl3PSun7wrk1DJ365zwU2iYlaPmy0+pev1xwNX0ZncoSXjdiJ42pyXe7YsjIlC9Rp736JMJJadFfBfSI7sBMn+dY3KxkqKUxHvfWM/u+QvQaIAzjqMUuefRwBVYuv1l9BtWUuIdh+ji+ACf9/TAdE8uW/SxK4PujLAx8qFVUm7tj7apNd3mb7c/wsnL48Ehnx153PWYQvNjNErHRCZXWrTlXtIlyl/2JOGvXGui5bwpVgQhmO/zp0dMWww0aZCZ2xESqJiVtFok19hGCPuKROhepY6D9THWYnCfKWX48kqAJIrHC9jKBW2b2JzpR5yKYcQXTkoJI9z1YYv/7aevPqst2R7bkXwOCvFLGlE1Jp28vvJ45uy7bL/vNBo/9+wgsFflHzQ24lCEygnNip3djLPxlA7jAMlhyrGUUFNhWAebJcYW/YA0Vp72pPmmKnZN5E1OAdExJS/GWWNMXAbLzEZRolaN84lWt3Wg1ENHMr7hNa7aV6TxcXNggfDkub8FRsWa2yQ+yDRuwbOYlyWISx1P/6dcNADTlimjORUqA366EI+tQXBssZXGP0AJpmU2Xm+UoC0B5e9En8x+4GGKPmjffQ/kpQMDnS9U10fUCI+B4Y6WiXsTpU+RpGL8ShMz6js+qEWDvnYyD9mkkgiuDJZIYwYhJtzMwM961nATenO+nYNNG+tRlyGXMy0eALeAiutQTy3JwJIFdKspRrAfoFDbUzLKzHZAmhwO8h3ry2/MiZYfh/+WyfLLWdSrjkBNQIAJ6d4JsgtrYnuHo6fCHw1sOpmCoCD4DhgCSCAg1RBHVnC/Gn3zjcOp0rtJ/8Kc677D3apl0Atg93K83ba+U/0mrA2wnptoOUyZCsmT5PpmRcfYmyaOqIjGmDQIlidRVL8ADZbMYRcUtcZqxhivadDyzE5u0Dcu2le62B/m8iXr6tbHxPhcDJTkAEPGGQCS0wEtPJbO0JxdH8CSSk25sEHmsLRh6Xk+6Wwd2nwU62RiGSwFJvOQT6p00GZgF8DNlf7OBWGolIei5k+dkbO8gpAjSZKXXnirzGjzEFmEcF8VY/8aRSTEMT6Kd+FZEsIh0KMoKtZpBTfcuG4KwZ/2vZsn10dMDv4A6oCqci6hFQEx+DJCCmbEXxvG9YU/gvomARBz6l5Zkb5OcpH4pkk9ijESRb2FaTDkfNsHhtJ5TFSrEgPT/10El6gZLrVniVHaf5dm1KgM9H1Q9LlrAUrIdkTzN4eN8nrqHEtpUIOOJPpBvfTtxFkUN7l9lH8w1ps3nN9ZOTuFQbr603vKgA6kwYtvhh595trvHx9nbpAnDGF9coupbPJ4J4/dy+A4ZotsGiFHHYSrao9vUSuvK0DlJhlXQLPgdJRnxEagBUr1bd+Z35zznYMUTH/gzSjimI7r+2NaAb+unVQYvBFjw88wXoz46YhlZIHOUzLrPLgSerSkL3MVeFXfqVjPNhDCZukEDKXYlxNF+v7U+rhaJ0Y21tbSOvzWGJsuecGDyTlSsnRTDTAUm8K1g7LS2v5IDarSlOg3pZnzK/HAN/69KpvVReeTNBLBcNBuuFuie2gWBrKswWBePdxrq4jqhSSfdHJIIvfnA7TWTp3K9AYA8uIBq1zuJA4PWqBlYxOfoNTMru7Jo9xZhBmpPv3Iifa5/gunKFKWGNCoYhvXPUnRaM0scLaqyt8Hypp+Mu6oRydYUk0C8ZQQHvTV9zV0lZP1aNu8GAnVlR5sZEaRzehw2UQFeGIu1Ibnrq6EGprpBTUmf0hhHamJYsejhis8wGDWEY11MbPrLqpQgz2Dn7u/HrwMaql7Cnzd4JOSH1x2qd7JArm4l65gVMSuLU0fiXH/IgReQYsRYROer8jvyrv/AhcVTTE/riUxVqOT6cb5K3IPiMteoT1MvaBuf1eTni20uhsymkkXsRiM/9kg58JkVBWNwRtgNF0fBuTENnuxOzu5i2NsuR5vAzS/R8/ykWvmwrRj+OjkQbN7TxYhGr72ljeiY2EVMk1PzYY/bsBrAUaY2+tOG0CP6Z8hal8d6cuB043Rqq45Bhw3VXMaFRA1aI0YtX85mHOOIRx2gvmyRBhomqXB/M76PiJuRGwKFLEM/g4vTD+iIRg1iXdLW65nLPhtb0wcfpUlh3U5zXIzRECDIfckpDhKz9eNoYdPxch0Y8dAYeIbUMfA2e2UQTwdvSLf/XRdPW6Q+2XUdofhg0YQhoA90px3cppM3vDw23/EQ2l3bGTFqYMNyot/tIemZ56IX29RmYwoqHFTBJPbZpB1/Ev4Yjsn0t3esbYyE87f6+CpTfoy8VL0CShNR6VLzsVWDSRax40elO4JfqbJJwmK95KVSQpJ9je9cZxsco1bQ6WS4RvhBG5Lu/is0a5DfBy/k1uMo5dQyzPsFFLxB9o+ilNaw7gOvlgJaaqP2PIwQkh84mpNQMouRGYRHbEY+keWvWXarOT+iOWepvfAgPWdCGjxKTl5g8udefeGhGk3orBZscDTpd/RUfGeBEOE1jVINXUKxSN6+mwyvsvtFd7ivwWjpJXoiDf9bt/227BukHyD+DJZxq6/IF1TvV3E1jp1ezcKGyggAuBrTae07yUWmOCDCgNNbUdgNCnNszwGSyY7cimlixo8wFSFdSKeXqQ1oyWeBk3OvKIeD6BnFqhUzOiPt7nmpnu3zlP9vIPmqi7GFX+8gmj2C1aNjUQCFa0qq7z/JpNbDgHmy4EltaT5vONMNtaw3/cVF2WJ9Zt3wcrv6zyw1Ige5kqy1TLnmc1xmpTVOT0LzJjlgmyUg7TtC10HWTI4x+CP6W9IRf0YeR/KSlelDX7yYQseu6EveMWvjXa8YpteKgycqfEO8WyXDyj1SsZFb3W2IX0gsfke4GcQWQKwCTXFr0Urd1M8lsEs9WuDMVwDd//Mv6Q3IELMyJnGhBpK/ndFfFYwxN8zjMK/1+c+j8KoOY+FBSd4L03+E1fuBs8FoQcI+DgEWl+rkWq7svBXfcxZXKL/gXdrTQGjeCaF/GdndsMIMCAPxZeBKHCpt+9Q5xWoLakd2fJZqpy1dau3GNsbfGqBF66+rLIB5QFuw/B+BFvQdhbwKkOBakpf56RoLzMMMA0D7UxRgwHKSyWoeoxq0+0j6dnSRKqGQDZEWo00Zdo9/CeEfyvwPyrdqT4c8B/UIzwxqVhvlrsDpFEq2/72RimfIYN7sZb/pxgaLdQKuPdFmXHqknPY4ah3t4y1a2fX59/nnwE0FWF3/zcW6Cuk2lztgXIkcW6ZEzk9nnx8bLoS4aBwmOULleY7u4PC+pNlGVIAxhFZ2yO4RbFsR7eJWw9Cw8rzcfLHLOK7F6IycOB4L5Eosbx3zlcck4/SoEBryUz4h0GEjiHAUMUFFnO0K/1MrW2CP019TzBRoLod327ClF+aT0ZyaexNP5uEOv3Kd33VTiCdplUWY3cVoS/YSmA70a1NVUGtF+NF6VgG1+D1ecVatICw68Ggc5W8pJKqLq+PVhS17xoaxHbtGioClYZpqTx1oK53kBJk+Lj3Khw+CwDuR+si3ZM6qAEGdW8yov6EZNWdbraeHs9tSpEfaj5hTMTCehlccr3oG5BufykPuyaM04oVaOr/Q8KhJg6wcQ1YV107g/Rl9eXVrc5Ixp+RGtF8bvoMtcKxjRCdsANeFDMkyLxVlCcfs97BU/PacH26uUYW5CmBdhjloRiIjVScUhSUKC66NQVSVSZP7c7+GItFFZnKRnPGXqLj+muLLinmwIIMPgxNxRLmn7K/oUh1h2XhCVFTZNo6wvgB0ZwPWJhZpox6s2E2Y3HOHONLpMPp6oNUk5djQMRtyXJGD/iATMOiF5eUgsOObKCJcFSbUW8gIycYZYQrAwFSCwOcEvxvB81SYD+o/HxGPRh7t7ZnJe3qUF/Qp9OcFjEgkPZ5tgSfnVER2oDHwOihw/lA2CuRlvPw7k9G1ZbvZ5OGpGidDS+W/ZkJ/JWFNcYTB9Nv/6zi60j6Znp5QUIdLix80izv4aKyIMKlrZemDtODViHUwc1n6TUlonV2Sby9nsohZ/Zi/dgT9e8htVt/T9Gcx/tF1i7UUSs1tkF3LDvYUb5R2elHvj2mEaU4bnR+rYW9+YAVI6ZmPShD+1Rna4TsCuBWOItqGoV0trWq5B6iLpX+ubP+/G0ieAc7y5sIZZqBZPqv3/WtlWMtInMt1NSSt28B5MKur48fNzZXdi1wFk2OvhD58JPKFYTQorFp/gnQ4HHXMGWvA0pd8yfw1MsQUfw/HEAObdr0dQ7wwku0fre26mdB6BKHkps3spVcs+eKMXvRCbzfBhWDiuE5TGYh09ULpCpQor4P4aCHkvT4eeUT9Y/qkhdQ99mBXBpSZ32g1sGMHz2cn2tEzniMejyQXvv2CTt21mC+J22ZXGVDThiZTldXKjxcUII1vNwoZUjFXMpMpcZ/SHscXivAbZAFdugywkccJLs+9etGwE3V7PcxZ+jqZISEZWwB3mnZxULvHO3chOIEc5t5H3Kw6uSSnVXMwGCNHzbN102Zs3apLKOu7PKPIcMOmRHqznF7HcGsMUSdPPbr7GMIUlkhOf3TkN/t8XakPPwqwZPpSrxvtgDEGGAsNHi9Q2C2CBvFMqo++XUmOs/TDPsySK8nRRneQAK7Kj5T8zAZD3AQSiN3UqxPJXdmRFMIXMmm9jjD3miasN4Spn19KElft0DqRdsjL7oW4zHjg1MHQrmj5zsX5pEaxp0s1dTJAy7eOXtNWWsWOBBZOOdI87kAojLcHftJiPOJp8mD1mlaMhek/zd8f5tlR7vwXnKnE9T2K4Im3VeloXnL3dChMLh70TrNP6gP90TOJP4nbybsubLMwA8iU49CYMkeg8m9wXOcOyPJdtRNbNqIwV9fvyva62v889NTmSGx1UU2lA2P7R6S6TLr4QQp0Mh2Jy3yVT3De42/DtyKWFYeA8HWCMsxNyzEpwVpYUgmQiX5qf52oaGLPZf+4D6JLYUFNE4U/rhyposOXCYEbXTOXyHUDN6cCP9gbVxrZHJAc78etcfVuRbiKqFaKSHqjepvoKVL8cLs7z35rwgrF/8YKwgCZt6wX5wvFSOpssdwgk6tCbsOKsKYcc4tTKBfyYxnCYB7j/fJU53MNgO/0UrCtzW7PSHFDFxrDgPFpjEUvCt0L2RpFBW4yFHoiYs1fqwp7Pn6M97Vl5pLtyY7cj3O08ongPrZjbbpWtwT7aVMh0GivBGj7Mjgt1l8qu3ieSP53yzrdlIz2GC8U+TMkJaQ3NSjcywh+GDW8PlnlEOHrcpW5ZE+iqtlL1tsPm+l42VGqQEzzbcQM31bIPmi2KmFsH+7sFPj6cr3Gs/cMdYFCyXk42RcEmgtSTGXgPriXrf1uWakWOK2uJ/G5TMpjFLRrFtGb/kIo2RalLpkv03pV3Ivgwophki0UIjECCr5xAbEO55XTqh1VPFV3Bl1hsvoqOHoJHpSKsW40nbBHI3QSpv1Hw/Ls993rjoJ/tfFlhgzlIOio70BrepUhwxM8C1R1Q8K/Ef/RvZDTtgQnEUrdj6qr9Xdp2BWX/6bzwIf9upYn1uXiMz5FPpg6ktm/oSVGsd5hMMc+XHL/QYqJbRjxk5CnR0FBVAyD0zJfkyLPez3SRiR53GjlbO4KwAiM4eQNX1bRih5GxPdhMAjmdSiaZt3Bv/97hkSuFTZ8vpYtBEMsBATENk1nAFLhkaZBIKcOm08CHevHEdw8uSKd2qC9UTJgnh92ziS3XTkTVpt3M76ND4MX/ZUPb5qbyrTfRjhfFqnuB8PK91DNkof92vf+yIn9G6R1HQGosl0wW0JODeqFMRoVHzlpCNXs0GpP08GRNJcsq/zeaq+iRE4bpmWPcWVmZZOhhIEe5IbD8BmYZODeLFyPUaGgaUC+13f8x9zwxX/+FCdVumyv1hW4UYvbNzR6ojh/9DBox5OqcIo87+2zWaoRDVp4wYB151xRV/57Csj8Y/wKpwX9QJklEfDmwt7Ehy9GoCWtYGu7uSmtZSnS9wN1eAyY+IZnJb0MYTgSpyR2co9Q+NdqiFGPp8/mYDXtZ/vrCwXOA4U69A40elUlKdAxetR+gZxm4xJhkOWT0FnJMf9NKJp+4UmD9h/VzPoWmhOs9hdXihE8S40JUcXVNxbtYMA7VDvooey1u3ZAOiOPQFIKjxNPhSiHDCmxhafQeL0c8uXs8wJVj4ENYc8x9RQUbzwjaN16lrdaHatmlvGDHfNv4Aj3dY9B3FKxs14Cz4LqSoEZ9NRW9t40cpUQUDyY/f+LiBOILkqTepRFG3le2p7JF3tVFaMvQaQK0Z9x2CQTIa/uNcmImPfP3txPklK+JIOGrk6Vt4vH2bE2mSfSKi+m8r/hecV1q5BAUXGPTQExwgeM9TIugtmbOnzSkyJrE8DDa4MoM9bnQMbpkXVFRMAAtRXktEz9GTZ5NoOQb9B17DT71FFSHA764GfQs5DTa3+Rebv/VgjNotrIfvY/u/XP114FhfP1e1/KKkmllnVQTVOWtCY17duIGrg1F3IcP22YIGjiEPPSGYIoYumh0OLqOlRyt0ntKjqcCn5pdd63IpXd1DqlOrYnf2otOTSbZaNyItbYL7WYw1GarO/679VkKUg+a2UJIbTgC+ILQw4NLzUIBk5/En157zbDanPo5mTbPUfrKvLWvdv+X5T/Z43KGUqUcp4rUlhasxrp1T65UaacCbEkvPrWU7LWoU/5pEiRDxIqZGZJ420ox6u+IE74WlUM07QNZWmDv1XnP/roOAAGgPiNEEeZY7ffTJ8OE4o/+MC5XFePURuy2cjvoTzEaoS9SnPILnBNOCk1FLtX3c1qcocW540mMWBcEJYDEOLAZ1gotmhRr7IG6bnaCApOcA7DjSO5PPEiSOc2PSufstlZbWvuv8tI0+xu3H8TnJOUSlQ8n4RTj0Q68NlsB/yCe7mrCkMj0gThR7MLmZjjLJupiZI0rvsq/J5sI9wLlSleSbdH2A5fymSKJdH4Uxq876BQ3g/IKjY00H0VV3b6KSwJgqso8TUKzEk9rfBbuscQaYf4dNQ/CwhBO8PLKiTfnQcIiSe/b5Ohxh/QkbL1eJMcehFKJUCVRnKSMSzwhPAoBxEcAN4UpcyKKzdsuIMh5ULI7yq6bH3mHIG/7Y7UZukq9883dOOyVwQZ6HsRd2pmJe+pgLOn4Jc/F2v6BPG4bFY5h/R6ODXRxZ8/5pTG5w5kTFV2/ApIKXb2FukXS34nuwvMk7vb+/vv4xPf9fvB1rqgmsgmzarT7QaD5dX7LZfUtIEYPF+usCdRu3NkpAfl/wj4XonEOKe/zbAC6s+vBDjYSj+Pqq7k1JMli3KtAJacJA3NvFOQiy+yAhubsPoPx3IC1Dd61Cp2lkhrbp3eVeXC1H2Q57fpAy1OPiUuDa8WSecn8uefsPq2R45xAtf6cVB2hyoJBfQ5n9I1BcyJifePVXKUs1HISrGHI+UvpGSy4PZ2HV4YnODlhti9ya4F2y9tBVbXjLBQPMPQWSDTSgR8ih8LmcMZH3MmdmGLb3FxPyLE/B/BTvXRU3/5vEJ5KFNbFcrTtz5tkay8wvlvHYNKdGIYi+8i4S/mgLo/SrBkhAGnLQK8+fMiF7n+XNvShP33mbqHYfotYLeKEHHJL5+E0mxaevhJNkgiy9Lp26qNBwyTxC8hoZxvAd9iSj5T/hsP7g5jiZPFDQ+GQfAECYTcPk2wNmwfBaFHwqXMl2xS37/Ow4+ZRWHiDowzH2LOfxIJ3pbWGQmeD7CmpiohYCWXVu4+NcFY8c1TZ7tUVFfxhnwJiY0sSfVoJ8q3XsZjLHiPgBmF25TsDr63qo37Upd9fiQs+SSHFosJhbpA8bMsmBb7e97XaG7NehLEESHhZI8WqMuDbj9oz3BlgMW4jMrVfYtt4LEo4G+GRtEOcgNkHGfQnW3ty8iYGDRxRU4lacXx4Hpiz7rnpcu+jzqWTLAawsbBtA2iTgXt+cjS6PKmp2CdZYeyKqFG/loTMJguYYwBwKtUU3Qm0WcwAV0YtGWg7BojRsoApH5q6s9A2jai67wuiI6bxya3yk28GF6j3QFRnWxohXPzQS7UiAaBLVsP1+3Y5kWy3HKagaYrm9tNCSzBnKYk7jG6el3hYrFLiTZ4/kCa48xWtre/T28rfH21ORvSz7ARrFjWiEWN+LqCh3bAwOHobwBNB4C/HncVHRze5RnzSJlsXAwtCK9yPVJhgsD2NRMjQTwA9/e1cHcTB2zxl+wNhvuNix40+QcWc/K2oBPmvntunX14Uhju1nqUp1VFsIzjdiCGSymRXFb/ccGAqYE0F7SzFnYQlSpYlidY/ZqE3kWitWSy8q2ckNusmrfIK9Wh2oALXvgRpm5eAAhTO3vhlH1hf/+hGQghqMVARWJutStiE/GRelEo3nwovMZ0omhlIV8ZNHkorVprONlTGNKUBFbZ2Q2pjQ8Ld9dlniq5Yd9tBkYfzW1TfqpQAvPb2Hkkj0PsLE0MMo/zQi+NgF1DIdLXFWMXOtXHjD9o8byToHe9LwEV0ComtneYRbTC1vL1SQZZjqec7+tmOH4Qh5lcp8XfXsSFBGhtkh3A75aBWQq2fUDG84zqk+jT2OpKy+IpGJJH79CDb7CFucX098O02PHFLEuv9Q5dt+5NPKzOENZraH/qpylcD13IWgB5rwrEFDjyUhHOz+6xNfiOcA78VE7xrCyyrNW1FJaEAcPYzyp8vUHy1KDjixP4poviFwgwrB3fW08HCa/j59rOW6QREp262qRcjDQxIv8WqI9Ob1oyMhdMj45de/sDQeMebdYKBEAsK8GHJbBnl9qEclS8L4C2ToNWg+Y3k6as5Nx2RWxFbYLG0g1aaHgbPb9LA+WXZ+WzZLogWfRTKHsOQv3aa2VzseJxMMtLv/Dbd1rm3DGfzp7GvtxMVXW7s8d8DSfpqqc7ahK1eqyVWlpbyvD/jeof7P4z10ZYcOFwm2nFJt8R2kass8d1u0zVPbEHeBWFQkjpsG5iWdNu/TqqeQUhMAJBpIiHy/HfIdyuC4479LfHFYjzD9LRezbcLHS03PBLYJSODMlq+4W6zOreprQhvMsjILC9uRF3BTQehrqyPNmDvdzw2m+8+9+aa5SJ8jNPFi3q0nyl5g9exRDHlyiiX+ITUfGM4IwUNHcPsxi8wHHO8h8Z1RbysQUPWLjVzSQsZCOLyBf+I/dH3ATFKyAQrNVysLiG5ESlNxsIAup7Vahvsi5DvPDAOVM/RvgT31uZlmg53KwK7sI6qtnEHuxQ5pdtXjMZ8ELR1+/ERkJEE3Ylayin3ASe1brubjNWyptsMxrJaQWMVoJ24O41Ts+ilC4ZcZdaPzXa4t9DAduYodoD8nuKTLaZ7F9s9pKKKBCotJ+2axUVI782KjN9nJscLjxUJCMYff38T2XBT5Utoh8cEh0Mqc8H4Jil+IRmhbuwSuL5h2Hv1KinBaSHhI+p9AAV0fDFA/Zboc8aB/sSjRXDw0Ip6/CGO+Nm+U+ck4oC3UVazgUTDiQYRQdbL9+LLy7BPxQ5IGR+xTRq92L2sDXgTQxVGilEVAtCOXJqYsh03hM6tAC60ui6xSdGsPwbBDXwoUyim4oXj4ArgA4fgduUA50uzKwneVpMZaFOYHTKcsWODPS2M74yHaDt6aIpIg6VAVeQmLkyGO+CLLWSUC7k5/zvf9Z0h3VEFb9ElUUTKPRyUYPyRgOW9LLrYcOYHyX+QgKkTro4z/XlzOMkvhyb6UimsmtoVQ4rZurZoGhYFwEHViF29Y1+T2c+VNN3fmQkVo393jzPQEzaeAoKD3bebbXnXZ6pqhYtfO6AtiShQHhJeJVJrGtyfWCwzJ/IVAa3vPanWkM156cBkfcpmC4XRvHWo5l7XxJjeayTOph6tEumvOuNVrjB5RGu1zAHhckvlm2hRMEodkU72nOyCk+iY+RAwzKjn8dzXvRcTds14Hbc4IDUAiiWKhwhvaaHTqP5kmiKb1ezFNoWVFd8sR5QIsng5tosdyH91rVfxLIs66qanZaLqiDiSIFoHOVTIBbgv67ayxr6fOSDGwXIZ8fnx1rcM91gz7ss5Dzt8WoNZIPm5CluS1MtJYt7gbKzsvUyQOjBaUafAAhcRBZmg7v3QpodfDC/WgHAelYX+1kTpaa7YY5gG4x13VA2WyHgPSL5QM+sSccQQPq2H24A70x+cM3f7nSrPCAYvpcEpXNSRaNRtm0sBdzFJWysyNxz9al6z+tPmWTE+fkqzdqCIwU8x/h9XWJTSFFETO3MOl4Xr4WT45kb8eO1RGN1nL6B82mQMahnCBWD0P8PyA3nqQbXy0cxva5BNfA8ypvk5va6cEgZNYtpMl9b512N7MwrpQNFUeqYT9KWa1XS+Bb2MGi82B5LVzS7p/pCQWE8cDA5xt+B3NLZkyFQHWZaDKSkMwKsi5EI6s/wLDkSHmKX58tt6s9U1jl2BT0gqG8VTm9Hjok0bzSPzS4K8q9JmCAjhNlDaXX6mN/mTgFlUH87wJHvTEfXwL1uVgA/48hLrfy/j0D6kPljMTrSmblml/ns+vwZv8GQxHCal5uGiYjbgSSFXQxIncHMAsEi81YcmnQC0j7d4mzGBpzKAAHklv+RX0feGAdCay+EuaVZ3C07P5GFO7n2JkOEBMrvY7dETDGyWivB3/UoKvMseSJwUeTilXFgGB4MvLdkZuvpJHmnWQmHwRH6yKsWnqfeX9PTdIEj3/KPcS/7r9hS6AEoYaQFriz201MbFwMeElsH1sg/2EtrmbRBhX+PAaeb5AfT44dVPzqLZ/75s1AwPK03LLAwIjojK2Dp5AKMSvfAjzB+rZ72Z86KbnRJ1piT+0L5WRjdscTXjfqfpYbhfxFsIy0ujQJ0PDZ6FxH5BgXErpy7K1HH8Ec/E4261C8GxYRBQNKgkQwx19juPf9bWqiv64Fkgf5BKe2EpigGMIO+wwk3UyfdOZH7m/Y8H2D4YFaFtqw78e11uYWWKooEUqzy5/PE75T570sANNicwrzhQ8HIxRKTza6hflrRCQFvryw7kxlrSQJWntCoDPkZ30VBmc+U99EIrPlkrZx9Gg0wJCBcPf7Y02Enmlciq6wpF01rO6M4rYsYUQL42EB8yX0tNlEX7aqYfG843OY2h8ZOzhYkpAYboETLgmCoScP6cMn2251FNHavMGLs7T8XBRzZYAYjV0cm52/aIl/NRYAbe6gADST0nB+/5EJEIUxTMuzNQkGz+u9X4Ngl1ywAy3c14LYcdr7fz2lKtpgyLREWSKyw3Kvu8qDDgvTfZEKPx/dokCBV5R8D/0UELYy/Uoj4151QE6M6vEAmJAHlhxYqOp5SiPWI17aAHZ6B0qI0F5mHscojYlI4lyQg/gKCHwOCCpMu8iubOO3B0nnS2UKpgsFQEEKFqH8WqIYhK56ERZUVUBzX/LTIJoJos30jOaITLYPPBkaaFj0xKYfhYNVvnYOYk8Xvg9ztvjBJ44K1+HJhTnobVX801ZgJNIm5uauTw5L9g+EcAhxN+yMYudYiJlavw3OzoLOy3WZxCf/HLT7qTFOgdAr5OzQAXgxPquNtHYVIO7tRG4s6L3aauBMlT52RX987Zw/GBzUEPAaXyGq+80RiqzoD6RBe9+YmhAsbrAk2O7IufCNko3UCoFo23mk72Ef6fT3kTMX1RHIMzOBmcMONKxjOtA6nnXR5jG1cH15iUV8HPbpclGu/zGpVfVNmetn6He84OVsTWnbn4+NMwHKnE71UAstFZpu6DdKtDdPnKHpgoH9GtuKHYxtJ6+O3GGMB/0YkjwQcgkt96vV9GH/ik8e99wZ9eBhgyb6PXKtGUv2Gn8n8Aj2Usiyvwopi+jAkccfk16C0M0Y6sVGKmqUUIpKGQ5ijXvCBaHhNR0C5c3tWYfx/ENzAU3L4Mzc/rF5l1WUsLta4B7pltx2YBRS1HiwFYcsRc/hlaHYMpyT9GA6ljQdyeUxmWgTN3PjvF5jWv2SH6Voawza9wFe34nX2mjKqdfMv9sDqhRX9HGuiNq19+8cYr42J8G4bLeYNspux/0C+7DB/JfkzeeIER6E8USIVXhT8HZi4KAwktfemyQ8cp9NXCaNeOaPqokqXsOBjAH8rOy4ZswTEv1f14jySW/wiSkR19FsTGdmfBxck6xGaK//tDgHK9zhfzixdqda1gqjAACepax7yw82o2pGjfhmo4cDMmpOqke0Eswwp+hg3uaZuuTQvXNQHrfO4lh+XO5roc/h+X/vAt9XTa2gTepdGjdjyuiZuP2n9zmNIFbZBfwAE5LhMwMCsOii1HQ0E8CQa+cxXoI52Tce/rjMopI5h+0LjhFUycWP7FlBX3Ck9BZsVLd9dfHjd8UZKVQxhZDgRYIUJcV641M33pabt8TkApkYL46JQkZL7zc9htbj09pmckhXpygx3j1xeG4HXJrPryW+H7Ib/9Hiz+f8x5sDouHBQXry2Xf0lpuy6Gf9xfWDzfeRZ1+kFCsloWBr/kOvGZFe20zqCARnieofbMr3Wo6pUH8VmziPH/MG54OVVxWVlgI1Fjj6Y154cuipmFQPfUS5j2WceiJoD3mpjz8tK5qjAjB3Zn7dEuG+PjJGkSwJg96oTYS7Fuh4VQnMaEtUxzG2lFqh8G2jizxuFOlkKAhnkC05t9SRGNEImgL5OVpPrC3zIPj50udYrWaTnWy5/Rw3lfPou4REMdkD+evEmcSY5Ub7TF8ErJAqa1GyIbjfw5gurQpnh8zZQzJDXBpK/YeFkHPhTc3GKFbcQzWPy8oL0oGALae8b5wE0erKz4ooYUo4gJWQANMzOwhXrxleAtq7sZmzBXaN6uehMtjsWvCgk+Lh7GGRK/8hNhWeIS8aAoS/b0CKP12zf9igbDb5P14JQZ5tywjtdzdYdA8PgYKAAOnbbK4XBHHywhpBxq9GxQxs2Vu9Rjr/brJCpZ+2dGDS5xtUh7ffjUXt4rU7X9NDHfcztJLnHNrx1QAd5yGwhgmzjGkDI9LptExXbODjR/XoceFV96ya30KO+SJEW3e5Z+M10o+h4KNzOhoUjiRwU9wXu+c4d3S3NGMQLkFVgDBOAt/kurIUku5wBsOARs9xTP3xbhOolC0W4odYRl00i8IaU96KnyvWoTNtPVgcY81ngYArOfoTMffARMQUlhIHX/N1Uz3OXsZpbuqgEdF77f/cLn4fbPvxpBq8bbi4+nU03AKivxdgBGo88m7df10hJbgoQLM/2Dd2ShaViWuCjspd8RJK5roKVDb4/ghMmXoQ3i6hTWKHeVGpb6NmUq+S3VUmMKAxGR0UifF1dveLKGDtr9DVGHPxQdWVACrfi/ycSvgzPlsi3dwH4bOCdkpBr9ZXsusuS4WESXNxLGjqJVkHfc+sMCOtbeVs267UZBoTxrCU//hpQBoL/C3SBD6f2DS4oWfcE054BdJjkwVMr++nxVbU2GqKF+eJBxdKSO4JfQecOe1c8Y8hnUy5L6xcbOQPDlPIPkw1mZtSc+hfab72YIcZNEHVrh2quzMifmN/YUvmceDFEhXHPuMzNammxQfJmInAE6MjBmEAOs8sli4t0dPslT5t8Kmt/G1vTi+P6rsiCNIxAoabyw6kQdRbZidQ1wI1Z/WXFDxaSZefZ1V62Ix+CSz7aLdRJAT+nCN8ofz5JMLplufNq7bLUh/mxDDj6rYR55PyXv0RACvzuiTFeqpBHKvHIdUBUTt8ZRN5c5NdzzBFQNdPK1vzQjyT+9tTPngjrqnYjWDysJYxcQw5GRZSD6e31dCnVdMcmkU4+LAkIKaJUHwkJ+1lf/Omvp38faUy6vOdf1HHsei6xUgCcviqH2sPOtdgI7A71JZdgRZ6wzt7SmU3EytBc7D6fM0tPdFZaMjPeihZ0ag0QmKKmSF0RV6wkyC9kr0EY77SBwd1zskZV3iPI8P6ZBRCsedJwEyVjl1uqkAXxeeJZlzOXq5IszPz643p/m3fqulE7Zzoi5huHgaoVTQGyIrtH8H+mZuhhQo0/18L96eeDMIJLwZwgCXgp7kCpFXKURVNhO3cRHAlCFKoM2cgvfP/XdQJ9KRngOQIOrGnPh0I3f4leGPzMZTANo4tCXUn4W2vmPJxxLK4aC/sTKSROM/DoXzqhce63jnrPtIGYqAijZsfKArOgnBYDJeCC7wW4uwROmAdNKOX7WEfoSqi+p49damG5JIhoXoklMCERfmrPYRL6iov2Z7Y4RNVYpbCto+mXAzP0kYpAONXkVk3iuH2ZjfUXeYRfTSE0FEQdcrlkLZ88Fwf/aAEJaoTLzX27Hw86NFIYBa9X6Is14DZsemtERFFn2BGja0egMnr9T1Y4J7q4sgSfiBg+DQpzo9pw7CLfOPZRrC63UTghyPrkspGyc/MVBhKEh47iWfgQ9G2Xmcp+E8LZ4GrZOg2bab9XKZQy6mGns7n7FYiInDXfv8f5K4BJF5CYkpbxs4rXRN8U+f9omfB+NX3trQwGnnR88PYQiJnPh9RJTEHmi/4R72gi6AXc6oMU1j2bK2sfo5EVh4ZHgJPkcbc397gP+O1KFUbssrizPBfhfI51XftPSRNXFcWD4pJZJAuw2zai1MHvBGtT+8W0kds9HjG2aj6tGQiA1PrQY9HwWEhI/ds7e+sGn3ttFPzdigPzAuxCykZwIoyqz1uMHjN1hWC809Ez0A9HUjC89fNpZxD4fa2rcE4S/3uDkH66iuZt7PQLp5Gdf9c+tR+4apjeR8ZvY/OwTGPhPo4vVz2tT6gmyhh2Nleqn0EiSqfv5ox+kPOpTuNDIqQB2k0Y2S4CvgzodIDarP3eBYNfO2I6WUIF4UO8mNeqEyIdcZPJwVAQOGsSJG4dq8q12uXAQUk+NvFhn+BSSaOPFDcdhyGg/E5NYVpFvVjLpY3L5BhuftAaFcHo9ov/KxxDDCV1B8G5pqw4aPPrXntLWBX1ykOWmokWG2lJIq6NOwkqnHYUPVhxLL5/KeyRi1fvgvYaFw8kthWYVv8IKKoXlS8P5AAtK0e3WIdFWVGb3mPkoN8XPSVOGYOt/HID/tHh3MQL20J30gkp88GDbB5Vl3g+xj3XpA1xga+XojCK5715GcMmnYpr+DSG45NoHkc1IbNHMGypU6SYsdFsFVa5cgrA+35wbvjo71UjsMSxtTA04ImW8FGRXhWANj2eYAq+SrVoIgLDfto8asW9SNsKMdjrzd5BfEARIYbLVZK0mTDO+0U2Ohc0MbB/XuoB8Z9vXTc/BJqY9iY2mkMjW4wqU4wUlN2Oqqg3U5YIE2st9eC9N/5FRm1b2QsRaAiLXkmP21PFHDGiDnKKdBZ1hNEmE3ZFXAkEWZwvMa+tVhQGESk7iRDkFIFkBA1xc8W/ibLoJPl5Ir4UMAN8P3vwPBC8ukWEScdbpaJaSDnZglZ3dxGgYN1rQZsnWNfQcpJhsFTOBV9cSPKaf/znF9Zie0V+NsjGGOeVXKAbP0ipj7COPcb5/VN6zEHG6FD2qZ4VT0Z0/eNG80q5/d+mcYRbEMH2D7CZuIB2iY+uw1XHMupYq8UDTb1CrFYMx/xA98MvASYAOi23ZscSinuoh2AWbgXqnwR3ygjldtLDo1MdxP9W8VVU0zHGTEob4U2HdhPdXfYZGjok4OTVQ9WcBt+7q0QptJpD8Xn8P7aOKJJm/K9/uuo42qZUl5BMSKqJ5MNiQX5x6Jqyf/hVVdY8wWnKgAcLuM9veFtAHM1OcSL15bLj0nyxQq6QY6mqvRzkIrPTgPnnZvvSzkUkvTJWU6EfyBq2OgD6NolWrZWKU+lcsfehkqGpinq2RBt0dUgTEijSH24c45KSlwl+gCQElQe4cRmWxUM34ybkDWAwlMs9BlqHJhwAPQ6/3bs5p7TScowCoYgeWKM+M4b0SWgXFLiiQmog5XDpaaFvjFc9qcwBdKKd9joHqLErnEsNBK7Zf4uAp38i+H7R7q1RURoVdAhfvKH9rDaO6PzQppvcruSzGEVV2tigv7zx458qFddKVFLM8b2Sp3ERxCb1dMzxc+cqP5pomo6g10GlJGIZZiGVTQFObXrNfpAZUcqQjDqi1ovtPW1Xp37LMNMvRfIoOG/BFVOr+HXLFFMXZN/4iICXKQy4oWpkaVFxyABKDvhWCb+IGumcl+tQWKdaerO/EpIscF5nnYPwgfQ8c5UnMY14hRhdz8ZoxXAk0DcAtD6qkhDRm2MZbzHW4Dosx+G6uWTWMY9bGFF6M0GINEVGSSnSHsDK3EmLBYe0/lmlY2KiM16iKSLvyORgNajrwqFCmjkcJKl9z+cnwSPjzCp+eOCdviOhdsj03chdONjuFvCRkqDj2wbrQisChicEerkZZSjItGDL5T6iQUUuBxf4TETU+XYbBLI4YnV+Xs8H9939qbguS3aMn8SIJacSxyC1htd36XlbxUoAwRvb01D/0wPwot38ehFjQGrPrGIdKoUKDrTGNUUP1gGrJkVTt82Jp+O8Fn+nnO+Loh/Mk5RX6HHzUmQs5YE288064hu2SJ9siy/0lxB3GteGVaoFYbXYB1D9SkZuWUTLascNHTBDSVsQxRz9vSp6fvZmzVsv7jeRNh4gdgNOM0djCeIJH07kRE6wO4m1EQaf4GNQsPKZBrX1ddwtfhj97E8mZ9C628FBxaxRlR+OGM0J84w3eXU7v2C7llityEKvE/I5h3uNzgX4i+RR3zFwdi5KyvN0WwQGAoOmQEnFg/W4pJ1WsAqcqjfq4sSuemzXJALDeRsDTZWFr9Hu+dANLU7WkLKmey8q6YmG0tfNR5Z9n/3Vuf3/8uU7DQv9tNcJ2rGdG2hvYvxvSZh0/0TOU+CPuB/NJvFXahMidOVYRpotOIWDlYy8vZ/6tBCqAzdZ505tOhre1TNo4QM7jVEhYNZ1Zd8o0SCHZ92tkkTt89sCkQyhnvx4e9ahGQxufYRl3hzK2RFq1iuvsZcQHbDFG7aNSW8gZqt+qSXwWvxsUL7nFNf2gCf2VBH2CXnE0wgm3VatjUrGPlodsbcoj26fplUAuR29VvAwR/GZpRNiFQOmlwSMbNbYw3RMyP5HB8kxdvO/58Jj+OFL6bJYngZal1e50KjFCQSMSDzIH9suJuyWXXq19yNIJWErtjw6pg9cx2kItLRspKXPIJ53d4f9Y99T/3kLxxnN//OIi+F92mWVj/KyZVBR+iDMUBo10N++oylAnWCinH7VeeYVY6HwJvExCzZUOMHfX+Eo7DOlXzwIqwn27Pyer+kuPZm3I/neOU0WgVUE3C2IPvDeoSPcHpRNXu5JtvXV6PYG9sv3qh0YXZmmSgndgOqmn4oeSRMeHYjIHtq0Y2moEe212tVMx6Fj243oELqa3ExS4hfgjBPigQ8r9S6XH8174RVqjW0NW0CSVXhYPT6r3COsJkTCNf5rkISExIb9klKpJ+MUKv+GQxKwklEIA8ZFdRa/nRu+8juxuPE56v83lbh1yv+83ykR327+V0HAIBLhUES0KIgIuNC4mFoVAZBgeNtwSWzOHSnnlWI/shjcrW6GMj/ly3RWTwFJjqZFdcXHpAVnvVnF+ay22Yxl3klTYMDARlzWUIoJxARQVgSolrl3qdKjaK8i5TVaJyaPggSXVHAayTo4ghDuMkZ0hcnmR4fTCRSkThsoB9UzJuYeRtGLlfvP5jxjfl62H6Oi0u0wsvdSzwrZGVA2qRJ+WlM1FcUHHa+sPy6/g/lcKsx1WcBjEDAQaU/dImeR4lX33iHD5kydAf+KDlx0rq7lI5S9PwGe4Ml+DNE6kiZSKgxbs4QmvPqXNXIZFQQSUqarUeVytozccLfqIGYgRfTqyGgmjQX/6jCp7A9PS9IY9p/hMsP0oOqpkWaz1joFVPELQS8U3XYwzjYs0S0KA78QU6WkkBo2swmTV7MemdLR7oUmmYnDjnYguNJbibwf0EVjLxz9HSYsCZ6TTOxtCyKYcDEfEfje4K5m/95OFj9P0mwZqcF7a/aHmlGHMASrsj1tI7Zc5LLVSf3C1FnIE2V7j4/pWPzQ+LChze2td5Q0rVLimAOsspxWYSynZ0msElCCYFgZy7yMH3VXdJZ2HRb149mIyw5B6jYfckAFns2GM1O7ot47rtIFyBIbiUppvLogJeZC6RJLGNObPxo/iYvGdrkX/Hwmud9q/4wbEEUt2UCi31wHz5er+FVHGat69GhbhH/OSiWA58Tua6ZXEbbGnvXcNfuwr+/ZfMFYNPm+xis3QDd5q0c3ML+E9sZSkeZ220vZtvcEAYc9F1YM2Wn3j0QGvEIJKE1DKq6TTfIUZaFjkkS3nDCk3Na76c8gHR/fFsntwNcI9efPKa/x9FhAN9VYH4QdyTHmqteh5hCR2RZjryn3EgJ66CLx7EZV0NYtzN0i4riUrcxL0Fi56dMna0HOJMGhhsUeI0qw2K7TYBAGU5t9RcNSoXYWg2iotvq8n41WjTOsA0xc8ZhyKaMENAOqnXKykl6LDjFYJzdY0ettSmcASJmx4sl0uXYZU751o0Eas/vsA7KGEPDitjW9IwTFqUH9CgjOEMYkeOmVSYCMRSUnYHvWKMBgF24Cio//9AxTQc8lnMHpnh7uvlr7Gzi8qoxMinGaRXQoM892qZpZJvorhO6/UigBRBCTexUP7CC5bn35GeDkHbARbSaeReOiBem2jWTGzj+7kXvP2bxcbAVq1yq8NUiZq+SPI5UuNATb36Kq/o7+Borh6aDLJtzXx66BLExkNJyVfuS7zcWqV/EXdHw/vMZfc0yLxcDXPcPpnW4RvMtYugwOmdl1qxCjk+/JWkLOKuO0vxefg9BRLk+Q+vq+xBabR2M3CHn/FDzwM6oHyi6oaRPA4bKlxe5nlOUICStj8bWfgMmVW58ypyr+/7yqGAigPYPw70IDo6nBCyOXBQ/gJNAMybij+ROWxM+wtZduVzsIrlasD7bXbKgAYtjagjYfIwICzdhul36TNGYFZFhwM4iZ/ubmRyASt4aQoNbtM9v9SkubTeYogQhQZwQj6c236E4bhjW1xKyWpbEEbobNqPsUZUpc5TJ5iYGfkdUSKcScdxigutRIOlYtnFE8zAnBrL8D6m/HJ9yeiO3hi+W7gtotKKe3+Z4Ojbo7qcMZf5YdzcnONBcUD200HVcTT2UIxolphFTgroSiZwJKSzIyzK0c1ANVMrs4ml7KZkhXVBLQpAApRRLU+JX37KfPbXSCOUZYcl5xOqNCbfBGy4qsCpWmkdKlzQ/WtZ6sm0mGYc/1yFtRqBAEWhN2pEkqZmR86glMiAG9AmwGeLcblaOvMrAAlvw8uvuZ/wFsQUoVD18bbEVNoCjrOICjsJBRPVSVI6cuFP98JoJRV8nOwvkhL2dQZItVzzM2wNB7W33Zxn6rN3WvdPxM2ec60IyhXbQLo83Ye8d8/hzrHzOgXv4HiEMx28rcDPObCinCfAv4YNJoYTpD8+Mt21ynuGWuj5YxqdaGPFpskAWRTVC+sS6Ssj9GjS/txwyi+JyNPf1P6Mb4WQDqH4YKbccvTyilXTGzhxiXP4CWrFPCNSpJ52UVda/ngkUGQ1s3aQiSEAN7DcOCGb/+YG1c8kULQixoBBJ7GdMnXcbW0OKt3oVxKW219ONalfNyH9v8wtlCXtEhh24FihrwFK5PUPLT03+SQOCYPuzjGqWrVIJ90xuxdUxwgpbjim9CN25/UpT90oKN4Y9DUar9gP4+Iwjx+U1gxN3fSPNpS+tJPUWqh6r4ooydaECWaqXLh23I5+nvONzsX17L5C4aMBum72zcYq0931IIvrtv28l0jKeugRkXcGvoVzvDuvJ9ASr0+f2fPbfhh5sxZ+RVSiigGhT3gtD6B0/OZL8rDN5yxX2hfNZP2NeCevLh7NsiHcxR2ffsytMqGu/at9xJRGx2VSnKgPj2U3vtQQqKLHTCmo3inYukjE9KpXH7ZmPLiKY8Y9DsoEOc6JRJXKpHYZRM3wwriE2nz7EreJ/zjhT6mJNMzQjYR8S/r3Q2UOhDUy1lnUwEpfEDGZrJUWvusEKLBr+sMFyOFMMD1eFHqKXySpHrljjuJeRJ0Nr5ELXkOWWl7FjyM6XVMioGIsF2KKdpnME6t2b3LhlNqQ8OufDjiz+u+VjGIiuFuCHMh7IzWzI5j6ZFZWttLBAruNLd6dAq6WDyuQiVL0KUDgctPySWNFF7JdLfDsoQs8+qGDj2avXfsC+0hH4g4pntzVSJGuhPAHl6TJG4jwNklHmpHgqdMYe2NhHZspoyQI1XUZvi9eU9Pv/9VG9Z70S9yAAqqTRO43EaOD9cLtZSInfUqcHsbOJHH0eggCBamIUOpOoX2L8hY9Ym4j7gYexPcKL8d7uelv/rwWAXzRFaOAUPIhG6WqqYXqSG5DExzzVchfzj995V1Y6Kubt46KQ3FIjVeQt0nmyTfEGl0jBT99KfRVMz3uyB1h37s06DA2MF+TUECPq/l/S7LY4NpO9GuiBs3qFULE2P2xK07HdPBd+VnmL3YmbU9UG2qsRvVYGYBiHIC+fl5bhNTlxdWJHoTQT2gguWiQQI6B40T7aO6kKcNVafjkZk9OcqpRSjyYep0Q9LNTzfyxNlN/3zQ5YEe6uPqWK1Hoty8YWcvm/lhjowHPDySSJ36i2QdHKKgrd0Gp0105HY+ETipsCLsi+evQ2NyX/SOWB/uzDCLFCDI1HdSFK9avA3HN8qjsJM6ukSwWvRAFKp5G+nmKlh4acZwQEXpkI/R1H7iirbwG/HY04xLTDtZ4VMBHax9de+8/AtjGSXcAyf2fYwOkEvXhm54TGqG/SX2rAdrmuj7U0TtITE8t1GvRye8LufCm9ZzMezrmZQiE2oMFKcW6DUBOxih14CaLF5GZ8wHLM11FM2oHReqCTfTEuqpveGD89Bro0640AYwzsPYLUzIN2p/24kYU93UrXU5mTMI11zjOhFKlI02bo0YJEV6sR2++qxWPQpJ3VyWZioy2Ifqt627UuKrECizOOfWSM5xl1yUfnFO97I/b+GTelY85f0PmnUZ+TYi1NOwI0S+SavnvDkXeXfMyVdAWeiqDfTtyF4kcCgaxJ+HltMemivtdOl1WW0gC9e+MKXacEjzyxVXG/uPhhJ7IL5XWEyb+pyKXV5zHP4ss28fC7Q2NaK3vYbkAARoWkJNGGq6EsSFvVwH9VNdTFdk+lkRqjOQCiIBd9Al32EoXlElTskeW74Fb13lnPZEDlX1e2fcotzmx1XTIc4idcjMwiCptCAmZEeZUilwC8sUCtqJnbUM/0lmxWwGRWFDLuEHENwVSf0nTU1SkJlKpzaZxFyqW1+yA95tXGigW7dxoPtTXgsBEGwRddr6+L7wFpwOmpEgvDN5rOAldKPgQ/XTPngZN3Dv3GsEH1Qfr6TiUiwP8ejZlXUM7i8f9VnjkTfNElNzNC1/Zc0UOQErNYiR6ZUXf1JYutcijPDkkRi6Lvp42y4d5FupdlsDbmlWRyyT0Mwzqsr2yQmC7VrVo8IyFeA+xCxo9fgKpkELfJkBPXjCwsW+HmhYedC3D/ZgcbDLTfP+i5wlTMSzWXmWwIQjQrRL7oBVcfEEcqXLxbWgCrFu0b1LOZgZfdgW3PBDH6Q9QciF9+aICsr8KNu/TpYzxEMruKwNZSft8w9BW9tm5fydWisVjrzhKo2XDa/FJRdG5QszsdIuyDlfmJU+R9jPdLEVGJSdM8lPe80UrBzvT0RpPkvZkeqz50Afu/uVc2rwWzRFThs4g2HuJd9i6jR7PaP0IKOV7wA9uqXmwtIcb/0BBJlpGlITXOWTlJ+oIke0+fWqUPDYtZ/LAkP4ec/v+fmkV1KQKRxBmE7yJfRzMz/mSYN2RRTFYz/cYp0Burjl1uXepbIgjdctYa0Z/c+jDeiKwY0O3gVVKL8W1qsUx9eIxVvAM7LnyDqALSsRdCu10Pe73za5LQj+363rgLe0OOCm5jYKDO7AeGIoJjRrOlUA2xB6/+qsrqq7klYB2QZ93gSct7j9tC4Eh3/GfIeVmDdA/Ar7wx34EZK8RsGMe0YSQZ7TAU6WHUgafDMcyPPJbLlMJYrYWR5kfH3v/XA3T1kKAjP+2rHP8B4NPl8In/bPHuPwM15vF5rmallLUHIKtHtXax+WVqVFj7sTF2pAC9m36rWOpiJG6/wqgyF7sbBNNgkgB38HC+LefOY5PJJBWk/hvV/TneRcrdynkm5N+YHMIWpVvQQ6fWiDrLbFq0d86DlIMYfBivEIFyDtolpeWZLYDihcbRXPxZy2lwt6EO0vHoxNqYsZp/D1x1lTSwXTwIIeN1UnMCaoEtvv7l6wAPx8l6Tij2x6ahQf3MPnZalrp1O7C5J9zpUdJg++191I6bWtFX3Nfw5JsW+CLtwH4dH4XHZZPVlQQH/ky2a6M2l7E2Gt1ZGShmIZL3bL1WwlEbSWVwitkIOusvWaIkU6A6jFOxswlNuy0o9ZOE1oqxBASRZ6rI8bap+A8PsZ2zrg1VHMOpt4U8lD1ROrVsfd8X7bYSJMrsmTqkhY9IZokLaklM7MyphXCQ1jT7rl6wSd+Ef693SZsQUSORFOIgtDPY34mzYk3dv+MBbzh11Xt7PmkrD8RYzWgpSYMD2jDiSAJO4Jly3A2zyH1avzgFfctOolRNOFdQ/iZeZsAdYfUbINsFMTly2evmB84FZqwx5VNXtA7xovg912UzvntIBmK7hKfQq5Go+YHE6esNGKADZ7DbTmVIXs/fV+i/DdtmA6d2Vi54EupxdSZ7jf3yRuNLTBHPV9wdTzxTvBoXYuLH+x8R84fbqe9nVjIPFDZQgE13ARghIJWcV+2VnoQm5eG9/gENV4Pdq/QD7QH73wcVUHhPDeo5rv3kjm+lfGg8bsZdcJTBmUPyGEjoeeE9O1kvtwKHVi0Z54598lPd0pqHF4y5YrlOQgwU7AjUarL7K9zo35f+gg5oyY/1fLlCEWqJQXBNO5nMV1gl/8LFKStTA4kj+jyQuLh5GYF8uRzBtD2llPJxTk5W89RavkCCNijZGHQfMXCPJNuLZ75vxhf/4eJIkhGebAVBA3M+Yhfibl0VlQlx77UvNLmw3MxA+5r3nhtN+olus4wFF9MDZI5XiMaSkTyl0OoUrBpZaPn5lV+f8Zw6ze+eqOvI0x+EfjAsbLaugt9JB035EI7duEHbX7hiSN7hmDpQWMupmw4GBKW+vCddnSsrB/nl7wF+quVVLE9XT6Qrae2/LzB3LTlhsKuqdeM1l88xRLImLmTHqjuxlvEJ6E/zR5VIjPUVWC1qwp1V639zNo/otdq4ESMh7ugxnDy/kBOxReOWZHBDyu9OGWNXojWndc/373mymYLlm1h4G/5IHDt7HQYjlN0rPUwdSHf/xnwKSQ9xDzSOfP2QTiWoKr4tVBrf/5tFexQLz3mD1/AvYZT8/27iG2ZGt0nY9ZQMNeZh3RvsA3MPYHyU+3lR6U/ZIARADX9M/DfnO2M1Qb0irJ2h7EAbIyg9mgN+KhRRDcXqvwxbETCJI3VnAGzqZLin3XmzrQnGx5Qc1L9gp3j4T+Z0OTo8tDAVILbGWIByG2jAMARQYqkG1y105XA/F/gyVO4BOt4+OxTChD7c3RPU6Ex8TAO5sYaDCCvZS4vepmsVtu6EQ/eOdTOOvaGR1RZ9wc89GuVDD8hwmnQH2uwimupc7dOtI+c7RGA0n0x0NupfgzfiCveAsMIqjAJSSHEd+dGPYuda21ahE5h1+WmSQms+nuvherVGwfnhJsQhAqBaLD3FIhD7JmDRvoiILLDuSY8fOhR9uUJ7IXtbqdylVZTi6qcZMY5J1CFrveNsKA4Fi4wcs5BIiavS/T2DizjHC7Jy/ZjzVY5j6rDhTwDs8LunfP+ueuObwglNWc1PG6q6mPK34K5Iv7+V585REFyU48WU/39w0F8yIcRn2i2DDPTQJVqovJ2JPJ6stzKPey6Rr3xv3TKIW50AVmxdsklAkVFgnFHavHuNEff7sP7FEjMei0v73rnYBVaB0b+UihEOid71QCHejBibRkicUSDCsIxCudDK8ijO9AAplvYVEbRglMGq5vGCjCoZj8uMyjefel/joecBFOlQlfAgxbsUMoyBOQDyO1FukAwq3Krlz+O4eP+tqNeLqAbdBT8ZkuPFe5Hf4JuBhOK4sXXAEpyYFspKj39UNBcJyrXIdrLos1LH/Ck06W0lZPc8QiSsGGVazK3Xz9IKWbN5A322TBAJkbAmHgXSlSHbaSv7MUyRtlyl0VYgRyq/VNsuMjkBL5rwwF4CT9/8BP7B0m2Ba6vWyZ997ILcMNeBNHUJC+zLFF3doORpJi65Jj6n07P7oL3QmN3ImWd5EIWOA//cr3KOm4Xemeit7RPuXXhZSyV9EkYHziANQ4QU3APrWcvAlNMnznXasP5Zl/x3dDVZV9Rlm3cNDMwh3rDtVLXZ/diOFGfOtnNkBx8qFkyeI6eD89HG5Zvk0QuSxSzEit9fZwrLxYGP7gsAKMIbX7of0nMmArXcBHIuX5WhEQTu93iirIbYdq17FQP3GtwmxOyKczXWPebISDG6LHBMNe4REnMSXnjimwO1mk2Zn6fLQOkfX3GVM7ummB4h7dDEB/6uflxUKbmMLe4hdWNGUXk1V+V8H7yt5W5EXa29ROtPxU7NhG23adZ1xdFf3/CWSTa6aW9ZVMPZG28h8ojGi+HWSpHOyZGv5yuqKrOqpWki4aMntLunECH3h8dp3Dj6KwxtQxazyp6hUGqFbKU1rQeu8IfA958aNAti2q1qzWzlbulnHMoNXJSs1W5ZkHpSd7G/C97TELxq7JBy86od5tfOwL/cT9ROu80rZHZPTjb0tKKNQePnv7JF0rYVIkDhbqFscfNIrozzDjbS/9JJLJg8pLKggF+Md8sL25Mrfnb3WiLLAFghY100P8lpk13fNhPecbSty76TLfbbBfBz1OcCPTmBCTfqGqdMloHQlPTxTwYeJMgq8koxUX2HiPsURKt3e5r6d/K2/RIVnKRg8Ncux+8RS3sE99fHQwpjEjTuqCr3xbXYXJyfM/e8YvwjtSr2HKQDR6RdbNAThyZbrRshAW7nDD62ClhBnqMu6FZycJyEPHdgPbVtSe9Dc6Drp388l/A7eiKQD1bEbm2kDUBQEuRvvjMCfXbdlxpzEIdNpPseA61RQBusPI5WeP35KAjGP/2T7Fm5NltihaHqOTsgPTD17jXpodtguTozxUdYhXusc6MtI/g8uVBup3uHUOS/FRNBsLy6P/dEOWGMhoopvrLxE5OJXFGZ8DvwrEqpBD+vQT0WLr3a0PQSHm3k0uGZmTwqAtOtJGTlRdWoZXuhPr2AGqc12XiLmjed4cnBgGN/FoH2z9uALzla4at4iRBoOjdROMNitGrS5f2QNsj5EhAoxuDMaZOwui8/OCktuaph71mIDzsxpIZBgNAKLpJIUAP5N4NyrIJiKVCMy8lZq89wEeUaIZMpC5EpOFO/JLCEeucBfF8topvr2jDJQCdPGDxd1Xj6uXjn0SM2lk0cC+1eKZIwWaFH+J+AJvq56hCkhPClGmCgZwTVqpmLIb3Z20dc75CiV6ofBnPAIJvFmQfumHNdm11gwTTEiC5z1ssIujddYFxcVEfBnxDh2wL2L5BEhcMP8+rGkrVKiMaI3Llob5Q8ASMCU1ZIiCL7C4Z0hFHZuyNspU5E+qN5GlEKmZbwuMuM1jd80m1tzfptL3Vga+1dThcMQ7f1taC3q9JIweYfphrTqtY3j8z7NxfBDUyRY/pNO5jGfCkMddHfI7X4B9cFkRkIxd1Y/ZMAoQpiwstr6BrGhy178wRT3JmlKGH2qZcwuULCFngJW8NCFe7CgNKtrXrie/xJNMUXnQaeW3T/5cV4ukoiywaTqUxiyoDUzYCKr2I96nEbNAfajp28iDlQ69QWCjEL10ruw0p5Up2bD/Gb4zxLZrW+65NkVgCS1eqb40U4m7AMhJQr8WZ0Fh/ME/9vCJEUXhLZGIRjbgpltwMS9h1bXnWYU1ZF4vHDK17gIMKWhHQiE9UO1i30Hs2ybODEjLYTQbuzwcbl3SrTtytnZsEvYQvc++LrupzN5edIvwhw8J0eMjUIqHWX+od/D5Z5D82dleUE+0qJCCQdoo6tHW/KJBOfIYaf2vNfkH6rXP0b39y16oHPpSG7SR83dX/epMzGbh207NuSsqSUGHzUOd15jSBNMoFoUdrWCireRtuFGB30E8+G2o+N9Aj/vsKXS6dP+C2ItwJyHaRAS9vy3s1GLAoBZCUrpipJLEQHF0WV2zOpydyPenztn8277INqPfIRQI32BC3oeKOY3FjO9C9o/EzL2QIxp9YicYPji62+RwghsABdIcWs1AZuD2Hg/OpQyj6KV5jnj1dE1jCWHZniNdWh+/wmBK+AcT5ToBbU98eTnrYmCnAAMP2abVK6PL88ufVvf66QJvjG6z/164gZnNinQpwlPpw9okZoyIfpobfffmrGumqWVp++30zOzsGH8oHZmdU+6RHBIgAOjErB01hKpgR/En9D0JmEwitf7svvBuvnppY0jjSbEOia/cPwO5BswNS339fr7ZPQbO8jpcv/F4FbQeGzMMYYsxGBKPuQFM94ED/GwkGssLmwdE7p6Xg8zTZG1wV3mdn8AEKIaFHUQnaRLZCTnRr18Kw/p08Ezqr4t/K/eniEYLb88dBAHPUd+lCLrTsLSjm9YVNejVfhXYwv2GwTLY6czagk+xdCDTF26pSbkb6PxplE05HiBCv87d5n/arOvO2v9wZf8kDKNxa1j/gwJ8e8zp/1Wkh3ycnSGOKyLrZn6EBlwh1hXINklByEY3SB3VEOW/g0uSq8/A+3/BNcHY0v8BxJrvo31ir9dn+2MqL/e/yi0eYrCfB1xOapdiREf1e2M8lY0FFz0BiblbVy79z0zkhb1y68mEj2yJ/GBz3e21Vl0mKIKj3FIVSDI3Pw8Ps2hjQj2GcdOQc+NgyPpTxS1WaLOe9sy6LKISyYbmzzEcaEVsUcgwaGzd/WMYn5AC3PTwCwOGAau3hs2Ze0Xh0V7tw3X9QseHinl73vtNvxovoKF7ZS+6LITC1dJj+woyT0qyfqoTdMCYu/2D79e+DGM7szwDJIyMXnra8gRYUfx5/5TDHQvmb2wjdXa/nTwvgWQU2J4bfvSTXjtGCMbPb9JO4W7owK5+/YRps+hF2nLehfqFYr4EoXOIJg1l7MGDXVXDGjvrBTXi3Tb62s01Q5TmG/fYo99FhsmmyXLj1Lfw8CENJBUAmcIkew3EMZIpT65NIf22ycav1Lsz0xvAP2KeP1j76x69xNsOhPSzV91WdaRlKjxg1mkSCX7onFdib9APgv4qunv5kOf0GvNWC3u5L+ymZQ0FXDh7t3/SeEIVY3jirYNLZbCPir9gfbxs9gAamG6/DochlNyuEa4PAqsCJdHkrHLXrvLjjY1MUcqg1Xm0qf+jwEY24569qAiW55M2a0sDov1mxZV2HC5/invSr8AxtrFTsfVlnUT13ADMszQ+dbtj8q9XjS+FxACTet+Y3j36ldINAmuw2pZvfW/SPQKdG/bCeOvy9fdByENti/dBtWw9JvwuZXPk7w1umG0PaFF0zf9w7K42wM82d8l9kFOXLu5om6UlDt9OGrf40YRHa7wky2Ryoi+dIfkfXKcwJHA9SLVr2lE/anvjvRjECPiK6srAsGd5Mae8VJUD2iM6V8Lg6WH5jRvK7qs7WvXFRfYIRA1ZGlQE9rcuJvhMELkGUHlKzBvmX9nzLa8/bZlhY6rdoFKtrgT+LO30pjFAO8Xlvf09ApVAGC1cvQc9jcDBIQ/zcDS+ZGtGSa/chtovYczVyyHjmlm+hIh0n/1SIUj2lbTOxj2qqbYdlOQy2wT8V9mtIdwErZblJg/dLvySFyUn/Luf/ofJXSQD4IvgTiMXUjnBIeT3kYA8XmOSC0jf3GlWYYrE4b7PeWsKTmllPlXS40RWG8EAK5jtaSz4J7yKQ01gCGL+KLxOZfzHO2ISGCNSEjclkyaIS9z3tQZJdm+cf7eh24GKYna7Q+ZPsKxdjqVO+iJMqB2XWDLrzO3YpHh1XyKoTXKekYQ50UNAEc8EOR7XG4z1WOOVhr0iU6k18kbydYuEh6jDDXxMQLA4Rc+AXYVugbNW0XAvz3ScLC11EVnOhM4cQp0a/03LvXcnHfI2BrG5rEXHAehB+zfMZP6c2ZBeiryXXILVZ5K8kbKPeavsdD/IcMRaoudtr2+43c/cOJX8srVsl2Sqo3AjQAOxPNrpOR6ubqBCyl0BWtXyx1pVQt7oQfiwESe05C0hUgwuMrnWpidU/NkJL1SixHcMwTnwTvO6LCsOVd7r/FZS8O4bXilFGwNEV6VzfvoO9KLKxgrg17dgeT/tj9gXk7CTS68PbWzuuNcEnRR0Z0gO2o0u8dYvdKkH/Kzhrnu42cV0ZK1kiWWGrO5aUz4kW4VN1vJteLWz3vR/BjyFPlhp1mKFviYzaGUwTa6mqXHWNydw6d+Ep9d/+u5alt/+LQnITGoijOkcfwFjJp5m6jg0dDwChek3uOS283zKm71zEmCAkfM7GUjPuR7En3ARwqJZWvRkWdFt9Zbhkwq5u2hA5kPh4aJLTna6VihosGDzpVEWzWSCOBPc+4wV7EWJz4Q02RCb1L49EY5FnwcxaXEkHIHua2IY/LbCkUHdRJ79UO4kvmzoHOk6m3l3rteIGK1MMnrNT2cXMwlyAH3sD9c4poJUHnYJFPuGOdtvMjMflBAdwBB5N/bmHzRxKhNkxewK+WsRoB5xx8PLYvmjMaxFFl5e+hE8D0W/xrqFwvBdERuu1xUf+Nhb+1lKT8zLqv9aJuquuucgYb1njSxRoki4h+WvgzXyB6LgXNHbm9e8hB1MDuNMYeRBv8jQlo/uYalsvcmObTNR25kGfS+yUq22EeAsDhKVtgAqn2PDoULbbclGtVayMfBFb7RlQqsxytxHbBBbj0Ok8FQtvmQ2elxygA9lb+Tj61UfuZFnvcyVbW0bDUhWQ9G+xOZvltly4wFxjI/KYyIZEDBvz0JZc4K7HOpy7l0oNrBOOLoCGXkxsXGpW0DF3JUXsY175+6kuezt8dPFQfscPtO8ZVUOHiQEQvaGLaGsNM9JkTBImbk6D8BgO9rzimQWSj7IdmkGNDtoXbmDqwfR++z90Fq5xbkI6+EtMuTUPEyPU+b1jXLy2Jr8Po+IULnTGPXevMhlZlTRJuLqEvFjBc7xApGTxdgWo47WVRcgXFsGFT1D2O9Buwv58A7ZeP4eaikwZcBkYtIZGFeZv9e4I7AStm4J54E/PBuR4mA+IRPSbXDwxDA0WOqEm5xz7h1ASmE8UKdGm55MmFi145UXr9XR/jJQ5wvtr7+1tl1gwnWfr/lheKY4Y4ra2dFcNQUqdVCF/hbHCJtnGgxRMxO07UDiBlPbGRICIkv7yN4jU3UIj7EUItHfiN6SGTrk0o64iTLm6bSFkoJUtzSnKzEaTxcZ5fFCaT5VF/P+J6w3Dvf1MQDKXjOABZ7om86FEoDNqmzrOVPOp/Lw/VL0P3GJun0b9obYIhxqH6GQeVZxKgFiODFabsCIRduqCMuZyhmF6JgkfI0c+p6NoimtHcrfl2cJ7r9GIWZ5ezBB4wGtpPjga6QqavqMzPysgy5mNJ1Zm5ARw+1u5olBT/jX1lStMH6H0tDDsl1OTphNwD1BtMyJ+fKehAGU6qa321TP6hUSWpwh7luei1Vyz+DWVWt4VXVf15Tc0Xu6eTXZJMjHSpzmMbVoguax+6mySEgIgg6IhmWUSIpbm6nn30NlMqe8FRChxIRC12p5cyXvdJpd04rjHFHV1zwmz13YP2qtrumJ5n18w43XdWAND1RsIUCHvQi48mkCjVbL/Equk8D3Lk+iooQJoFdRHFj6cHUj5gSfQXpvZcAY5IC0S4gi03jCY2+nsUMhYMF9BpshIr2ZwcIkPskHFfVTKNfq/9GHcfphM5UVJANstkpcKUn4l+JfScksVLnvWtjcAfNZ0R/Fcn+2c7codARlW23WaKepRwVIHer8pWv+dznDlIxCdybx8m9VAQm5Pl5AsKRXy+97Kicmu7krPGU1FWza5il10SGFpdTcUGqYV3KU0X2rKg9sikuHVyrYaYb6jb/izmNT8s8aDpJE7Ny2VGkZ0gLzZm4tGs/WGRODlprrnuYL5AM0wktJR8/WC5zxanF+Xq2hMXxqzqs8Va6OLJuTCOMXGHIYEcGeInZ/yXoW2MeFTiA8C9yrH7y5aoQFSLAnc+604oDu5yzo3FxU1g46sWHQp54BZjDAGkImx0Us5Woo7LI+03joiJi7U14ZzDLH4epVn9+fff2DQKbxlC4Sv73pQtYa8QEC9oriZzrwVeMOThSLaIZ+zKIsrQEKU5ta6ykDs4RiRi9DvSOUr0fzUNVwiKhP6BC7RXFoz0EeRBwpmn7nkvC+w2/ixiDTRjFiKwesGS98VW7VYleSgP9otVbKbnp5jUxrKkhA+1sSkjHUBMIuJrIvkFIhk7vrsSaIi9HZ+rQ1OUr/OYa62LUcW+mFCoUeJAuxaSLz271iyRU8msqKJESWn88/9fDhkEuvTAA/mUTF5EKXAGzfA/LqO1/zQfPpCklLnL3Vpdt50DgdbLxcTGftuY49j7Cx/uqcas+Zt4d5zy8Q6PO9E+b97BNu5UzQ0E6uIturUVTinv13hCKJF9YPdXiNYYtooi0N3tlGtyKYVdbZYZfprylq3xMiyPZJO+SPMYuM5AvnkT2HTJ0HD+8/zD3T0edclxDfyayYAnPkxeJGUFedOtpyyJZ4nmmH1/DGERHXZv1Zgp62KVFuUhwswoTwdEFSt7w7+D1mzGhtsGQblDharxB97cz3/di2NK6IvlinvJncCkig3I9evPLg8AH8O5CKUVpwrJ8r7DbyEdjNsfQw3Y+7S7aGm9WHR/t6c8cO1Odr8EkTuQ25TJ60TTVEPcx0qTvq/Om1/KRwOmnQlRMN54u43LsfzupCBgrBGBj3dXi7FDEcJUCIF4M1YzXDhrOCLhRLsgYZ57x9cvOs0d+NFkZ2OaczQPteCLpudfVGG1tqQNWj6H6ELnjRIiTuBdrobMetPBj3w4QzJj5bixheMz+GdICOVEv2XQ12OWJqWO2ZNneVjQFx+qDcQ5dxQQSynQp4qMx3pgFWzJgooBULWDZnsEi29/XKHNPvUqbv9tUnvp+rB3/e37RPYLEeOeker75KkpssffdfRO8fApexsTvm8OBt9LWvlUj9TXXBakjVCsIUd9aAdKIdN9wN41T0dmfjxkWiKMubBEsZb+UqCATQQ4Tnyy1OaINsbZeowvxnc49ahEj9he0pR5z8Bz7deUKsrY9etLiV1REtm1nCo+WtzCqxrZ8rpTM8kviiag9Y/6VOy6cH6c9gNENCjjgISh9/GMwtui4bw9nrm0o3lyr4tJ4CI1hIN50pmlI3nJ+uGGRdTRwvGYKiyhsR0kMrhWD8LH8eI5N0jmGG1o51SB4JJ+YiccosgblxTaGdc4n8Hb23ZR0ej7Bl/v0bwEMEQwFMMAVMFyxS4fBbuN/udcQfV+XUgdS8W++obxWw6GK6EP+vvdUl/oLAUaSPF0NKHDQgECNh6wr+FZ3gVHDxRRb907Tr4RHY40bFArZm2nWghLphhPuraLR336cUUdVCxW4dIPepLZs02w9gFBfOIK39bbI5g2C8PFgiIEpV/EiVvA0v858Zp/UE/gaPM4JNRSjC/so/SRSS3d50jJ7W/n3GDSgPSalTQX8lXzLF0tLzYLMSCBqQqlUKB70Ef86XuVVGUkgyLzE6hn4/vAj+VlmT0YaI71aLRRjxCBOkgvF+10qXaFExlm9T4IBlbHLPYlPK03Gy7s/JqiJwAj3VAVLKkfY36ego+T8Km16OKwbRbIxvsbgod+4UFrw8ztkyAjTbZhqjo14DN02+V4nOsf36OpfGeo611dNpDJeMYrDkx8LkvOTcmRo/Gf6sYD6Kj3nRVTFOpZ/CeNb5X7eXpGB7KB6HGCSrcSfzpOL3rtOfSuRG9x2myii/G5sRrUANheT9asg/p4DjGboYRU0q0JzoRqL7lrCKeFBBcq8ci4hM0N7cthWBSHa8ySHLIISD7tHsCS8pGtGElaq7eiUjjMrr62LmmzKj7TPzKzgZ+ulFDRO3Cnp2UCYiY15v4r0wo3AZ8QTqjCcYttIV7dKaa07BetV96EfZlJDL4TaBuK0b9d68xggvfzar9KKOWs3H+sV0SnatiXe6D3t+N7FclZo6g6rXBQMaJzqe2tl10pqu5OoLQxfMcJ3EhPC9be+7A/WBhTLdguFUFlFzyvIuZjjH4+zioe4a3lTcHYuA979AgaEm7CSqA9Js2CeZJlNicONABoo5nlbdWbUr16aqT6YZWKDVFObUUV3W1HNsMAh3M5usMo7bSqa0a0munVF0vG+6YwxqzMTCRL24l8WnYyEggUzKRLSGCqVX+AYcVNRyFU9avgyKUZ1aCaKg6WqVdAWIp6FsuxBQitLcgtiFKPbJ/I07WvvEZ2h5MHhXqO+auxKb1WN9Y1nZs6aXw2rg3xq5dAdAHeeCuySMFznXurTgqi/hwZMNBYKD4DFkywKdCMVhgRcL70vDcNuh1EsjntiDA8rOS2OM0nerO4hPdrCygY7KYZb6GMQCV10hlHEm7QiPcRNJ6sJrGXbd8d3FZeysiL2mCsMhpkitMXfqcDf/icsbf0i4CgHDblqqjLira6tbMS7oYgHa2ZYERxG7SXwEt7b2MrBJDMPNaa0IBXiDr0W/eEKGGFGhODXPKh2h/yVe2grs+ahCpANCFuA2IAqC5oXB+2Q88bkDAGr3vNc4DALCLcByEYOUqTyrwqOEkI6LLAwsqgbm3Z/ioY/1zt+0seRbSo2f71J+j1+NS/jib9JW95PmIxpxWUSBY2Yxc4pnNNaJGAvJcHayS4dqVxmbKUTaKybYYck/7Fyb2nljxujWPWz7d+tdMq54zfYeyrS6EkhfJn5RqfqR79p+XH9g474iE4Hh3Vo3Leocnr4a72fm1xsgdrOMYLmvzvf+mTYpxA+emlyJiL3XTgBPwyx06l1gEH2P0TStaZsTJAjSgnkXfS+HzgVg1Qy05gyB5qcTfEMtaED7MaZV+Gb9UDc8uaG/DKvg2XBCisWvc+38D5TM7fct8bFFY+qN3GvivpLvrwL4dETFLzZyFfjToZiSjFuyVfa6PhWH3zexiqBDBAnGxCcICEcjFvn/nnX5sYUlegsNAwePRBuYbfM250mUte0xNCamwRoRp/vJ9x/YreP6KUnC5bVXJdRDHi8cjXPLX5gzd1t42/nRy0TLHgY6P57iFJnttZbZIebaal6dCZcU2Ae/k7sYeQ9d1sjD8L7qtgvh/ta0gRwk1A4BuXLzKc3UpBp6ZLrrzQnGllQv70IuDYBUMSAPDbj6XfMddbZYaIwDoJf1XZh2HRg9oFj/AUb3RC+aOBgTAS7Lao9xR//XxXo1YchwIKaZYYDfBBTp9FM5nwOzInbHUre63FPTsnI4FHvY+rT3AmLb73fOrm/8tdi5EiSO0v+NRkNemWPToWWKjACLsZa1qGSRfP6M1iCV0aR1ssyEHIa2X6XtngHg6mvE94guAZctGYtZ7yGGgtxryy6PhUO4TP3X88eZK32GH3fCdpaTQ+eL6opMnOnXxjP5BHbdoO8vtuKPIvQr1PqftvObjUlxwXkpcEd6Av5ZC4yaYAS08izpQk0mm+PpqV2XAtZwyl+cJwfxj4/GUO9/qPsPBLnWa6ndFrSoG95NiUzyTKTJ/SkTez5fxiLw1NOb+H4L94h/Uu+DJvHlAQ8VwIPne+VIlligF86n5U8t3il+vxdbEk3jnoh2UEyXhIY57ht8y/1wyn1DDKxb/vgFqNXr3cMtzXE0IzUnSicB+EGldDsfd7/WxFyyf4odVhPQN0TbbStW1P+dOnx8be2bcEqbaJSSGVkz22A970PS5DgUG2Hr9fbYTsM7N6qMND59FaEGbFgidq847MxqizHsXU7g63k5h5VBw/9vhbQvsdNn0G2CEYbBawAm4jSV/F1+1Ip5MEH28vrNGUNDP3WckG+obm9RjCCLxcfPsDKehBnKU4SYn8KveBydDQEmZwPVgaI8OpOMCCwrRUjyaS/W5S20wkGkW1Xw7ksHMrJwib9tFPyhg8eozX0vdr1utfTw0YDXmsJA6S7OjvVzLeD/BLPlA0XEsEqYK+wEtRgjl2Pz8vX8LA8M5oQJjDEOu/6RhJ5mBc1/2jjdEOJ2VX/v80HzRbP42ord2Q+dCNNLYmsAnWH8kCVMxy3RfVDSbMsdiYlMW9TTAW+NmkavRXaDRTLJLucw7csZzrPcWzHPvQLJ9BPKTV4WGL3wLCeCI4gjquYCLvpIHb81GXUKwL6sGtIL9OKKoONiivabX94t23DTiFtY7Iw1CUIUjUZvE4aaLdmpPpRFZ09Vm7ofyU7XRJ7J1d1IfvX0bZ1KtCPnQg0hdyjwR7G2exvy+Ad8zp+B5aIhaK3S3XJG4nH6lyzUVlqSeD5S0oLjPDvPPvOpu+GF7mTDXg+X5g3+cLpd/FPQRHNwElx8onIvRv14+QaNSja5EzO8HsOSmVJE6DmRbCRIsr0yAyQxeE0cKr8WaoAs6WMd3Ufwd8apt+whtKxRiuKt/AgtaL9lvnebb5bsOWd0zuV0uxCFqSdlG5xWxp0r4lwNEPxuXeRnQTkSvfyFfsbx4RCyY7Vkmua2N9EUndmY4BVjWT3dQWQcSUej/oalI61Nuvvw17cLAwsxi7NwMCb5WQzYZKBDA+tSBLy+msH3emuAWMgJdCUCE+O9DH3MAT4Tm+7xmsQ58uHCic/uBvLzTVukFTGDxp+ToGEgyQbXJMX0hkNnUj/GzyMWKi2GJ9hGiIDuPX3n6iCwuzM8kUCh56iauAgNLXI1V9iQ2U+CKdcMl2xbSo+ioi0/rlSr6yKYGTMlbieiFtAUV30DX+FqswVQysUaC8lcOIluUVPAHJvpToxhWKlPGeN9B9OMkp8ewXxzHQ107LuMC1Zx7AdzyyGgw/9uf7c1hh5flqpohTtsbt+5MstlH6/b9q33Lf3AHbxLhEfArDMtD5thmSKaLMY61SMBjvsjdlDJ/HSdQCAr/MQhDKLsEsCUIazjhKqHWO6A8EyMQtlwJj/BRUFE7PfxjSDNjSYBpyeyte+zcF+kcM/tF7Y9KDEedThuUhW03Dsp2ekXQCdIXuL1rhC+0cQX1SmY8SKgqhiw7BC9FrSLO9/ZEIHiYGruDIfpODGP9OHvQPdMc/PdJWL4nAlc948j1bdkf7S7+Ccaijk49X6cjLd2fRAdVWnXK0ytM39V9HO5p4HdUhyI7K1EBtSyQHBeNFvjRCaH/QBXq4jNA/nyq3098Kf02zDJC4DO+Ad1KP7Qb1YT/zR1faWzS8g9CMso86CyX76BDhfmlDdpdxKG0kYDfuKIGlNpy5rA5J2ZzP5q6ILlefgHIe6w1OTBWpahJwf8eR4kFlDd7pAQ9s2KkNLM+pW7jzuXfJtTrMHHmPlqGovcAggRL3K71YP8MEJC1LF4b5UvhJxMC2PQUGQ9p2qmKYazlQSPfp4iN4rkkUNujz2Y2H+ylGqw4zl49slqE8IEdnY0CS0sC6IxkqVtD0X6JfYNDGiHpNsQqnms258Y6yFWr6LoY68vUPOs6mvib/dUanev1thoTQs3kF/rvIncuG0nJt5S8y452m6wDJtuLSMNJOAl9nXAupJSXKazGC3Y7/9gdyQQf1QAHYX8TNsJgYkWBaQyxteiSxbQjEWaE12gbJ4xsgtEPJ6MD/HBlGZQkweBiUnwwLaVSyr/Mu2BwgH3nUtFJB9N/fVO75MnbA63UdGZ+ZGbikclDmGNHz9eRDJdks4Qh5RorOAMH+dns8FE5sqyA8qVPD8+N5FkG7n5eI9ctiL+RgXEEF1eVZjrCkAadsj0rJy985KCq+1Bagp/klReGdgn1NCWH2XLqtj0PNsszufpprpRVhx2BffVHfwDGaiPB4I0WLdQi738fGHzUZSPk2DvLKsYEEmok07Cmixc17/8jNC3rQBQvMiP81iLuaf6MMDKKaGiBd1TOCy7ib3/z24l/iDLtelYymtELRUoR5T1DY2SOXrWt9fTJ8WKMrBCG+U1MhcTX+FAADUupjyqtHqHJ4xaLSjX9zWRzcAR7zsMRMjz8q/UO9eTTE9Ojbou4wUEVVK/ZTy7e1jM4guIKo6l6PzEfEdmBSLuvL87uPuo4C4um/KL1HuXCsZIwGSYg6w2juJxkWlyqXxNPMwNI6PVLNzk4T92vVfNMjR4mEvcIHvf8R7WPeQrhDNW7Rilvw4XWmKzbMBAtr7aG+6oyDW71aw1ba0xE4mRg2LJs3dE0NnOG4I9t/4CifdPUBGmr/JOX8x3j2DGqTDiYehkvVPxlzp00VhgiWbBpjhH1rvU+tKXQ0IT1zbLj775et9jkLXSvxSEcWZ9n+iYirzd2CNcmwCzcPD9yqthDOgI8xNhaeOC5SEXHBKLsG6m67tK4wgt4/ai2xB/vFd3MXm6bEkfm2Qs0Txuh058lFcnyCPclNapkEYaUv/9354nZ2Yd1nQ2B0Rc442auEm+FjCXEtpBzM3wwJraXOAeX8ug+7xjB0fmo4hvUeWQPtAPdjn5jL2T1FjyFEE0YIhCXipzkRTOH0DpTSVxMkLi6W91l1AbZbczakgX8rFvuP4OA5D5WR3XZZ70PaMfpDeoJINnWSJxRpUxkdF3wOwlil9tAXo1r/gJfB7buiOTDDmRTagW3NiUBbYOxPfr79d9qTqC7FkPAj/gt9rfB1t4il10nGlUxfVtLKk4DahAlaYdbnTfCZVyOd1ojirHyVoi847IQMcvC/xkG8FfvYCf4Ur2B5X/Q1y4XoEHzCt1AN6vG4PgoxvnAh57KHT2jlp+OtcuIWxYZX6sRRAkPRMTXyMrx5izNaM6fTA801mJ/D3Cr577KfLCaBwLPFBtv1N+1ZN6BPvKNoMhsDXdIXVDlZ15TyeXvUPfIfI7w/9+vrqVpvpKCpQb9ZUfH5/3y2IQdOYyQSQrCLgQSRPbbdvG21M4hpAZG6uUUcsJaa5mgA7sdq5Z7RGJD+4B5X+KuBUNhJ8a83cgd36IY5JRyy3Vi9ewzBDLqwWnNZlwgS37+GtKjyS+qv8skEHVMlD2WqPMf/vFBsJbXrIkDB6mvSqK2SI0i7wQjH1bmzWRctlvxaJmH+sVG8v6QZZlYVpA9DTDxOn+jtqyKhcvZu0jOEEOSmOOsCqSAbdeNKB2oWOG+HFCRnRhw2wacnzHT8fqRIS3X1iNoDGsx7DpwB9O24FoKx+kmU7QnCjzXFpkh+2qcYaEsrn/vhWYL5Upi1BF2SZTYbbvIQ/pHrkP0odqi1fdJMER+5m/IhQubjOYE+11jG2E3kRSr141jOswveBkG/9VBfqjl3c5Oai2+e/H8S3NqvMr/QV2qKPIND+Hoo8T3nJ+0nUQTlASZ4VSbHk8CXtbB58kUIZUvqNmY9yd7qHorCyxZE7rLdr58pxTOvMUwtsJENtrSKFy0AlnYuGseBW51b5YhjbF+XuqTPcu48Dk5153pnHk34gSc105ls5E+6PZtUk4rcnQfnQP2qEmBJeykpQOBHtn/SEyZVNNUX4UsKl2/gJb7DulT1Cjfn5PhW34IEXxKjbd9qDZbgVkXvEv1thAzOGhuW9qlgRQ/P+YGfrqLf5ltdjvXg98R404sxEc4P0pIp8slV5R4NEpT/GukaelmSgi+rUeTvdpZAgRBl0bkBvCvyTuNQ/E+3NJglhyUIR5pyv5gf1QJqnSf6G2bFmbMAUNTXl57tR5/zsyQ2AxNTszNfH5oispjIBx2jvVFt4DM/BYiJEVt4sZn3AXV7K3acZaf5zOU3JAr2oBU5Qaa3YdstwB9z6Ueplh4GaufyWhY9HaMskTqdjIzwqy2efOILQNXw+5EM1P+Auaa/byZYyh9vBYi/A/NFL24OB2RBz3WIC5EBkFwIEjJBGCnEMh0a0yEbonSySbjTlngUVEnj9NjOEHQpiooae0REGWTsEtWdRyF7Z+XXmVtogSG975EQeL8w0wbmCuDkQHWw40QYPBAg93Hvo4lt4gUDpywMtIVxupupeiG7UqalBN4idTqLB/Y+mvWwQqe2ln/rMUe5PKbqgDU6lZho2ToX+f7J7i7wJ/Y6yLhlU0stQdcWHMkeWTouup27M/t+g+ppZlMSWJIUVi6GlvC3hluPkGDxrxjOB29KpWzTLaLz6bU+mxykxYL1Q9CO9ODzk8s24c16SNiMLAaP0iLU0kK0P8U2aRoCTQZt/Eg9S0J4xH8T2AO5ukqyc7A7pwi5suzYClblpS+U0pOn5qhb05svOjihG6b/PSTkegbw1WI5h02MZvz1oIIyIHBSp1RRGDf/Do0VV3Z52EdwnbBeX8tx8B+vIaGFZNx/dvwO5CYokiar/NpuCoRvDfWdkxFN88ZTNzV2NZBFwOgGpU3ZBnh0ymFfRo+XYl44sNsvjwiQQR85LFVbTu6xMe2Scs5X8fb+d2XuYsw8X8WcQqT9xU4xGTAtSCel7dlS9JWQ91VlIcyfT3V4WbXGbDv+0E3YTtDYIyz3jI9RI5Rsk86qwL+x3xBkY5jPNpmRiNxWW0w21F7z+TYK48brLJQiRiaHSMFdBCkK/jUJSdxqsxUzmFRuWPLQyjbOPXO/m4ugTkRAMsYy2Ko+d7L094k+vhyVFx5BCnrCx5gggx7p1d7Ds8/lysYLs+CGbbksJkOri1HzENQm2Bnna1ub8bD1I5nPOcyJnUxOLachmVwpZT3BBLY6a3v4oR6gmBIRYZVsUAcPTQxphCbfQlRBgxDtrNDDuQbpMZicMK7q76bgxWcIzG9OVMqRZkwGngR2NoRdO65GobQ108OTTZ/88AEgSEHVnhM1fQb2QrmzWC1cFIRDS/+S+4C2QRDalY3CD+ccxC0OhMQIQcfTvKRIwBzrt8jAXjPhQdCwJ4aLEp93JZRIeEUH3x8dDKU92aRwAfVh7GcYUgiVkKEDE8ZFH0w/iZE/B75luRkSDzadNql4gCJE4cl5Ww/LQijLNsd+Qdiuweam2Yuq0dfDaqu+gLZ7CFEeJDo6nLNoG6dPFAmkLm3kFoJC3QwPGSqhXlCxKHT6G0u2wLvuzJfdkd2hlBkuAxcy4dozEPaODEHwT+hupAiXyzMNXQ5hSZQxADs7+CAj5hdvDuAPugzGUelblIlpiMf5c5AyOl27jkABqHflE8wxOIHy5xCG8jXsX16h7EzVGueEnqckdAP+JvHcZz38GgEBmynWP1IxDLHa9h/vWZ/bL9Tx14LlCNFIBGPXAP+1NLdvgaPbotjFKIpGyPYN/wDqYuqqU95g0AYEOYp26KuwZCrPhxyGQYYz68xsK7N539UWjcjqadvWr8spRbJ/6Zz3o5/Rsew00U8Eoz5MdabYH9AbJqXKYINwu+tkILaHMm6bejoOpC9q10IVVxxRsbE5XH316kvOG/VkbbSZs11OSNfCnVvn6hX52IhnheHxvGxLCeJFiWLwAVEvXv9ByN9/YkXhQXS0Kj0nUcs2eDTQeZiyTBdd5XdOA+Iv4b0t6z1JE0Bstq2+UmxCoybjF3YQgPTijD26TTi6gAZ6TncW5yHJa7cYshLYYzn5S/eutfDrK9T0ryDeI4yiRVuZclemKy39iMuG/VCGqSsaB8xfMikD2EulwK8mvhz9pngXlDa94KHOFaK2AA3BNJXj7hAYEEZ259JmgqrvH2JYGVdCqldrWpBO+o0zDBbzU5IIlOCZbW9iVyOJ4gJT+mDC7J1OF0O1zO2UDrEzFLQyOU9BTbgbzW8phed7PXjl9KBJE1NXQtKVTo/9nShTvGyKadVLF8XBQnR30DvOjGxT8YS2YFLLT1m+dk2UqywbTU9cm4330mQFLtF4pzNW1VG6W7OFr9Ug+7A+3PSADnA0SqwPz1Y8FxUmfqNwHnZfOVQ0WWyHj2ErIYnOz7CKUpBdvoVx7Gr9PuFxeT+fmCnD4fADys2VTvj6ATjkBRereqYv3vV7R90MXBIZqXJgZbkT1Jakf7ATIk0JXiYjPvRvi5iKtXN4y4DMM/cFVK6X/mI3YOcG9r+hiFX0QdInQSrtl2T8p0vjDmX0+Cl5JwW92NvSBJ+loLyjcVY8U2KweY1c4HZ7FoM67VU678V1YT8lxRuj16rqdznJkoZlrSj3tLTsoZo1JyEg2akTSTwEOr2k2SvCJfVT33XqHK99GUiU6CSBQnVffCYSqC1ajd/dSsQXovvyO5oHIPNhzBPl+5HILNTPDT+S4XuKE8xHRmRwT22OvXDdIzrj+0Sm3Lrf9G3XF6Vim5Xr4Z/ES/MzShPUJQFnqFniPmJeGNeyX3bwTEzvuWdMGnD+WD8SVqqdcP//txEpL36c/kxxlqyPfZKhRodS2aU4BYdpVjhA++/weLKYGWRx+puhaDmx9aAtEsQ90NqctFOEqdf5FGcjn325KPDxYL5f/cp8BoiJVDG6uOPGB3wcnO0iFqgpBVFB48ufWOBstC3an3WBYIFhXSRg3hFzVumq0DNNrkhN5sQNi2kY8Cy1TneNzcWlZwuvTwep9uSKhBZQic+IZaF6Q14J7bDdMpTXtlHjQ7ei4dJ4Zk3m0TE8E3U+ud7YO6zVM4xX59o4TWW/PGFmXmg78YraMhXqh4CXjvxz4OoD6ohVyf8VEapuzZbetNj1l3ejVvgztIMcLp5W3MvpSbACceJc7pD72//VLyYXaYyHAGpW47VLrGr6u1oclljFQleRFS2goIIaJJO66QbpTTnVJdY5br7Q/NWXg2rruhl6hjTcp1kAaOg1OGokCI+s4m3xxZqEexVMGbWZnChGLUTE8UV7ihMMQz0pX1faJLELGZ2EEABXQr00JFV4HUkF6eTAfs2FfGWXJUDm+4o1D3pBexbZ+OmE7g3tX1yaMprxXEyWZwbX68CyIWIECRjEh6VQGTWx02WLidsVWegmCpx7FAKtA79vhAIWL28n7Z8zpkak3Nep7d0/7kmYa19PBYUNAd3LMh2QeVQ6ZaPSjyWIb8xHAzkCckqlgAet+dzeMh6rUxhp5hilc9zBMjEsGJ8l3NpG4aaKgHKTaZIq1bdeJPBUQL4JzzxVSzTwRulbAkzo2TQV88tgl1uxT5r5J6yBJekTexYAue6VVPVhwwHiDAnoXa0gK98Do0hOvY16yZFJOQDQGiIlDGRTlgW+7ZdywAHKoopHS/wL+4aSQ2nNUVSbRYFudcuCjX/cuv2AZ1iUpKfq1tksC1aKPhJ8YAqJ9elPl2C5USOegNRTPU9mnqyswSTmHoTjhuG8wzCZcVxb/uwphARGrTCk3XP3I8B6VDr6QJPCARY9KPHLVIz4oYD/xgqarKRrf3N+bSWxG4srhIntw6LGoKKJCcOH4bHBX9ZnKQDwNmit0uWPmtwx7Ec81f6lYWf22IaMUXQoxJske5x8LmIq0hecMhgDtH4bEBI/lix+Epp7v1qFqg62io6dZPmSZkHYBOcXsNMXUSN1sci0EPGEtfOo9HLE6zn4B45w8a5F/LasSgI6zBvp+ydo41F/F6bjZM9dMvjd38MG1mKoLHPsv2zOX6SszXitw5Ma/O/tN4DdTZDHuM1aExbjVQ2xYeB174Z7zeVqH4AziOYd8mAos8Ta6goQ3478pBV9zhklEGh2eO86d1IcWu7Ny4q3a9BA6wxJTuCwnhr7GAguCpWLgsXGyOYNZC39s5KPVtdRgHzALZnrEvIJdftm0elr6l2+DXKbPgW238JqHcxPXR0qlnU4fo+TCj6tA8OvYJ1vp6uADTq6ybVlO4ajsMnOjVWjV2o3qCNRlobwmh52PWojG+qj/cMaL7ST80gr7tKAE9VQjOZj+EdE8kMjDD7Y2pINGFpYgjk8pjlOcISA6O6KzVuV1BUjpJXkeMlB4ySZXnToWqaOyshFtpXpdJ9vxPXB9gCf7dsOUr8ZPdTSyUDM6h7VLSYOMnrV/DehwYuPQyR7xrfBu1BHzx6INN/V1nRZUpsIvtxWuR+hIOSBOvRm1+814AEciPWrqmA0wOryfXth1BYRiP9zMXFav9M0V9PWlt4dwmpEqHWbx/1z27uWaR9JBblLxTTEB5wBLSKHFX7rorKgUxDQOznzYIahqUXTm6ZBEPmCa5Ooh6DOhIl4itPAawDLwt2dWPbB8AAp7mHxkGk7To5DiwIwTh55qB+Av+I1M3omb62+B1XYZu/P3+8UPkFixWnK71C5PKGCQKkrRtvmsAe/zoUoeJ4LN3TjBxAibVYmoV/J0nV/uoccDi5777n9msCROtYUPBrpBIVFQJRmpzPT3vR85SOqFeWkq/rAVDy4uSPahwx17u87kaSoRUc0CNwmL0C/DRGTf8GHz/33lv5qWyfIDcoJH/oYIOTaKrFcCSLST67UVSzf8w9VbzMiKMF73PjrqYThBH2LDATOzXphKyB+8GRttjYwO/GMe83LkE2hGKzRSyHUkTzMRH3Ix/ZGWEIExBoWzwlORYNt2VTAGgzbmJ9tbCksmz7JvA3cFPIvX7Ta09w/C1Sg5KwZaLvnuAOBzO9Xb1/hVgD7+BtGQnhx/sIi/c06M71ROtNMQw9SUKed3DONIbhsN9PVo+jTwNouuPIe4aJ8HmjNmR2OgCoZ8fh85RCiMshqNN3cjmfKOxZVlrEiNJGRynmFf2DT/XSjzgiSdGxicfsyeSFf2mUUrgVAOTVznfRLt8q8LF1gQ3WY4iVg4rwLRB/EFENnRWhN+HiehxKUUBg5oUokJscSoEnU4B/6ZVoXLRCBG4BC4vVHbuesCHrzzDPnVEVPzQLOaE6ZClXcCG4RbDJagm3EwW9PVuWcxdcrk0Bsm3ETH5y+trs4bTTsoOQcIJr04DvV9ARKWMtJ7YvdFRWvj64SRzP2w3m+HJdca48S7GiX4ZDCFx/7XKuhtj8OPxtTxv9yjKsAnZseXueplU6O1iK0iL9dekXzbIEoVnv9EdeCpLitT77GZTok1xF06Ukl1aQSzV96RkW/H4ZMt98zM+A7L4YNxDwHlqQCTAYV9Ta6nDCK+8WXLLeQhYRit1WGsZFQplOPlr4gElVZXtb+AvcYpEhMJt8Ob9w20k/rZxpfVRdMM16za+298+IYwGF7kK7jhoQ4vV4eBuF1hWhORgddQHhMS9edT1/scN8LrHt4eNJl7OQJyaZgLMLYc0BPeVQp+xB1ShHMquSHg0RyeUXiqtr/F2KT5A6VuM66ihr0WrB6uY8eRY8NW502u6gff7vryXxOFSeeCpYNE+qD6vCvXoCik+nVNKxrpqS7hB470d941Knvx69kMwerVMLNGlR6AEn97ntsND5Y9E16wa4NlM8L3Pa4oXlA1ZPvsodAmtK3DaFOFLRZahYvEUwyytRN1o8X52CGx/yumtRL54yFIvd2LVCdHjZsssDECKi+oonMoWIA/QKIMDwURRWnC7xNKE/7jehFo5QUepwxo+5tdACdo7lSUbi6s3FfJbzf94zTl2KY4fS6OWfJJKTBcFeAUHVI8V9yVW6VvZNF4Nx1U3U15otxRVDuPA0UEJ260mmmb/hFC/Pmlb0o7sDcBxgyiUZMLOgnzGjOjlPcqrfuNz4mklFVg9BGx9SaZPnqCGwOgT4H2HOtfcke8ZPIRiftJFfSEbVjiTz4M54BtpprGLWPahS9woLzh9cV/a3htJb8K0J9ZvY9y8N+81y6u1ZWwaFyxu1JUEmodBH/o+hnNZoh4wIqLn1AYpGYccfnibpBJkRkWaZPRJxztFbqq2cSomF9Db43RT5YEdTxuODpnaQMnM+Dn7CObV0jTt6fZC4IUwmGywuNS7dLP5OrFt12/VVDvP5QzVOA/Ij2pjb4eLpCfAbcV9RcDru2dyMLnnb0PbYE3Tw2ZqA/Bv67htAybm/TgobNJKozcXKDh9o+xZbEfi0hpuriGf/BwRsO4h7jcoUJ3xNwjz7Kbx+juPA7To7e95GVXwcaxxtk9KRXCaw9h7X0nYDhH2LmgI3IPsPwWYRmEE2C2pzoS4LUFMvSBtd1yQRL3FgFhW7dbBYURgTcpPoRwayKSBHWcVV5KhShjEvnHHH42KK8wbsr40nS79Oo4uQ5zaCRJgKWQEfS+PX/HoHh3/aQwONKFtR8HTNNp8y2ijDtED5XbtdUdqYKWX12a+K0NiYWGBNfuzA9+fOvkxraC7sE37AKYi/vopthXo8EPMy9g4BV5LPfpvilmJyo75f0Uzy+c/bvc9PX1tbXJ7YMmCYjmZd4oTi+pcCypEkJ6UJl40P+L6QWcxyQUo/Ypg+KcCfRV/W67Ys8zJv4UPnWHRo3gmZuYFqIUGoZnmGyR33n87l2/JuSh3pYIOvBkAwxfg8ioYDLH1XDRGdIQjZUw9SOGZibqUDMPpFQ/vVUa6oo0759HlDckzInb0ZdO2MzRexu3Uj3gIlJ1v2648O8M1qvn2FTzUFlbNPNFfqFkm0Hh/JXy4Iu+YBvKVro7JdlbT1BnSoliiYhNCG6u9NPUzV7I66ZEwIWIq2tOarKoNcfzuMZiVY1B1Kk+ujPt++w6CqAXuZyLb28tkPzD1FQLZhiwtc56myycxTFvZn9ljo1Z8QW+56lCRCziMcqIVpfv+FmLfL8VN48og/vIhDoaKgGVbfWiAKdV77Cyhlt+zjszyF34CJU8Yp6pD3tzPXG8RY/dPfirpx66n1Siuvar0wKoSkJtK40k9RfInKUpo9CgHZCWLWs6mapZvbvL4vk0JsgQfCGanM+ebXIjJIy3gHNamtzup1EXvUwxWQzrvnkUTmqBK/d4JK5XW6U4/0oNA9OkIN6oNL2ZFZiQk/g5qvmh3o0E6+4oWFcXUCveZf103XnAUDUqJhXmgCKpQElOBxc9dJU2kajRDQLl7lQscEJRh8qU0SWVmMy/AgUnPveN8q9nzFUsr6td2YHDa+b8i2GZvrrYZ5gN24hkH23pT3EgRD3PzERyEOjPy64aWT4xaawiIJ+VlqL1TgKPVvVonWNFR2mbIRceTrc0VAj+TLqeuW+JchB85E+27TgOdYun6FoUa4g8u9KQGS/472BoUwXvPqI6PwB7bg6axlkwwoZwHfS6geW6bJWyskgm5BrJu1S6FeP7TZLA7E0nv/X1jFhwZ/0m9yqsilY/W1JinwhWtCBktQP+mZLbUnv3a6WOgZZ3no5X+diI9AlO93OhyDU8xGJGQCYnIxj60FKqtlpR8jKofdEQTF/zcpFnlMif3wErSFkv9tk6ReWB+UnEwH3HI9WErBZ6D0DxRvU/fGdFU8Nq2yzbRvuXbZ5pWpSHrOH1/w2+Cy5Ng0rsN1u99IHwc+r3vvkTlokYvYEkOPoGKYY0LiZPYcKLX6dgM3YJIsjj2RD9vyN+8FTVH89IgZ2KFWHdDjAJr+Loj0rDbCuiBubibCCUxqWkbUma1bCXnN5wrYXTBvsDeicOoJperJUNilny+CuPkKLkZ3Y8Fxzn0/PvYtDnD5T32Ne/WIKy9sNSUqfBPc5w5jVKKuEUYondFjnmPpl3cnHc+XCv0v6hjtmiQHzYfeJbmlvuDlnqQXVotrh9qLtRrOrT9evxzL32aFDPw5eJ69wk7xutN8EOicofsv0yTwJSqygSs0ly96ZGmuEqsnuTHuGA+OaJlYAY+F0Uwr3NHuAt5Gos/Qy6ddvaGuyw+F3GqvSptqoBUiwFaf7LUw0Lp/SygPSBVe1LeSLzNLFKucoS0lwI6HxVSYWe0+91PzqvS7nXjefm+A+bO560VxAS3RgfEE/yFW2E3iMbfvoymcry50PpNcWaKCQ/0ApMqSftQGkcdAZBovrgzgwf5A54AfHE96pCIfVwWfcV/KRPqVmK3vAx6kUOosuTm3Qbx6Kpefgusl4RB6c1sxQS9WigaUhBgriiaG8uQCPpFrx3kXEa4gBYQlf7ErAs2TNNsTKXJLGUt82OHtxRMzCYlufxTzH979hXCYPAIyRNGG4zKqpUXzSYpFeb0bPcvuThW/BREKtwMOwv/GTKoqDQL6vr54iPczKgCLbZ1qTsYOfNe+7yYrKEVac3GXL1EJKXjyuGkKnb5AGJsmmZIKmMNMZEcP7YsR71yASdUnUcVKMY8cCkiZHuPXcZzf4Njz9uhK7adZs1MUxhG61LIW5l2iixAI7Y4JFmtHvtlB8mLEZgrzWoUX+2nHeYThOrw4HZ6S/m2D4/wqrog4t47HUenpV4WUayW9e9MyzOsSBGXxuavfswrGZMXkNlOf2zsneEwoXhydMcJt9EYCqM0IKvSho29egPfYglmRRHXGRbVOB85hpugVLgvy83sOQhoK9hUFJhRVRR/tribudDZ5UAmUFfCnbwBlw0eXLsvOq+mM2T/i02kX+1kFRSw6b9AOn+GHLvGjjVE8lJjINgar5YcPTuyxGayxuJj17dwSFVY0YdpCHO6gGzJ4IiyfyKHqQdFVhRdA09H40OKaGLlpOwbKAEGeiib1PIviBMiRQHnKZRhRZsMMYM8xrYobQKIVUBZKs5PSQLfSy8zMl5SMKMHxyebLdnRG8cVOu/HonoW0I0xrxci6RVbETfKnTaaXq9p1Jxkd7DepEv1ubayx1pHqXRJr+gT0BhWfgPOkRaiAigeHc5B6y5MVWM1fk3rVwubU4YGYlHbvRjp2Oj61KUxeg0WUTuaTTbxr0GlFk58xSn2h5Ytm59x4J9rZTy4ulzRe7DmHLrkYqYqOkjEFr1pTfycqxFGiTBcbNUfS/y9EUrQVs1UEaEHs29ndWOLG6vlSaOWdo2C/a/OMRytInnaDzvHSSET8WW1IRmVOMLWXt32OKkVnXei366ZdKKqlvKkHDANup8WNDgny4Ce1yjO70VuxJzYAzTzAsuRGtlcLSpbREsC363ZFeczS+8gVM3dgFSoL+t0WjTMccyqiZV+59f5S3nRLXgy/RUG3f3+GLO/e2iP7a71KHFtZvAUKCw7MolrPjWN2XEcqtba+OMBMq++P9hoSUerzmd00bYfFM/U4i/Q1m+qjjbj/Npj7lcXTbaWE4AQZVXenV64K/9wBLQGnt1IlRZpVUF6Dj6Ir2hmfs/tjSCm2cVo5tPpKOYE7hGqK7VTRllaw+1QrxbuPRaKsTdU3e+ZheFCFdKITN8/EPo1aRmjrc83oBrYNS3GMztCokxrxEi3o+wUj+TYehtUdMeuUnTve+Za7VYxplrkLzduE6X0mD2N/7ErI7Co/pW/B+y8fwzzC60f0Ai0sYgG5BsGT1nrY3ct4pR/59PrpuB1sszyFtx3mHv18cEWpi9urxNe7wfLNlH0EO6mFThzujiQwVBZuePqIaYNVcxtla6iaGuWxpv43ruJwFxuvGEt7YTf+YHROF0rH+naYB7T8WvYOu/muDlAFRSVoRCx342SxhsIQczyrBUAxnJ2wQSjkkmfPoCvIPhjMDGrc57oRWH+78AvyCMBMwCcHP6r07TPQ3nhO0heX3S+6PwI9PwhR/1mMkYBmfIIwDhAogGSTzwMKBag1QGwoycEeWJzhZzVHN1o+qRrDEYjJgf2UQPJ7mTjRBl8FIKkJ9djVROkaPSTdfMeCXKYuyTtukR0sucJM/cRB0thfKXkvkaCGsF4JtiuieRnVN2yBeDf7IEUC9IqGqdANjzjXBwdrpER+LnRpeyVFRKPAIsXWrNrwetuoDl22oF9TRpaiixIOExRUakLCdHq6Wy7y/XOIp7Uc1KXFZwZchKnjVAwHnLEvUTCzE8pSWtKgw66DDHjAZAHIA50NdfHvKEJPf0pHeJpMe8juWHuAgxy0YdLAJ0JPYuUQQvRV3w0Dv4bdoP35YCkOB9AdPxHIlS0hxEGgXlYvYpUi9IvHMrnWNhHLxnhLhN48HXwOc2bR6aaIgi4JuaN3MkXmfa7EIPXsBTrxGwpP3T2dDNdOhnOI2/5jApRC2AxYAY4aQBsbH3ppY55mzNAdqlysxpc6RRq/fO+Iqt8/BRAySQWcnAvUKt+okr3UD7wUFfcK6czgVKUVWEXdRhl0Rvxv4bWWBZwXl9L6pd5ZCIaEZG4Zf9CUYJa6IyAPuwpTpU/g51L+gzSIFiSiLLThppZlm8SlYLZQDCnoXlG1FrRI/HfRjji6uy5HLbkB/eNKRjukE9CpldWmFI2UF3PNCeK0rd2VP/BF0x2sM7veAI1n4TrFxiMTRB4YV9WoC9I1PQaQ5EN3PNsmiuXKQ8m3HV0q7iEsHsgm45fatxbh2KSLr8/6YrFK83Q3S8wpDLyj/VK6ydx9ZLzhmWMEr4d1PkA0U0ThscTX8IWQQDOcwtUsrrAiP+KdKvhGPP+MffmunU2L5EO34OVet409J8le2KnRS5qPD1eznfKxmFY9XgSKRt22ap3mMD4a0qVUHMJ83FrQFa7V8h1NDs2NHfILuljekUqHI+5EplzBdmdvxDotILcPlhJ367bKWr0H8dwT5MSAHjDUm2z4ln4kdhGRzI0F2itQLxf8K3kUWizODGWG7//Ql9RN088+1rqELXvZbkHCxaw0XTryYBy+oiGFzDnN+8gR9RagFb1vEWC/vptGPlk8JU4cxpOUfGg4TNw96qDudNRT+NjGZxqCIkxKshenc/L+IV5NjBuKlmHSgAhZRnqTbaI6wKnY9F3CaEWr81HmCfmACHO7qDasv1bn4Ve4ncJPUpzlg9wOsb3CPvi1Ksx/xHZx14HXNJCJ80gSmOPZeFVXJun6NnSrvBkKXFcng65snR658G9Y7uKrVMK/Ip1CsjTuNJtpVeMjBVkfRo6Txs7zXiMM9w3pc6Qq3rCZmiG9KHQds9JL+MTdn4Q7rdvuCxi5NMb0dhPFrzXHuNrIwOsPPcfEHvbkX2dBGen+mNVm4fKzw3boZ/cvyBEEBMXb6Qn1CilceMbyG/2m89yrhlOjtRuCfd+wVmKovRIw0Km5rcRaAcPHv3BLz1o1mfwxs7TCYNZmaasyp83yu6MN4hiZpGdq6FXP9FWgIPK1uQSF3QIckMoymjizqW6SLmSuJ077MkMNxd5COEzTvOIetbAhp6DQE2pa72QFvTiUlg+c9XtWgL9J3HLkWZHE5FH3M+ZU12Axht63RvVAm2Gb0IHyAbxNt+tDSsZTrK/g3x8ThMeWBP0wRftI9oD9HNB/Ddwi3OOnQLyQ10p1wmuC2M7HGzYvYhqnOBI5p1XO6gmQX7ZzY2MA8UVEeAg1fyVhm4GiQ2NW3ktkVlNpX+220kOProq8cxormd/SMfoWsybwXNpnlW1DTjeYHyd7/gQmd2rt3rFcWddKTPWxuFegGxqsf11fUSyz4jnH1o34QYY0ZlhteiX/JUAq/VJGkGuNW9jCaNIJck+5r+FEtB/HOrpN3v0ZFq6Ozq3+Hb4aSbA41hmsoJekYiaBnuUeaCNFju0THguVeQjb0EvJK+QBOEwUvZ1hk+eVslfGFovnBQ6kZiRRaW7LkvbAh2Ee+OstmL4dXIbZ+oH+eYDF9u03tub5cITMmrRoqsA+LM8WIdk4siV2g7/ycyLZOj3VRRsXw33GP8MMKYXsNf3aG2eqsPDAgVuVGNau5v1XtwJs4KUGo3Hzke+3KGXQzkGCorOJs7x/CZVhn8CtzDIvpnbEVhaVhmxk1uhklX+rEzhDdnwOUGYUtXUFmcczThHpNjCVDaan7Hr6C3XF2sOOE5QKZN6ze4a6vE8oazSktdrIvv//diG1ofsASQil6O+wiE3FhklttL1lVqu+9YeFDyJzf/scYDQBis2e6TPbW808A4YOXfSpHIHLx16zAs5LLaFF29gobo98UadbAbeGngnh+ruTGFDb3dqn+WbfgmYZfieL0sizJnaSThvE0K1bPXnXQhylqdLN8PySW7TRE13GyM9J2PqqQ7cGSxzPWraQzAjqIXLxpPYhUwJ5Z/grDHw3hXwg1j7dI4C2pCwXv92Kb8yYNfxC325qJaSkR2Oi66Yn9azNLZ9deAloW0ExxsP6pIR92988wigKUXkoY3sYzMh9bpGjkCX2d+51bq9PcCWVFXFvzAkeeLOkiPihFoqpftcs0vaiCqUd0YNqpNHkuwCCYEqCUmGJymrQ7C4CTPbCVc1ODPN/76kLXabmnorVVjVRVXrajOxGjiCa8jp2qhvDYYb9J8Rj44HLtm3Bp0E7KS8Na+a1EZsviXLFDPeThykF094FoRaxttiKzsFJ70k/10JA6FAHW0xxFgBCTJLDR8dlk1ydsznLDGnul+aPtwA/ARmvme4N+iQu+vbuECqVdA3pRZtC/+XweSYC0+YDV67dTDb9Dn3G7PCedf9+VCMo2vi2cIbL5bLwEoIOxZlZQwgTNo7Nor7dy2cFI+m4k0oyIso3xWpp64DFLQUeackJBEi3/r7ioNWxj4PaHKBnzZ2We/mwYcDGM2XQ7k7NW1aas5D/8y+EaO+h9OzonjjY4YV9mWfDDtp5ZYh5HbmFwS2/Gp+HshZpUPDOGCK0kyWUX6rkSso2gmwwMYgOaF1iaK55k2liDdhFbrWzvcVpWI2zSeWQEN+oVnyJq02NTiBJLZIp6hc5UfNHSGz0yhlZ0j55rrYSre9TwFuZ2wt1o5zqnNN7bnywqXT7uM9kEQB95Tr042U+yEWLqWuejAOrm0w6fTuzZRO4ukXaELzbBlxVMVkNE5YdwenUR/6TOjMQBvw+zTcBREgvnnT82YdmYRvDfVHol9U91zdzTeAjNAg6jTfGjJcTcuPKmu8OVPiUqhm1l/RH1Gs4Bnow8CTvouxOw026w3XucC8+ehi0JH7LtfJZlGzQ361aqaRyaZDAGtgAX9x+cWhlhpoFEhQ3FBZTHoTdgTlTOtZ9bS9s+gySYUrCVg3T/hmE5MOCX0CrOyToIgbZGPTPYYu5zz9gvqKiwxLn9ElNCkpZxdzzulDcat8QqwtyRwC/dOoa7TeZTYXdN5cSzGugilD0yegEKPMIAEGn9csFOre9BZItS2fWetSUGNRiHmk9Pmmf4omHk55tPHbDar1pWVfLqUFEimHsfWDsb4zDssJ3jUY/VECPs8pyIKuAVAFcJSTf+LAx0CtlWKSFGgHX6ZtyjcXYqfXLxBPCCxzMEIArBhTc1qC8lE8W8AYIDLuMcM62BoNf9Am7FkQML4+5vFFhLOZGyQVrM+uIYKNvTB83WppcjbbArJ84FtoZTpTmu4STtKcHPb8R1TIiBWQeJ3IYHd4fAXbKpimbeba1l8+KKUQ0MdvEPUQlaGip4OxjdOXFukZTZ5qp/ims+f78yirzh4ZPK16m+AylQGXQdmDN5D1qwI0nUIVetZSljujKh35hHl+McIfOELY/nKcnqfjPaKkTaZQmilkgg3XbeAs6oEJF8bUebd/P+gFKb3O2aFeVbof5jnuMKi+Ps7GJYabUkIXxO00eLB3R6/fApfFwRDnySlHzd7FAQiEcEVv5FtONTx0HMhtMk2mZk383PJIOG7f/uyp9Ugxj+cUSgbx9fS8FOEiyNEjm5ZhqVKJbG649k+LL3Y/3EpDRsyNsY0hJFxAza7zFtNu72pF5n41PeJZSqeTmom0sKk8e1FLAyK5aYNIjwLJkRWPRmtahNDOKtg3Inmad7ZvjV1FrQ238PnrpUz4/I66w99z1EnwhqH6Gp9XKfGwdWBeZXYrsHEyH5R2gdzTTgDKNu0vgQuQBf0P5TAdunKbRVl7Rp83bWjn6vZOsb5fGd1hrT4neFhP9/P+Q3IRnuWMhV0sg6lJRMLY2ltR2MI01PHUlMNMCTcHmprSpHf+Bmo+xtvGXeb/rq76hRg5nb4G9La7UlV5edQgHeVSLu95KUGMGoxGsBscYlaYY8ZxJpiNVQQ9Q56y5mZCHh8qCqZB2dTfh76oG7xgZEm02dv5UFpntUetx/rn5a79nwOnmvn74rzOOskpN880HQSK5Qyg4voY1BJreptBSsBlufjx665ycAjeANuwj1CZ31T8yfC/1DvHYrWBO4t/BuVPqnREgJn/wyGXWVlNLRuCCIGaURD3HzDJxJ8PVbUxMaHebf+Igjs/JmJjG12Ft3hoMQPOFAJAZiKYmgmozr67KJIw91Qkt/bMzlvo5APcx5iHcPzbx1CUhds4qOX2x93/OgwarzTMluWueKqBJbcb5//EXXrafOs+as4IhELqOUOf7uwIE8JOsEP1BOy+1nx8XYGlrDoZYb9Rteih5g8iSnD1FF4XvegZ9sDA2BKpV6Q5ofOEdK0jLVinFzS6GG2OjOVyuGn6wDxzCMEv90ySSml/Uz4hQ9LKA4GRWTjLJQu5RKcIZzzzvLzzj83u9GAhAVCht4tzrrVdye7T1h5IClCIhJX4xLAyEVAQ1VIsdRyQ4zW2YGPnf4KC/HixFtCKDTRnOC6hKWbRiGiUAK7g/VtWoB4ZnKyWOAwq+XgExgsvme7PsVz+Nj8Os+KD1aVyrDMh+XxxlX44oS8PWG24l9H/UgmD3Gao2Q0JdV3RrMCzNHVwuEzUJ/EpCxwaKgJKew6oNb/tppLfkinzGg9bWB1xhKkLEl1+i21yJ2bLkkyD4uk7mjs1B3ND0NBFgU2JypvgWeOnLP4ILlDdAbA8HZRB9oz8rZhDpUPVuLrP4Qj7X82i2KpdW/YGHBgoRDC2v5KxzvEWrpjU9f98SQ86FOEg1IuxKWUSFazywaax28Gk3i6pPvngA8Ul2fuB50i1Jj0vV+VW+Ux7gNNmaCTXaSiSEWZ7/IG7gQ6P6nmgK1eJcbyV/wFP86zGX6jUdwy7W6UYk5Ec4i/1F1gRQwRaQgSQni15ntwzgFYb6eneVP6ZX2L8lSMH8yO8xOiP3tQPSs+E6hCDFbP7zlJwSRaITdNgjbNvBfkeYS4ZUrBj0tkVNpNN6XnPW69A9ZAmDHeFzEMKJObfHPS+0jG/IpuL3+zFoXyvg8gxCX4BM6P1wwU3lc6pJNMTwtoqx0FJJ53cPMIkTiDDOkFRb6F0dIelIL83ldB4BIN+gBI8wxbtHhd5AXMfaijedEvIEXfe6p9Ba6VqnPrFgRi2STzzfwRkXZt7yJlVM8kfdhj5dgXMLsom/rsZXR6JpsNWhHtqUmJwtXbts5v6KLnCNDUrrlMdgHZmmrlCAHfSVwqZQVdTDeWSKnTveddUnGrmGi140TEpDl3Jkmi6onFIUZ768cW7A/VXDCFebGSjP8dyaTqlzHb8fypHylmZMzX3v0IDlnWIr5AIxWAZWrWNXj4foIaQZKNnBdgV4TzoVhxjXfUZavhDOuoJnMqWjooDlvBQXXjnKhuMQaVPZWL1ZCouYLunu0ubBguMu9b1TsUyplxoDNFewJ5PSDhFW61L0SGBvvBrXyRMW1Pyx6+vsWLkyddqk+vbOsrQLCljEnZo66lfEL5Xw137pAiRVsaln3Y1tySopfazmJoR55jXuHnjW90oOYP8Sk860y8VuVgHCQcUadUxXZdO/FoI2sfZnITMThsYYgTZAl5oHdxDVNWWgXgkUEvyOeidDMVfftO/+nBIDB1bQ8YdsvwDJRBNx36OVlsfSwvDpYCMOk5dYLX+pgSq9zP89rWw0g/QC/1mihwkDBRh7yV95lNd1GiapO0DCsyiwJLDDPzySnDKtMzphkYAhmmnIvKUUuS3l4RXI4ghcr00QO+QNolunKpZXhf+beeiU4kXNt8vE+uMbHDMO/RExzwLsjCMsa7nflOYj21pJjj3GHbbB/ZQEuBD0vvnxpNMJuNVYLHK5fYb8n4CXAR3lkQEVQrmVFuzIHp/vbdc5dVa+06zj2fPNjhrfVCZdhT42xRWKQgfnI55+YyWvZSTS3yDWpCPgfPtN7CTspw48R+dM9XWGhmFrXkxOqV6gGKApV30+LNGbX26qNgeV+NJpPrT1vtoKGu1ZPZjzr15i99BGUjhv1h3R4IufXXwSBhnTNp0TVkwYWzCOikZVl+lVBMb4VkWw03EDPF4efg72Zxskel15wmB+fuH1URqvH6JPlb98d86Z2uqMdAbxHVYusEyv28e4941YDs3VGr/xiCGztK+kft4wC32x4OeXSR1hTf4ohudITC4gO8Pqjh129il8Xpo01Y46xArDfF1da7V2LFrWxks2h9hcd7daKzsDFehqK8LRZt3/2x9dX0ZYAkJRwSKVtLlGPTD2Wg08pKv+XVuE1r6lHXlim9Ip8s29NT2a7YWrtfPm+4CGrzKkpcK6gdBpIdU9zZoCktPbeDycli7nZPucBftTdubvS0OGaKnW/uY8XmJX8WmKQ5gzlj+Bj9rfVsmGQkAMyEWIEF7zhCkl3/+Lmmoc2UD69pivbxGvValk2FbSZMhmT7cfcve4vugcjtLfZL9MtbqTOqi8zbXPLghmJHy0ksRHCy8750/IBWnOS43BHFpzZx41IeCPoT84Y8k0eHCRr+xiHrjR9+BdogConK9DdBJkR2zqtl2r2jyR6W+YumL9YKcP/2FvYRQNlXelyTCuoqDbRUVRAJ9+QKcyBwABClSsSFVb/x+Vd0E/DKCZwmEVdBc/RHYEUDlbMDriU2//Eze64yOWv7Ni5ZCPCMeNOZqLVqCPUzp54uZl/hPQ2iejndsMk2JliZdQmqXRcSve7tTBTXl6OwRRRwDZcn/AiSzRlgTGktePHGra2H8bRg6cjxqo5Ra/On3vq+JGe2EsW0oBURT/uj5LZ2h9CHyu330j7AuSyFUaCYeTFMBkpKFhXZ7ogmrgtWQ0BEWXt2gKHeu+j6RcJi1/U360Fm9t7NWyHrix5OgUJLETOOsHHvCwMrt0NdFk4vRh5HV/vqqZp48rZhSANltE9TJE7y6B0hNoQxLub18roPwQ0g9KyTIgdwpNMUM9R/Y82yRIe56vXblpQ6ID6QjXh/2xBlX0MUAKjwaed6gXpzc0WQkGcWcGgOF8fmN4bQkB5PgB0BZV2j3Bl1I3Me5/jg2mY9LpY/t4HRbGpT3xYnWIsfHRKNeYgjZ81j6RsZGojeOktrO0JiEJECqffSigVLM2agEZOij6Xkjl/s/RzYSapp00GwyvmEdXfbe0ivRPlqlh7r61QnOFYHj/If/NSX+192oJprgtV6bsw34MuHqC0wqOJ8lSZPgjOcxSuD0+izYA3MiiDWtv70MaVCiZbMIIBH7DwblKaF+wsLdvRFFVRYPi5l3ybTgROJphp/DXpRGbvJ7gg6uu5rNJvU9dPllgvPHq+7r/Dz0bhnH+inPs9PfpfqZR2DaHtfQYBNsc9KXcI0Sd1k5OhV9Or2Dfqryaum+tzOckrEAC5HMPI0/fzVU/Uml0AysxemWzi/XqjlATvlT7WUHGWl1ZdNVQBZ32YOgOVAoCfGjLKRrmKdunBiPdDeVKARSGMlTZyPq2ZO0sXthA/kv4KPgS9NZlSZhPgNTofF5pYY9hrXx7mpS6wI+Td7EUQwIULa3t4vGR8F00f6rIie9P5L3GWlnCaXNRkfcPW9rcCDz0VPSItYISy/fv2LblC5wgbFmIQ8K4EdfdLAKQDoC/5lF+OzpqptGgvQ0biEzycS/UZTNR91prXIt0HHlHbPYCp5T0lgQxrQ27ul8Ryx9tvqyLJsVNupvErZNwPvrh/Slogahqk3XoGLzQIJNppW8Zs10aYmqXsj/zj+OVwMf/AH2rJtc6Pk39sSVu5wQk1P2zfCkK6+zuJw8XdUrzwW6gYsmH1UM3QIP7xG4rs2uBZqNUJhGG/04ZujcEN/rL53no21t0rvUkpqs0wJHQjpkyuTOcZP13cAJU3dIjZFd85//HhZif63k6mhck7yPcQDkPHiYvVjtDIFybybRRBy7ylWGRk0mfGJliF4fNUNBfHqt/fUmUZlRl900qrmDqk7bhGPHFzsAwcTMVcdUpPrGdndOtf4JM52j7AuTb4Wb3YxH92EBSBMPkVh3NVy01OFJSky7eRLfEARc8AD24RGfSjdZCHGmhdtD3BpMTFMOLELBV+2QeyKRhCkrvcDDJaN2XA51M2TM0agmGEfs2O1AwXryw1YP2Zw9R5+o+VNr+h1gdGym0Lgubl6HxCeTg9braNW0CSDCROydWXLru4jCgItDwfNzD17WybGGdeqjY+NdHSIh1M4rU+wzJ2b164TByPc+ah2BLYWYqBtHlDaFj1hYuQhau0BhCO218k+fZQlbSHyv1i5BJ5bWOuRqahjVX1DJI9YuYCA2c4GuWOofO8bZMA+09lhWt92xQM2qTyZvRAJ+8kWwRp2c4cdXeNO3pnjwqRB4wwwC7LAGGlJHqYcvgVf73bgWQ3AZSO5+DJ+Lcs5tQZFQrxUXQXXBk+QJKRumfxC1qQj5zzwSFD2qChNjwH/h64dK2WCNscItVjA7AWk7V8kHzU0Cd20HMhFNvGpvzMmLQydUAO8Bf7E6cShjNFIeTXkaJGoIu90u31UCTwyUS/viZEVCMaplmLZqtQDjSuACfr0v0t+iTo0mG6iDN1Geg1Wd8P+M3txGQRMXW7rF4Kfv8LrmxR9qEC9AanlcMcdk3aNrcHwcoJ+T/auxEAC0G/Rl/rnLErSn25r//59H7wLOI7saEtBzdxsMRvvFcKyanLssvDnRN1CSZh3IUO0XtPv3b33+XYDRFOr4o1HW8X9ghFdocTbsDikKKVXfuQmIP/ZE6xfBLrHc4TMOd6gTVKRktmaJ4j5M205dQGGo9mPk0B+nTBtxJ4vHaPB4s4qboOOJA12yVynu9Iov+/Ar69q1vSip8XTU14p493c/lLfiWR6OL76E5vFGLlp1dmHOjNLf/nVqdB8FdKAvlVq93EymkXXhXb2M7uqSJ8VL8ivtp2Hn7q7IkuZAb7TI/o+EgoUFStkM1JWa5b/O3c5KzpE4Zqdc0Gq2Gps9mafsWssreVC6+grP5ILoe3AD0rHjYpmbGjLwPDwZT5gK7aphdvMQJ4WBcQbTi9QR/GtbUsGnra+TdIeBookZhvLDwO2RfwYwfHRzayPg3kWSBAwqadz0dqO6L4nbYmxTWdUk66wnd9tQBsha2sAmoBhCGl+KL3xJ+LGVOT4zDaQCagFG24G82g9Dbb9qpxf7o4sAIN5TZsqYGQG+etYkvMwdv0Ap9ddCsT2Xepi/SnZDG9zYpio20NaMEUyNqRKIOKEXF0bvCx0avffE5LKBusIU4cOgeAN0liqpt13Ljd9SB43++vdGTuxiu+6gfU4ACclw2Cp43B5B3l7BSbtYHbo0F547mYIercrGsBAHkd/8H3iWfEo2yaoBw/zpk2hEJPXb3Zv506p7SQtbJsavkgJNrnouy5ck30BAuHWBUuJWnoTa4zrrc+kdaGeZAYysF78RmMw8J2sepzDEgXVbd+ts7//rfUkgFCKVvbmZ72gdQhKRAvsbQH4pT39OCn5VBXmLMLQbeg469FcGA99xU2jtCG+wyxD9I7LeuSk8Uld1V5On6pjuRNtzpiCB9NemTIsPz0/UddxwY1UKy+lAvHgggLb5pyX/Zkat6l/bUylgwRY4hHnMfDuJVAR2evo+qAKP6g3mgOk3MEOWtDYNcndFWMkctNlcSa0pyYZ1HT2hC4P8E6KrMvMiAXMydr+LGSYNR1RqJF5r+htZY/bx+23RP1TYf+UCMFm4H2X0j+nBoCi3QrtuJDClpqRFzy9XOBzZdQ5uZNiUMEHRl8cCYfxDB0dADM+6uW1BPU4aSvYvLI4fvwbL52eh4BHyCokADOF8fWohfL7p4uFo3z5YvA+aIgdVrm9HhtiAIBj7U4LoW6oZ5WNA3NOre4Ls3+z0ktPbu4b2ss2CT5dT0xoyONT7Mr6kGB462qRJFCiGUgBN+oztqGD5/nDHI4D2jlM9LZJRSnhKgpexp/2VtXCcx3TbTP7y3ZKVA1AjS1dTP9yt6saeb9muyAs9QQGRCMm2QWbdgql1a5HpmsiFguPFO09mbHQ2E6p5nPb0R0lPMCwYAnv+vUns8sSe/VTz/oC9MMD+muT/liAzrPwlVdFXrarUr8WRHkeiqYHkOTGOSzYD83rZ+f6pUhyjcjYjuKsQ/CDpucoDA0UNDFrQMj61jMNDNlix3e1i9GlCz5ME60S6mKlZlwfEyzC0qpInJW/F9OwY0f65fqDPaOpCZWxObl8i1pu6Z6L/5LIvwaq022MtV8P8rCet/42UCfmaUwuZpeE5wgGCYyGMwi7rCRxxUMk/086ljQmmd0+JFqQKRPChFXVQaLspmU3aKF8zSKcLNPbHsEygGS5Ee5Xc8Sm9oWpYute1zqhaGrXUVSAVJb5K+N3MwAhbOk/3K4XhChqokh7QyIYZDr+zdvUukvwOMlJRr9IVFpVX5mUXv4S7tOJh/Ogkz4J0y9QSie0v3riks+zFpt5FcrQV+ZIx09FVXXJ2ZDp6Ofg29kyGvPAJRwQ0RS+ia3BXiFZRtuk6HsEf3UHZcP7Nfr7dM976pSMWlxCVuHDSMwWDQqUatn44RacFRCc8A6vcMFDpyxXqMgeOFqZqGduXKmo1v8gkctNG78fqTWRLqbe+z4USlGsTjDeaFK6Q4Lj3ghSv+Qu14BQaJq5WfXMo9Fly7HAN6abepIxviIvfagLTe5Dj1S3uCChkFvVor/lDQsA9UV1G2qdKPonjtYQ7bZyhUMHdrI0VlIdFqdIzJC6kND/rVhKRz3uj9W5XwVtR70TFAKltfq5se36VSgsWtD2B6u3pC6CERZAuzYBbnVOCHVVozbOcG6LltwSB1H/LFY1K92TEkB1YWKnBDutv0pe8ZoYoxHPvrObaL1X8IGmAtRAJfWdFqPd5NPVhWouvji1s42Km3EeU0NSBI8Kdw5g9kJP3e4+64h2OK+XCCVxQnsRc2fOWL4lf5/Dj5c1jzVc/wFuOiGC0z6nY2EGGsJG24xs15YR2gRuFSn9jwhMyBimn/ZRQqB7CIuDPGfnqzhTs6Spwzshj/jO8M8Dui0YKnFlyrw9xLxPVHLmY6JPr0nN50QQnMyURgR5Ukxvoi+3otIZISVpl+/WoUpuwYrkcSVoYDqHnTFOX+H/yWG8TvxlMR4zbBQvHT3lA66jEdvl5bgcOLXDBibzne6xn47qn6JWKEhd3pW+9XsO8zbKcmZIDXNSVXdj98UGcKxRK8Gr8dK9pSQeHsUcfmqAEIvkcydQRGb7gssJKAIc63RKWbimRI7uYs+7KfeQnL1XZMraold0+ckodweRbOXrFO5uMqjKazATSfQuJTajD4eq7SDO/NqaheWsceQXOJJ6eAu66xNkYapExkhUh1SAT0ElTlrR2G46wKDcCFjafHuOWit0co8thxvS0NBotYpoKAhqsv7060u+o1G3VqS8E7rQYDvwtJvusnr1EW1oVHTU9mqn9tLgeAC2TuJLIJ2z+takcVt1Ju4B9Pjxui/DI++KpzNk+Z5RSk6sszpu1qfjGmlaKxkiMJk8tgnNtM7Z1JJoHBQucruz8WNx00Etf7Oze8ldSrBgSM6Jg+eDvkMa54cHG+tU7sOHWW6b9vZt1x0vdNCUldPeVEqciaoLFXn2O3cpNb8lCrTIabpziG/mzCVmkX/ojS3d7oJjSdhwRxJ22ITw3xtZjeHKAQQsiBQCbVXmJUoMYBlg05FLSVljh/MtNHf9isNA+ydE9WScSeRR8ga51yTUC6Bo8Ra14IB1WlAlIXFo5AcQjhCcg9XVFpw3r1IYIexUgE0mWDezZyArT4ss43M/mmqZomilByoaHR8fVFeUkzAN43FTYMoxR3EIpFRr1D32YgpjJg69dSLhf0fkMQrszNvZA35NKF3ita30uX5BmaO4vVJRlR2sDCC9ejzhBWOyMXbg+K7lXg7ZlNCJ9sFWqobG4V3AbtSs/P8R994W7qjcZqs1eU5A1qPO2K+nJIELc1fpdlOACxbwy2sc/9pih+0wNz0vCIkxqmPw93MrHxowYatLHxCvA8jIlbj7Xq/HPw7bD+FX60xT3OzA0GEq37lrhPV5EiFV7jvitkXfUQNWmHd5DrS3qnikhR1UCmXbvKbtaM3Z0AzA5uwUt1gYAZQMRTvInsoLFVAZLXTXB3mcchZb6+gaAKR/Bt6FVhXWEpebiPdwDcFTl0rhZCDWGCyqjKVEkhB6eGJesyid/NKI4AforUH1QHzDHuq1O3uQfZ+REzpk3nA+uF6mdOjs/jwXI72mDnPSbcA11/B7ZSWCyV+YzlF7osURrYgtHeothQuWV465q3L+pVamHoFkk0m6+Gh21aD48EQJtwnLDzrexmb4CFl0s3ZqVePr7Lt1dW2akEWnhq/O7o9bv/TZnv0aQJYpq8eR/jTVJwrU+cLB/xTv+q9hI2Yrd1krlpowIQrlBE/VuD2yPY6r0syqD5T2Gbxkp3prlo/+rLVxd63qoNX79PyyNxZ9L2ERgVdnEqgqgNA96W+VJDvm2/wmY1kOo4oZUfSsmzQqYJCz8jvODdBKkZi5lqFtCrqaB4nauRR09Vay5Ee7ReXxzxJbOt+iDV7/eS6HlANk9PVge1MSxMPkCCxn90jcpg9DI47dLdlJ2fJIm+CthqmjW+J3Dv6GECAi8bdGxQkAG4JiKSXq5FUMFMzck90On/VX8F2vPyjPfcAASZksLFECfNI9Ru3/kzRtQbHqqXOfPuqGM2MXViX18AHsCppay9exMRgdPaFhHl+APj7NPdDwITbHeQKuYQQyGqAmcMljOdHd1Vb4+WHomudg4cP7hx6CruaLWxO8BpESSOPqcxc9rtvGY30IyNHF8UKqKNfR67CGscupfGvKXKxnfIVC8O+O7Sv7lkONc6LGxV/tZzfi1VKAI8Ow1pM5TmYeCe3gzfgsD97Fm46iq7rJDcA7+iAW3CyJcqPSczMOqDtiTA71GgDQI7tigo36zR8wpY6DSwxOqAS2KHGxSRO3xK4KLAdoU30TbwXvDux7oEIPAjciSI4TVX4APANogja9AV+fIMkbSNsA0N5ybel3zuNp4ru4IYQd0zJcm8R+uZcYmNzNz0Dg412BDdMJnzk+jrk2ERv0PZmDbUY6cloGtOrCuFN8IK3bzdmBcTRCDya8Mfrx0emE1P3za8yGJ2FpFdgBUYaDL6qt6mzx5q+rhb/Wj8csxkRzNfEJs4kNhn3Jhp3ifs/wnwmkrx2pgaonhmTNbUfvjlzWyFE7bVj8CwN+30Upn/nXDRSQYTZTxN2nxHbRPVVwDjJgoUFgz45fukA+nPs+R2yOcOwcyeQst3rwV+Rpj50sc48s4JR9tXFrB+FZP57C0Isw3qawYTC+wXG7u0XIML6IsV3tbTESsdvgq0RPjhw2WIk5y0bj1e0C4Hox0PD1KrNp5ppHrHX7ib2NbKnm2tLp6b39aRT+raQQUP4b+kZJQlk4QKGN5+ST81PnGqYYm6oehwGgTPWIp0zeTb6I5H9Fg7tuGVPDC9rT+Xs1PYHatv0ToiYJVv6fhiK927SuG/1DIv1/f0Mk1b0WHv1XkdF/EpogPGQKUVIZP9oGANmVX6K/xbE+uJMDcx5NNQMU/S3j/JYcxLxu57FqSYh0JsGVbrL8DU0ZmSuUZD2yx99ISPVeyX746fO3AfW24Qw+Hlw3cV+QPEhvlc0sIQXGQafGT9CmQkwNhbzyVaiUh7fKEsr78hTu6Mb+25PEVedyxn1RaG2rOzpkm/pyyU5nZl2zXJYcUl0YJbg8yqjyozIsHzc1c+AMiRjPqigmd1ygPSeb8R0eu4bqW3e3G9J+WE3i+krN8Jsb3rTQ3OMYfDEi4qO9b0ohBpZ2S7HIVor4nTCBxL1pxf5hnEwqxRh1zrTvjOOjqJW/6u0gHH5B8QoxPFudBAGI/wvlUOau8A5sST0QolD3jQZSt4IIPzGMXuE1myfQfczN/ytWXG3Ktvjq4BBPHBqeJr4h3LGEN5r2Z/JUCLuqzPNvbrFMBgNVvWIJw9CpeyhIpd1/K96ShZflSeR8Y7Der9UfQ0+gqPVsh0jRkNa+06z/PbvV/HihuRPpNnDWVwv7biULfFk75FiCW9vSNz+bab2MtbVgzzzgUW0XoBv1bmBC9jQKXLwFK1T8c2B1XNghG7pEPSVKJGOZUtEjgCvFw/1mu3C005DkBCgfTuuwAKtQotzquUm4Jd9MjNwxdE8jFFBbGk+oPjJocJFWeGn5wefcQHAwOyi6ituvPrfocxZXGt8wkTpReypOZoF+9SYQZKiIqhWIqzBO1UDov3cKzBzRzH6fg1Yvc0MruH27MXAa5vt38cIOxOPgc1PPsXGnFbbyRnKrZz6mMb6/vsgvAfFTaSRRE7fREpE+UnNU+fODXxOlbeiAD0ZNZUC/1R5ZKMwWjjfua2YAtovhgClrx3gRqKtK756CZtpYIkcWm+zFiMsgO0OfpKNlTw5Rhuf0UKhJwMtg9DiOAlaIOJJnN+vR38f/GXP7EJYsa/83SWCWv1rfgGzgQ2+OfFOUeUiTibz3imfT1iQLXT/kC/GI0fw0vQdvHpJCmZkPOJjn8XyFs2YFo9jJjnimOoTVoeLy+JKp7VsmD3Ni/bkIX7YtUwHwiAg9PMjkoOOuiBESxNsFWZKj/YVCBiJX/A6TdG/RlPrVGOzDcV/jpWD6tFossu62SSuyrdL60klK87oBygZIVc4l0HFdcbOScH4dD3rG/d3n2zqU4xlRR59XvESFXdPygugUDNNTyVImENz64LapxYiWMH6UvGmFjvaUAmIMuUmJBOo7NqtgMvcHsY/byQA1TPDqNr3Ll/xIiGvm0Smlas6Qxjyr/iadxYs8ZIqo9Fwbbork/Cyei6jCt5xIF9BHwiJ9GLSP9xIJA0+OKFGHrT/PrtjkIPvq9Yt7kVf5cWp2CtUThqkgYvCOvxg88ZDDS7Ob/rMUkzf5u6KMSfIk1RUaOg5fUwNiZK3isUbC/O6L36CNc2nYolmyn5+BZ5daNpwgr1vLs/aIo0vaiBAz/9VfbyWlpUZuIwu5cB0g55fWy6LkFQNBe8tBYLTR6tPYk5pYGPdnkv4plN+6Z9T/vTacNuHOp9NrWvbLkVuvaCP/BB8SVD4Ma+d+23vaNtPm8U/gMR56ECzWk+v2P/F5j2qyUylvzEWWBsDM1lLXOBSTk69Xl3ID4gjP/WF386KlKG7PtdTNoo3985nGJC9EjV1FSU0xIlhlHQ7JB+/07aJz/5friAuYpE0KChP2/uBS+C+Zz5S1nhNlV8Yi5l6jprXIgnQ8F1PvywgfXMJ2Y8xgfzQM2QmcTeZPkYQ36CI72H7LZiBTC1aPM80ooW7MzZmc39+YMr2yt/T40C7a5Rkl1bld2y7NzO4A45LDQiCI9czYMNhg0Nkn+WO5cDxLM/bLbcJ8n/E4k6bDdzrT6s0DiwR012MfOsxRs9u3QGDccR3m1qA61aQ7IduFkXC5M2prhLIxWjK84tJIqrDAtU9iATyCkc5T0ePB3QtOAg4L7TZXgpnn+sdeTBWKixy/uP+Sd2plWR55i0yBY1ulq9RU1nukStsEFdvVysT1xRc5qG7ESn9VMCt9062QqAyhjw4eWHam7LooWx7Y0CgP065pmC+mgGfyHAPsAigtpI10lPgNhHrTvgEh8KxCpSE7OoQC93VFF/AlVbZYJ+HplILX6bVEl9Y/v4AesXJoluMZqCr4vC2ZIt8dvJ7+9qGIdZByyAgtUfERv8UrmvKI5Be3cWFWi30loSZqdVYUP4i3amW2TeE6M+Ty5O8F6XNcKZuHpPrlUVvjyv8nb5nlq38hsXTkn7LEgsrgWPKbvMmrZbwp8ocR2Z11RMq1ImC4gzAO8WOCfI3baEiyOaAl5prXfnsK5yP99pnhYZpKemv6PZZgy1Vde4VG76gioF5szSfsFp+kSs48oC0RipRuWhtOD8dzy9kri2v2e/x69LmVk4U4FnlVBRqGvTngjeewKfgca4g7spNoVTvbZB8UWieZamJoZ9wI/i2Rn/geHLCRM/M0+3VDw991rsvorERhbiDg6eTAyBDK5jcXQt5x7LHc+99iB0++vghMOoLd6HHfWIUBjaXi5DJMnjhCYXnZVD9SE0PZiCcAreNmsOZxaKF+G6bBLLXFJaFq5pO2zaXx5ZUZszasUdmdeEX8FCDzRtngaoH5BxX8SSvlzrkWiX89xH7DWKPCIqyPzRw3jVomEuf7u6b90Dk3YGePZwWi3w9TDGoVobPZGsIXu6P40cHVCpJKmhKznCEhjBPRUhqrmqZyAZnP6u1d2bCSHcrPtsaQlfwcGrYB1vM0M+L6VXOV5QuRICJXgULtBeyctYLvK+OJoGpK5mw5f48FBQvv5N0hHj9xqbDwH8wrfP5UBTdE7hB0Iqidzsxy0mfkk0u44Ariol//CRW2R3TsXp03y24zZn1Mq0CXfr1usg06ZZ2QuLUWEI3dHNacU26XmSL4e4cOkc2uxgJnN0uGtFo34rOwI5qJ5Jdlcb0+q/pkVrDQ8qUqy6wIqpPmGgo1C4n8E1nI18nGRXlxJmmfMI+FTJOwDR2ARICXm9CSyqL3RqviLgCpc2PWKGEKbN5N42Z1WR5TYibEeM9kSKUa/ZPSZqOykJtqUHwIzQiRFapn54oKtuup7Q/o28+Vbj4HgpBQSkt9O2vuuArnPfvoQDcgOq4Sg/zdlxIYEp1tsPB1skofd2czwBF39tAELMXLbMumWcp3yzoL+HDLAB3g9mCslkWZcTF+wALdv1MVMOysVod9wHvI7xkoN22L8qCPimIvI7AGTIDOYIQA42aUmDKxsDQj8+sIjhiUu74xBucynw6sKOk9Bv4BLVnE4sYNtq0N4DNrAlDwe7lu2f28x1YlYuJrA3oSJyRHIXNQRiw1DDiZjWhqTrBg/WrbwexdyUadl1q5O7hDZjEPDvN+qzLrToGPY1q5klE40vB/7dYfs8toehNmfvbLeYGokd6ky5oY3q34zle+IhG/OHYxQGX8QJOQ6fE8dqBp2Ijf62H5RkjuZmtPBZOTD3vXO74GcbKt2EMkhmOcc5MbsfJHH36UwRKBqyynlnPPmqvT4cCeNmcxTxis4YlS7WzpsNCrVPO4zXK0PJtxiplj+qVBBvK1YQGZM3gDTUmNXRkfhgPEgFZp/FuG4CBaBEIllPHiqWRQkzkf+C5f+7wGDRQwPpwS6SpngpNnMVDY+heKm64EaL9Kh3nyZgnmSBWm+60JU9pgihESYSs8EKfgk2b7G2Xll7AVK2y9LHrF+PlnK7xySxAxtAJAxTcjcWEY+MLz3gnP/Qvs1owy68z1Qd3jgVe/cYG+QGY1bXSP42xcBLMIEXJSvzd/Ysujj8mcz66Tw76EJwd66MvE98IT8SmRHqZjiLVlenH0sE64yc9mkt5Bde8WqpRLxR/7XFiyiIGqnLvmGNAosxCi5c0snJA/6xwHPOvFuqSr0IQJuWdsZLO/eisIT71wNPeJaP6Z3XWQsj5y8QFxjpq3mXmTt+DZT7TPOpbe8si4K5kIxldMVCByt+sdpyk7EOdlLwO/gzyMXMgkM/hcA0SQxdjAYeplLSm4l2RFGJUxKFyTELeRg/As+hedvN1un+iFVbKUEV4JANi69zVK4+EwFUa59JnTpJ0wPCr4x7pjsRpAIIX+LHGaHGDAaU1llk+xxG/x9j1CD3PhU32ItBW1HuWADg78PMc7remh5QrWo9+EnXFK/bWFeX86B1AjreahK34qSn/zHXfbaSMJI5FNPUON1SsWIS3T850Ap29PXNJChY9SrHxP5IgKeeFHVIz/CwCcdUG9XCR/amUo2oCTbXo0NyXIIeLZtB7zXc9iq7ttL/mGBCXnMIUqdN4RlD0S+Yo3ZxVbUaZ9p8E2oc1a7hlDGGb4amTPK5xCCyCYyjNKC9n3kKK/YnoxijvP7AiosRuzdicVChyaq7ShdW/YMLSBWDgfD2KCg6dCrotwWv1XP+CRmeYJY9sTppEthaX8RD2IBy919oitO/HqZ+5t+ZBddoxbZQjmvLvDsL0EoRjZl3WOVDaN1yqgkrBULUFUe8PzWBaT5ny5LEDmQK+DgnAj3cTjrIX74i6n+NJUcBiz4OHBZyfZTK9ruTigm1p5oUFPI57aj6ugIPIJM4DII5jeyZNYQSH1mCJqW4T6j2XohTMrmbTSouJN7tKwH/JSRAJXwruePvO5aBTmfWUhZmwqhkPAUDxJQi59H1KV2322/Ic6Jf6N4VFFAaMRbFZiCDfITK+Q59WpnPYhaeVcYJ+pZilWDUv7sg6Ny3DEg+cSUb05Ml2EEWcA3rE9MhzLKPWtGFENZW4bDGm64hDTziPRs7baWbfjTxcRsCpT1gX0QmUsmFxXq2F883ULRrWXYgeYnJGjFxXuZA7l/VYVPl3mCgpECF4Do0Zaqj+7XfY1X5da4V7cwDPvQCwir3ONigw/D5fBhX+sZvjVkDm5qskCrYtOheAyS2jCF6eZCn8Dq13666Ojj74voqC2wuZ0NrhZKshVLf4XR/G4l1ZNr4M9f0wy5jFNQdbKABwjrRH91WZEPwgtY3t4gWUZ8VBaecQZtV2PrS3tafw+ilKnhLad3jDv9aaVo/GuKe7yqdWUwxjQ/h2xmkxERTA23oFLStvbNlWy87EsUwKicEoV8zDtusEydg+4MlG/cPZQuOyknAroP2h14i816+TrzK/bioKeszbCNE9ugiMGgbWwoqrmiyf2GTnU2JnkGXBl150mC9fiTB0jUh+yqPZpD74/ivkECrXz2GvBz9Q+Qi5gsW3CYlwmUvZXXHloX3hOUjAVWVC9zdjuzfp96+9DZT3mV+dovvhAQpnWyk+OdysimcbB1ENCcZ1EUUkaFQyXR7Hxc5u5DfuS7c1R57BS9EaOLE29tBcFaWBqhSMCL/Qao0SdujvHeU7r3z8MbRuuQQKW04BDBWDsrydjz64UtAigAkCUPy4PtmfIWGgo81uX418VUZA5e5O24VcOpXzQdqcT5icX2KkNn+GFgUGTLvigQv/lrtqN8aCUgscybPTUFEEnRovAaqK4wJAV6pqzLxK7hbZSRyzGEHjQ+w72eW8T6v7t5TRS6R1zIb1o0hsK2MqlG7EGjuEFuSzHP1bxIxYmgtErfokIp9APZp5+XhcUtO205cpvuTWgdkDY4IshA7fCVtkinI71yjuElLhl/PrYqOyi0qHHTLyVsdbXPJtVR0ICklB8VKCkH534yYX4S+GxqU1WaLA1Y1XwQBXGxlqZi0ItEogM9VN9BrrSg7xeZ7euFVzWATpoOz8Kyp55u8ubOTUmyPPxPe41QslvOIXmc3G/Gsig9Dm3GSdqu3eAQ9r2zYw95C11rbMvq5RLDsJamM1I1kNLM0MQ/cjL+su83hj+TdhE/qROFxz3DIOog8VotKHiImKSEFsroaHT3BPo9SkqT+xgPyYJU0XG6YlQPbLMnM74KHBnJSEBNItvixsOeXz9DAsVBJCWsF05sut0Mkgm3qbVMHd3oeo9PzM+5xNWCsOqkfXfpSt+GSMsd0zh5aAYwNSnfdADMJsHFcMROzMxLiFTYs96jZPx1vDHmkUrhLuTfQuv8nRAqMxRWNzPdqBC6o67OAjGb8WZTsYFW6JOARtDs+YwHVZ6ZTlk5CVFsdXszPZA4TreNBXECwWmBCEm32MmU1nR5513crqLMq09HV+Z68F+FjfqWQDLw6QITyYaTOb6NUb4ZRFINmrgc+cvGUMQHmKJrhn5Ve+k3yw2227TQ7rwcZItbVPrVEElJDGk5GfNGGd/Xan+vQg0Otncw4ggBWVCgpoXH0aqp6b5eyNakwWbN4heu2oAX0OvcRmZlkIbK+ojXzpflE7vbXm4g+z8eZipXJSY6WPeUetAbVl6NOaMxx1f5vCa76U2WwZoUrtZG6wR1goSQdG5E6NgsYfv3/kFhyxJlSCyLow1q/lR8t2KNtE1/V8rqKzIrSRB3sA9M2fZMcCMXnHO3sDYJVdGuNw1MueUmQN3sdjRTYvl3iE7qfTr3mmwlXzXT4s66CBoJ4Ta+uUjJJngJz+OSDBeph6lYi4GqRdu1besXW1GiOMoDXoOQFwYwoA+3kv/vPU9q7liAHa+k/QwyavJ2sSdan8EBWF32s0OeuPy2rx9to30noZr84YzqHpaQBStpgJ0VQSt6cUXNDofEwWQYXQ8MUMB1WAfsJrmFIeuXDkuU3/KZ7l6pMYt0p9kFaLo0pXZ0IZKgcOLOwI9BpJXuXrONix0JYRMvmCCbPRSm6yi/aOMpodFJ5upMIDuJx9b0zNjquXXmVX9cY5b08rG2XXZ4YNhLiifIM6MdyPPf7CZxzSIsZOvhlGkuCEV7ybF0iF00RLx73VmkXxbbe45qFEPFAMbH4PjwRi6pt6QeLpksh5b6mpmNOdKF1e8pJnd3GXRdoiE4YLhR3op39pongF/m5Ke6qTsSLb8eYdzrjYCpPCGakQTxCjRTqAB+IhpATc7qp5eeGBMghmXMMKM/gnfIe7O2lUHGHZrtqAn7Ooh3w1D254XzEIOlWvqHi3PSDeJvtci3xNDd+f8gyPMzm/JX68qz+ovmczKOsTQ/4Yvx6TqXyi+gw5P/S14oJHvCZYvncRfS1XVysRnS3gU/J4wufvVzFMlIs1YQhXV5vLVWYGY3mV54k7U4M+d0hNrTqCaw7o1RGcDNfSVZ6UMCUD0Mof9+m3+OkqL1lzpmWMV7hxKp4ZbFYeZRnE8wftAQmPSngqXseZY8yPnWUWehnypmrAmf92WXReQKgi9fRhoaBNVEUNGMmD7ozfiOtY2WYKtEA4Ze5iOAwfUAVUYthy4A3bIpMiaSxdn37YmyXwW2yXgPj+kBUyMAhniyVwI2vbhV3fvgfJHg9Kdweqxcj49E67W/e2qawPkFsPRXqpxPjz4pK4GWugFeyOjjEGLyJZYWilLV3Z3thtmpE85rBJ+Tq1GrloZNrPfQtzD59SZZnQftJiKpY0ieGJ5qMzFyxHwZrFJWAd9PXLzpeDQUc1K3e/v6QcDZt6zzej9ZOn668ebNC0QaN0h7enMkvwv1MMdyd1WfR1NW8F2HTJFDKjMOc/HUCcmRmnpyRKI767ouxrzfvPhnM3gR7PPNs24k09kx+scnrLYbHZicrW+Ke+Qx1vyJt3UWlbga8NOVcDkoDU+miYCxnnnED6Ye9Xa2R9Dz2P1590iUKoKkAveP3xfk2CG1MwnaAh0jaNRE6Plg889RT0wmx3MOz9b73Q9Az1dznzG1YiEZnvNgxauIekFwd2UXr9LJYjjsNtT5YQqSF9lLr/SVbgorL+pxb+fXB2IHkanvFMOG1CNuOoeuoc9puPh8/GirkSL08STpC75v17o2jj6dGTkEFUwS8VpIcV7z4ETYCuRI3HPD+ugkqMFn5DRlc/fmg1HzicdtbuNEB2XxNOZKsaL1fFPCpXS+sF6HFT8NOITN1u6LgzUu9xjbZdf7gzS9/cX5fV+QXzAkv+bhHKPOjxbJoPtH/C7W4J9CjHGa2oa1HyNKU7qCfI+ROUzHrJQqgkTdpetymQ5p6vsueKSfm/b7C4wFO4ybeTkCB1H/wmUPTsNo4nHc2dY0A5kT6M/OhMsLigX5U+pFlZy2vdMEcaYBNooWiF5V4ZdBwdmEggD74UbGMEGaqyAs4e8+ZeuMMxF6V+48OfgsPNCfbUL04JigRtMNq1ukiWdwtDxXl4DDCMHXiuwm3wtycYf6gRc29GzYds6nJdfWE3M7jxCnIk2yNGkyw6ju0toU8P1cgQ6VB73TT2vrfos39FxKzXgGMcd6cuOcFbw4+RYItdVOqKeBKOBMWzcuzLwrlqI2yvLN+Dz8zqAPdv+Ytk0ZonYONodrfRI15Xbvxj9LqUCFbMOjUfp5Ozg+kG62Nwl93ZvsuIk9ZbAMEoCCMHaeC60sIfmybpy54sIT4TPKlmK+mOwflEw3IkqsuyimdRXN5nz7GOe2u5hS7KnZl8P9JUpgGU0XCsC2DTa49StYUT+1Lxe2p7mjAJ1SuQVoYuEY3v36XNJxMb0V8VXePNI+qjqxkFjH3Op5+DNXHeMImV+M1nqcef1e9Y2NemB4lkYcQgCx1xBsx7Ng/ASQcbxYjQbo0ITKp14BXSdbP7FPO72UVM8PQ6PkYGkGyZa2SPrHz3/m5GwJ7/bcfmDcf581E73BW8Moat3b1lPLKG5FKNaGJElXQnhiTKnbOn7Da2phXuJd6b8XkoJZvi3W7q4P8nxYOwqqqKgCq+Y1m7ULmO71soKJs5L2pre+ca+OFZ1noY40EZMb8/S7FQ2AhAhjX1elZxtGpIHBSQxF6RJUVLU/G7sEkS/vrPAytjXYACVqHGumQTDneJ7C/5+Q4A/oRkyHb61WC/cp/zAXu2qhTcX111jd5lNJGGld1IxhM0eZRbh/Y1N4TFKNOoNkqL6NrTX/ZFvIx2aeuTQtIj3nrjTmKZaz2nm6jsxZUBlvzvOqZazspgt4SBPOpQaUJBmca6hzzMC1qafQt8bBghrc6Wl09dodhCb7vOeLCBiZclwnAugCPFcf29ptxKc6NMAztH4gieBRryB473HNxgg0qhppMGmw9oeCVoIo9Az4HyKOUN1Hpc2U9iBtZJJdV/st+f4f7RamX5RtfyVg+L2o6MalH+UzWeu718DkXOvyzO1vYujVbuiB/shKUOUy2Km4OPj/QEdMqpErepK2T5S7NFAUNTll/ZELAN+minZUwK+ycJnhp0kOGezz8w5q44ZyqvVpz+YTmOWfh9aKItVQY2mvBq1mrp4i2uIsYwMmaNlyQ7wg8+TfJbttK2hEiX2791j1ukGaY/BgIhh5T1wpsSRIS1M0n9xZuOD9sMvS+OQwyRT3PEFbGqmdoTMII/GNcDR4HHHgFTF4HQ9CliSkTZF1T/InQ7Vkt7dsYrgKJn9yji9hns7oe2q3BIkCaGT0CaUe9tgoBd7Ihp0GN33sU6sKRA67ZudUtDuAZw/ssj54k5yOAL31Aenu0wLybESxYbC6WCa7MHXUnSb0vKCxkLoiB/UvmSu9w/z+kwd1clzaZVzuwGWFgY3WgMXx9UTvLnJLk1lMgJMppeuKWgoepcZVtc9gXPIsrsIXKJhNL8vgWSvufJIm4JvyeykAHBPOPIArbK4BClRCiNfEhUMK39FdSzRAwooiHxN2wqzty/4xqWCf+ZMk+Ag16TyQYPbLOnu4irBr6OdKY0LZ1Nx7YXoaloQrEweI7FkCdrpPg43SriMoA6AH43wFPlyT7HqO+IfgQvdHspEHw38gJjanqyfX5U9o4NwB0g4og/PVfG9wk07eyxtneFkQE4Zhzruy1+K9/lhzhX7LHeiQsy8HTIRpwiwytDoTmRjaO4rN1OkXvV8SpZBviiqFm2GGPP8YvidRaH9IK4oCU19xGIBN//5mzORLnyvQxIfBvhFkSviKC5q78BPshnpERFdP2p3sO+eFw/uKvy37gsurcecSz2NOp2TecNQc5FQUgx9xEKhilG6RRTqAWohurUhevfID7YujEh+RmS215GCobr2AiBVcqBRrVctFV9c1qxnWUwKmql6OVGcSyJtyGjxn2DkbpxroXkj2oiOQXRiwgBp9CJJbTsKk67DphcpbUk9utr2+Wd1lOxJIxOI4rFc9pj1uMiYPPzaWHexl59BtCmnqWP8A7EqXsKmwdZSVMtfCPVmWkdCLM0F74kyvlmdGGMfcT3EB+L+EI2/zYyOePcYzlhcqA6o+xVfrdGaEOBg3EXktxeACNIMufDPibwhKgmrJ6krRGp4N/OZjtuCAW90xmRuT7FKkQ4bOlN8LJ7nyeobpT5om8JOAKwavT/8YVNyYfOfjJz/shdB4AStf34dWQUu/ua/pWT8TEG8Vj3z6XoHQ3m43A+2k6VbPCOxt0+/PakSjVCBqUajPJGI0mvedvUMPaY4OgvkSBbyCdnuad6Y2sfGdX+j0NZZrxxcfI517wp7y74gV0+tEJcWHZhLoYgXqpsxgDUv9/WKq+EgiQTZTmD50/au7hWSQ0rnoPOp24cWaTEBk441APYigCOX8/NPKlAea/2yATwtd5cD5NurAIiFE6w1NN7wJ+kAl+BRAf+K8IvjGNVzSNjwY6qD326QZ3+ofolhUF04KOlwSOlP7RpRiIZYwywyktWiTmkY9rse34sI/Ts/p4bVvaYDW5A6Z5mV22UEbrQLeoQLcEa1HkwMz5JvJ64DqX7wre/PewZAawQYwGDLkAYOkSES1yFAS/xmAMxBCBHAO/JBNysPCq1SQh9xlvhMmoy4DqG21Cisz5F2/RY10SsWGbAQRNDk5ePEfMZfVD0J9snPBUUKTkO588zcHS563nK9aujYnYwjGzOIXjtAmSPC6Uua4EF5OO9c7HzTyhSq9vLKwlX0Y+ht2rLbt9GvkbF7Y1NsQYYjVw/r+zv+DKXVXyqVUE+IDqDl4lBbdJp7XUCG9nhQ9azFLG9jwk4dE1Nw/N7D+uSTDWPOUxWwtzmS7/NUh59f+1omVYYk1OjKDtVAS7YOuF2hw7EKtmkF3cjIDOl+GLlE6/KuJGjXir8nbESjUi5+XyQy0rJD2fAF+zp6S78Mm8owrUJzKaUSeRmkz687aYt8LPmJnPRnLDChzjtduI4eXgYw0nONgtdWRF8ORoueVDdUkP7wMXt74Mhamo8xY/NsgBxGAPHhTbL7FHbgUWwo1/5l+WKUHmfKlGx54TxNaYT6LiA93wJGPWn1YzTA7/u3L78izxa5pGbpCJUp4XKKAMIAVWaqWH6yx7gE5eretXGSfUEfFCvzIktBqn+j9iCeaYyKo4eQt/sZPPpmSpb/441AQXCXNLARVM6lVpIB/N90BwT2EA+xDr/fxyb6RWpm6RiABrN51hEu6eDEtjV7Mrptd1Md8Hq2132V0Em9XCwHdUozchPhHIAcPNWwKmgzQ7Mt/vDLPwmN+OlLNDb+esIvD88rPBcAmjB3+7Infzj3cLMa0n/QDIRuNY1cOMhr0FdHv31cFGxvF8+4rjX0/zSb0Vj8rCkQwI2YIoZdeVeq9/9RuriiJINTtt1OzZA43xXt9Ma0X9jqmT/NAC7ibqK6ASj6n+UV+8qqY4FDfrARCP1xHPhSBHGXv1Z6kYwewXRmGYEUheAhkpvvd2vXJ206oa3+e3XPKtIYNwZLjQMiCLt0FEqIh+Jxvfh6CckIq2VqmqYjBnPeANODVqwDdJCr7WdZzUhhOGLKJWUlZ7WG/3y9O57uG5sgNQRzPDTLYD2zXKClcE6uonf7AgUVMyny27KHefzVzrr0vTI9PZa26PzEf/lgu81m4yq1jUwqykRo3PTjSrvJQDifRCvhuuIlz+7HZo+cNiDmFoYtPr2kw3oLL2zyOdyIEu7yJGG4GTr6ow3o09AtuisVwiMJcyJ1ku9/k1/xiYzsy0mHx1ASeh9+PK8Q0V8sEOufsaXiur0LucOUmGOYohIHKYuuHiLGCyLA8Vdzo6JBFvdufjB/D8fN80mkbcD+nHjTQc05MrL5WWUUnkf4wcw7UqF2tJicSwksRtPSN+nts5/M9d2k0YFcJKhEHKqNCXNFEr2LdEqHPk7ojpobsAwciD6Zy1xrIvDQzlW4BebKcTxOKVYvY5LK4JbNJpfY9emBKT6pIsd4lYESKUenBPte8HZLIFBD940m5bpIrqpNb7qIcdjKj5AgXyQsYRIIki0evFeno+E/MzBju5ofcprOD8m754/jKuNVWiw3yVmYP/PkWZVGKTmMyfycVo5nyX7pHwLV4hGKAIyyhH9QplsCgdb/uMACd9RdycRJ6s0utESz0O/9rLfW7EAQg4DE2UW8mvub+hkG3SVEqk9cy8mmt6s71pMz/yO+nwHCEWx6h5z7yGBQGHtM9Dc/FxrBsr+5AR7UOSByqp+Eg4F7zMhHDtTb22auxlehub6e5eK5/IZiJlBID6aKfg0EFKietaCBHjXu3WKG3jIViOu08agoh8GyyjOl41zy1A/0uhbev/1BVNZ2Tn+UuQKoodnC/L7a2l+Vhyimg60VXsWAShQAqqpZMXPoqEYBXE+9+zGdFPwyuHh9sGKJqa0pPTrA9M4mUq8o/dBdUB+On2k5hKoZKaI348rc5UpQhKRqMIpCxCJX2JBp8AQ4jSRtWbRPkUDfHt3mzkXtYGpMAAtu34LlPL64jexJcm8xNnYB9TTixXuWvj7OZqfNJuoXG7sTD+s1dvtP6hl54aOY6ZIGJNy2PQaH+PEoHum1MuS3AD32hSRhMt7HJWi8uhGCXY9KVQiquNt1FVvELWWbb40sd1Q/y952bxFJi/oOJ1oG9W+Z7j6P8CERtmgRYn7BOuzm/FXdUZiBHhzVdyCv9JoCTV8PGP22OCu0Kc2s3EW+Bo1fgzGAPmfI/yf5ZgTzpFWIK7AaPzFe4kb1519YMH1EkfG6PuUi5nRj5hebvlpe8uY+Q4Lb74ZuCjDzOEOw9oOeaX9yUJ8hXADtlie4poelbIT71Hu0rL9Gy+yWcmUtyUvuEszex8pZOc1XAROEG6vHPjX3XoNX3lyZ/wFliLNHIdP7x1QcGuEMHYFb199KoNsmpHRBqXHSGMf5+D3syDCbL+chmvOM4AXnpX2tzGFuLZhg2AJFVzDi3yUslRVvalsfibsYDxYaqRP+qHXuKFAoQCWNLUU5PRZl7kbCNYmgHIVDVTDgX22Uwm9msFG3l7jNgEBSxDgwZK82xot0ImduwGFhrCJUw9cLnqvtE8dHGvHYC5L3htiB62RoIcYYp4CwAPYsWILext14emOAaZHzgL6XkjH5eD3ko4jOvKaIQh3Ex6yTK9+1SnNzp5A2Zgz5KbPN6PoZWxBiDgdL3vOfVc+mFRrCB6Drc31TbJNqLv6X3/OnSoGLhp2ibp3mUZSpxg2BtvcqFAZoXlNrzpIFx6IWP0pb2kcoItDhml/gPJMycnnZd1I9NxbW3uxuG/dxe7QdLLCyfmZn39MLdfDayhoNvjpCeXI/B4Qf7Q004cUVTIurXcdSPqPRxoKZPUj3yMfKAv0Q7lGCm4dJT72PAUfTNsUNp3JhZ6nee+f7eNnL6oSFqr/sa2911/7zSsyc3GuyyKmrHWL8h1fvcm8hZMGcWMG+KHndSLpSspCAWTQ+v9mCJ2QeVaAvwqpFTt00wdKqZHI6cex4hRUEz3Vcnq4D85cNwsKhrncqhyEhNcmXbeR0T4WmurTq0YSLB6l/dddJphlOys+0wyoZFnsVw32BLwUlZqgImArkso71hBg7DvirJ3N3uKL1H3iLzkA0xUGVR/9/u1vmN0C+A3iCP91vodsPSVubY8bKo4dq1ZwH+Yiah8YQdSDsKgTPew1GtuDMP59mwFu9TD+/VTSHULbNI2GZBM3ERBP49yazIuv1Hb51/ZTS6kb+A5Yc1teS5Dd+FN1hosdVl0aGFo3wbqq2U6LtLr59XGEPqYcsV9d67fNh9OHmuE8e+uw/JE9oZhVwx9KvLMDkJqbNTiSLw9PLKYP+/mECs0rJNS9vC2LqCGxvTPn5OMBSdIvK205KYurVFe08+nBtvNpoT7l8qmQ/qkdOGUeAf/tR6R26f80J7vTaxYI8UJjzH8P5Y9zpAxcczOxPpD8bEjtI9EUl+T8uRJF474/5wZ1TVOXX+LwjvXjKW0kOJHhYKv9ZRAZPIfdrLzNpoybNoK6lwY1l2Vq6jQwb6zPgatDrnoJMUNQGGfAuNMCFWwxVwo6k+6xXeMcMojq4P3U8ORn/4h3QmAONaUvvj75Q29zDWjKSzOEL69RhApLTdIh7ODBvgbJH0zafDjPRyvYjqFlk91PEwQDVO2mNlqt4vqn4Yo1p9EkgWzMHW5bcnXHnjlbP1vbFkZdBLNsJ5ly51PVC+xTw2rxsMk3jv1YJmiuBHoxuuVKZmQZEv2x8SacnNOGp8vGHxuDFs2koGRH/j9BtwsJ9wuJHoc6XsNVRt2qvxx5RGAftJZqoSWk2OmX7xYC8aD+EyL048IyJoa5B7kEn/kxy3U7lPXn8C5KTduLPo6T5AGpRCKXZFFwb9bAb/9BvWV8tkP1o7k4+5oSE3m3YbTyitcaNhhwb4dcvcspBzp0KrwS1oym8Vjb6Re55pdPLdMaYkhTDROa/iScZ5FyNn1S8pIKxizJ635JAv+JuVfo3/60VRj+OqeG7jX0+POq1OvrAncBjHT9p1BUIbgHKXs+s0hdNHT7YhWXBqBmAcwOhKZsBes57EZFkPTGkNjxQRLNTEKnCLf5lj2V3rpzRKtT72KsBJLZiuYCMLOOZpeHdVnYzUm1omJgbH9IWoePGiOhcFG4O35rF4cDVvrYSyBy62XO2AIpSAp3dojKRrulnlnYmQLAaU8vLg1FYxf+KBdfPjCKtWHuOiF4mlAmHbopJgQ8qAPEahjHxN+p5wP29/+mHSZlKiFhCSKyRNtDBk0zDl2YC3DO7MXnDK8Ochz45gEdR8GaxKGax4E2K7SvK6fQsZARUGPFAvciCn7XP9s5J7uvSdkj9M7JhqExqqv+qK7TckyyJFs3FhBCQX41M0m7oNIsLGnhEeaUcCjLfh4/ri30jZoMUfAr+47uUPhwsfTNvLc919wZPE8pTIbHhrEFKlf/qQFi9UqbyQ2pJcoS+McHcDlMPwUVssRPHF25KFu2dO2oIFo/2lHrnt/a77nWmJBWH6eFeiY7ihaibJigjv7rx+AX90pvKIOKBFSev+PnjARf7ci1i2NkuODFZ6h2i3q/FsPmUjppXxtHF2HMYbauoQx43fYIDyTSilpy+R/zzctf/EJ6+TrS3YbzMSSc9vRTYxXWE7zoOgulDtapbgwmS6sMD6DURwY4fUQWcJcyu0F23Wn6IfR+FYcRpx20T1Vy5VAyGdtALcV6a3OBnYN2NMWYSO7+2bGI9Fe5QI1ALL2ogZiO0+iKzrbafa+r55Wa6NCMvsFGQOQN5pqtMYMNMLad3PZnhfKzahQrtNRtRcjYPYGrTcPgEE7SK0W+8LVfCH3K3ffvcJLVfJOrxHrvIpn+j5dIuYCp0hVRaYnNLfUtKp83Ywc4v7lS0+oooLCWIB8iPs0+V+QADOZJZmwmdfyUIhdskpEcEIFOvMMraWapj4Sqg7wzKp0r4XN22caRZLgHcRr+08kEQC9S9RHt/fWXs5HIO6f2nQz8xJU1dIFr+E4p0XJioYKqEVFbiLEpDeHs2B7pLnMFwv2ymwNwEqyAOPVmhZEEDso/BP78wlztBbq62auFOM2zX7fwZsdQNWy/fNu/mYnjQY24948QtKnIpLv5eZ5LbUsUvza8RKwCNEYP+90lWT5rM4J7wzU+ldk3QAO14UfsNX+o3b1Pxoi0/1hxOS9CNOH+H/zliZQxeA0As3Iw76/cDPDszlls6hc4ghGhDoL1iRc5srERCAInoxKPEWEqWqUzhcM4yI8qKNN/6jx/ABL4uvox0Tc0ZD6Oe2eFpDVbN2Wgsfcb7X+TCb+JHobCDino754OYbs1s7rs4IX+vpQcSruKqVwsvYexqnXHrqqRLlRiopbpPdaIF8jz/qGjUfNlEwDt+CNn9uDf1nsYRbL2fnWOI4SNE9s3UZ1dbash4NIKr5g1a+v/VFTRyjZRfES3xM5dBJir6PfzDj+MWpw4YPT8PBbCq+berILliNZFljAqyBw3aCrWiVyD8ReiMu736retavsUbqEAvFxOgCj3qweADWEfA7wKRA9iAQUcdJPIHYzdLrdPjMivx+Kf4enLYVOFQz7KjeKcMi0mZ67qvWiq9NRCMQQ/3ke60vRdPq0fwNZjQiiZCv0iADkfBjzgJpPgbeq7n1p3wBuKjqmfh6GYnqnlWeKr9zG/C4bPnW5jwua1epqsptcCnojXYsn2+MsfmEotc6FKl/bSrj4OWXaeXLgRe64S/K2qTbRCxVpj5q6DUvKgQ35gWXwgn+mQPNJG6IO2grzCtv1yXvCVGsznW3JaUM9edRRSwZG+ZRziGrMamyPlAMNR8+6zsceJNc8t9Jn5a91ffAb3zKchGlESiuDhxYV3riD9ryaLVf2lzc2pBPb68TfNYnzDDgimi1rmRsolrOMBDO8Yfw1zQXs8D+hJpi+2B8TPakzOH6pryLnoTd8vTnveg2hcLSgdyemEPgvTWoNkwWBNG5yHnAMrv8+o+amk1UrSDdgemPmUZapKU+HsVq+/1DzSPmJ/aIXhln4rB+gG3lDZTyMBv0izfCxnFOJNwxIa08Lh9nWOaSvilQN838aPfAwlE+9mGXHNepvmnfRMb4kVyARy9lREooI/x3paVU04qRv0ehSEfGf7e5yFN2TJ//ECl7sq1X7o4b3IDxwkVhOkDCEPimr9+ABMsn4h6aaY1ucQFc2dvDrGJWp08oEq86wVVzBMn55FQKXcrsyne06em5wvjSnzxaMgA+fSdKQEfjwEDYD5hUyCCe8dRSaJsqYB1fDGtw+ecWqu5LQwSO0YeWUAF8gDJ4TteXJXUjzcpaGThWa/Riu9X7f+TMWtmqsyg7t7Pf/hMYtVrMSkoMOnhu9k2NHAvTxWPIGxmNiY2jQpKJ6zCwiRcD4IMjWBSwusxZfV0D4wreWDSEcvRttdu2CNXc+Jkxks6jY1u/4cH24hIw6gp1nmIsOeh7ZfBSnUk6Iqj5i6XEVVcudvWzjNq4vjNw3u9Tf8wD6f/kzUwTmChqYMOs55kY6g04n2/uH8ENxl48yt5rdRvGsP1oQ6EKqESY8uhvHphdQ8rOSPRX1vITnM3qqA6u9+LMMRGsgHyKTAb7SjTNm6g/Sc8tZIombfU5NDZKCIXfYMS5BKOgCsFfcAreTxlZ8lZqiWNLDZV8tQ1Cd2wNwI4PQjzGpWyAliR6FjXJaFAfG/X/2wUsK2EM3vdYjtOqK3iqfOREeQWt6l4Jo71MhLCiXGLL/2ksNh9E/h/OOXPtjaP8h3hD66QG1NwvEepgnHCgrP82BGE9PdBtFAlmjIBkhY2QjFjegosm3bk92o3rruTEZbuNRys1JQRo+0eCsaepQx6vFtpLmB+KMgyIA/G2CillklisqdQOVOQOTxCbFqIQfQkVGeh6CyPJu3fgmTDV5OkBNK6+EmYZaUA7aH6jticI37YzwdU0UVaWmY2ucvSEAKEtEqexyA3J68diH7cyyYU8lct4OmYKykVh23B/PszDMkU8m1VYVTmKbtomAPlWT+7F1l5xnB8EcNk0Ssi1yJPIez6YVoeE48ZvcLxtW9at6Zv5vU3GqIG1Pr/s4rUlVX2wDIzzMVQjweoud6pblQujhEzaFIV5CQqp9tDVRo6DbJNIcgKGrAMh9V4SOLO/ByzTN+SiNWyWN9SEQ7yIsnIifjkyNGzmLOEMXKz9xUdkqx538m7dLROL2h7N2uBUNF8oDVaOiPMv/7/Mko99Bxqt8EVrXojhufR9AsSCLlW6ViYqeoz+POX36DJdpLT/eUdWB8mxZwBOfv7gbtdwioAzrKEcLdK4LYbAefAjsnx8aaK98kn1rYT5kQdnepR0+sROY8tqvmeubLYyBMNPhwQQgysjgGIwIswLgto0NG63yT4FkkwP5pEIMk8M1Pb1FL7kxKN/hZVvcHzpsw6o8wn2g/W9AP4Wnk7782N59tAE6mfJtpaftAoWfKFcQNLgR4J1M4Uo0J+aDimepRXaRkT+6cLcsE1qZjBJTAqQG6MjrqH6K0snbl72lO7ZaberD2cjqY52dXcCQIU5FgozDOC5UVawuN0OhZcvpjjmUcUB1cx49UohfmdOvjEt7NJ+aUJ5o72y07W0/Q/8no8uoCvtIBkOEboRFx+TAMkhTYlFSMHyw/zM1meI/xqtpiby9qPCwDJFf3+z5CfF2bjuimGwFD03CM4r1Varw50qD9Pb67dPHCXSsVoUcjgbE2Q2GYfhWG651N0hTHINOqKTpe82KM8Mg8umeBh7xOXLgDmvW5Se+sQzGasALyy3PlvdGCoWdwb2m0+UYkMq4s1PleJ1m4cBo5hTeKh4g4qVKCtclrq3gcr4rcZggalAELHQ8/fHIiPUfVuX4h/XmLXGp6H7l3KsxGl9+XiIw8ez8WfA5sm8Sf1Wp9UzjbLrLSebtWIYDIhtToCtjniNEgBgO7GmR2khVlG8UlZJ4cbI4TtJL6MI61GjI8ZgSDty5ByiNT7hE5cAGwKS4bZKecKwsNgVx2w//9vr5/wpdM3RNZI55N6L/+Ek16fL/beeWQ1vYVHHLsLH3Y+O+9BUVnY1+qXzsvAQfvZiXU+XLqpqe2UGqiw14t2CH74O+qYHWQXLQ+OOOTwNYVfjbF7HJO0pvCQVqsK1bX3siT9nPjV18MG1TQy9ZaKpF96SUbqbJjiKXZfA4JPTV6nfnMuUfmt6OoOuzY/HC50S6C0nqANugcXTj4JkiA0onHs7xozjl8ZhIo2Xpd7uYQlr8PGiUcx+Jwl3C13a06YofrL3adwfLNcfSqhIHlLzX3SRqztQdM53pwiZeISVHCdSMkQy/qOWlh4siIvnZQCXk6spgP0Tel9tRJskId8JtHngf/GpDxEZqEkOe0H6NvcD4aPFYswlDQtTSLTS2dz9aBNDgUZDGbfClH+oT7nUIvmalj1vav6HNbZPiPslKAecGfvtmLwKfyE6bI63Uwb53mEue262G76+Wb+dkUfkXqwgh/ByVXS384Kql9ie9zLLjjJSSPu7V+TofGh/CL3V+Vj9iLwMUDtf82V4QoKrGVvjcLBtwEwyiUn3AYBQkoVn9bzyn0zRE9qVsKCzZ/GNu0bfdsXMTtyi4eDILCDSmOD53/LK/c4a9eRX7k/owgfcmUBB0WpY+cKGgdMtGVcR3qR+upSywqBOe84PvWtpvG3zvQdXZK8EFuO+eDxEEcQFJ00KtbvjoANmw9rhwyH3czdc/mS+6A+wLEMzvNKabRC9DGisU0Cbmte3jV2C0pshhD0Li1tdh91SKrtsEh/zez6RUinUc3b4kN0YM1L+NHERWUgjkX569CXmyi9i9tc5WzqT5ehBAur+Okk5HDM4nT2cBNQY1RVfdZdcC1ijZisvuCZ69XjPOLrYa4CUy0Kgz0abA+AnJd0sAd2TABjMheLgkFnPSI6p5uo8QmKvESUyCHRGsY7TGS0A5KTIF4nTH/3OdSa1Vbpze8SW2WNZR5q1iVC4FOGKPG+tRhW5Xsg03a91Ks49/DyG+LVe3cinki+UUDQT2f29KFTXCG2Ppp/Hy9oILB7HYbrKRXNPvd3abala8NclLKnN7pCGnlFMghedpjEfC/qkN+zZF7Wk+RslznHpB3wqQaNM9tILg2yEqSrj1G7flh1nvEoRPCDHk8jStqwlfYHLtJQ8Sg55SoQAhbwenqQirr5nisjCXwZ9BnD2qEaujELulUdIqrnwfhFrweHIvxqBvSwN6RM0vrIs85sr2u/mPqT1KRA2oMHqDroRphFPP9B5jXWok7vbY5HjyOLKgA+wxvVCLTKINj36Tv9w9l8M9DPU8PSz9wysonuYMK4dCWVxWW92h0ynggoJOfvZ6RCIJumKbx3XuTSnbLRBmJhGu53mDB1ST4gxlGFOZWuaN1GMpB1Hj7GyagrICI8lrGq9AlZkGDOTBhwLOTNON/h+c7DNsMBGTY+S2/CJ3Jmk6/ObA94FyOPg9s2etI17PRH6U5DnuKRIN6TKs2ZsaqTPAjSVsfYxEfTPyQJeAF2Qs/yklZuEhNi0C58bL9ZWY4bhRSv/7iKJ7N+D22YSfVV+uyaG4tSzEeXpKWALVMoqoGO1isrAjtnKtF4Lcr8ctxMEE7NfNpUyRJhl0vNZ/4lT7AqZni18gZAmgwtkRNB5RjTo+mFfZ19yzzE1Ti8El5XfzRJCB7bhGegCPbYuUe3/RM65zoXo+tC+j7zR4UTs+MEr0+jLBvAFaCMVwQ5tVIdMwRIvoOwIf4syseyscZQHlTL4Sd2CIykaal3pyMnv3ZlKiZwtY3oc0DKI8Ac1iX5Dt65kLk+Cwo8kPlriE7y0pv0O+45Rfpy4Bpgs2WR5vaY3WQrL8ay0zpZ1nms21CKtIzNv2wNYwQGQr99hRwC0CGYbzAUam3gLZgvUvQcqvohEzaurmutGwtzsvA+N+JtJxCSrRpqG+6cqHX7dVvEo394px7N+Avv1x2P5LOLrbPXof+BdWiqpehFeBjpJqBgW3vc0dzO9T7iUFV0rOmBh7rtou0oug7ffMqe+F8N/TYsBvPBP0sgErYty539SAyGu56oCBHQO5xGIX/QaqtT84QdBpFytMBbBbQUxLjAOZLABv0oDNFlrIoK6vfhHDouRNXfCSBESynaut9HMQ6WRdH0PNC3af+4kpNy/tTIfMKb15kvIXdo+m7V0pn7IV5iSuk7bOkk6NEJMiKUKjM/i+QeyFvyTLze9X7GJ+RrVE/9E6m5IEf7vNp3im1OJWsvPQJg3skK7tyfxfNYPGixS4d65IWFhVkKmkOGSzHGjobWZYbBox7j22oM4ajaZGL5HXbujASeq89ThP7iVo9V2b6PjUXRCCH836TvhJuVlahYy/Fkz0ADREHgO4tHhuIvCx3W+XK5nLqVx0PseHuuCw7rMqzRn0GU2RjLI27kE6v4MZMfUZpRJE/f1Ebyo8E8WOuBKByDtvPs83OKtx903bMonjoL0SGpeEBvkTEzZlaDbZJamiAI3qVxYqcGpkZHM77fy1+z4ymDqZFfhD5P53c+ioE2BwYgW7NPPTWxp4CfDL8VZvigaAafCkPfYpZ4tS36GsS+U1hzTQ114yjTKPR/GdHZdrHtBnpPEdXWr/uRNrHMr//73qeY9vn8pR2lZkDHi0YZmjDutLPXRqLkxUiUDbJUTIF2ehs5ZkXGm8wU2R7dQ6onQ0ugDeJQbwE8bY4bKWdF6AjUwITrBybAB6vkxeN5n1Tw29eK19AxwLNahAXphIai/gPaKUgcUzf4L4a1yS7zt2q0AWtJqw0EmNCcT1EQ3FZ7QIVdaKGiZ5p5YJ3q853T+NvCdUO4W4iGwrUBaKb8tIshfgX92Nk5j9wEW/s0S77sZrgva8foqYNnKXldHqtdnokwOWaY7Z0fuQdgZgKIOrUSHUS2+ekCM7BN0ExA7bCI8sREVFCqby6uuq4oVJPXa+tWYOG4YY0irIH8+HBrykgehHNxzgWFHVOyEcY1I5gzxgjZPSEmhUs2xHdMgVP94pr01vcNcUsAmWPh+uDVqbQwBc88PZGgWTT0QiV6hrkkErPVLjT78VO8YgNoMDRyiwrckdKUlaq7Kv2m+N7VBe/avSqEXO4OeWIZsHQrH0aPLgrq/PGRaJpwcCwmujYW2jzoZArEo3v1sMnDhjJ55zK0axOI2PZDmTpTgQkIpDX7oAgGIMdz/AC2N2Vklm1mEJQgx6/2ldLSdjqMQDBO7viRlllNoKfarLYgRGpnLTu46RWzNG7ar/fPvZ/MuTHHUEm05REcB2Nw0IrowYf5eeq7lqvBJr0ALJynHvIBJ8XZYlD1z2yGf5/GTFwTAKTS0fYr/tNHE0taYEU8CjpOA4KkOWAVMiB3dbUO6dbFYPOH5Ds9iEniPcYnZNsd451CHlRzA6x/VCYroC/ueSdRkNya6gc3rWTBMq20rLVlRrNYTiFWyUw8Wcc1qP1ELl9oFHYJmj7GMr/cGo1Ztt/kJ7045af/MQUXFEgP3Ehkkvu2uKblANvfmyMhZNW91/njmWaSiOpmGyTJVyCnABuFx4p4iBd++AkVgLcXo/w+70L5U7/PSAogtTZ097wqQr/aZmPPZJZH5ekc1O7AI3e9kPNCYNDBJZPrCj+blXgP0HzX1STvvo4p9W7hS//T4s6wE133f+USJnVsAWWUC/CigQ/bgenzm0kZ+gv0tWrPFOKADj6fPMCDQhKhU8rki54ePRrbVYCday0NeyKWTF6gtDQLclZddbTyLAVr7gZ56bjftDsNl8gSoh8ZijV4pBCVwpWi8bVMcQFXcChM3/520comB09l9FLQnKZnV/YE4jkqReAqdydWGHPuayzdKLsqD4TF1g5fonkJnXGZFkal46+OFaD1zQE2kLA4zlt42IN2p+jllDTRnKrJhfArNm6GDqVA/JjrPe2S8SufW4/FgZu5Ir6Yl0jEEQP1uK0CmposYOaRuMywQGmcVY1BmmyPtZk9/+p1rIMX0TuxPzzxZbWlCEMmJWj1gw+9If8B2lKH+tP9CnY1yQWB8o6Lsz54NTUa5izw1dDRyl57Sz5TzbGYpf3J+X8/q6SiD2wGGzhXY2yIe1INgomjuXB3G6De3UCuE4TWJ6WKcdY7UAP9b9ua93/J/XuC+CqL5Uu9MvXBwY4cgWLrmwCHpB33pHcx7TtVf7oG3Q32M7ouYMKZgMoeBzaKZccS7DeGEceMbk6lhMi0t3KVvZGPJ6m1s+1aUNk8R9XD99l3efAExNTnFZlJQB5gdqWVh14YJrLIQXp1rqKPGNj6TVf8XFQdK1gmgxVPJEzm74fz7A6lEqEjoG0PMw/DYaG7dMXdZCS9ZldHTnnb0pTBr6z2D0bqB/8OOFxKwOsYuL75JsMnFSKdNKn1+oC2aRTkd+OZ9o+YygKDH0QqfG0bW049EjmIuRZth+MpCyeyNY5DJrtw8CYhWBgyOO2qmuvOh/5gDgWTghmVUAIMMhJv3GQEkaTMhCSasNVgh+fcZGP/AlIQVAz9r1tgHlfe9uoIrwtPOg4+yxs503D/WVtNcteR+BcE7VmqtXQoA8UtaJ8PUQH+aU5e35gudumGZUS2yfmp6/tra4wdB4v4zRym/J20yEZrZnss5fHnFwSelF6+Ya7P4qYLgDHS6PVh4hZPt3uD7XToiAoy0CD2qkUz1KzbtagvBh7aiqBo7Ong8nLnIDBaOrEUDABXNvsxcWOkCGIQP7c4C8zBtq8kUjy3BiBSE7Vk5fIwhpeF05eGsuXk0v+S9HlHu4JVPSXHd/lmNR9SsocGYIcSWh2hSyxIM+XYoqUtFMTDo5uLzVUXJa+7LME0+CuUfm365x8gxHq4n+RinoYSvR8NXyexlDYLO6ZIvwVbZloXbegsLLD/uubHTM5soWqWbweT6oUDM/lhHdWZSi0DlyuVY5L3KiFNCoNXSrBD+uj3fqyXPcE14bSXEdTMZklLRacApCPMAfOR2wVMsC1HAKxj8OGIaKZ/Q8pnm316A6IN0nn4eXk7lBgD1cQ82NDFOQUywzc2ag9Cr60pV0x5BXp4ttJcZPqa/JmDVomeeD4yoZcbQbGc/162xEi213gfPL2H5+KV+iyJafDQUSHopefvy8eloYldXuMWcMgmswBjwRab95YBu1aJvh9h1EA7Fi150C4fQkt0xkiypE6qsXqe5V2ZV4JCWMd1kFJ0s5ZB3idkegIHzHE4IuavDdxnJ+kiKBoqCQ+J8y0DNKEs8z4354+uVPMtIMQR026H+S8AaHZeeU4SXHxh3xEDiMW93p72gxGTLPse+2jV/0Dc02g8m5X+/qVuLngT14LO2MWkzjmZzTeWgDtLtyEpMrqfCDV4cFcRxtw2MRHOTQRj/K76OYYgZAm0WjXm2dbaVQNS1GX2FGMFaG7bP5wzyArNKmzQVF1xtL6X6XAOSi7R127Oue8W9jDVpl38SFMZUd6MtHIGZzlaKPiuRrxpuzk32Pa4I0m/13ZdYMSn/3FbbSi3D0hCeIYMENgUbZH6N6ZvSL6sNF8DvWNTuaLIIRNTUGv2HNWXrwJQiinvHCL361TfvBJnlk2tVtTNax50+bYCbfMaSWRhnqgEgvPSWCMzkAbp8O7IlzOKqqMTPgQZjpNmxKic2EwTd2/+Kh80fY2bs5mqy4VmxfUidoOJ9yuYZlDTHps69lwMb7fYnE5lvH9lpfeI+tFp33QXlSOXQVHZLH3aJ+ZrMw0MdUr56pC75ZTAca+rJcbCzOdZYKnuhpPf1sxGZsBwfTvmjEMgnKouowaAV5aPoRbHAYk6WNoM7pMSBiGd+nsSWdPKYDGLmWiVEvbNvgTtcFeEjW/boWMfieR2fCGldtR+yocAUBbKGEkWgmeyEIBp+Eo1eVrNryhA3LqTQMt32oexWtsT9bLSmJ1f9T8qPzPgvluGy+p9Do1PO1qPNuVW9q3o05s2IHsB0lUMLIvyLp6bh/s+Ig2KqgJI17RzwW8O7qcsZuYo0pOYnO0hqpzB3CCFTBU1BA34QHLw7+apz20ubrd4ZrslOMonWRQO/rcyCCwa4Tu3BdUfLDXMZCTYiXQJdMTCwPgr1Cen8V1OuW3tIcZCF9lrtenZc8FN3169CICy6MmnHv7nNgYl1yU5X0sifBZWYKy/71PvywgvSt4jgfgKTd0SMrgjS/hUW6cAL3tgVgXZaMEl2iWms23yTjLETQqq5++JboUuH5imEys8d3FRq+uQXA1cygRIQ74bU11IyParVOlWk3+15CUe17n7Chh3dpAW5sLxYMuQAvZiadvoNdmXF/9zmyIVNRWi/JH1WcqQ2Y8UW1dHt5Ge3ji5vfOG+jWQBWMRjkxmjt6d1B6nnlfBvNvxIZEb9NDUrTPq47nk3Udr9yNTkqok4JUCRLUi7FylYJa0JGvVNrtG+/Mm0jL6XpKlImJhkBA30k1aLUJXmKQXnJ66F3rsENODRZj/6JMBHuTCznA40k98aeVkTVLZRLKpwTr1CFCPFLCAMvuen1jiF47FsZUNvnjs/7pmhLgAPFcqP4akMOv0px6cSm87PLu50p62Krmc0+mItCGF2Afs4US30DThqv1IQZHn6yQAAXTMRfn7+GrNpEnHwEDDvmxQMDpWCbrCkA4mJmcC+OxYCW2GIsRAhcyoEzaxDZ3zjl5rnCwb3HErlUoPWLkvYMcJlnNltzlY+tuE0iS8w26+asY9flftmUJ6FaNWbcsGBloX9ccVb/cYSmnVJLf0uZ5AkYF5Gof8GF/BIk0Vf6dyMAv/6TkjKM9ET3hhy5lj2X7SPuf24ONx/ha0F8N4dU8JBTYCZm3C8AkxCmvUWYlq93AxcUdZ4qOgmNaCBwTTt8dvzFls9Dh/1OHg6jxwo7D0TuV/sr0R6Ad65Aslyem67k5tm17QqRENaf8uBJ/nCveWMlEOe+aE0fsDIRpp8/cgnbbaDLRlJat6VPbnnbrY9IaKHkAHj8aE5P14NjE6sLucyQJOVD9LJY0yNykbsLv2f/KVEHm+GOCDNVv+oRdv7A3MpqgqYKxCYaqpOhqRlSpInFoALAoYRE5CdvW3GYhgE4uZUBeBqATOeJnRX66fGECru8cFhT7zAOkQcXcL0Oqp9ZsxcM5jeAMrfS7Z0g5HZuJp/VFKa6nIMK2XOI6EL4Ens6jJbD4HAYuW5uIYb7u0w0I2UZHEyxQtqsnGHO4ABmAXL/jYZu5hFvcvBxJPb/6WBbzi5Gn6oIr0bprNUoK4x72wPyqP5Gxpdl+i5+jTDBOakUTojX4rwTTSONLugtND74A0p/2T/1yxQuaqFiJ5CKtBFXGulbWR7gtWOpgDbBoh/5aJK/Ps5HEJ27d0Z9SEwnM/mYdX1j+5eXkxeBJ1B0jMSHx7sfuRUokOoKH5/beFszbkOAIpbIQ9aTSdwLT5Xwh2UK9hqvmyolbpAcske7DfDm9OtgaNdVLBpSY7lg/JJGs0HIVpbPBj7DDUmRwspXhLRBiSYpe4j1MGXaLyPV7uR641l45uyxLAnuFNrN8LnXjxJt2loLUJvpLzuB53Yxnvx+wvfHEEa1NCn2r9r48qscMTyN3aO+u18i1Y3FtY80ALXzXC2jyqsXwmALC9tL4qaH6u9ge/Hy/72XoAWnE3Z5x3RNmMfbBmAlE257ILHZ+koFjxJdnMo0eYvFO5qttijuGf4AV8542ZOUI14cHe0MOAwWNQPDhp3yDxQ8FwzrvhCsdTryx7gycTQjZRYM09Oxf35gR02tshSiME1XUeWxwkOyqMmnT25UTpLF8brul+6KUbcfsbZ7zKhFRAZqUo/hgaeVvwugNahnfbkXQudMJFgaWDrnVP4KghMoGnXMN+FpWMY/iHcbZ9eAHoY5AqGhZAXEKY/tuShqZ5uuJdPkpzb7GVw77BmL+EPW8yHQE5FTMQuq/b0SdLOHaxgpVWIPr6vKr2dFq0UpGDHxqUPXG860YyhKW8gRtZMOH4SXDDdctGoJkCkxDXMRianqOkIRP73dgz0UiE1f8dhZPoSj1q+uTpvDFHytVvVi1JpqTvOYVxNuvHpRBiEO1Sn9ORWa59cRKNLlOh7m/13UiQm/KHR3T3MvU/u8DAgrOd/3AKTZJ7w5Hb0D8UtHpu3vmRI26AfYUrNmulGdn3XBaotFAZazocqdBNV4LX7g7rPlYogVZP/LVRdkWBKX6wvFyaK4AQjwwHhr5tSdsgg2ltu+/NKDiA2eU/za+mYe/ih2ZuXceGqaOIX5dxPeyUYJuUiVgnroRakcm0utgIWKlH8YKClx1kEUtTWfONb+m+PcLHZUJiGGABRHAlGL57EitIKnPvIGzj+mQlE/YXGVKbMYSBeYm7cdBJz8mSg8JPxzdvD7p+DyAlxi+YPBR851XKGE/WL7+H5dKPdWW6fyrhgjw+gmEkMeXO+KBrwVyt/+FsjKoFfQ05gfvGeAtV7G0z08/lp3tWdLai1g14zenV5o5RAIfRMXfLl8/sUGVS53iPH64xi+l8ShSndaH9CZ4vqSyARjNPVNrjLFn7kbJsxr7WNaTDGKAeSf1Ztem/uO5xdpRvAvNMQenLD5+n4lvNGJGQbvhY0qJG54U8g1ytxyPrydWJmUYwfs1155pTxDzzZouumMTShtKJ66zczUQ0Bdy9gu1FxgTUo7Iv5wS2Tpy6MWIM9TTej3Rw7NYT71BQDGA+7JAuWshUT/hkCAMBgP1YmS2EHZIkHyzpB7cUTO2CkNYAjfsA5Bxxlp6tJm7aM1Irfdb+R4ZMvlfWlXDUzPm2vq/xHSamZ+ufyLNdmJOlUfBoE5ZiIdS6Xk/c9JcJzoNL695frIS4CKxIZOO9Y1c3IVBRXC/h7r894dAddKkSP05KzvGrmcGeMnqWUi4lpfYdgKFyzKIfyvW0zwKcpd5pUZl2JErFvNnLgczjjI8w6kDV5FzeWUQjnQgkjAGfuvPvKA6YKDmqkmH29bVOk2p/US/QM1oQDXzo736zEHdEba6OwQb1KsmKngjJTyzaHz84X8g3kzGuNOTeD0/APoJuGm0MovwSwrRRWOjkv3qLQfP5k0LUBMeGJXDCHa+28qQybWsvj6AOZOpFxIYB8QOaMs75dvbqTQMuEy46FeM7G9F9O6SFwW7CwVy3pH5P5qwuAIikGUENQWL2x85K8dULntQQr0XHeu2loe30t1sqAfsHqftoFnCNOOLf2S+3tnFlRmmVBh0Bw2XYfPqL7LoTlcgf2UUq31tJ4+s1CqDYOOEXO59OhFf6eKy4feOJ2nUj/Va7kjfGLmEKJg8djwCpg2PjJvi6nkO4n1aY5W2OX3yX/YSnEXfKpgNP5TEacnVH1jv+HhLdpzoXpBKOA2V8+dPKfwvmrpz5FOmrdEWaOMUSV1kbMLXdR+j6Nv/bQB066+S3nB+otyjMFY/cfJSvbGgjrxw/09JsryFUEynm7NXJl5lPjO45gviCFKDYrOaZYEh/Z18ngtRu8ssTkYUQFQk07eYUw57FxoQ7X9Uidvi7bw2n63NILpw/oQPuYRpniG6cjxPH7bpUALkGzAS04GLIFg7w5I5sQFo6p7H3b86EKKRYIO97kivM8orL9VnHNTE3B9w4aTQRD+drWCW406VOFG+WE64YucX2YXrPvzpenxCLiSdvoHNQaZ0Q05DSuUvwhlSkwIGJpNbfOaO4IpJ2Ai5oaRdcP5AyIrcDDBOfHnj8x7Ih5D2Uc/jR7Bntnkno3MLF8fmy+xso/cL6VfLQa957XpV4fs0QuBVBxLrF7qvax+u81ql/zftBBItGD+4hPoj19oSqhw0gXpgqnmr6rNwVgFjpYKfUkkMd/B3vCuymj30YUuWtELRuRBmnW7MSP5iFqOU6Dlh3NlkJrZC1qK3cbTKFY5JrhfpzI1foeKWEsv73HXxe/UI47uLv091uW3h+xUurszZXzb9P1kVy0rT0Avx4NO3ry80jqwo2h1icADKZ3DUjDNWa3szx+lNUgynqae8JsfEW5oeqN19IMA3xzy51BJVhqJOrXA05niDINnKs4QI9Uk0tWioGE6iUlHUVxmNO2GF65Kr3R8y5fWzR/5lcmZLxPzAhzrIRP1tYu6ZK+51VqrxyfJcPSp86oDLHgqmWzu1MmPxo5zp6Y5xOo4Df5cGQFpVvE+FjBjGJjmlPRXkbCxUQN3zs/ioEy2k9aXMr2wq18B4XW88t+2cM18f/aO+kYjjnR6oeFq8VHXYXUu4pE5+G8FyQ1XWlaYbbJVQPFMrvSpCG3LCulYQRYWitC12IB+2mA4cVgVDvtr8ptLxMot5S9plKJoghsqS2JtWUJFwmg7G+dc2kP2WrgthJDeteHPEzveMISkCdLj2DAcDLK1djksXnfpZIw23ttNdWCRTv3IAmqGfIdq8LnP+dwM7+STGg+I40H41kUn/GH/pC3QiNzAZHOEY3MkO9MGQ3ivi4GCZe9UB3uC4dv5NOb+fF26OKMldIoVXxeH9nEdZT7yuFyK1zstUjK0CiBMI7WvqQBd/iOujf0wqke5zUHt4nfvGbCnNUHB7Y8mCw8bgXuNM6Z1xb7s+4U3fs1yLiVprPKwWsMf2IgZrBiJzqK+ogKhHuD0H9JAXZntGbzkx/gEVrhP9Vx5LMikUyXSDTSGfycOZlvh6C/qpImkQyAIFkZY6DlJIEuCtjGD+IH0i4+FVIPqdbloAQ4MduDSKnaazFbVdyzGb4nFJiMtB5fBOWUObsMRi95NXBs7MrZIc4b21+EWlrEKnuI6EC+VWwIDK/QYE6JupQYzg5xYr7LxeeakMsYWv8sQtmqYvM4Ll1DTP3WHEwAT8XbC6R5cUNd7HzsCFOZUZ4ohwh+kXU1k8IGpcxKgj41PAX7fRn6MvWWQNXW33nCIX6FjBKAbE5mQUXN1IkCAAHnZ0OPgZrerTquLIpDXIvj+Ln2tDVQ2bqfxRVqxlgG2Xhm0SxQrArCBcmr1KvMuOVY0paZlDje6csT4BJeACS7Fz0/QAhChEoMmxwcInAhYG7+ZVmJbp8JN8D8TVnGT0ktx66FNOyLzlvPNSiV6udDfatu+wiUzgqO1w113raf1j9+9qzBMxKWwAap0mnWPtv8EKD8GMRqGAlkbRKxB1P4Wl9uvC8O/uYPS5XwytacdjTs4Uvxgb7ZjiApu6NZm4RzLC/x64xn7gip0j2loJ4X/pDo2H/ikV9DHbhL/y1+MHNjEj268C9u/DjSD60xrDg/b6vzvC1fxt7iYdM610Kx9bKUDdNeMigwGSPf3Tw85ebaB6VS+GLpRn5Eq+tY1REatQBQsq6WW8YYdZBzZ2KUXXWdMk+IBhTDiH2ea5DkpVL2TdS0cQVbXOJZ2Qvr2YbCPo2O+edj45jzQwByAveJM+RRaIIUXMF8oUO53S8X6N+u2zlAlMCURP55isuheNWSeLKZzq4qGUv/GDN8lpNR4E7Jmyms14ssJ4Z2ELttdf9Iyzcm99hmMC8zqGWPp793TyXSmlKdgA2WYZAydUhKCrDSBR7OQAkx7oaej+4/4nH8EFqwvtAA5QzWKlnjMMVpLcpyojBcxexyT4L9QZEnCnkGAJZNlmy+xuM3BQfUWXNXE1VB2GPNfSqvWMBpTXD9RJBgX/UvmVoAT3a5jBhZg0WD617/IwpjomZ5gecpzPGeaIg7jeFXvdlZa+EFVROKb3VyDBfeUcrAMUD6lY9wXSeYbM/G9Hgs/UTD6Z12DXO8yeG55CwtZq4lxjpgMO6q6TVbB2RNR2UN4x1PYcxwKlRHtJFP0AJwuEuE9lP7n/BDwYf0gLusiTZiPPX2ZsduqkfZDUxSgOnMAz6i6Z7YthP+tzk+gILwRyhk2usYDY3LPB32bhQggHmkVqng+nsoPpRhXLVkWHOAMTzpsyvyJnGdvGAboUktqwqt0VSFgxnvPSP58v8tkJVyp/IYnwsgFTHMoc817J6JQSdXZOoLJZ01Uh1lcZ+SwiQJ+XEKul5A/l5yb8tx8P2lbSLbmbGEdv4F6vigybCeXfDE3y94qjCbupuQtIjqBO86gR2j9d233m/WL4LEOD/fK5nY9NORJzL53IymvgbNa9L+ryK2qsE+OtL/Qhw/zu7NdFAusXKzOW7Z3mNPGH52jLP2xgVlqqSSKvB+O+xjo+FumG+yGzisocyAQKBJiSwCO6laizS3BcP3iWgqyh1REA4JL6LUF1DA5ejSZDEgNATMz5Kj783SJHCJ/Q41jkednRkejTPxvicdqnICtf2K17wfl2ZVQUYzPwgfOUpSuwrEjmdl/CnLQnRo+ywjjq4BuB5Rm57p2pHUfm04949PN8EBm1BkLTlBr9mMIRBmQMk3CazvNuyjnNH0gGsE75wRwb2i5GL1i7bNbe4SBAT+ztXHJEu83py6ZeN5VyYJ43LYh+M+Iy+yterUw8v3l0qNL5zSAldqaytxkZR/LEEnLaNL1kSBg8o2IEzrt45IDsYxRJ0CBH5W3i5WnQPbLxIDjv+m+ZThie0WvsCIf+xaeywDSTkfCNy1VYrQdfgPI9YnRw5e0VWCPTLGEB+Mm+t+ASl+MIjznV6M+RIkDq2Tl4nacu/D+pHhxgemUPjXiM8Fj9G7lo5M4+0nRjAUL66Mn5q9Gpgi7LDbMrfgdt1grO+TQieOONMhujrkRtXPV7vMTYyrCpaFW9sCIteAmatQOVBCuufEaQs5wcOam84Ydf6qX4SG/MxfEhepGb4VpT3BSni1ZQbj45GvJLFVxlQMMSBEvYnxfQRPSCrM2RBehrV34CFvj2R0w36m/hnfQ2XSoiwwzpgfoe4oPZ/Ui/pV0STmIwRGaYBtsdNGhuiZrZe2Z6PWUwlmx0toGtRpgrhwCfJv2Fw4Sp2nKgFKsN/rLvd0W4PCAgzQl2hIfES8eSLkHb8NuH2l/RAMGlFdZmdDJDpkXCIBbSGGBaCTAOJIVFIr6fZjKEYNpWAVLTyzAWrIxZP552E+uWvmCXfFqPB/HFObq89MkPT1QzTm0q79+Zd68bSB+dosHt7PHLbhltt+QLUoI582HKAirvcFVluW1vKovVMj1J1f+2+Sh+Kr1HP76wopbOkPoRc84qOApHkWgXBUt+nE8hEThS7uXZRfJdfpg6GQJR1yujNyO8ZqCLNHycpo71K3om18SQTZg+bdUyTGeNi0/XuH46lPfFRtJdWLZvEephBRs3P1jS8Jv1mj3FYcj3yErnRmi905WXV7SEza65WsxA8DlXXPFzEsLzmZqc94byFTBf9FgZ5/yWFDOSk/jv0zB0vHXCiCUSeGF+W28Tddil1bRzPTOE83bQzWfKGSO2NU3NE3JQel2TW5s3hmUUI2HJxEjB3LQsLuamDIvv/O94BFHEVl4TxoQfBtxL/iNTD20UfeKCykzoHcjzeWH/jLKXo7TZWQbIWPBLEHOwnHq4PiVRzff7i90AD2i28DZseiKWLTrDkiaOaytMFlj+iwpGlGNEow3saKd2QyGs5ODGTIkLpOr20pOhwyFvxdlazcsDIdjBcNEer2+dvyVaVQE1GUQp6uhwk9F+VPkE1u7ceo9dlRoWkaBdH12ggUrRkuZDOYRL26Nkc0+DmHU6DxXVbxHbl3W5puNDX3YOiSzJeBN1aXrU5qo/zAPaDiLfUzjIxAkHItT5Ghz402XSNBVDrwT3f4zBqB8jl4LB8s+ZxAqBAvSk1yBe4snA9fD20NSfnXZsssfFc7owSd+TNXbNLNg3CNtQ8lsk0Me73+zyZwolW6ikslhsOji7GJa9Wu8hL4v67e7fX70UwpifEvlBUA5fHbg8K+9vFckutBsSAkhwsCCaHwN78GPaTPnNslr9YrMp8jRzYc3u2xLB7Vi3t+uu6Cphl+A5y7ZML5lN6QohjcGjorvg8nxRCHeYjp9VuTa7EPriZe2yQ6nFILJo7SrIaDJxujEB7EudsYefNA/+hhfBEqUqp8/QvOH1QdKHlcRrtuxh92+OkLqOJ6gDYIRxU+RfkmYVb+LWfmt8glcGyFYI2O0HTB2y7JMRRu1yi/xZhZLGcgj0JH90KBNdu9lX3P/K2FBXkrCNcbXLKw/z3thLu+jQ4iofA/d+zFZzM5qrve89qBIN1ecABomne9QNTQ99xzCozAzzG4YfJnjQXAsmRlD6yWi17XHDOz8TncNVLJX+NG8oueRakE7u4BcybmLo1pqEOSukGxAR2XEMJ8zIa1b1gSdQbV6dxTE3T3w/3j0jOcFAwhNQgNppw1qUqOdGcymDJCWXg4YNMW6A/rt8Jyy/J4k2e5P4LbclOk3LOhUDpoBLiDw+m7HmOwJSSzLpxJCfNBZaJYODwphkV9GX7l9iGm9HjJKQAAzO0//d/67USYgJ+CPl7j+FMfgD5MSRqya5OWt72onC5r+eG1fgWxqBvUCBUx2J3M/Cf/t2AlwkpRgfCtJiGC4nVDjZxgfB1C2HyYemDjcIHE3V6lz1/3ISvFpcMetYbz9zr4FpSZnidTMV1v1syFg/vPQoquI4D6m9e4GBru5jBzIrBpgQ040ysnkS8519hHA2f8a6ieHWRM6gYEXkM5CYS1b5Jm6vnQ62FkvDDx3s0DBy8Til5GyNXcwKAVIcD4lfIpyCOy4Y2oCKS3KufWecQLepi9uunGpz0Snqdm4ag9JE+8pLR4VUWsKYpdvUyJGWSlLQGKLQRLeDyaWDuu4MXVYPprBZiHo9zGxKqz9fdlyEXPpHv0dZDCFjcnmYlKs+iMupz9bFoHVy45W8Xj9LBQ/YV9w0u/Y41PIeJVHz4Fwr1r9AL6uMcHO4/EzdyOBfXE5b9s8ke5ubadSJ9USI+bt1BbMLvN12rf3IQ32QfrJfPEVixQ1LbrbJRPDw8EEAGORPq3VJpXsiY6UJJ369GKrV/u2OeRc17ji1tAJmxZkpxoCsPKeP1/MxkRgNSmjX1YGo/p9F8cJAu5myqh1tKcZ5UvA2VOPAE+PIRmieKEij0S/PAuXzVKeILAgGLPUf+S4Ddn/UVhqdmtMAN1tbL4ewFNdAfaV0aLcI54IsUaZgxWwYdKb+YbSvPCgNLFn6j8pxhjxcfm74XQRC8XQ7nG+JZh1dokxts4D3pigZjDr6vKyAiVKMtU6ArWTYHCJZn+hDgrlv4thxvXgd4Q8wn1tFcKnhXp+0SGKwN6qrZuhAAdNSt3LZShhvDSwcWf6Qw8ZmaKeMY7J7MCJ4cZh6ohuCORkUTPAJhq0u+4gGlT9+1Tp4kGp7gVSk7A9RnrXXhmeY7U7ywcwpfIkbqMiZ8ebOGNzeF6+0J47NaPX7qqF6sYZaP4XtSiubxD9/yIKa5lUK+arm/ykJGuEeHtl4N45h3CMDClF5rloZWpKGkoLUk20GXPyzU4Ih5NHCP+oDkZ7xjIj60drVcM1eAlnLXrCLXGs5rj/Qs6UcC1BBKIApcG8mIdfmVev/dXHYNoL90ZUeDA6yVIU6DeMXQNz6FdXbWGeMybxwP/5yFYEYaQ2VAbg3zUn/AcCBUHuLCgbjIHSDK6pul8eLSeltgscctG8YpVpHj1AzUPDZTE8vsc4B6+BI+HD0fmBBw5RSdltctXocdkyiW8Qc74IMFHGVPGMs38qzsshZW7UJ0segvfgEHxT/Zz5fwAMx2pY8BIbDb7Sewtjs25ykUH6W5khbGCKJG6MuhK9K+0fcjsCaNxJCEOKjUNFIqH22dCrye0J5GQc55QmnVJVW7WA8k16kiY1UGchoFMMxPXRMGB3rhjZVtuNBhUwlceZBoVmLTvch7Fnna1PZSfonS7PdtMiAw6LLwRFjynwHiA5FlCVB+bOXMhNPEkfD7v7ODFQ+1Kb9ndieB8Keac24Nnb7Pyzyj8SFTJb8iPWGSxcw90gmulJm2Bkg4l2RDs+7GEaJ8Yql3SX8YXn7oC2QysETHldu/7D1N3Vsu/cuR9Z1F7fxa15FQ3kR7RIdJu14ppU1LXaoq6TwdSxx69T8m33SlLtuvL8wap6nCExe9009yuDGsifhJwZthvmTa/BKySfVeRLzbX3LwFWidVaqusTOhh+oUaRrSERqF9fY9ERjBXzoGwUgfvfHc/Exnli71gb/CaKrbm1rD77LCoCwaXdPb1kC6HMl0xU/buorjwTnA/ULEV6/zn1DnP3TMAuCTIagkGo6w5bn7/8A9quHDi+3qeTBXV3A4fZo9j5ZcTeNMoObvn0QfpqeHavJko2ACYX9TckzBIPg/CuZygBS/O1k/elVQ7J0BwWVQ9CQ9THFY2TJoM3tdbyYkC3EaaWm95kW5nenXfJKp5x06DriVFzV5FO2xEoHkq1p+4BVM6T16Cd/T27vnUpaubR4d4QOcGDBXj/I1EIayeTc0aDA/A+1fK2z5RwHD5YXJMS5/tlTAusZ71QodGVvGIdzvTDnafaZ2l+rDJdlpSVkB8ew9AxAYX7lE32p44QLWJBhp80YHt/8jiygWZAFI+u7aWmxZojIH1BseUcFkrqXlujMLW5Vqz/b8mjcmHmDUJ/0nWhSxje8eiN29mopczqlJwetfzW9dHMKqsw3AfPG1Ed6xuCeGQfCofjROnhIsVFDzJhpGsaM2AQpIRCuEvJtweJEbHqJjuRPWwSIfS04GZ442m5fRsDDVk3y8kLr3rIZL5eMy2GReSAQiT9BjsErJ3Fx2mTxHyuXMRpF1ScaOh+721Wdhlo65WTNNd+jxayizuR3YggN8x5tUtcSTaK3QOnuoyqtxy/3GF5gDK73/RMLRFhBu3KDGpIIlxgG7eSS6ymsszeN42wHsSbVUo9Eom9rcYKqfqGnzQ1Gsds6O1PvRc2RfkIrG5IPueSTJ65wnDjHo0vzZnfQFE5YfEUx3+qgehE2a4PQ0yoCRnaXUUM8Xqj123zJ9/9SSDL3kgXe9O5aYXHLrw9IWdvphm9NjWoIcbF/GWe+EtpN/Hckhf0FGdkOAsHGs0iNwZP6CYzVZH3wJfSxHgLHLOPcTNieS6mlzv6b/5fPN7OzSSHtNtqqpk5SlxIZYMFtC3gjjq8H1g59YjyPEIMpm1bcMs93vpTNSrEM0dDXFw+aeVTF+86iRv7E+W520xw+TLiY7Gmh6TmogrPhU1IuOIkR2UWxziCRls065BI7jPUlvZw1LihBkX7hERohl5Ped3Gjo9hD9j6HeKCUmVilwMISn8SGekhIRrEYyo+oLbGH+WRxV0+MHlE1tL5T51LH8r6bW27nu9ydA847ZHoeyVihDn/lPHjVGOQ02YSm1rh6TyLXH8VZXYQZO0EFmGnY87q3NMfMpK1PoyOsTvJhrEPhHzZ469VZMDtGxaFAJZE42LlUowegoKkJPk7mjebomCY6wcqES7po6wmFJ9wvwRBjZhrk23XMVkZiO1ta/nwvjApmeP1FPjYTT6VAigK4/zPVclOiHszOELetK2gtcscv7t7YfObrdw6bGqvdQPT9adRCOZUCTiutRfUh1JUcUPUrE3AIoW7AjUSq1k/7iTjZGYLBqtootZrd/sBVtybJOJT2DIiOt/2xhrTTcdxVGzV0az7OM1ott7IF4Px0dkHkxEhgxa+ztHtQq6BMV4yBMuVT2nnfhXqbbqJD6qpBcru7KKcBwhxsbn71Mnl8fx6xaeZFag3S8XrB0fa1vJN+ZmbnMWNl5VndBIMYtFoRq/IFdtztqo1+1tCw6jS52ykMR2m2SMOI3e1AWOqBesDFJFfKSYUB9BoCaRz0l7PlO1RCMXFgv0uWDNMCrU4g2JfRMuTjFGj1Y7vn6tlp5u3a5Lqy4nB5IQ00oyPIz3fdiGtPeAi3OUjTqTi12SZ3M/C+EDkadknnbmTXvxvcfBy0EYAeZPrLMSrSdo/+lU33//fDa0i3Q6NKwuv+1wb+BvuOwUKV0fu57lsOKuVTNVp+7HuhuQjHinrU+MQhWs9jUsEUKcuauIo58tgcsiI29R4tx1KCk7Qn4imMZvkQlQBcuFgsoyqpDCg8GQIgGDFBuIGuevGQxSaHfAYXN3xRJkaWN7mzNapjet+0VFKTsMzHsTaM0Syi8tKtgRAyFuQGCKkcQ7xlCszng+AWreCkoBS4T5+zyMPcAYvHtWawCY4DPKtyCsPetv0a58OtFe8eFfUj/nL+bBnMKQjMhf8k5WD9xSAwOm7D594IHUezUpCQPoJUTzZxN9qh3eNvMGybRxwq22kmzQ6MlSajQfOgmutP/9x59TiTcQmlmZOW5crJ6kxEFsaAvbxjqepiWO2cSA/4+Dl8won9AXHPXNuVzbuI3iu4iaaJTyOyUQlVmqrvwoG1Fh8wl0mQucausOinKtj8xYltPkyjVUO6wEoWvMzliItpRNzjV0uZVusdfA44VFg0l4BVuQgdigAHnb2rE0vHwaY2zRVPQukgLTI9NfK/f7WYrYw/c6uFWYLBPGtxq+whjUV0PNxdNk5AhgRdguR3GNP81IKUyYYjYma7JfpBkHHVbaUVUOKUE11UK+U1UVgodi9fpkXeWN0bcgBBtxkRmuYNFQ49I+r8mrGoEb4GdMRvXhkhHHIFdx4QfQwhcK+3MPS5gciML6FNC2LN6ETORjqcigW3rnMXhRt09MUr47MB37izaiGtNkbed6AN23NseulFiwr+bvtq07ltJdJpghQb9vqvxbD3JdCu86A9lv6jju5yF2OOJzGs5LCQQBgGr9eQk9jFvicKvBuSxQERzGFd4cBiFE/bkiVOccdxGl6TqRcYSdz0a4izfPB6urZwHL6+pn8T4eK6NhYvDw3K8BCZBjGR8HO9uwudZLrOdWNp2qjq89kLTa+5nTUUcEGdqHRYNJaztqMKrWH+9W1EplzFEsktC18e10lcGwZysfBOiFwrdpRsmqKraEP+rzlMbCREReh+XrYqgiE8hZkFkluQggrPamygu5ZBWOMRszVAYC2BiS+MsOF4MME/3jSt9a/FD61865DQl7oJLXAfDkoiBUpnxGfdQRaH0M1x08i8oEvRYjLd7zqUK9zZI3mHGKSPuDg98g6MocU6GzCufAje0RlJVlJREacLhK9lIVsbOc6Q7Ec9frB5wXa5Zx3e/SxLcLhuLJv8oQKtpDamVwabGU5QiojnI4TAwBI6DiG+XqsLR830DXNB+PZQ9Ph3P30fucVxH7Pg9/MexQXMu9kuF6/H3CCEuNfMy8BxT6o1bU/cEWL7sRAW6lHxwznrEIU36Xyjn4k0tuymNVjgQTtmpJQfSHp0YNwhUBrb1bk9WKncisc0Hd8/N8qFDuKb44zeDdfQxgc0kd0qw5h56mMIxJgw/QiMNXCwikpRY/ubd9eyF57pogCsWU+THrCrRh/VrSVrST2SiZSYODpN37QPWCaVrMqut4frZ7G5NNqCB4zGQsctrVVvJgbnhGEhuLPLhBoBiJ85aEscLz+VbNoEQrEv1uwwpgZ2pemveMoDVWIESt5lqYryJJCYVPAo4sQj/WUxlfDEfuzK0yXI4gTYnsqL2HpvenBG1PI/6M8hxjJOyvUfuqj1vf5WraM+N4D9d8H2zFptak7bxesLZLi+ASe43OGTBMQULkKdlldha11seTWzayzAEbSbt8GGHJznerCgYbxH7oRF/TmgNbqJ39nHo2jtwCdyr0/G2AqeBFaBB8YLclT8xRFUAsCfRFcB+eBFUUYVLKrAS0ZhIbo/PUDI9t/SiYAirx/YUI8a3a/Ep/udq7XBo90qALW/6e8xVNBm5s28sT1x0qKpmH2dOm26Yg+QnU19xyJrnPheUJzmCPNRB1cWTeQz4ZwRfOFZpLjb/OH1Lj083hgGpnooz5oJol25qHXCsSWJHMch+Ok0rh7ojVaZO6oEuzGgzZ9UbCDLG1mNXBbTIb0Dfxk037mpJADJzq5cBx4BmqwkyXsHVdMwnk17bS8GnZR5DxBt+5gG3wMe3CsZHz/pXEczDpwZ7Ejt4iNfqKMsOacQNHgLqqIbOQeUTm6eJbPFLIU7M1uAlz/R6T9/63tVodw1WehvJxs4RCrgbAR6nLP+m0rwTam9nW+GtBBvFZvC7QkUp3EGYVMX8BzW8APkI0AH/ehlSU3zp2UVuLdJ71ikPMtsbsXY6G5maax7TUJmS6XhLe3hy4Odu6Llf/GH2hmTHAWKYnj9TQnws+0BjigxZUzNPIeHUDW4bsAgy6sxI2PGThBmNW7WpbHuOMljou7un5wZf/QvoQR/TiLG9Nosvg1AC2XTbsyzrTiea2xU9l02igvIo9rEsVlR5tuTh97i6S+D/6TB2chbK9iJhprLQ7achnaHSN9YHDt3CpHNRkYPzHVI/P3UebBpYbAqOOLAM7o40VWdQFiJZdBjXpQeArt9BGrzBKpCGgn3lGOJW7oh2DJ5UQmCQgQVFFf6oxScllOmFLhzKHsrhJOZaspTa0F1iVDVXe6hQUmbz4cTWW60YfchzlQYDSyqXjwQ5eTU6LpZSbKJl8OmZfxfycCOdrkV9TKVMW3vkFF/cKMho380unGPXfiTDQQEHgtkQhT0G9vKcsbzq13ubLO6nSIR78gPTlLzkcL8s+Ajpl1R3EJOQhUIEtF+pvEq6/pR1daqNxqsOG9otrYkdLuYqfb/9sKhMEf5GPjGbpdvlFiJdGXKEXUsgPWaoNaxdZ1DLj3Y2K/XMpyPQE++W62yYB2xxQNDUZFXsjm34u/pImArbAAzbN3A1MhAiq2cN1dAZsf3drvFIPoktJ2hys8iL06st6B1yf+qjomRGDhwLUBTb1kJEfBdpUWXGVbsUQaXJfj5HI+evYC9E4EUxZXJpXRtgRV8kQHKtEy1FtgvixC68SVxGo4vaBxT3OcCs1daX3CNU1zD+u4KiDzAeGbGMR+s+PJh7VczCzwxX2L5ZbXwDEaLWb0+Y5RNyVZLzMI2Wjy5lRo/6yvj8L0N1wU5vXj65QDNbUB/kWqUHqJ66jL7ovthAkduBteVfxf1tHlXdNIcm19SdpcrZrkuXrolj/2c1cg3S3gNJCHnP4LQcC49huao9TMJcPALp4DRZu5c3rm0ZzfNo9Wo71Au1AwnBJdvy0B+oDjQs4aKiZYixumdpjtKnfJYOgyHlmPaHht0at5XauPdTyv0hE3zp2VNPuGmpUXabiH16+12v7WzWd9VZ1NYmev1SOzkPHOJxBZnwDPO4svY927lSLs1U5vOu35xso2fEww04eJxYYxLds+9PRDt/p26I9iGLSf4P0BzaciK5VaIKxfjwpZ14ozUoBeAvlIGLedMQgbw6Fozlbhs6/TMs7I7yyqmmJssmxa24YX3MaJrT0mxMaTtxETDpQs7EU9xcnGrRrFLlYDeYGVTvhDV7+ge6oSkMNY2ECDZreG2hZobW4C9QwRbhTwBZqKpDAM+IV9teUeAB/ePmA1yOOpQrd+3Whioo/XMRpQis65LwfW5Ik/xViwUjsa4L861xG4C7ww0ULccGLFFj2J3ljoaEEvyOHN7PvYTS3KCcJZaPfEWz+I4jp5KBu3QYlQlAmI2GnxfMw/q1lIKSr9RnHYXjF5Hw4IB20yb/nCvN0TPo/aybto29E6chGP7Y77xHpSIx3X8w9hdcoc3x/cesagdGsN8W2eVUVnLVgCpKmOIEVCqutRc0ZylMroxZMYOwd7siIxy0RAiSmDzoTf+WNOXjBxOG/R+RJ3nAVCS+0KYhKNZCfaVVwCD3U28nt8AtACgoaWgxhN7l6Vm75EY9JrYFVcNwNIphb2tU7QBjj1Fn8VKbIs/c5wQGa2VbpiG14Bc5s7o6G4QrP1WbrjNawXP3pcHX2In61+FP//4BA6Tv/Ur6KsuRC9EptW75LBnROJlOYAZ4yEW2CmiDMDJb+UhdWOfG66WHZEAoaGWWekE1ycF/grzC31ABTxL8ozpWknHVZc9ufmdE0O/zguFUM2Q3o0WuCsAnlxmRf5Mbd+PelFD8vozU/WxsjfpJDPmbjaKIhTQF0sj7muf5iIFQXKeqo2torveXgOAq5W31cdanSxuguQd3fEsDtizAHCTRncOJpm0PEJIZdekuF+k46q02uZ6GlsMwzZ4P78oIU2MxozoiJL0KOimmkMwGa7O31f++rEtChT08eeGX6yF1s3NesmErelvEc6bnpBjXf/hMjjwSW6trw3KZ1zEpXc2ejpl3Wy2viSsiAY6DwmDyGlfYfZtw7c3kCj6O1QMadRwIpoy3pSERSlATjymCqVFa3jD46i+4/MBM5eIvuzKZ1Ih2fPcuvYMVBjf2+VTdxk16/VlHYMQin2b6eXGVx/NHVau0kPGUxr5rXgwjQhndQelEpxLxbGUA72X/xI6PpM/5g51UaGaiMzZqrme4Q0rqkGvWKE2gLtb5KzgLv1uDVa+yOqDxPgC3yLE1OUMdCT7hPPL+cDkpsjGW4SOu9DOtERjXjAERQAMjsIDuK2xjDGVkZXEOkSv4ysDcJRn5kPWFuakmZ6RQHSSV2Lgirge9gO1OmldBQyVLNVIdfn8cGk4eYLxh10Dl1AHjHUR2VYsY9fLFaKPxbi5qpUNgW/5xGswJNHN2/lAegbIwklyOH+i2Hy69ntlmbuWPoj4Z2cVa+fMd6sSeKNBN6HBEpMZClM2g0K4y50v0o0/YOByy1h7Kg0VJiJcYaXfdel4AGaObzDToWT+JZ1mRJtwrrupJCE5LMDm+7PCLQH2MZzk5X5rDuiYCFgBBnbD62BGBBsOYWaat8iJs2ITEeQGtcitzV7bhfTSk1LGTMdB4kbGecUp8QtkjSVJbEUVepmX/6acGunC5CD/8oVkj2DzryiEjd1mjHu/B90PZfzDcGlPC4YytKgAaNjN3WvCTUJSsB4281GTx5+SI8UfAGTvIZbUoWuxFIdfUavEM1sIZW3aqJkcKLc4+Zw6iIeUhg5TIUTFfJp3I8f+iakVCQR/CSjPHcOMw8fMN006RGS8xx5VA8B5PrsvTe/jLvVFjCJZFYz8IlQsPnRES0t9NwclnvIn+DsVu4gLeT2Rk2qPqD0nNp3rAjyuxe2B9R5477V1LvHifBwj+VeB4FV5ofUbQlPuYsAQHQPVt16zIE5qMCJgyTcudUDW21ddqdI8q8NmnPDVoh8Ru5k52lBdVpSnfTi67J13flPk8WaPwsqbv5G3cOU972aVSLAYuig7+efwLnJVwrVSixrgi3xdydI6pjPHG7fZ+GNCuYHh3u01L1nZOO10l8bFUzRQCBGZt1IS2X3IxCmcimnE97TZsqgI/3+xGeu0/8qgExZeK86ocfbVgqPMvwSQWD1W0SCUCgE2agiN1qM2kZ6RBUVnpo8Z26dHueQgNnYJobxTkWUE0bE9wd2duU9uEU9j31WttkihcJVrsOy2XrehAvEvr0gucdF9MsPIMyyhCNTSw68x1hPu/TGRWIaBc2KgOkOPkjrF/vLVUuUEOa1LRRQGgRvf6ydKf59iQkaqFZlYvlJ3Wmc8gVofUdPQ9T+biqroBdfWWwSev6oZYExblkNZAbPKH0w0zK3+fZCvQ+HlNpgxRw9s3nVJS7XQgASYRLk0Vxsgw320ZeZ/vmPBPNi559BMhxSCaNGE87+HvMdz/8nIKL84S40maumfmvgDZbXoXD/5hq56tvhh4Bx0gjFjDBz2JYAe4W6w8/9wG5/ZEj9Lk5LE5+R+0BIJgGn82rPMrGRd+5NW7dYJodnOCln761Q2AwLr/QqZ2ZM5TUra6Ov128DLhklrnd7U993GlhFi3KQlU7OTJSGCrG8Nm8iQJihg29aAyRS1euzcF6+/LyXx9zmFbw4HlYE0Zuq+cVbjSV9mlyJEaKMHOHN7Q2iOQX/fXBBy5KObx+jjpcsBUxja91xk3u/aQMJm4D52IJP83bMEoWa5SgbPYsHG+doWKN+1O302r1zgSo682y484ZudKqNpmgQPq3zNJ4vemEHLt0JLxH1pqhNboj0Y1CKoeaw9225rCX4t2kXbv1EPOy2TgS2a7aTrT9aZZLevnwQ9XCbt3k/YjbSrZN/xV2fmD6+jbAuEszN9ecwdrP07OH5K/FX560XQAzWj5Sldvli8cyOKk+28BmFyuwlP1m7ganv8+lBqwb71jADTVBqFIbtfcCz3Woh/psDYNslnex6g4fwyqJ1hrFjLz+4bhRWt3Jf2pbC80C4v5dBIUTjUFViXus/4BmA0OdEhWNFlmWmQGwfncWVoEW2ztMBlo55wiqlVNJSbJNAvdUegdt3VajaBl0UlSrxe4+2Giwmb/2n/m/INCtJnuXyiuHt6IhfUpOijTyNpupGOvq26HvBxgIgQ6MxCzNHbDpLErEgU4UhQg2eIdxR6VTiSQ6pUW3R3EAtNkFtf2Dp1uTfy6Z0S6GVIyuSLjU9EWhFAakn5BSk+QVTv6mEf+5hAX80YwQHVX5MGllDP81aae0e0W7gYAUW6vQa5sLjdrWFtfaAb/zZwJNYH+h9HgNVMlBvSbn43ifPkE4qWhzEboxahaLGGDgbMpIPKgrMj0hWPXtycUK4qxL/h3lFqBYo0Uqv00Bwzc06SGB+zoYSCxFXv6acaAYujF15SyqOfEadtxNxhlvlfusJX+ylg+231XGqBvIDCNayT59QUhtCi9HGl34aWxMdxKKKVaBeNteTTLheFfwlQQq0nxmWhvnEN1kFP58q0iA9pDvmpOrz9OyfD9U95Hx0P+4APDxxQEofCY01fiPMwS3515Iz3FbCRfgX5BVWdaeQpyfkmAzju/N9caBi5TJ/K1BO4DSkl/wVeyFfs2kv/s1bRqh74ICke6/I8eHTqsdy5rCRzM3WNhMBf2YDgaDNLWZwUm4/aWRGOROhN3idZF9pTDcZf3h8OoAgRy4Mo0Tyh5pNm4cPqV/DC4lbxq3Jf/hDFqA/tlog3EHkEuS1Mobw1bUzWPcQQ32TvUOSqgbKMXOR31FKRG/S6Zyn24dFu2O3fxXMifmRJ6QwO1tFCikS5xhBKnroX0IoweUSJ5dR9b5P/VFNgBUAgulOC5y4LU/btEE0E/n6hStwp2bEiMaoejrCxfxcKsu5c9As7rDJ069CTt/Xh/0A4pgMR32KLQawM5G72AhVJp01cxXzRc3LH8sldqN9tOOOnWGrIXBj4FQXHxFWgjzNunSzya/SYTWlcbdH+U2RkMyoJzALnW22xkSIUKrhaOsEsq7YYYjVnYfMb016+Uys50fEuXSy0J2q5EitRjQM/amWeij4uIF1VfVBgvb79UF94J2IR4c/q+XZ9A9FaHVF4LrfDxh83Hf2TSlVW37H3bUs00HespR/yAmrZrmOslT6ti+rVMr3pTnpqUYUcYS0FZ67Cge3KvqXZIKsvq3OK+2nG2tKb+zbZXUDuP6rWpuNAwDicDL1xWm1OT1dfp0ca2bstv3XKKm/cijTJy2UUANE0F2X6wj1t10NOftStt56L+z+/IjIlhPrWd1DAZjFmJtxc+oSw0+8uqUAEPNzAiEbCsH7/95MdvqqEJUa2vE9gjbgDMA8stkMiMslHQlnzoS3MH0urvtPd20yf2z1hzayFrfur/xMWtdz4mF75IEod5nEhHT3KE0aC2sQ72mo10ZURUaaSo1U9ohTpDHoLpLdDMP1gmon4xHSCBp53ZhZ8g0+HXwWCnPVchqOPFbie0hF8R0lOtt8G41zDY5RHSa3hEDwUrI6O9SyssGn10LqUm3/8vIk824R9/H0iN5QZnlqQEZFsPhGOp5I4/EVBpiMa4pKDC4nHHmXfAI6EyCsdbKrgbdGTZH3vftPCwYoTzgON99bGLYDs+0JlE05t88SYuOSttyCzB+DsHGqsfDNhddw4GaAQBs6mDbLO8ayGt7bY19TPaBIZxyK1u7gBdxdRtHt8r8y1EVs2T2mn348JA1b146IcPd3QIlj/1VZUtoWdj9UtFT8/sVWAgY7mHsuwzOTYUipPytphqv0B7+bp6GqYilTbsg1XBAkHcduWEQ7QpKGk6Mk6sbtv3wts0DcuGg5jGnV30CqSmKLbgHOowSnSahgie84J6e3LsQRE+/WPgEKiWrv5r9qwrH+VDTO2Yfej4DvOE7CzbpVjDdb8fduNANM+38Nn7gnubMGZYCJB/MKk72eTZ8pJZCX0oP4+x2d70YYX0LelTlUq2jMBI39F1wC2k/OiZBWazfh8X4rArXtCSlS7QZpfwRqzjR1EN5wY4itMk5FgqOR8ynGerwTVfeh9uYUA6Xx1pJav2ZIPt1dhaSDO5l8G4B+51gMqirmxFB/XjXI1Qk6lUVCtRxRTMyXHyfhxO7yqlsGw1/IEYeWyHMQE4FfBIUr8uJeNYIDyaO1iVdb4Is2OdUOnbEUkyZfNrMn5Nqx+NalVe2lugka0oWqGXN/ZT9QBKhlN4emAh8cm3HpVJj/820iejVojt7FLMd0cAmI9nP4yVINOUVgUy51JIgxTYrB4kWbi1SwVy6ajml1h5sAmC1YwdQjO4yO0xa1YuGbJ+EkB5QvUEdCZE1tdS7/H6k1aQ8pQ9HfaXlz7MkF2rjc1TB7WGle8pjUAOIQMl/hM8Pdb40QDruebOaZds3tcizuY0Ap7MVssqfrxJVMW4QIvbttOcd5aKB3zgdfbVm/GzelESFKinaZDPyca2a6Jab6KthcOUIn6/N2IW61qVXzdsRqmGw0U0tPlZ4ApS7V/OGoHO8VqYxT6iG/NNpSzesMo1cw209hbdz/bjTXqiEBnRE2jFhcTW2sRql112fdt/gFhaYdY+0ou0qv6MVMhaQlO3StdEKf7w6ZYTmf63HlQdlOtQ+aAUyWVqEz6PGiYA8G/Cc1gZNYwPSdhWUzijKmb0Lbyl4TUAcpcn1O+1lZu9Fgi94ehnjevZ+KWIg70zkBnnzUYVIXOQOv2M6gaGq1TsE3D3NIVKqG1mkIsQTPap7E8N+Yj5rUn1GfnkMfPMoJvsiI4kcPN3xWEGAReEzo41BMsJcv9LJAKwqbnXPz+/xKaIl7wmHodX6+k7Xy446BVScor+6nK3TJaLQ0rRFDOKSF57d56Xn+yPyBlPLJf8tlZU/46XXjNu+FuGS7LSjZWsRj0AUHz9PNNIFR1QIr4CT2KypaEFwyE+BoxMcgY+4IV4RUCOuvGONjf6xVUivCE1fkuluj/SGl2j3GPZolgC0ldDPy+/JNafF5RBi8bof6uFJv2c06+HOdCbNpqcLuK47Uh42j6N270hbIspUivOlFcZfJ40Jry9OEXEX14SS+jK+P1HLb95rrQARJkJ2xkG0h+6EqaarRE5wAL93e/lBv8MWtyRNeQ1coDIUsLxPDCWqkjoCLGctJdD/ldb9iePfAjmfpoKOWE/Lvi3YTwTfg5PWVoykbTkVQ/52WHsVfQXGeV6aCWEJrxU1hkl3eHnExzpbVBTXLRVSWaHovc334Q/e/LsoU+mfOhpuwV1Be4K0kc/SC59IXO4buOP+gm1bZ4LM1OHDi0GVDlDflJNrGRpYBkv88BfOlxg0g8Wh9x7G9LqWIAtqqP2himj8bybGf+guRoCii/PreMbL+ac/IEFVJpWAHBXHfHbsGKUUpYa+9ll5CgOQr+zq/poSfSXSB/mokdcbpoNcScJWwNJqB82mKYMF4M6GDEhdgGAubSOWCfl2/X7M6Xhn8Y/1sqjjoKig43/vE6wjHRXkpFO6wkojLAU0HwQQQY7C7fd7n3dJMcXjaaZerYu25pA2ZQMp546pjQCvxApkDaNNcuWEQRyQxlw+IyFXav9enJBR+0TFrLXmJ0xYOK/KZLWl6j5VQ445QfIrxzsXRS+uu1uUGEyX+LbkXL1OxXMIvvTwkeL1EQikM4JqdALWO5MCsa2+RlxLTAD8EYsE+GrEwvemj+iRIZs6qeFYtXAazETDJrEYmuz9qM93Rmx/B4Hgcn9IHYMWR+RoqU03bWQyJwWhM4/o6gSgu2Fi5mh5HrwwnUzF09e1VG+5bWSwWk8dr0YKuwIhL0YxMlZwrLXV7wMOxM84mTaFbVTNhT6byyikhJg4erZb/3Z9OX6N9nFYcRUA37HR4GdpU5eVT9G/5fDPccIfe+n7YqASf132xx+Eka7jywMmXf03n/fcXQVuZIeqPzDl9SAh5GIlQHB9LeciwXJo8uvq6zSJQB96HsT2I+gSo7bbiKVzcTS0n7YsHEvYPkSXb0/ZoAx0XsTf2kv5YVH1eCazd2QpiGMWnTulNpTIlTrVR2L8e0cI+iO/ElxUjP0cA8e5/a0nw/TvZ1oBCxq5ItT/rS8Y0Ix+LX1M69AMFxzUkIpReQrYiGJOJDpS9yw3VrmFAy+WY+9EsT7qeToLYXdRtDisBfg5t+QUUnxk9RZ502bLDQAnz3RjkgHAv1u8wSoM2xMrPUr0paRmCl6WuVC4Q28xRuhMlC1xeJ2UdNAf0NX7+dKrpq0UcNgUG87368dzeO5yK9Ro+2/9/7Ze/7ZMsW0v1kf8wx/bHMNVIuma0wZpuY7RND5TT2X1gli3Kafj3MMsxMUPHFPFTcMSCIYNIcqHX8+CsAAFJRsrVm2voui0SRz76xsgad57eeUh1Vw9PhKJGqu1xjgMR+6JCloziTznOuA8H9eORajCYrPfsJrepSLPwy4OR/L/D/doP9cb1to0/aMDPsrorANcUPWPjttyX5jRhrQenAb0ZNPSVM19FAsyv03OqKHTK79HwnuJwygI74NIMeUERhkBRAnjut8syz/CRJCLEdzbwpP4boYngWcWgvtRM+rUUuACSFl1CqZm7mnxpIQV+wPyaF/vPhDhYNgCEt0BLMyjF/thPsK9S8KjMr3u+/rW8eqmHIMhCnlSbX3X/8jUisEf+f7GIF8UJe0V31B2deyoYhndpo1BS4iyyOGwzk6+6vNkZIi8VqSWKCIooY4th6JH7eVkKFXEC/9+Hb/C/NqRA2U2bR4lsUaTuSTA4VoVtTHoDaV6ZIlfrE5205hevkzSSt0FRK1TZQcYSDfUERCOajM+A7xQBoq/xLnZQTOOuwLJbYkwrypaQZflJITi7XIX/8XCOAZ4Vh2AeWAFDWm/CCBuTY7sUSAdbmw0nNGkTd33oO0nP6ZIWqWUXkS/2sS3FLFVPNELXnP99VpQvFDqfE115J1coH8bFoV8BpksiChJyEF2yL1eMVPyOfLXu2pQks5zMMj1BtpuPIt4Np4AuCSKciftiJ3o20jJY8l+uJPpUFrg4VgxK0EQYb1+zwKzw0mr5KOGoj6ib2zhhRaMQZMtF2GFo6NxNZbR+Z+cPcAXO6YWvY5GDsxybivSN2GVrK4OdrVdMi9Fn8GC+FIFmesFnRVrpF4wGYtN4PP28TLQxw+OFolMU4ko1SHW2PdKFx8rZHHrz1zXlgAkzRX+vjeiph2oK9pq1bmZCYkAo5m+LLFZFAdyaqC9BmAbnhTpKKUHulXA9k5bOdKZlA8JiXiUfcL0DSmhKPws+YvLhlE+4dmRe8afwD3SBpu50EwzkS93AbrvxBz7/K5pJsmD/Wemy0bKlHZZLk9otTkQFqSmYtEeV2wi3Tsly/Dnn1Njm7KBcmGy4MkIi5GcFLOsuJAQqMTmudJjIUWYcHxoboeDysDcFwHnTqHDHJ2Rff9SC7njOQ1fTo/uziZO9j8xIsn2OZLMQ75MoovogINqDsVfqd4m+YbrVPZohfq3O0vAHxjuM0V4KqmQNEAlGeXGosGv6AUQh3St1Ueb+c2LnBy2+oZl3tGzVfbDDEC/pRx9F2KOjyICfZ/SuBcyzC1eBWj1lejRr03UBlg9IL+7qgvkEKTfQp1fvZ8uDmd3eeo0eEBV/FnUt/3BCcqcw2j2Y/V8zEIl5sAxJxGamVFhaIlUy4vuhU4ZApEclVEbqH5A/cPmWAA5aYuiP8YrBqB5mk2ZwPxOT+H+5Or60GvgR7F/nqYoFqQeN0uLSQgK6v8YJM41F7GN8uqPJK0JqQba2qyRS/tNJzR3vZ2a81DESQR2YYx8Pa0IVXF45aT6Cw5JZ/R6ewlIm56cwrxh76wnGFQjxvR+e5wD/mQ/D0WFt2b/5DLxxam4UX1iPQO4Ki/yy0uwo//LzpvgZskaY0m3lQmteawqGmx5hghuo38F+ZE3z9faxmaRT3n3vBb5wPAFBo5iAjM0d9vplPapBbGDlnSAwi9zVvjHdRaBliVEh6D7vZMWb7Ez/NVsaLzV0wrvn0Z03EMBFwuYEhHA+D8fpqqmUzojIKY1gOoDU80C+WzBcaknLlzZU7iD1Ea4llzMMfyUYkpBExJ8YH+4cZzqsOrFy9uBfwsoMLUYWDjxCasLZtFkBZh+S1MIIzJ5ctId58tu/c4+Qll+VvlikTiMJeZJSPwVg9kul2xyS9CaMU5uYyzJP/V/d31ww2aQ2y9FfUJ725XE3gRn3Yn3HWUljAtd+HOJQdD3ZhexzpUHt04goz0VtV1VUI6YIEpjhpFhb33vBwtTVAtB2lGeJviRwN0qL/XMS2q5mQDwpUHGsgRLSfT51Jlsr6Vh8QA+q0QFljx2c01+eVJ8qCvtGP7XIIwYBBsoYkB27HCqejgWLgsTXQ5ffy1261rdSH4/EX3vP3vRT6swq1ioEyWhJTgIb0jShv7uoYHDrUoPSb4QJXDp+7XTVEusd0dZBwJr7csyEY7sWzK7OXqqADiGasYOq7z7DlwpNFuJJXrY9q1XmawLF7mxE51/Kp7xv3f5SLttVNtPsp6ZwbJVDiBXTieq4sLKzVNP6eyryAC/IcmA5HPvu1JdFniTidDeNXCyczCqGaDDHfoje8/ZMUAzyibmligRqD/EKOhuUY6tb4c7Tl0e6696rgLLxxRwyHJtXi8yvT0fhCuCm+gI6Xv6GgznoxZliIjoUaNS7hbDAaQyti9Bv4hCroGxHt70GSj6E4DdsTkXEpzclS8rekQim6FRKieYIO/4XnNI3SXb4ii6W7eGAT4oOFttjIh8KaHEGjaFh7FwJvzzE5Tpv4D/8Af4e+Aoo5v3T4izKf+MmHDXYQOYLBfYE/q8gqESgPYUbf82ckyaAuD+4LtU1RjepZsLQffgzLhEEnM7rehQ9O5iHZLjRIJ97ZDKdAw3tGsuw1OAsVHUbZ9vq+SrHiMhG+PQ0WrFBkYynrGZG7up1dyRn2bEUCuaVpWvej428k1UIJ0YEzk+4JFewP1f3WPdi4j8rbnrN1hFFVit9pPOQIND05/PiZqKwcU7Ux5ELYaf8WLhuMuSc9hxM4TFgJOIBElYYNsl1sbcx7B79y+dmjF8AaKfR+/zLAy1yQL4Jw8zKmk0MW5L6ZeplK/9vU4cnF/q93uYXjahYa3KoUa6gPdymM4xVax9LYR2zDk+Ll/X9u/adimz/mUYkRT4GhdFtifGRhcRCu1UHumzKANnH87yYAk/0LyEHhrNb8oGtUn9u2hQhEotGeHaPgttz8uGfKWcbK0RuvbU5pKT42guRLoQD5E3u3RtNOwyVVBFfIlk4RGiuGPSunGJwvlB64lkZpD3+vOkw2CcCnKoaWQUvCiECh9s7cxIA+nvwh0fBFRe7YPTpNhQmec1h2yI3JyZdMIn84AgjvtRF8iNqD/Q3oQh1WywrM8X/T9HKbogxFOYLEN8DF/jt30J0IKoMQM6sfIa6ji4Janwuk4wbMYqSrInyxNWd81dT1NzQ4D0NHQn1nX3CWOj3My4pNqhUddZCgpflCZNYj2st67KZx82nXIBKmdezx5aueu6052m5IEKpZ2brhiXo5csPQJa2OhEmPXa59n8lGK90TKgSYeVx64A1iv11n2peY11amLlchzp8U12Rl5rvJvL46G/o1/IT0/4Yb9zotBlAdxne0olXADEZfpnxL8BGxAkBc05+stzOTf7Y99iqnW64by3Dq+cYvcjNjkVKtNymvgj91jqfI4I+4xO/EP6/ZeA0pDzjVtDaMl1TaT0GzhiPXKz7gC0iG3UrgUQJ+h+sNhrRCm7kvarpGqAjQijBM5zu90AkQpb76SNjBRGIBfhaF7TzQYiRCEE/RMCwfJNg+a5y1M+IFi99HXKBby/Z26YTdv//fat/BwV6HjgNUxhSJ2cIgVlJbxy+sYeApiR22GG2HKbt916yOkzB//eLwIanljBCR8TDEI2fGvi82A19P8rfQGoqv1Siv5mZeRgeH0FAV4K4mCwjxE6zybo/AkzpwklhL3qqnGOC+49fAejqc+v5BjOj62wfpDKSvOq3i8QMVgI0m6O5rSym4NMa7aR24v6ov95vGVOWgPbFDYUMolzUGg3R/I86WOIlqUH3k6I3rWVRvAx326510lM/heK26SKE/FYc8moPRMOb3t1SDxjW3zOxiepB08y51X9Ksn/lBAMBevRi0y0p3Zn9C72RCDf9x7IP4RHJJO8s6241wI1eHW0Cq/xWec0WmBut7DwaOL8PG3MjfAVzMFLbd9eJjo2+PJyVB4lV0bZhbQkN7+7Xidjrwxe9+ahpzdwSEMzBRi7k4owY403Iwi5N4syAvurYl9o45ojW1RnwCpWEUxBm47q/YLwtLNrD+jyq5ShvSStsVgxFeFqBMwki7vcX12ng4ik+T4O2aSTz3h1mOSy6GXm+y4IewpeZyWDX/49Q/t8vFx3yWnuvqpCKGW5r9JMaJPOg521q8aEhfy0uPllnLo/6U+UwTzklbLsUk8tLPgWB6GxxGvRPnHysRKhzZNMPujdNJL2Xc2FyOKk/DqHEVs1zOOc10faZsmff82H1C/SJmNc8KTCki+Iv3MD1HDu3+a5b6neU706PztDGwO7DyaddjXbHJfnQG5FYfqijSeP1UnxoQxB7M0TomRVKp4Jds2+II2a79BYymRkPXyWJMdtYfWNcvHyb1FZXNrf0Nn39E2IR4fzZHxnnNimBkqTwLx6VsUML5B4MLfC6qU5D4oPV1iSP/6ia32hWv2OOewkaIlVX4xm3WO2dGi5aw0nf3tl4lOtEaAOsdQ1HTdCvgNljHcCQsAaX756i/6GO5oa/QitWg4PNPEW15hGxzV/7iMT9KUGGphUZYdTQL2bZoTLDiIkzGikt4iflW35UnS88i+aUWxT2gypTwk3g1fizxoNRhcqOxNBB9icu+I375Tgf1MwNbbpjIKdNiV9JOCKL/kinpSVPrjmqGnG8wpBgig/MD5eCQBcLMvwaLZ8d9juK0SVdBmKfJIX4uE1VzxJWz4VADDlL2JRyjS0V8VH3G7ecUbniSoU9LMU33887Uf9OTr46egwEwJ7dmP+SwU8TvvBCAjPGfXfA25bxZ1li51NLdS9eNqlXRLwLsK3xysS19JBEk8tEkCpzjuAZm3CJztZkH5hEiKU3UXJ8jLgot2ZvUPcIGoQKI0yXdE2wBrfMGj8mHEZN0K4SDknZT9lgkoJ77QZAb+LNCWINmYI1FrHbMMSIXhUdWgjugViz+nMB1qGebOJ2YV3nGjcAjG60WRdKaIxl1oIclyjS57yybnSPA6JN5JWcpOZrYv4CDMjE9GU6anZBcT48ChxNK0vgFri/IcuVHT9n2mkrNhSR2vEMZrBaZjwEh7FqYqLq8BsoDOf1uVHKLfrY+K9dpu3gGBUfMm+CYoRU1gRnEtpfBIYFu6bVTCHofuEZ2mg6DJ8bD/o965fWGjuqQNEg+bXzTnXhDnvyheBBP94uCZ0gasipVq6gSPx0GqvrCr1vrgpl9lmHI0asxM5sPFL+kPBXUPOsFDh3SoXZc2d/igCYdSRdFgPEHJeeceDG5vQHjsh1GXKO4ln63QF+23UqcvYRU53A5+Tw1kDzOq0VZmVah8ANNWJf/TDd7YVYL1IwU9jHttOC9/xJQtHtKW84l21U9yAxcNBa5ek4JXX8nehEnS//prNeRVwzK+OPe7R6pak+7niOgZ5kgd+VsX6CYdk56z0LcIwXJ4YCxquiq5XjrvDNkXEZYnKYbAc6Rk1yxlM0zD8hEJssUQs9qmhNReRNx/dslwZwJTFyB3hNO4oYhcOhLUn2G0QdGlIbT4r9vpRbWdwMkertYfn/Nd1U249tlL5aVXE+DrgQ7PLSqRsIA1PXnF3u5rF6+IuUQMZuTNj8e7T1ivj5BxXQSZC2GveQGUU2bNo1ZYXsntRqisRYzbQyiDMeoRmRNqH+3EdNhnSSmzkVtkjOT2Tc+lpSgKkWaelU0Ej3DttWcVoSdIZowF3V49P5p/6JTMifRKXY1c7TvITEPo7892JOt2YynvYeYgrMWjWDkLxsSzxgBgOu7U26qLSbT+0hvnUNRHwmsP7N/sVALmE+2MT0IcrGaYUYPyXZVnajL3HY+CM97hSXFYywehYq8XtSzErw0TQiCiHJxzY92ufd5LlvQgF8KH0pB5m9Jo9tctS7GxX3//gkPWlARzPSvA+3ZdF1VxWyEJoWTgdBseV1nX7mzS5b3reCyvdWoaAE0VyiGMLqlWVN6NckFi0eAFUJAxPye0NXXCG6xE5WRTIhSnKNJyd48h0kPDUV8Uf8qoZwnB+UBYmb8Ncqor/TEwvUzUDljxGUMA6zZyMEYGjDZZ8tOyEX7M94zVBDz9jilPGKiM16QNwGy9jnAiUJP9YnmAIRrmrBIy6LH4UMB4del4T3zSOnxfOdYEUT+0mtvC5Sd+9ahzdfqPsOmKWXaIHzAi1M3gXMsu74XQNAVDqB3H6Ga/dNVwtvdShWdhnN8aBfyHjRc0mo0br9PQwdO3QJLA+sVVdvFG8O/RWpl54gke+85BKLSyB4/zux7oTjcdcs1cor48mAy+sffP+vX5kpE5BsOg3CRU1DGKW4f3jsXsTIS18OOE+ft1wCyu81wa6ooNAbwvD4HwgKOYr1T91XmnKL72tItPvZzETnZNiXHCZPVXlbjtyq02xswG7ofJ5+3sOJoKw4XPMmGD9AqJ7z9ldqlcNEMYY220VaK6OdTT212/rQ8P6ylTq951gYF9oXNreLDIfLWAWahNkDdhi2PzGSEyAXTD9O4G7eQc4BJjaiaNk4fqZHM6AMi0xKS0r0Xs8YTwiQDynZFCN5nVegTKjZmPXatKAP9MqItUcmuhe6kjq5rg0L5uFQZ5v33EBB+V1cFsBJFuMurN70/5Z2evEHA8JHgV7jcwHvWawWElSdyegoDROFnc7DlekLOSYZMGBq0XdyUDUYNjhoAAdBiOkPO/z+kJdRKprDuCBadWahPrZ9QhivbaHzAMsTwFR8VmwSQsqRYsBPZH3ei9r97taZk8WgdUH2wKcueKsUDgFBLLXVu35bnXUwrbPGaRAOui5rVlb/yxNOQ8rELi8SIbCflvyqRJfn+xZaQjpAq60e5UuPp/ScVHQjnUsEAcrIAUsVJ05BnKvWJyqELSvXh6FbCu3Tw/Ts9WGTrlZu+Nu7NDIHnvFxrzB3ooZLOcm+EM5IG93a5M9n9uvBBiLxGUENnFkT8YRngyr85P0DpUoJs1DnDCzsiZRYxQQBkFvxbQqbhDQY7crrpQ2xI2zjHn8EOWaZcHt9CyzeoXXJ7DA3kzSl7ymtpk2Oj2suzVmsHFiYgwclMPaYD+/HTZuEKRrDvKvZgbAs3K2asa1QrBrESRur6HbKl2RrLj3TruyOk9oW2lazhJVO4tFmuNwPV56EzEBRus0VT4meTrq1U9WwEtNGKW3ucc4goks3BqqapQxpuIy/ZTH12ak70hzTrfmSgmq0xtfTV/DWimUpP3QAR3lGLTu8QhNlufYAUJ1pQdiLJrFAQdk0qVI1wTmQ1ZGxWn/6s4NcnAUo+XS1sjTf4S8PyU/ooEvMrNlSd7TEH8elEodyvmpK3j5E/mHZfmrU18sFlhtXHtW4bB1u96WhhqeAuhIDvEhA6l1ga7NR/mcTJS2UOQ7zbOrL+GF3GvZOEarkNYRgc1W/RdA32nbCo4lRdts40VhlrhT8m8+YRfnIXkIBSMZ6qT/hMoMcKHUbY9STeO4kt/DB7d1wGE20zokQVHokNlbgimVdwdEB+pqvNcCfz4cp3JZ0iM0A/DjQzLufxwOK49KmAgZtgkXUUjS7LiI9O1w2AWhUF5MdmNfcz1WYP4pIkC83nfRHLG7OSneClne60bC3vYHW86lGPXTjY78r7SqKLYof1O5HXoLxE5OySBLgbrn94yilDAcMazQKUvGXbY6Z9yA/h+31VwEmSaMQpw3Wq4UILNoSCJDj7u8FXlFC83ZcqAHt2ABZCttQX/2KiWqVXQzwaHZ6JpvTYMvyP7jJOfeeevqB9+e/GvDdB1R/o3qjuYerWMKqRRXUJSnCRLpdeO2V6X+5JumNpN+yE5wR4AVxeYK+22E0Ib7AFfnsS3RDTTjbHRgA7bp5Kip+fkHsqOKFePDYTOZF7ENMsTe/yL4bpdXzoTamSEeWEIp5R7sXGWgignzWJV870/Kix43bGODqjvdRbNkxiojbtsJO8OuU7FYGoPcNon4jEVVOU2y8Np6KG2hFcLBf628LQZ5lAMhNA0MZATNfNBq/wpki9AFZqj/AnY/GsTP1InKRVfH+oxsqgbgYyBOTKg5Te7SAe2osEnupRZc5Zm088vUPHtNdq3XWXYiQk489jiU9/X4h5L5ZzOhNbKfmCwWjgVrzSSYC54FKz03hksxCiUGqYO46VFqfsqVNbkBLOIDEd9cqk5/5BTt+ifYEPXPI47Z/xSUmgLt1eyUIDJCc8+HdA1pzYOUqq/aZjUA5T+1IxJJTRZesZk+PR5BVhuFk2SuDVGgNVou8jipGwa93jHa7Buzwj3S/Kc09DMb+3YgK2JdkMppzUCilUxWzlYhJni3h8U9CBw/lyIXNuEHKSHAna030aAHiYFbOVAJgL7n5mtm0VuXg0kVA0l8Hz0ki7Qhezs3i5UksFTAmvFGShEH3TRmcTxzZzm8OfpaKfahMboGhRvoBqkH5bsD2WEKZcdg7IqTTCb2RQF0vudUcXqg+42ldjPBZtNzKlTXNvE21Of4G8KLy1H2h8XZrXt0RzltJPuYb/bZt13P5j+JE28tYWJc3/mPHurFyQe4rZndPl+lbNQrWY0mLxIrvZrL5ECAKF8/qH0ruPe8hiibyyyTuXgc24mZF91uP1VDZIQN2l5fQHVZCGSOKWkUB8ijfLKevYF87fTlKZVNBVBrybxfkUDKZtT8UtwdOSruSl/l8CMODkc8TbgyCxO3Bfrpins+rhEG6vyeTmMGj/f5vJY9ZIjVCmZyr3LfXyVofhCvJ+Lvq6WEYKiq5qbCE/TTJ092iuEbuyCz0eAV7PrGR6c19pxslPBoDDaAmt09TErRbeWiQVBegXqsrfcyfMK86R83522Uhy1ip5g4OfrdkFDdlS8We/CTA+j3WhOPy4BKGK1u9nLHnbY/QajsNbFw7zGVKyC/mVSsO88fs8EqibaJLTlsc+cHdON6FUrxb5gDA/Y7HIH6Ilsi2o5RrVXlu2BMGus2zJmNY/iU8LvjXJt/YV/0x1IhPzzd74dK+M39Wh4QLB/neyr7VaT1pip2uiB9LQ9MyCGqe/VxxAEYS7GGViYf3KdSzEB4Hkg3TeSM+7uDp06jSxtSLbKQnRQFwenyPyqV5I6AX9RPiP6E9ybSaYAGJcwOwu0hQvZN7aR+2+7kB4sIrsVdVH8TtVcUJIlIJ8VtYk2F+NPuAVg9s9MPts0XlicT4gwI+a8cLPVkhrLoMsDtO9MGLcOdqlClgcT4hTsnlFFeK1ZBgFnT30+dYWeofLz4qfgA84XJpHfJR8xBH9EQJDjMdrZUHKaOM92LZlWYZPzbOvMeH+KrnpWkeq4bzABP5DlGANj0IEem0F5OY7Qe/INhYs10794QpVuHaMlWFKGjA5uB5YpCZw0bVuG6iO2IHbNQ93kFj9iB531ctpTHk/peFv+Gxkfl+OsNaItFMSi5QfpzsfDvn3tCml3FwbQpIB3bQO7zvQr/+7ouKSm5IUhvs7V2EPr+agNcf8mUkYmadmmBO7MQ/kMYaD/3RQqPkoakP15LpMenPL44CsPmALGB1U2hSD2q/WkhW++LTXID6TWVi33QMz2YDDfDFLznY3dmHOKAScGoieOtd+49OM8m7SogFYNIMrTtQdCskA7UYUfOn9xWdmxXTUL48oYUcUlKq1S1Iy+tvaAoDQuk7ftkwSsXZVsOuwPdEbqkjbLG7v6eZclePQHTdZh/hCUsTnmmx7n7XcSSJLQ2pQVpDKZAv4SQ2DYo/xRuHzHy9XWn+EHge6UfEn9DliqDzU50EfSiMlWBlSr0292wGsotLrLD1PPa8uGCBEwsn7EmkgAOaauwwt1SQhFOYgze6zl2X/xsHsGLgv+YOUhHXpnAxCrfq5nSxz6B7EpfqwbTL3x3VkNyyUZAgMlnn/AD/6fE+QhHOKnvmyQWYYM2BUgHPuI1PmLzGhC0QdfZWzneSyejlxq/JJrl7jsIdDpIqeyaKBw++4t0HLnUSqKpyz3lmrSLKcg5y9lbUCGgB+pWcBiQz5kb3A94ROw/9pv+7tdmaMIGZt7f+vUd08M0O/7BNVm21LQowR6e1aGPkORHCmYh75hfB76XI8hBLhanaKFhxAuPpQK89/im7DVnYXvdSzRf2M87uy54PUrvMrsFMb0BrGHOCWYAbReXQb2bPAQEPBPZQgbaJpR392dy67HbB6N7ZZQLq0XNTSSuym8aD6CbRhG153iHQNBsfwj9atnZbJa757DSsHjl5ndIhOF7F+lgAExNMpAtkeq5I0/hCZ4p1Yf8zdgpOZ1ag1ZfLqmkk/f+Tlzn4SvZx+w6U3ReyN3w2FtPNhimy3EjKT+Lh4uiDir6/v9eTyg4s42Z2a0VuSlatuN31XfxU2dDI19kYspkl+W+JD14kpI1WJtAj/UlfIqiM6ljt0On2FoKUOloDbnGODAWRgjNAqMeQmPD/Idon6RNQaCY4pGrdkmwjkhC3ZQQzoA+eSybag77H+BdN8of9I15Gtm8c9SBd1FQb6enkbFtXxMl44hO8mcRVXA+bOUCJByWhbYjuD1XJi3Q3eNdx9rT7a2/4kDHhXZs2r0o+6NqaNsfAynqEM0QSB5d6XtQJ0MDKYKxnZHYI09+HN5Eq5Aar5kGtxpDQxwP2mDu5EEH5Ea7CRLaAaV4ofHIsApiGcqHhC8KaC4pO+sDwkYWbZCw2f9WiCXUFT0gFR77LYYDVKXrqqdAEhema7sg/GIx+h9EOJsLoaUKpZOn2GVPXLhGHorutTz/+FTYnEe+wEaz7vdqfawtBqpAkvUpF4frjxFHJS3lGsm+5RmuVEKNVebNprTd9PiwGDwsBA9GDXsjpzK2XSmjPQ7thFaiJgaKbD/gJEN66NEJLvXm7beK99NuJcEPfoBb+r9bfiJh05OlqFW054s2UMG6hE1k9hFQrOlIa3/50gLEx6fXUjnbxwo8nbRmqdwPsDPTD9/ghnfb77u7hTMgneVuRHUm2BTz5PJAteICMin4+4fo95hfAIwKbY3o7aZQ37wbnXIixs2T5qSkmEBCTuBaOCe2pcFJA1WbS64IzTflwUjXTNLaSU/7EF7lcTwUGrRgM95vMOKoYfJJOf4pDEehcWFMlvia4uSq+I0se66FNUQkRnTpbv0zb5uYmauMJBTUUVJ2IjmCsij/vgQz9spHOxRsH9Dit0Bt1LO6TvXQMWcGi7XFBiKjaVMQ9C2dOWJXKQqeKUpDgYtfl6rZe1QH5ayj0ZuSEVLYbicz5fyT5rCXoang8cMILdAl0zmMtTq0n4wfC5yZAFKj0batKYCuw5yEHJJwvBN6dD13QSzgR+XqAqzrFHyhfKqKIAmygZOl/WM7kDCpw+SYjGVpVURgZ660xyE+6iAr7Es0ljo9W57i5OSYEPQf3ViYn+4HGkqEHuxXeVI6PtWGKhdFPP7+TGVHxwEs3+Q9YNVmlSVvLH8APHd36SY1tlcR1j0dcO4DYHnkAUalkB8OutJr0vAMi/kjg2N8ZI/6N8+CVT3MXDwCVwtHVBxJ3I0FxaJzxy5Fft/PbviPahOvWlnBBzvqAw11Q+66ULwvBOYxfBuMBZzIESXdx8nys0b/gg5HXNa7+0YEagBhaQFP908XYlPgLyjbu8cYUgCO9FtflWuBAhG9qp/QYHPKhNHCSbdOUvbW3T1fH1GwOCht7RzyUUwG5lbtlWKKwCczYaSYVWOfjfeFmb1lCGUIABbyEqA9u28ulLYJNzNnsn/4fgh0BCb4mECFMu6qYO5sISa80GOJYCiHUjXOWFGOk5jPOvo5ZnxqdXaeWBHlw2etRZqnpKn5kiu3VQcGO0d6TcPxDUYnZQTIIEDV/0zKWP6zYmSIXmclo1qq9R0VYqASBFfQo1s5VkCvdrAA46vd1uRH/dUwNrAgDBr3tPD/UO2mStAJBK/ntukaFSxHfJhiysVMEYokFXyv/J+z+dPBdvpyWprraSOyCOvEs/IgZckF/byGH7+qfHnDnnj21xi4CyjuZpmn4mdyXnoztjiYkXI9x/UkwhTwM6rNs1qvUlxKHWAFY5YkPz1nxiAIdYzll/3udf9eZUqpmiW0lQjn1nsxwQxTCjOYUapYYTlatkJBCYXybKJWb5qStYQsPj6r++g4VOLi+cGejfpiRAR3Ja3AozbJItlMTnMWcunaBQ7HKJKo4uJxfg3O5eb/O5T5+UaT3AZMgk20/w7Tw64QwsqPqhUeA0kXcbXRyjuXGiYd7O3UWCExIqLNC1txyqBcUr+PLDj6vvTMHQePFhIZK2e5/nYXmLxNWPkFEElq0n5hm9RpW5L8Xg5l7KHhDJLfWQ6Xs6EMEzukumEq/MgmYeQhjawQBxvHYQBNrD2/JT8ue6L1i8tX/P/6T/AZYpbm6rhBpg1bGJHdzK7U3kkxPBODGj2QqVnksPOi4/3fJeStPULr5QlQaMI9res3X69pLr7YjZHqfvDc+FFyOBhUSkviZo57WIwpkjq3Nio6q52QhuaA+Q5mky0TiyGuqJR3pF/SY5bmHQb9ZDe+rjILK4qAlYYu75eN52S1bg6xkUk0sqCc24xjYzghy+leLOzFFOi5BSQPoUyM7+CSRocWTrcAY2ol3wUW8W0CthDxjKKNul+vsa9zXD/zGfR/C3TDZYEWchtnDKzhLywkFrSA54p2m2xcijJpI1z7cH3Z0gYDUhJCIR0cLzOv4mssGFLAk3jxHXU41EelPJY8tFj5NZNsLkfMQGQ6MwFEDaFx+6KxSChh3plBeqPZ14Dr7+ebG27WqZysVk2N3i1ZzAGW1YYaLR7zepb8s4Ky/Nc58n+8v/OG7DJeQjYVE8E0JCuiIYgMYQ5/uB3oYLuof4IZGz9TUTshBvzsVfqhPmCNMS4Lewrxllr+OpPxFx+8qNUIdyZH3NjzGHBZ8yItgQP/QMGJ8ZJPoX4xygqwlzPD3TfINXyoi4spC40kFPocalVwMbGHxv5YDD4FhJiL2P7HwaP4tUDZX6p3RF0Lj9bFqBjvJlBLMLXox8xZX74O66MwmfDsqTEb0KTvw2+hp4u8D2Uct7r2Hi5MFBcQ8ruaElP0y6O7dcKX4arzNRaqg+M+FZ4wsZxVoBEpQHuh80uylDuVWgBOlOMj8N5PZt7PK/+t/WvImIU20FxLzYM24vKe9pYNCwfztLEoJcz+hvYapTpVHjSPw0HfMYZJKfoPcS4yRr8AS2+rPJPVJhtxD/1sz907CS3ZK/OC3rGi16VUJPIx9ns9ybfDJWzKrHTU9ty832qDV4wmz41810uS8Fm0JjRTwf9OTw/0l4KzAYx+1bHkbEnZxGdmDrbbdePfBGFVKuZkdlSBDd50/49m6lX8btjjOn3Otnyv4x0v9k008WpYYA/ukhBNV6Cv3WYYxA9VJMooSvdIDjjhYlXy533uK1zoypWej7Td5BSBEGloTJF7+VClQSAA8T/+StMwHsTYdY9TjRoV9t1D0S5BJakW+HhUjaAnplyRuOIuDEz5Tj8FIW5WVDqI7gAk4F1h9Y5gr1x5OmO6jg2o+Jsn4DsadY/h9XXY3R7EQ1SmaKPWz1FXVpd5zOBcj4OaahjGyZoqFAYFybAgda67o39bV3L0Qh8vagvU7qEWReAaaePQJkrKTV74escEBI7Hp+FhNaCd5hbdhvZIIE4OAZMdxjf6bywiFmuB3A61cZquMtATwXk8eYYKsdcTtHiceOpoRbCNJXW9zXhS1Sr3r0gFBUie/tePdac5a5cl2blr+0jPrfwD0R+Yrjei6ZOofM/aOQxjyOUfjOuIBA6llNyaiHy+sZH0xmGetLPq+brZ5mcSXK84Iu7H2Oo1iZ1wMtI3v1JbT772GYql4ADbdBK0yzTovTzcTDNswSOMe1tF0YfCu3/g9kzsTsknoCirkdB1dr0lU6EixaqsUg9+/x/H4zk8cGoT2fHQHKx3GLSj05OL1vtH6c8gKoq6RKjLw4U+Q0otgvKdMg2CfCKUnD/Bx2bi/OJxAA8hHbylxQQvUAraGqyhiMzbsvBzXm0zxERsjTVnKReD+u3Cva3MNnQLk9k8T2+aU6SVJihhkymWZkwddYWlNgGGoTAz69SbCe7nasRWs1VZRPrOv8OjE9qaudM6nqplpY/34wilb6w9BUn11ruCzR0T6dqIA85ya/VitL6WIN69bSN6fMTANDhFM/7YR/zdiaS8F4yzhJwt1WTYjWz93dRA069wgj3LLNbUziJTctK6Qyf+sdhUFLh1BXrAZ2A9a1YClhfjBlT5K5n6MwBLLQufBRMU0//cs+WZ3puc6gfEMrDVqKhNmw08vx4DSRc7p+P1OGQ1eJswQL8vxNkk11G3R5bngRmshD/KT+8PonqMuVVcvhW3YhFkuU9bz7+f0W6G8Xv+4pkP8Hdk2em4oQpYnYt75+zD6t+ATe6Rfi836PKNHHzbg7lsreEfEyp19Da2Lyby5MnmBU8KFw8fAU3YUbyHJQOQTd3f/z/+Db0kBpwS5CQ/aLd+uDHIRQOIkTt3gRKeBlLxccxJdcYmrd7kryfjzw7/bQrNfCfhmTD97e35ZRJUSMcINC2OfIUcK5yhmwpb3wWTLQ/95zQpANuakytq7sXEycTG2hYiyn8iU/T+Fw6lbUOs/GX7imZJrxTeRxZVPBPOdEdWU3hA8yWJBS0xRD/tTCOQ8yQKb89m4CiacFBeeSMx8VjTWkQ7IpqueC8H95kgCr+2vDpu/UFlhYDbnNW70K/DWIOrtWofkQw42f2UL4Me9lmcwdAoLlPEzf2byVcZC5YCpxsT9u5i+1EcWr5LU8f9CbJA+hs1ILXGI5ModMTKhKpH/ymiwhHx4ihldnraqW+IHFMCPMD3Sli+u2p73pm24F1VfPOeIRzjvAuvcCAhHjtdZc4IzuYWzzgNiJ/y24FPGD6BuJ1d1CbEmQWy8ySS+Ww09tI6jhbjHG6qn3CyjSXk0VHeQPYfLsk+oL6nerxyAx/lpQvObIwjx5yLamuEtkgBwZAuVhNeWzoJaFJx6qDBS7YDrOEt+x7UvRJRftdBNN9fNr9OB1vmQWbm04clq+GIpSlwBcwHgCNAzLgm8bS06oVbIq+m6Tuzqyj0QOmdX07wdgz+8XQDHNQGx49kc2b+AMTedgvllXpst/KkLzYB+KLMmb+RUsWJlvX1bHBvOkZot2nuuiOrGewvy4IsEZHtC1pXIHGvKhYksiJHT0JtOzuZziRdX3D0uDKLOw0ADyQ730YcG1Ml5WrgzTAGFmgxU0iStntA1YSloJ+fjqbPVjpMn9zy3RvjwTdsPCExDCXL8Jgrr2pX2DzEm97AwQrqE4F5z2D4OWZNSyPe6To5fJ23Umzxv2N7fqYIHV7jfXUZfqAbPRe5tSDYoT4QTizCAa4U1LKkpZeK63Dom9Mxbh0+x8hj2oyPDiFfV2nxH6BrYRdU5HMGhMN9pFysY2Wm+nDktL27cPi4jKXIxI1glsUF5Ewcz/K70lysR+6/GBzwmxfsFyWXQFbndPF4cchxUglj0A1OJgfgzFM1QfjLQsNHABn74iD8O9cJ2xjn0HXoE+exr77H58AzMrcIKSxk96AIi1ZRAP8jDzCd2oYUfQDbRQNNY4VG3bKslFOusMK9QbvgEBdD9uQ/DKs+SZ+DXapcjiTT8SDdb0AL/izfqjPeMIXblu7FFnKJZKT6dSHZi/d7xrRRWyYFrBZoDCYAdtZJzvyabfwUVWILMQHzk9H67dJOgt0fmGIHQOJlYcZOwB8Y0sZgmVR2AGWDLddCV9Fqpsq28TlJJ4lt944bDO5ySegfdH7jvjr9XDC36S0V8OUCXrP6AZUJeYkOolVHcpZjVANFIyd2h6WU8GMV96CApBDw7Z/mgCg8rRqdivD/x/xB+Xn0B6bUOYehEpEyxVuLUX+kHqV9VAqJU9IG2lGYnz8K20hwSQn8bN9qqViWQvK1/nepL2Anc8J9of6/OwmTSGW7JSgq80+pCshsPvOjHk2mBd65cWZh3N6VHwi/8Ntjama82Obp7TPeghstqT32Ltgf61Z0pX35J52BPVMcyPlOMJuujzr+RKUvRRC6hIxVyB0cPdBzWgyIvgLaFWcl+3E1wYWva7/hGBGmsPY3tErOeaivvkN2MedWwQAMdtKFFpRKe7jh966+H5NyQ9vcfn3m+DcH64Loey4y0QqOJimeTKh345UWTk8uw/IBRQbwuAC5I5CwGBsuDc3qJRNVcs/TOrVCsioydeoqBL1cXu+NXxuP0HuAQOVTQwcC1JeYKWWyTs8ZcbFHAiDC4VCnCNvfyHm9spSQ6YNR7KdJSsr+04JVKTamL8hFAlzHFIUDpfMPn88wg7seUrYho6x0qu0qvDSSXnJzAYHYXJmuewRQENdzHIuaBia1MBvaDi4XFeX+5zPIGMzQptDE4QR9x/V2AeOHDC7xqjc/FZLuJP3pRqzN3EFWAC2YMiHcUZWtEI7PxS+FtQkI/tZ8FVerCiKNUA8LliYg7TUpwmTsvo3RcNF1Cmicl0g7QRuNWRHVTQ3cntVE5WqxK029o/9/RIJ9fcBSmqJJFQ8JJA526VkAb3LirQ8OOPI6L35SaaSVc6lL6TIEL0Bqf3O6Y4zVMfJdYps28eg3eHuttZ2rAd/VbhYTlXGZz498CJK37lkPWORLjCHxInpZ6q9xLcn9uHp2KRjh+mCAMEEAIZ2AivTxqkESFtAY7CWyALi1CKQW8r34Oqr+L3OSrVu7VzkPHYgl6iPGf8UcsCPKBbRj3fUquLg+9+1vtDLUVA9i1JyaWt/D2QiiTGckMchOqJgI1SI9PEi5UhIKYb4g0ZGpvzFDicn3V7x7Ys7ZaUMGoIAgUu5rW6KQehDt+KmBlp43HW+IlMemAe65u+QGhTpsd0M/YmWFUzOn+CtS09pI5a12AUUmX3CnTAimbL1aMvgsTO3swfYSi2LwgtNy7ZHG5EIrgRplcdxLk9LZ4GDsFtt98jKFAtw3KVSADE1qR5asDkcyn6EBumGLYYMWKiFen989v0539+uetAVgmblFuSTDTH8SJPI5D5GqjOfpAioau/yqUg7FuG41aRExFS35qb/InIRH7qMHeOB2bP6hR+cZSwQzaE2DQQe110GUVNH3WmYMD1zdLmNUl6AD0Mejqt9AthoVqcMVzpbFgxcQ6XhyOg4SC8wCpiDZfyxeAxWDiJ/wYZxOd1/PM9BF0iwfF15QVCk4/rsOkbPpb4AvZ+nX7kgdMdvH0SJkSN50Jj/pxQECQU4UtjLwau+5ckR9POAthafnNQ5y3AylxNqEMAht2DovSJZu0UqQ728dMOVa0whdwc3sWDEH/E231f5vQuKUAIBX1NlvQwMX5xrKxQmaTBGRhQTb1prZ3CEEulK7aS69xv0fOgOucd0oxyN5HNoh1R6GBq5Cx8r3nzEZBJMsuF4mt8GM3hp18Crjw77JGFYkvuPjtVLE7ksG8IHPNDtK4rxRcIPFHwe+HwHulNjksc9HeAfFeg4AtmisoNgI6B/1zmaoFjGOtGwU67AYXnCnFtAB8z3J0ZeNIZtVcjtMoZvrFrIaD9wCfNuZCjrFSr/SNFJKulMfiL2egElUBXvsxuGfwlh+Kr62QkJqgpBrpiFW7NucmDgGEHBvQSkDmUicBIAyqmgmnL7BnyLPSYPc1ie/lJczk8WCyiFrgMqPVqU+RmeT48AnT8br3pktyqvyTzAK/adLhF+5pGWN3YsgluTD4TDplouAvz1G0cLz+pBg6GcD6YmOYgEkgmhZvUOEbE+h/ukzgVrqt2kYX/63DHGIATYo4zWnrlGyeLU44ple/aWP8YbfIgdr5IDWDXRO2OWGbylXrHbSWplweH7M7PwVvYjkYkwCd5oXPMsNvNKivqeJuBZOEoOaGPwhDHo58nIhI/XLfxN38rBTKhnIyovZd+yHsMfsLowdtv/6KwrVTjfTl2Punokap1zag6beepncio5H1JbnUhJtFMajEisV2fBAHzB5S7sE0d7xMFfcZznpuHjXhgD6EW2bB4OOZfuuE72Sms5bG51cUFLZww8reMCSF32H/WBGSylECK6xONtaibovJpD4rknlQXccLHZwhibHsuStZ0qJLhhW/b8E3LdeNaEErNWKmmtJiN5KjjI9zI4lUSVUKhFzXd/PHQJ8Q0wP21WyXLYakXTr/4Z9leujT7Abk2NzaeOI77oJFTy7W7AyRG5EsrfwY9uReU+11K0ks4cHeIcJBm/3j1D8VDJoI3kehBtRBKvJjoqLWUsL0hmgkxNDsatUKlFgRYijualdiLgvnCXCUTNpJxdM7iVU9RGIE2x0VZXXCqF7yKKnEOF6HmxVhzaX15qwlb0GoZW8uT+n/oWelzP3InDf+tO4RXIsawWER/QvfvAdGIEl+M+8EmoBsxvXWHjbzBM/DriOJUedSaU1u1U6hBdpDbUVyItTPfKRa/xiu/U07TY/v7gIuXfY7S3Fz2PaOsGtvoyn1DUShsSPeWHb6hQOjqBgfFDZho/eakn5JBsTSiqQcT/Sz+9c2Yc3a15eMrPqUpJCSbGDbF2UB+fuRk7bayxxAzDhOXtF27XamZiDMCpVcL2YJAhty8QCUxJ3EOSOaxbdxoJP2e8OMQbVqejuPM+W5S9257Jz71l9P9Z6uYOsyKLF03XICsqBtUMhbtSt4kcqjEC7bJj2HgATxfFXEZ2WostqPUSijRdXCtFXbfmrGgcXCS41hCPP1yp7oq2mjZ0Ki4lEqdSpExJod2RfLRBnRPjY5puPsa7YO2tPwjYMRjzXo4NXJ60A2ZI+70R3GjQqWbz7h6dxp3cwqJQ8H2aReAX9fHopjtCB20OnvYAu2DOUon9Bdugo12dMkB9IytZLpNQnrw3czfNqOlMq2Sh/M804nSnyZfi3cz+XLku0Sj7J9lgVr0U5qePnOUZuLsBrDdOiElvuKtxjkvNbOA7U3aa/wqaGYU3v9gSnQJuAs1HfYo6RaI8i+oh81juKJTwF8Xtdjkhc4ysozI105fmehwiXFKs8WFgVzVsLPkQS1mP0QPZz/AWkUdINjk08GqX5YFZvuxk9nq4BdVDIECg5L+xmOyiGM2u8kUiwr4ytAY7u5hjHI1N5cr806DwvzWoYUIg/hX0Fgx1f0F3+XyDIqOUiQ7AUO0w5KGFr6CCsdXCyZekMuIrk0KrUPI7nf2LtxD1GUVOWKMGF0YcmF+rbnLYzcTx0VWiguTO0+XXSajKGGTcDBvBr0K/BnWBIgiGbSN/2Vh9aLhtOqL2bcD4GOLuDStp0YaFa+Iq35mfTAOeE80JJfVbNhu/Qz+yq93US2gW6VR22BCu649p1GkqxFl8m+MVzRlBlnA3XgHwygA+t0JyoJy0K9Ksh9hpspH32Zko1hbfLks4ZZeZZXO/iLmSlAPapWDM39WgiNxkNndk1BMHsUsh5YaRbMCSB1eXYCMNwAA+Jsi0N7VCdq+rmHnDiMGI8npHNvPP+bsogshwofTDkO0oKUnkkM17Qcz3ROXx/S6H6Lj6S+700htNyQ7Yjfpftl/2yBKHcIS9SE+U8PgyUFaOTKw8y6Ijl3g2HO6uk5IoqUEaDu6OiGeOTYMnHngTCeY2qxznpaSWFgmmVj4fLlmDF1SsctqkW6EX4ETTBVYJ6cR3KsjiFpEbJIGk6eo/hmQ/D1RoGSGuZjArIWswJdNVhngz9zKap6+UcGdsb29XbbaT+qqnn9ptDmKQ55CDC1f6qoT9ZX2Gw4Dxoaw0wYW8CPiZp9GxM6oNr4gJXr/3lZYGS+CHVBUroF+ZfxdJdAtx5WAM816ApaYjJbsxMQUoQHiTDL1oe0MKfPvhS5YM7FNJ9qBQaR7p5Gpj7AXO/ZHQAGfdZpYiYA1Nvrgv+xd6b4ZeWjGSLjEX20IGsrMV8pVQPCOUaUgjsvX5nJNeopwAFB66F4gesw5+XpEQQzMf8Ojt4ALEH4JWMAs90t9j7Ixq0ro81L7Fv1dL7jQMA1wtdhHZclLnz3CWITVWwb/rQqn8HoCmo9OX+zjLrJHYThMuELIw7WuqOLUqpiQl6oBOqL4lUe4iCP5HO7oBmeevxJKVx+BZvZZCBPmTuwH/FghHgLNQ4cDf9iVxVHQVuq9E55wIPw9fSn5qUwVw+YjhAWVrvZYm9xLvitVAtKfICFV28AXoSWHUCLyEW1rTh24yqff0HhpiIJ3Q2bG6GKvMRVOuDMQSrrrhOwQ96v2/vk5yinLNkBLxjow3HvyjyoCzaOI0lF8bMvLo1iugTRdT2sxBj6ZrLRk7CZ9CcQfpsMsGg+WHqC4kEjkSOPvFs0UGWFElUkZwN/wRJUXH11KqXUYT3qDuMG+1BZfVJcT7EdTO7Se988eCdaxixNFCuB/uZ4INaRlGsEs6pxidCVBm1MpJRlBvOdqnCeT4uC2MVnrMO6Sq5bBpwz7rRGF2QdvmTT12vDttJjLNYWswP10MbqVu+D555AgLhU1UoHfgxxMZWhlBhjwI8dZp4r7Ng4cRjVSx6eBaNWnokNffMkW+KmhkVTRY39Kw5lldH9r83RzVYZbwWCoZSRwgiedi0+EUM71Lp7yeBfWRfaDuiEVrr7usqV2eF0Xi7wCXMSAxpSbAfOZ3y1gLYO71FjF5hA+gmAy18GWNqsS9MeTDDvRuMsj9AhPUZbnnhhV2B/2HPRUtZFhqzVC8vlMQgWoSEegSwRblfu0K0PhhfswBxwhpu4QSQ1e4KYy400nglaXpRMSzHi06AmyAeklF267OrFK8KebDqK3G/DaBsnxvncsegM7AKNLRyOnMtRDJ/K+KEMdzfDiv6UMt5iYVtKvwW+7Jbnd6yR/T/l7bQnYLR2QW4QpylLeAz9MGuPiggrHLxFm8uY52dCVF2tqDRhncEOtx1lEZRLDFDjkUu+CP87Ppnnry8K0DsgCr0luEWymRUd+gMLMKya+yeIikt08ylmpD+y35s+5A1g7US6MZ29AK4QGsOQp2XAm5H5Xz+8GZSPomCMTWRVjTv6iPnLOxuIOec16RwMxvQViSQVAWXXZl4rghmqXdVP8Ci50ZfNSRLKejs5qomY21PvRGHH0tDKOshsqIPDhXqFEMEFa+Mq9nbvrRY9ZuNj7WQrPJ/cq4Aba5+Zb7IbkAsd51hY+jWtmqLrcKBclQ1YUyd0YQMqvfisD5bsHFNJh1+sFax17aldUw+pmtmWZ04Otb4fPHXIlwrp1lPfbucvVyF/lKnWwYLknnaIjuPLKDJbh3sQ1u/JJAQCsj6kUSVedwJypO/VGWtO/Ixu3rrduweaezA0PUUPYEl7D8GNrbYRUN7qPaDW/pF9e1ZklA/gk2QOZpGJ48eHEc63EuLKX5paMGoJ5FqzzBPd7WZFJlaUr6QztWRAw54Ou1Id1eeY63Kx6SohFjWcUfOO2o+klhdKwF0ajVUkdYXQfoe3yw+SP7W05hDtyJjnokpMRZBrQY8ncG84PtPLc6PoD0H4m/peVif5P1Fte7+6sRZfHXM7E2vBJDKVha/UW0N8O0I1oMh+2ZDJaPbWLK9ONi/ITNkUvAVSGuAW++v+UImgZj9GlzU2j4llnPt9ik2pRCR4Hscf6JBr/iBuew0fSQzpG4tL7TdrEvTjj6OEt9TaSf6i3DCNiANiNPmIZPX2xk27THcm9vhdYgbEUyPK1IEnbYRv7V+eOhLaaMnmcyp3+tka5KCatAeYICkjww1RKvq15j8ILgQ093qCOiyTcUgG6Ad/90h7GQ2s/srjVvl6Xy2TN3cTYHZfRHsUrekwEpquG5dQN/k3MNzk6Pau9M/X+tDZliegHNTp8L3r285Yx7DrkDb2USnc6EDUz0REPc2c/9vIECzHgHCfbEtuAjoU+UGf9fhASN3NdMprnmRPvkV10TgH8IruIiPVtBSjpFnB4aCplEePlpqWigbVeM+b+rdF0t6WuO0M1zEOvNrUmV/cSgucdGCc5b6LTQ3NPjG+8lQ/2c+0Ickq2fM3lxvEFbTkqui/R3+wADdFHi3jalFIrj1o8V6b9y3d+H9U3sVnu1rCSXlLFeNJYWcTWQghSCRWwmd0YABZDkbbhz1mx85jBIOrzHnUwl4CZBU9uyLANrSAcOZuXlMjavhy6FdjGmvf86YMq1meW1RlvH+M+gyBpwOQ68Egba4SS0csG9+z2/Bbj99NbUG6Y3uM1dp/mkXTcXtLkDp9wEhrKfThuTs6dL5LkvgORizs5fk2A745SO+r0cW/rxEN9/nhX//5MvObjhGjPClMWMw+XZTH/f5MTivMzDbLizHGpHcpMWM1iJcmnpC9RR93t0aO2YhGvMkiQhKvNbFd2evwgGqjmur9VC/MTgkUFqwvn510Z4OHGIeo92ht6WfMn5gNUAepvw0+jDWxFd2/K+OzrE/KWwMR0FY+vYpfAajLstvcEZZtN19qM3wYGLvTtWID+8DRfP44dUGyTymNGMVa33EW6UTOERpEjbwENxb5us4RxodwU3TsBIdZnwoR9hR/bUZOE7mK3WeoW6nhny+7FM+mMjG71ZnD2ULv/5RF1pV+zZGQSSr0ouDEsmJSBq4eG7xNL0tjJ2mB1Iox7iu1BoJI6Cz5+kMrWHTHb72arNwhzt6NtdowVSaf8vF7b98gDxEctAuA0++kdkPgOqZgRuK+Ft4cIoYa8obG3V8KVNmKt0aPPwpsQnl0gNaCMt7+J1SH3wok3EUhHBV4j76W9TZZt/QZ36Tgz6KJOf6WpxMpEtzC2a1jOXfcLqjtMBCbUE+ALNgfFcpHVKoxQgZ6nprBVR3LETOQb7S4mECg7t2kY/F06FOeFaH1fbO7tP7kblgsH6t4JgDzGrSLOml9a/gLazXCYI67r0oRci/AM7Hr4twkUUTLGvl9Z/GPHO4uY9rUIFdj0K1XD1i4fUbnGBfbDIizyTmlCE/03WqfVmBRne3oxbg+xGDFv6NzOyBAB+qHpk5XqeQ6Uyttk0+ZH82ArC0BgSXoOiwUuRD9NznkWfXx7EL+Zh1UPUk+5u2XO2tFaDFf/2boyIxt/Jeux5gLWThcVCwMXpdWLGZgYccWpk1murjerMRLwTX1fdKCLbOy/iLH/Ql2Yem4RYYENBk2bRvcLOx4yoiX5yTZ3ykbF4/vABYRHZgsCEOQPFDkEnfp4ISYErvLSfqpEhKQkl81Fyu234ArD/z8EMhk6W732xn4P6F37lkIwi9obQ/jfURbThVM4zR+qjRRLJ7W9vqhXGqvttrZs8IzxwiKbvi0qDw8JpdGG/QVNzHd9g2sWwmoP/X0vlMoVADwaEmCWcvQWwJzWk2suYVI+fQiODPR48R2o0PiZ51/3cH9QGfaeEloGknGU8hiYLDyEzmk3YePwCpa8Dzj0K+0lpVyXzW56EZc6/Teyy74YqV5uIzAhXpmj3nh1E7HS2Qz8Xo0GQAqNMBUgjmX/x1YwYfD3ImKiSkrpdeST8fUVbdmq/1/7VldQ1Ld51MmuKSn88YvRkOlmn4/OYLPomLjSBC5ql7WcKoD1ICsNBWJLyOolJPwmNqEZPoxRSttaHQCuWkkfn0dN28ZHmIZUU+qzLyLi5/Tq0flzad/Ls+pG5pKrY6/Rqdhy18kf/z6PNw9dsUxskDEwIdYA7lnr/HCzto5G/U520EXn8yzyhX8NHaMd/VK+DjEGAEt9K4U749fOBCQK6OjfGlcdCxpBg9oDs4H5wLju/uhaofW4CZl1bwhJ0KJ7HpabWdQ7BN0hHHwTu+jwHutm3KcOX+AwO1J/P8bHPSy5BjzuhEJXV/kiPmpZr6GkbL3QIDRtt+ajGBHmihqtT/Xd+EAM+OD7R5BqQgXs3Txc9hSxCEArVvhnMruyqVnm8CJgSmGEbBYmO5uZVkY2cY76jCw7sKfYaxL4wsVlPMxYejxny8J+hUgD5HGyrAJrD4k3u067C2hfNQnloJGRc9cDD1XUaICfmsn/Vg27u/V8SKUl7WG22feTl0Cl5JsNspH38q/PrmobVc55x6rCwF/FF2KLB3DCmCVnoUmRYBCfQ/a4nUBx9J0DLHIb6ybF7GlWZ0HXp0a1x40k8BQ4AHJoYQA9KYFcgb/rgVKf/xbU3E1DlbTgpx2EwRnOTkts4oQ8t+v+FvHTJqi9O3twyvU78xnNMlxRCxY4phBYC/PM2u7tNuMLvWJyvDcTuT5T+0ikkw159Mml3hS9tMj9GqYGmk9YESMjfK6wnvAOQAnNbc3GJEUVR4NeQgiV43WLeWaGvl+1BLEGMVza3ooCa4ojcZl0VOjsgYHwAekgVytTBi2Btn/i8M0aHSZsNviyMwcFf/5ysN7WampmI2IImSYfJUiumckp8NHhnrIla6sPfZ/rjttcNvLXOtp5pRbXKCjTZdHLsdygFIQvhMGskrZPw64RgxlBVPXDwUChptZ7aiDCxEWxEoB0UvuyqC9G7t/sSUI8uuAouuyhnfIYURRq/ZJjqCH8RjJUmYy9vfuNVBIaeM1omCc0dzM6cASPmm9dSAAiXlV/EDicuDGuxhaQLOMnYdVMNQLblMUsn81fWzkp/z6ihoeGorOeaoDsqwJKAY5fxE3VNOx9H78vtr81PkEdjzqCedmHl3whc/OHK+eKmLZIBEWnG0hQSvNmDne3ET7Hk3UgO5aTFWtMECTBNoe2Jqn6wKOF3xPqMJdkMWH2EbL0QY984F2w/Sc9V5rkP1HaCp8YO2NnBKbW/8kDlTFF/BoX7cV40/41TiyQef/sh3BmO7aoOajlaiogXWr/0gC4875rcQIloZmvLafVhI9ldGEwbSW9VOhBe8xRNaHEUsXfxZXpy4BCWd/S3KJ6yTZCHRymxEzdWHJ15upCrRnF6yZNIxpR9L+jDiC6vouJGEfUQUumh86J8B1DoETdQUIfPcV4qOVb2JamZuK6i1o3uvMg8CLXZ7rzIIMGpVzyMYK8MviYhvZUGc7GftYUjOBJMD6A7LV8yF+zxsx4JTYGFGpM69GoEx8O0LMOEr0xD/tWTdIZgz32MgpXUnTAv4TivoFZQPjpQd3RQx9Yon0hesQf9z5HqB/JsjyXjVbYjw0tP9NU1HPRjfjNQmh6l99eChIX1OtWk8GrEBWoso3AZUJRTRLuM6GjDSjvzxI+n3V62b72v3HSjDuXEICmwaoUreGUJHXQ6yLKlRPVrcjc+qnUZUFHdkRmAfOXvscO7+UxZVZFeRlXit1mQIQOc+oFANjcW19HlC9B+ZOWw0X6Yo4MPLaHpALSvu9imNaOTh5/Jt0hOiAwYILozlIFXcQ6ArY08NqkeQNB1RijPu8AbHADSbLgSjJEPgGMqNbovpsdXmS0uOxp1hf1zJ4SgWsIiQ6Z+PfXDIONaf0yDxhAhdLKUA9vMBznQI1g727FEVJ5vpCouWS57VfMNreX0eamqLByYTGwF4Ts8/IqI7dfS6dIa1vHaQfhBT3coR6VF23qMEkgYf+hLUd2DeO60Nqz9hlS99HFA/msuy7eoF3HlPG9pxCKRJ3ZbvPcYyEoekQvFK7vmbyu1gmOem6U1f6p6SPYE5bGn5aN90mJ+ERkh1erm1xKTZfk7JRxkeGzGLVZCLDuER62cPUT+F8s7YVHBgxSGEWdsWSkxPIe10xbrGrywM/ndBb3B+gsOAFvw084nsix/kXK4/zIizjgR7shZNCAzHZtnNyHVWaV8IoZh+Ek52Ni6pG7OFzdzREd4jeo90LOta6hGZN3+dpk2UpwNyQvloH37ZxHcX+PocJH/KPelx8cu4pSwRjjFK5tTMAdZI4Nxg5QWDLtj7JIByp2RtIozucD+YyIpbFi4ioGCKwL3OpfKAHySI9VTZpLVqhiVk5jL6JN1vZcWJHsKsvHR7xPupyHtu45eLFDqISVhZiadQMb4aZv3tOp659qZ728qtFWcbb7J6X9ruIe2egdNoKXgZvQlaCgGh149Kn3rOGX6TvaBvhFaMQrX2+rAQgwhgA8lRUEjgHVXPGvq8Z8IpcLyGVKCRQ9w/zwqNkXE3Emh9B459aKs3H9PznzKTjn02gYUQegmLar07xM9sQmVZ3TWPaKMVSSISb8w/TKRaBCkdt1n4b3vzPHMDdoYpouKvpbkc83wav5hol778YqTtrnFO4TMeomG6V30ycd4EdxVXUlKAUH5TVFYyDcJHMThReQz29Aa6rk2pB85mE1V44kUOboLCv9Innt5yNrkIO24wPNr7v/qtpV0KA1eW21KEuw2DxGaZETokvmeJOPtjeIDOPtDfuxi2ScYOvDvfrDqA3Lif/XzKDx14/Hx3jTjI7ALG9YOkufiSP18n9WVVfYRP8TVzqmh/WKhFsgLqrbk9hawsHdp1T8rNUK63K1OaPxUhOaTus8zgbcQIMDrQlo8ebB1Yta6Pb7TYZg/eGW31MkS+IOE1VoflXx5AuUT3/rV0teja9olBxrgu3PzoTY3YxU7KG657pVkWViA6xpNG/c4gUMwRiK18p8O1fqm5nElQR4jUH22JwPiwxkN+yFBv48hj9PiBDD0xcCEVWIEViFan6N7G+becxf1AgB9Hz27kZ/Tw71waFr4ufjmMeZE0uApjR0C8AxVECladCFbLJLCrkRfFfzmekrtUQcsBT7LOeezF68GWOVS1pZWsIL8WpnGHhjHhdv9RAOgqO0RSWcRbAvAc+vFFpWTF9cAC8EEFoBc/6V/tJDzcYJ72KjrGPF89lkKuMI8tQlMAenSzvzEkD6PT0AJXrSDRmdTPyoOApzxpNCi0vrIT46k6jbdLyQhhhgqhMrIDPOJp+fn1Vg7hYkB9bM/6SgpsAgaZNaNwt29g3GnztP2HigYGtHuoTpOTEJ1SoZ2qn9O7a9ocH/1hV/dp5qq5iw5q1PlOCEaqfnk5GBSD7PxV6E0AinWSyqPFBG/XsZGBObjSCaR0/+NainyrIMfVzKo4sElKBJyvaj3gmpHJcziYxTsrlqLD43z4MvDetkxfi00AGt83tlzTeZJY97W3DPn2C6f/vF2AtS1aVFy1wTiDaW1hKb42gFgtpVQwAs+Lsx/Es5kgQFgiRvAn+1Se39Ct0RuPtnyPYYuWU8E7qMqbfrQObjs+QWecQmPwNX7cfkAilkZY6PtFygx/m3GtnXnHAg9ogtrAZBjNZfHmK4n+jfbRoC0C3JdC+QPO9UXcFBJHclmTk4tWaF7Ccuh/fiorl1+u/RpQoL80yWOCBQS0EEf7ce4OCor9jfDopW9q7xAG1gomvz7K/CTL+5Q+CnjWtwFP+NcVyISkj8nLY5rZLg1478UlD4i6PNu1aDSP1vcl7jaXpacbln2LbE44wO34yp8HF4mLMt1phWVkbvzVEnGEyuMCnIHuV/sAFGK+6PFB3Xtv/F5kFmLKikgeKWPiN5K6mVRV2jB9ZultzlndYZ9F1GjqjSxXDfAvxYe/2Zja0tGBfh6hXXId/g7ebriTmEjQarIj/X4BQYUMHxVKP5vIz3q+IDrgz5qWG7nPFdBjPTy39vBvWZ18I4HikHtMHRBtTeV8VHtdoz2nRzSbTnt4Qa77q3AxyIHp9Od5chH0OsWluSnQa3w6VO5qweQPKQ7GBsqLhOoGVfsklvrN1MMPQJyeBYx4SucM1mIjCTFxpindyKNtmJLBZY38gDVFIrnNiJjDKLDLd4eKMDswvu2ZvfSllC0JfO7OpBGuSxpEmm/XplYJ5cdgjyZf5ygKbOWJekqtzPzXVz9kNmO+qmjlnurwJnquAUt/3Ad4aXzhXB2ltQxjWQcC9gXPROUTgFcORgFK5qARXjNA+OZVJDzqpTwhnOgKVma+Rnum1pXNhRHIzP4ug0pTncHiwKIClcJ8tnlbRXX3+vkGJBkSXSd2lWCLfjSamCscrq7nGSjQjc/RU9xdNRvMd/fjSPCM9vSABklgPr4m83Xm7dUlRBdvFMA6y+R9NFkvZBKVjm8onhW+hyCAoLz58/upQqUzi1u3UidN4nt3jo4OlUGyk/gNHJqiTy1OjP+xMDj9mYSvnp0YTD6nWxmAEuaDEn2uAPHvLquY5tb6pBTuSu0r43veR4zRqDLznpOZx3R0m/A433E+n5WVQNvcBgCxBQKVr6fL076J5asUrcBZruHr56FXUrolO+21Yip9SBzPJufJm36EZF1qTfmUzsyzly6oLxxU9pppG4hMG3oIH+52+mq5xor4T+aLutJqjgri/+g6kQU14z72A1A/0zSt7Okw6ixAQjqHaVi2mFHB0jokyZkRUOimwt8FKRyIyK/Tm+1Gd7m0d6ODtEO6aos3xMq7cojGaNkbXnYYwsmnpBybRyTlEac8Kv1Wv6uk87Z7h33Yt0D25fCdMbmErcGzibrJ6/ftxONW+F6NMnGbP/R9s092UfjvnSk/hVM4UucwFibo8b6D1vv6hjA2HrfIU+ioFqSZY9+S+0MXFSu6COJ6z6iIiwaH2PrSdj580uGwa8KQQpjXVtrua61m7t6ssDsStUmiNOi6nlx9yK0kU9bVNV/ywYHsWg4gc8uaaROZMGCa1E1AvP20IL+rqOR0ylT7FeQ9Cn7nIeRh9R25Yv6/ruCukcBWcKlmkdtJ2ugP+r2DRLLDvi/1l0jFg3r2FMgDnhe8vctoqQvv9JLukSzaVe4MaUE1wX+qnhKOuTciFL5emLru30lQtVYTX3lSc3aVAI3HpLkIERiboqo7DekEAVr1ytaa42somaDTf0vHtTUw2tsKImmupoDg+6D1Knjd3UtF2ghYfI8h0gHw9Yd0sXwfoVHXAY9vYIhk/ZtTmkQRwDsT9N3+rp6t23g7ly4BC4TkERY1CHl+la0dha7UNKkSi/akXg9+KxZDA1ytGqSahNQat9yNuFWY6ybppiK0k7oqkilo/dNkoYtSVqI9PDeq0fIpxyC061zNzd/fI51ryKD1tB28KR0vIxMdcT54wQAzajtXgSfg5pToVf4sxrZ7uofE+hkA2brrZlB345xUM1Nc5BaZ1JGEQzwYMMGwKNgCC+4zNR510yreWp0iRh9tnuaTGpbhXkB7zkHOr1j6U8/BWOvk3WZpL0WXVc+8xVubvUx7vGtB8Jfa6D6jDtvTnCqBvYdlWfsTv8u5ejChAX3NKNR1SS91mbgdZIdnqpgnIeNEXRk5XdHsq7EAmkyWDAMMdaACe1ZGW8rV1dv7znC07GYmf1a1uHSfLXu4ZiPtOeJneQIe2WPTnT55C9iiyxg3x8PYLcV/6qc+YmukYZ6nIHhaQ0diIhltbcqT2wYRQlVTlsK3cXABbKnqDGt6jf/1DmVLkJOdWfAx8qGclRprg2BEDymCOfSujExlHX1yREzs4VGiFBIdLt78w+4oCnX4OVOj1C8c9RNCdFwQuyX/TcDhfQ39ZOPo9U4f9teuEAkjsUI0yo8FkuGNlFMHIiy9ybhCBvINOsFpnFVveyQJECXMTzGfnE0/CX+sxgbi4+Fk5xZusTIkfooQdTJlWytFT3+Y8rmyDz/OChU0mc4oh0JwcOMeYITFmWcQuTzu8CMKL9PVJ+CWf34aMwxXS4r8aqKF+FoTb5e6KNA0i7EpB3xELRW92e+uF3Nh/5ED/WJMZGEZU/zJRZUpmJ7CxhJmHid6DixVuVbYFhW4WxpLa7hsnM/k8c6cnA1G4uZyMxDTvjgtA2zaSEF3HmyDXU01ByJv9tifEE99c8zev49yvVpbqIqjMtzzaWRpEaz/sjmu223nMw7GL0kO65TufvvEQG8QXw0oVp/CrHr5NrikuEqFJh+Qh+8Lr9ALBctuKyY2IZXaSDkD/19FpiMWW7GqTLWW1lhsx8QvZk0bfJ1PAuJMyWRUSWgnyh6kWnPyymPicc2tBabm5cNdnW508DUpW//CGReDzYMO/NkeyJRqK6PD9feS4Ld3ls70sD/FlkMm8V9o2OWy83SoDvmzTt3XKw7oGz0fesJ0QIKIlTvpbuyNoRzuaYVCSwRckziXNnbnDSDPIY1fEEppleKBHZbAQqvhZcD8TD0lDoxBmVRxr2hMi68QLU47EMH82+9aBdMIvnaIdR/2GJ/dDAwnVRxvbArZcReZ8uTJvgN8EA2GlB5DEfrCvtHLQCq9jGpX+IVsMv5x78JMjY8HIMUTFI2AtmaQUAQAE6IjEKU30XwEtJlYMghx2+j31hLDaK0DSLQTYN+zC1drOExXyBsvKiJvJiXy7rnu1Ps0O5o4F4FL4U6oX1rK4+FZlm4WBRo+Oq2WZnyCiL9Tlq0Uzu7iFGlfEqymFWe7vlhbk6RB4+4JmY62blKY3DyWxHaUyCWMgcc9vOy63CcIRr5/kKn41fSCur36JZYnypTY2YPKJLiZCzChfh9c6X1MzKGeY4rLxbkoKP+OXfuCgrUi3KWKaFbyr2RPaOBgIy9EjT3ur0g6Iz4AlibpH1HZMn7K+gteH3BEoGW9BWZ0FLqZEW6r6TAHDjTzOcTpQZMNscp/vaYOeXH8KEnc0cRzIS22H0a47acJbYoAi4LaSoHjDbDOEzKcP/WbWZuQiXXd7w6pEukYBTYNde02JchSJxSGzdDLEMJ1pa7a5c/uSeeoSxX9JSdN58KlaTMUmrMf1meGCAYFz4EFnAx8crLV/LduoV54LiMgP/4S8kvQA7n3SEjVq6evtnvdJ4XPAum/j5y8h815U1YdlTJrXzWZfZ8XM5Mjz7JvArkizkJ0c+DmuGJT/cEdR2rfYcprTDSydkDVU0vt0M4Zins5PXIz709UMkJPHxPjaV3uUMGD2Nc4m7IBZa8js6FO0qcpNazKj7GQQFwStq7yxEOSjbrPF0dJkPU68fge+NaCVSH3HTASIdR7Wj7UQwwlZTyMltTeSMn7LcYiwQQqFfmWBwMEO3SOh0a9hXT8TpCFsRZv54u/ub553IB7ji7YKkrw5Yj0qEmYp5gIQBdCC9RGxAthH1azu4W3qY8BSGAA4KZpP+f+tLg1JUbfi/LkOeinTqkH9oGdMafbL+A2jcpHY4fIIkrerc7O59nBPFXySYjKvhvRl4hvIL5KBdscci+uJd/MSGJj5yWS5eVZynX9FOj//0RYJKZxfEYYf+KSnNzt/AzYy8QNb/UmrLpWhpHNgfVYuRNLY12gmz8kNUKBG5yj7WSNyntepxbwPavkvc7NfDN2yCVLId8dyZy/GAo/g2kyNBjLESXkpPYBZrUevEG8cP0mE8jiJXmUhhBK1jc2YnbB2sNS2QKsucpqniv+ROGw++9RerKp38sVHxBM9g0Q/UGLGRpFfcefX07QR4UkFH+EI5irQL3TzsYtZKTkdQVBkFTD1OmRLqRc8HdhNN7rW9/TYbQcVOS5U3K1Ab6ySf7hkkzcBiJZrdU/7Nc4plww7Kp3fg0IDLSFJ5KPXi37rLb/MKW3UJUyudjVasmza0wvEmBIHjvo/xB3cOwSx+jyhCTtmy+S3BDBKMI4ExIRmuKH/zYczWxxjJsF821F959P3AHdkzppDl7K37pxrIvNIAvPZ4ka6n132DewjXb7TPCvwLvacjGk+uVYt+yDA6ez3TzeCyFDb+JBxnGPZBWxr92lParR8ZjicZlPlosh/SjAE7MB42iyNMLcOvLLG0C8y8Rww2hvPuDexhmqi+UrXYgRmDchfItGVZnFLQLEKUTciVJaumd5iBQJ5udgo70s1IRzbNaSct2xIwBzSICi6JfLUP2L8Q4qUPQXAb49a2b8NHxejeBD57t411AWK8ecgEQ4cylD6rYihTtsDOLmw7WVHoyXNuwaHOmg2wMxWKcju0JyO5EdhnS4Zi3Zop1fqhDiGQQ2/qRAbuth4VHSUsZ36LYCoPYJvLRG8F6akiTwr+XAlTr4sdpB8YFjjcIGdh1O2u2DX219lmplUv7d7u6ljeXTBnzig1JcFDieo7O9sLXwCoCBNnN3QYEgNE0GaQA0m3+GJHjkmHpeYj5p+lw6wMGsp1AK7bJ5xo8hH3dY8p4RGcyvJoQ/upfSDZLi9h8Of8LqbHL69OG7f5FHh3UdtkDtiCKYBfrtIqhIqzjv/SgndMWSA9FyfDGzW/FZKcKj2RIYaIMw0BeccDggJ+7IMTljs7dAIUX7QVIrMJ/GDVKBXDr+ui4bBRpfHp0XfsGV0NXW8pnkOTgmQyNxAwnkTZsMnZsM6doinwCrSoECVAcBrneZaKQu9EP0XOFhdGr3FLJuohaVeRm7DLZDiBDrO8Ulnxd21Skq1zfyPz7q8v7NgjDSw3y4vOSuXJHRbljdVT8J0QN4B2rlP/qOrJh1ltxgxlKaIocA4F4kKkFu9lQARjt+3Drl243n6ycAa6x4SQgfytIZSPnj1qH56+CB5FISH4wH5ngWOqEoXL0scQsiFItM+4uCYPfgkmBM7H/Z0b2JNY5VMQERZU9g/FSwQUTK18+cV6TC1+TJ6IGXQ+XwlJzUhUMmjRjOxTI3s1Sy4OT5VyZiwL6tXYQrD5ao3oQXz/p8COieVjFS6Z5nHgWt2zRfBpzl/vTXJLXD6l+ipPLEb2IKeSqQi8vSyumK8k5+vdhQ8FTsInD3FJEQ0Wtkj0aD9tHyqS0JMdX1emdX+mftEbfzicWkGIWQzF0yuyDOgsxleMejCbv8LyDn8+qgrZ54j5iCF6XdNofr05OmJ7+/BNbJRMN0A9qQDem734sDs8UhDwQvlovSROX1c3kyBS7I0iAL5yxBwjxNpSjrgiVpVP/HPRq+LdN0wU0bVls3HDDe6CX5AqkrMJ7+k4rWGQOX4k9Qe/isj1ZbPDXsnFkwN3SZW0Ls3gV6D5JsYzgArqBzeiluVm3kxMYhzaBo/FVw3yWm/bmpfaH7mXsLffK1VdKEFhP5XN/AFOi47Mzl8bnfPoXGhQro8HAO0OBXvY4FHTQ53c6QyQxVIkfmis8seA2LPe+1gYJHqJNC7DzEx8DR+Lyk5Ssj6oLQuSqoCZ9b5h/ydO2dJF5byDwaeEoRzkcrNffRZAaJvXNnIt6thiMKLB2aJIa+sU2knO6PZXOUexnaEqyEuajD2umkSSHlb9Xh1WvPgIrQmSTILqm+vWFkpSl2XXBxZlnNjwL+6ynQRTjXDA2bTChztwSW7/GoOpWA8CshU7szhCNHiACEUFsTmIcUJ/LEaaavsMxUr9laGgBiIXKq9WW5AM+aOHtJ8JWkK1lld58n2Xjby/7Nj2oYfV90GW+FA5JrMGMtQ4UXviFBtPUTOVR0RLRbyGwTXQE4O62Tyuvfyt8l9yDTejOMcG9zPtPjdioPalPjU0BUNGhVtfzauB5RcOYnu5ep58b5e8N/kQeqpYlk98D4d4oi7ZTZKMkuEYId5Qc67qBx3WdzTPhSBCDQ4y7ikV8cxll9htAwMPqV4wJWKD2KoKr3pNE0RvgJ2E1fLkwkSvrxcR/0D70Js0gwRxpMtwjD32+jArE/77ulDeYzK9AFMGkUmBDx54CtfAPHbjckelAj2LgaofTcugBSINQMreSYe/Og5DBR1Zs6W9e72nsNyxJWNC9dQZaHAAtl8a6e6iouYMCjpKB2H14hTXTJebG9aQx5xDBkFJb5FRqk9Mb8Z4x2vkcqArV/dvo7f0KWmjnOEKJh74RcSp1ZoC4Bg2n9kZ/u4yNw4fCDN6AX02REfS6JGviBDghtrWcTcpJUJh5eXf4cmS7YWr8k+YQHX0lf/1Wb/WGP6DKBmC79Ppqm0uZ8JAx5nuSimgfPj2CHmixSZFaXIuZX2eE2pG5orBcXGTYP9Y3sMvrfxei4wvyG81ongmfP5Z3UdXaLjXJq21Z0KV7gZTB7rr8pqla6RnHizcmI5X2umvoQMoxRJ0G1L1nEob7LKr8BBCm/9D2qzeF/AsKUnkCjIeSChbmdzdP6syLoBCRYEYFyu87E8f9kzj24cMXYeTFNmg8yZpI7YsMur/lo8PuDaGvdy3mqHFDDKTGmPbXg39KlweKwn+YDBBsmNlb/htxS0xydF18pQO/f5rxOvC9XOt10n9rTN1D5crtwWSFwCAV/hNlt5uX0mWiBmRVtbsP2qYzKYNN7M52kRp9UjuW9WWPJ3a5ynqzTxeI21HT6P1zDmjPG8VdguvdrSO5gwhe9l3y/6TJmdh7K2FxaFOO6su718AewLxy+ljX8+6ykCTZFReS+wXYO3kdi0QxGTiycS1Lp68c83Q1yZ46QgNMJYEygG43Os1Ur+9ILlpwvMjoQQAGmO0WrCWKdzC7FhzURcB21iJ6F0J1kr8GC+1E65P5UxQ8iKLcIQI+sSAiZ4JVf2gjr16isKdDQf+jUtWb0ZZJlUjGkMT8a31woxu5rCSeekEP/Tmuf1bNBWcIhhvhMAaF4aUfqgb9mVsR7MVwLFCKI6HJIzXFuUCK/KqHAPBlm7Sx/aj1pesc6X3YcCaV3FOToMEPb4YDjwpKwehkOrTVgRAXFGxShGNfKJF/nS1Pl5sbvsRwvjfIaQEa+l60b9tI9ixHGBGQKimN482PHtkqxZYrWkXq5JeNPhQSGUybQ8bb0mPaJ0gPbI+6jZZKgaQGk3+AoQpQYyohgChORmqRij9298hIfhSBFfxN7Up+z76r7/v1mCT1iGvbUZ8KcJX2CxAt29xUwsLKtcg/eIhZx2XzvywGBkxwPgEscSC25RcAU4jjLrla0yAsRyMYQvpWUMX8zaOwSYIEmfpxQXamKtTEBUYrdoEuV1kbU+fNzLtGYbR9kvH++yv5EuPMv7USvUVkPKc6nfIzkVvogA59UpV74Ntf/96Z7hJxU9mjrRvtUTDy+wMNd6B+B9Aoy1CczeN7pAtLbfC+Ul49pnl61XIikbwNyykptKperPIiHPDGe9FtaUku+a1KXpGasU/SKzB+RGWt4pIzg5mTYX0tE+PYN+yCvREVmdgVvj0kM7vH4zCkXswAwbs1jxuJob/+HGUSTA/ZP56fay5Lqdb67WYDvb8DtOPklI67BJ+KKxCaDggNwNga/JFUIQwpnDsgMcsUtXavbqRHZ4ElbonydYX6GC9XYVaEGmgp0hvElxIC/CefYSgBviq8DKmpcJ0NObKqoFwULopiHbzC1CafHMjcc28Bno8WuZi29FwsQyLuWV2vD69s3+KpQZIt5iYvToWAqyzZD/aex3e0Y8Fukd18NB56rL2cHO+4Hf8DZ7estsdiRBpXipIaIqAN2cY12IqhhFQ4HcqCP/Z0G4kPUyrHBy20OA3Ls4axh/Ea+SXm4FWQ9O35vjgTAboEsE8d7VGcZDE23EnLMKzYwI/eOc1/focAo9fv78JbNX4y4lHdFYHf6jjKkT/WXM2y2qGt9s0n5BWd77te8PN4hp9/FB1Ad4Hn5eMZoLt/aCrWFxU0RvjEDDv1n/xP2OUr1CDWimT72ryo8wmuy/Tir7B2D3LS8e4V563k/6/uehoHRKd84jcmGwUBiR3fkAYi/9WOAjxhZ6g8Ce4n6u0QHGu1aA5cLGwJ9Le661RDDMR39nYu0ifd+XrUi7CiJ9e//oeC5gMwQY3xhygiZ9ELPFIoNxaQB6HTIt+MLS9yvYuIgTU+5XfNZGVAMUBLGTUgX2wT75Ljs0Zu8vmVXygikyapSOsWVvD8aiAqCornDtKh1Aktfn/2fACtrqZaHRh5NVtAjkYDucHMzWhHtsMhvebVtZVpSjwiGZJIDlSbgyYDRU8kB/89lohShGazKai8GuoJh8ZVgcrqt9Zf0JhHPP4RHfqkrpaKPwFvgoOfAvaGnP01DGBVAA9Gtx50yTCwCZwOl5+nzawMxaQUIhupG6JCh2i97baFhrA16YncqiNeEu4bf5CFLxawFjT4OiLdGjSNfEk8SfnF5zUBDtF3ryow+aChHis+9rKdOK7/J7xYwQ3Mw3NAIm2N0hMuMM0dHt2HnvH1EKek34aPSbyUDF3lGvh/CwEb8+MACkXSyURCn1g0OSrOZRDADk5M/jGg549qGuCRJfufL7YAsURq/x9/h3GTDVwOrkIWdvdupq7Tm4foF0TTWWyhk/uUyi14PIwyMsMwY1TlFYBHjt/cBryXClwHzfcqTHstM3R/ExOd7RP7G8IITvoKF2kH20EOqeQLGsB90A8Gqo6mhwBhrj5sb4U7iO7E0J8YbD4Dkmm0yoGvP1GUg7zhTDwLvEmO673UjyTbaJc9ktldg9yAWVSHsDExalam8GYUzkT4aVBLUusDQfKk3FSzOeTc+KQ1IK5cngGIK7B9H9ocZLv9T5DLrVGnhHyUvSRv1WMjZGUTpNJz32I3FuAiurh7QYf+Qx0FUVf3ZIf2i00xuG8k133j9TIMByi406wRGhja/l92scDxbubbNvw2NHa5n36/zO59hNUFfpJ1LR4flgwgMAwvHDC4T/ObxGQqfW+tQwcmxCLJrEX37EXts85Yl5Ydn8OMVmiIxlvO7A4M6nmRPsOV+aekD6fgsIiSsH4jJaY2yZQVIWgn/hU6OUS5mUYTCYqEoH2jBd3DaefLEw2TJWSXeGHgzGecig34QBR2T4aM+VHmehG5gHzfyZu6P2HcJlOKO+8RZc29zdx6mDWZnetNa1gKGoq5vOjI4OLWwVtnRE9LqEPTdxe553rqGh6I+YD9JI5Jko/K0HMVKXd0+qRAAV8YQEoNIz/mbmdCr/11O9eb13+TU3b3WJI8LzOTjkU/7PxABl2kcoGVROjoTPC/n8UzzD1zj1eY1J1F1JeNfCRCwISAcuVtQM+/yHtPTSFLxmfRa6RsjV2imS7N9h5ZvdyuZF2r0rN8lpipZYlTQ2If9LlJ/b5yd4/Zw3TDvJpvBFBaRqHx240xb8qZfg4eNxgmhDoypnoM1fIt6nnK0eAS21g+MHcDNrM08ZWibcPeUP8/ABmGwY5M8OlzhYQG9BpRwVx1+a+p2yh6SVoLlIPJDU+wrCY1yXPvFOS503YOXJzrlKT9F2pE2E2edbIX8zTJ6kuoJfT5YK6490kZTG8RUos6zWjFS2k48XdI/tSKlynuZ/kquK/wN7iL24o5SatkuHXj9yYMVF6q9FP7ovzzubuuuFpl+Zw1GnDcfGckGMwL8uo3cu29Qxa3kn1W4IM+NyP3a0l/pKoNIltCLFkff/vTM/Em3CAj+rX/SU3OrKeNWm8YASrTEQpQf+ampsTHnytrx6EKFFTjSJwNCz/QAqbOwwwgTSZMxfPlJa1vriDPbjEaCrePjAJmtZGjK3dXTXUYMv//mVJT8Xy8QqTTpPfAvuBJEXD7FsBv+h/kEsIj8HdBNoqQh5Nu3CGO9OYyNQGPKs8mn/hFDwGiuOGD7HWqvRwnyOkZZwexhl9KnKZT9QGN6Ak94OtXN68sSsjewC1k8LdmsRJlrpJscP+CRc/rG8KHuVejgWJ99cxqnkNL1OxdFXKqbsB6p8tse+yvgvRoXEFxwYQeoB0eWtoQ1iQ/gcJd5wkvljm4SCYsXUr56s7WiowsEmdon962xgI+cA8HFni0wJMsxV/X7TvniFUtDc/AaE3ISPXHpPsWtcJBzvsEoE+KeIgJRy/oxXsWXiMAX8bJN4WoRikeYh+pq2XxrVbGMeBUZgD0oCbCmkbCOHkGY6P12/EnOa7bVnAKlaqpbfYhAf6V27ngdmZVG1K9T2C2/UrP9feYkyt49HpJprZ5zSXwXMK1hq38kbFs7r3MWpB9QrUnXPVNJyf2T9etKXUgRCVce33tf4VGjmyvtLKXdJ8GMurK0D7HflnSZ+Yl4olM3fHfeMjJx5mMEudVpOjL/0pEXDXuyy3Y0VZ3buynBx0mgi85NFm90APWwdLiz6wJmft6kmtu2MB48Z0PM8HdT+NFKaivR+707Is5husiowbxPdaGyz11mBG2iI4ruWiOh15dpfU+/HzWm05cucTB2nxCkNN/s2vVwcrHvrINaeTPPDjgFqDIHZqiXJqGnRimdYJlxHA6jPeWoNmPFUs7Zadc2oC2QFJF5IgvVqQ0kLULBXX3E+6KOYKdCZIRyCJnGq9gslCqXeIsH3CXGaa/9bMC2N2jW5fxQ5dQc0vSkLsnpPnpCuEy/2XlW1W6kJAY3hbMJchOZXT77EFzvAdHpKKNQNfWwTOOeGvPO6PUK8i6MmPKZ+jetm8U/FwZvqsA3/iwhzJtKf2xEgqvoE938ISiyVT81dLD+n36ez4VUELGOwiLrOlsEFTie9fGO8Dzpyv0P3Fr6EZLVeIBIbeoWRXui+mOZac7ttm2aIZajn4SLQQu33TE9Jt0QOkfaC4zQ/czkjWe5e3N0wi4zZ+ENzy/ns8FDyVNskl/qLmkoWsKTs4SAf/9/POM3osJsRvKQ0/7uegYQqG7uzj0A1SedTLnqZUaSzD8mtDd4lujpOasrj+mvg6CbzeL+3QkJIVmPc2+pgldFeIiLSBU4DIvQo7cOmGNVwaoIFZ7YwKw0QwRkaYOBIJtvUuzC11zNxzxZXRnRbTuEwg48kEWb29IkL7fFLt77iBXN4NMchexjoj6tbHFX7ML1QPVtdG1vWPsT+90nsY6L9teEF61Roej6bU7Q7IomccIeXwdAZPyzKf8+RhUOj2MwiwQPId7lLIOo5r9ra5+TEabR0rDX1aUcAvsAaatsVNjt06bGDWkdq0CFioSC/S+kG8PesZNtDKovWyGAMGafP0tJXmLXfMvAcNDGN4Epp94mLVFCWDaPhuTQzx0KqFNSW9jcKsjMziPimWHIfVTjqnnbMTrDB6KWZIrVSx4MfRYrkLq5MgGehR2dBwMsXOrKr3oNqlAglRpIveGLjPMLSm2JUvp5gbE38ew8t5+g6rdv5ws5gy/sSOiDx5KJJ4qCzROrLjJ6aU+/scjuPObWj1p/Itsj21+ZsHc39/8+QURsLCtRX+JYfvCnZqjIScUuFLJ73Nm2KFipGHXWSqRVSyMP4ocMGi/xtjdpaf+bErs0wE7MWGxu9wkm5Abzxwgj66YNgSx9+Uz4iH/fScf3ix9s8Qnb1hB1S7xOddTREDy60m77jplWdPSQwuWtL7QEgh1x8MDhMLDm+znYtPaLOGZKYwPlQ/72vQamvS2631ZBH2z2ib7zrdzgn2+PQ3Q40Ol50m/TTkaVam69xKL3Iqsv0whyGekzwJFGCv115QrfxapDEVeLNyTQ/l6UciYTnUA+4GjIJIW77zGdFNGnGQdIt4qH0rtNXUhrcNmYQprlziSU8dAP10/unu2xqQCQIsB0nhlMqMr1VvYTEZZllA40y30urY3w8WY1336Ij7SYL9J9qsZvxLkGowMcRlN3DmDMM1NbqMJ+vDZ6UJHP1uz+2/lOfqhOLXLANJlRRwSV6mUGlN3cOcXQiiypS2hNGCSOyOtBTtU/e7so2KXoBbLGCXJo2qg0aVPN6JzFkJVw2CO0gbr0ltInn0hal2MsYoJfOyJ9RygsF4A2LZje1uGRY2mnmUxte2odUEicTSzlwteVYzxvykwT3CPi065yK7cUhRtG7Iha5DSrgzXbUo8Em+GTu8y0CDadJ/IRVSYOf04RgdGNzbQeWs3Ub7GlwsENbDCLqc2tnLcBAEddfiieHeo6mxxQ7EOwXedbHDQFzP2X4PzcqZ3mULGX86l1U7co/VmqS3o6P3D9dEJEIegHYYGUdMnUtV2qazXb1iiZ9PGklfsAfeAMwrxEG9HsST2Xiy4LTiLKDYlfI/g1RZWlPiu/eDi6z4UIeyMoth34EmvF2DYhSq2bgfYt1lAoWSswSkWEtLQf0tbjuG4myu6W7yLJawM6494VKjM2pIuXhAkAl+KJKpWhplWI+T5h1xfIc0n1kQWR8x8/aGYmraKe9LJ6ehE0CxgmmattxIXmz4pXLxqk5SgHGaj9N2hTb64wbSyOkBJiI7CjJDMyV3dcr63CIfa0YQd2WptYB2WSWlulFUPZGcHJe+0xjYlZOveprIhpe9UbQzu2aYnlEjbmuurgrhs4CmndQfDzfmmPobCqBrCFJdPOICQLjqnTcADdJmNp0uD7I/6LJ5t9KZUUVFPj+UjRfwijNcNIaDD2IkCWxbeZrK/ZdDSKsxsMwJzBz3GYVd1gVB2VasbX/7bLqF9+Kz59kakbqA4rPVtDEE7ToB0hKNazG9RwVqgKbJr/wAw8vfuroyB4UZcGdtACFwnwZ4wGWUSU3BFxqlTnXdMwpyVF2j1VEv5LvULPFWyD7fhLzfldEwworX/3QdL062V76KEQocijRA96KdiXoDDtnJ5uUsH30WvYfzxYGtgOIpHZqLT01uS5UmJ5H58SIfbfkMhLtbuON2xFnLdnrY580pWTPSoc1C+9gHkVyalJ5DjDPTtMyS1jAxbNw1oN15klBp+cDHo/2h2sY20iCxVOEIrOe2kKtwgraoqfAcR90lCC30Xr3VAZV6jh73gDwCalvEv2Qh5YzH9d217mhUmT5fy71awZz72gaHuJtzYXL6I6MfppoNaQ6+b96bySRsc+2BVXexVlFyhIVSXf905YxhR4IQitoHw8nGWMYTMLNBZ8UQu9MiWmM4CQjqHYwT7481X47d0GFKh95UL97/pXEYTEDLGivEvkuCwK+Itnpmt8+a6dv2HcAHSuIXhrAIJWE/w1DUfluRJ8eDVDGG5x7m0yrYS9ETY3sR6enoAscz6GNCDBk1jZTE7+MYtENeqteZYqOTkxbZtLFm5PZuqHM+gEmZ5xXQNQZysZG1l13g3ZS0RcvDXH+tGd70W3ZFger4Fh4CBxHUTBDe2MB2FeJY+31L62EvIX73LTHhsqZ47txfMz0DMlgd8EWn2mfRA6LfExLJDzTR+STW7CfMF6h0cE1ucBtLqpoxtFixHcp/HTg5CjWNqHvQHRCiLt1PCRHVJSBmFfEDKzHmiJnMo3gZoDRRE8TfJhBCaEQxIQo0gRVFf0zyjQRQwMLbPbSTAOhQSA5XDZd2ii8UxZMXFr+9KDM/n84yxL9mAwvrqHmyI3afOExv1O1KXyQv42GL3tS3Ds/BA7gwDi+KuLsgHeZLdIbKfktw4eqeYF+pJ1LDHFjQUpsTSbkbFG1VzuhsrYLIJIwV/JknoMevEuMijM1AHKMtYwr0vS5Kmb5APOxiv6QYkLoL0ur83Bw/EvL1Czn7l4j1/0/mkABuHdS4AGn6yekUe5jFYIexUSP2+NIjqCWkplzvz5GJQCJ2NnCLYSpS0EMPgHBMeOMj4Av46bVXFb2EbiOgcLD46adW9I2s93mjcVGCGpX3kIXl9+B+xJAWitHXkXQbsVBIZygtogwRUx2meFjXcL9foMCpckv0f/Ugjvf2YGFt2j+rTRtSvqDlBUnqmjPLH/cUjtzTXFU7LAQiD5JsCH3jVnft7WE7L/bQ18I/9Z7wiPZwmdZ/w0vu4CrVM8e/t/IjOGAI0LpZD/m/pE6LYZhGZEb+KTxOKvRxXM7ylNRJfllsvTgp1cOJaR7kLiCQEOzdpvGS4lHarKLtCvkY9JGECYdYx+TgKLCk5DrWYDPzTvM71AqOqam3VppvOkIKy1xqNvYbhGw8jWh07jJcm8NgrlMsIRPiS5Vh7kLkAzjK0AVdngU4d/7AiEa9+5Z05Yxe5w4ELLuhoE+y5EPZwrgZlxUpNh1Z5IZBlV7Jes+BbsF+uebUwGd/wicX9jv9/WHL++tWPe25acMa/clOTY0rYw4xVw4jAW8Rd1DI6jHnxp9ETvKGFKpC29R731diFqUQTARfWor2SGus7pNLy3RgzwxXnaZtxtSKxXNLPgMDukikQb0YuBxmm5bWV8T+NcR45dYS5aLkzUe+Jmwpv7sOae6WUYvGvMAQYSS9arjbqpybIzaPFrMjv17/MPcW+6gj85Xb1v+uwlGuoVZTRuhyqfWijn6/D9lZaA1mNn1wh0fYf2K8giNkjVoNnTfX70BPV7OGOu01DVUn9OtxQD322yUt0CUsAjMOwa4MzQ5fpTsL2Sd21SKQRmZ5w8YUlePeuAZex6+ffN26O34KkwotCr3E1EEyOtP1aVmIclyienM7KExO0T+sE1L+9Aamb79wej8FyIeB8gHcNougKcrsAwpDL5AEi7AENhNWfSQvD4C/TquZUX3VoWYPV4+3GVJQPmKSKYH3nQ6Ha1tSmRPNzr4EdLmpnUsTurR9ux5D2oJqwyhQgJjulRGiQBjsZGdEVsMiMGbfgQLazDqVQqZIAKH1DJk99yP7KSOVgYomWYkfap/1xwAWSYdImAzUYxjQUg6UlaRRvXyEEwYLzhEqIrK5T33d21gOYE98yiIlXQnJvXmoU8N/WTVIwvQ9p2D8hEAMRtGpVOxbFrbub3Ee8VAFSBvn4ZM935M+Z93oOPuEAh4dWkE7F6UAP4I4BJM/NhMQ9VPCov38iZRdhN7CD9Tv60yjYVEGaRXGSfw/z0AZ5waUaWm2rgf4YcXmazSuGNvIfMrDEj4p81gejwe5wyxaHk+AOqrWelmHZ5yJ92X7DSt4qjdmFrcxSpvcK+B/GiCpOCs+eBuIDsOD2D6lbaAnOWhHDQbt4oLTGVxfdYDOdg+p4MabW6hO1bWXxNcrMnasTdK45sL/8YLLlm7mKg6zFmfxQcMMcvrEkQSMi89OF2UtCXMDG1MsqH/QyRiV4id0geOmzW29+/zTkxYkU2Nk+az62biD4vYUubgy9sKjvdQCIoK+HWQUMqU/89O92giwR3xl3y+VvaaQ3UzfpAohj6KxpUHECPUHNFkbcog5ZNh0Gbpsp56gJBCs1kB+7fRPqAQQm2TCqoLOVHT+M0Qq6PbeqteK/WbfNHQ7UP5/pIBOhzSleinWCMaXsXFwpdMcvT0z7j05XyInaTJ7hthDOQeg8RwXNVr+rQvN7CqBoT332X/VeBWPIvX0aEG12mEpB3oVeammqUSqSdYntcvZa5ywb6R3a35AXzX6YzMMriSPCOS+XzrTTD8qLfzznqrzNSKQ3E4MS/DhAwgMz5QzmORy5KALvEYGuMUOLsyJWYc7mY0ESkx0is+9ipdooz6JADFn0TtOpqLaYjwSXXa+44TDRi+ZdVM59EfKHTjpyifBPjguH9e2PlkzxQqn2ZVmkZ4Q16OCxeic+mSQlgYsv3bJoL5KtYfvX2plAiMrehWba1ARG3A/8NrSvyiUs52gJ3WhdmPtmHro5kb+FPeYcUlnT+7alDRpPk/5VbB7S1IMfcaXFNM2nuODa6dZGdRAR79BimPmqLSnz4pka0OQu1C+MceOunjMdK5JrdDUf0xCyYm4VjBKsAzSRcm7kFvMC2SQ09JeRblsJbUP0vGpcW4RkzKgGOg7Jo0zKz6BMOT8mZhU/ZOw3HamTQFiXqBkgjAxYBAIUzBB5b8EEVtScDt0BVg35PIcDk5thRWGoJ0h9a5s0/F2cxtJjPqBXLiZ8jJ2v3Pd2QBGKbatjuM1KQYaU/M9A0sfhQ2ilRioExBj6shA2rWLESnGADc3Wi7EgkZ9tlF86JvAHlBSRq/Q7JPIhCshO+bYFZkmZB5WIuP0EHGhnPKC2TXVxZ7udNgk3GSAPH7bpubFn7KG3hCceT2DcFYD0lJW4kxGzDZ5bAJ3mnHcUfdX9iUTu9r9pf4p3kiPeBiZM07j3hj8/TK2s7tqYGsw+8nORw12RM1gO9Ikve2gQBvw6pscup85QzeEQuZYQZxs95W9FDkV449HkzZFWFPXlQDF9jMqzce/9O3HvpFTSnmY8oBuxqxj/umBrDbUpUcaO9zY32Bi2i/rlGT+XPlt3PI2fjVWAUfXSYxeIutULRIO53u0YkmlubWtnU4fC41IN4lkq78+/7tZj7cWL6yjlziTrnqz95YPohPfznSlhOs+OM8/I0/I5PMiKyR0w1BglHXKrGiGlyqZ+yzr8sENyflACCYLhggV12DDZxl2ydTGW56r4kdrSRFwBC1FzqqiuBg4K0AUmhY3UVAdzWC8FAz/E/flu2Lrx45JY04QgNpdPUN1uKKlubydNHvFSe/jyr91jCqWDuV5jOpOb2NSbj8187xuH7z2Z3EuJiLLxljKOgbMnhNrM9sZpmFcu15xOb0DL3vEE824dWQBiakkm0TpJuKYXCU3diodfljSdFKdA6fkCtAcqdZYCHrr5CqpDNrWKp7Lr8ci23TQHV4njMkb3Zdj5DvrCzxrhaIE0g2gFdtAYfF+zcPergXca6R+viYJaw4aakyhivq2kvpexK/ZVze2yBDT81CHJK+LSy76CrEExl23YcKJL79rzZBTCrjf+gJABjXwuG3F2YPjAOLII2nPkeNdtAIOMjHNVDg0QZdb8lqKFVPHY3L8dMrKZrnbwZ7S6glEIaclC7FTJcDg+F3hRgfxbF+ysCuxVZZQ/mm3atD/dw8r9aj5T09BTrUnHJ+wVAA+VVZjQ+n4H5d4U7ei3SQWSb3SjXAIaxWGXrKnYPATl59x9Z0BTBAuwgFWMuMlNL7kE6JpFsdqEvB8RkYEKYIms5Fdowm01aRFhu4HcsSqD1U0PK7gq2ozF6k/jpnCqDN0KJPsmS9U6UnABoeRu01iUmyy86+XSvIA8C/0t4fUM+3KaDrOF3o6PkssjTQh7weR+HFkZwJfcR0ptgejLz53O9N8ISFYUTX8Ul6f7v/sK/6rUnbOX5NjRCDAga6J9AeBJSbA73YEMYpoqeG143O2DM65/cp3iaNAjeMOBJxhV4u9FKeQrWY6NqNl0rXdCDswU55BVNo7REHgyoe8Y1ydt6q6RMQ0h/3oAOeV9Bb01w0WNs4IfnSlt+FXhkQrptat3HKaqdfViofJXxcqlXQ3R93qXvTIpYzb+hoC0IkBJBeaJynFH+rVinGO6J8yCdfDvXWsEWvpBV2gFBxtfjmMtVFhJ2EP7rnvymrP9sKYngL+K+r9WFjl/qw7aIt4iATUk4tlKJelq204A7AIHdr/GvDhAAMiDhv/vU3Pl84TiNnsvvxvXGK+kX5J2O7G1F5d0+FlMVUJAp0YobKyDFGsu6jAR27Cirrsyv09eO3AphMn+Fg9lYq/5Q4SQGarJoMnY3JU0PJw4h/KvNWtyuhbT+dD6mvVwO5YUw+gb0NLkYFy7P1YDS3kB/VMknelSk4NozuGtu8wCWrOZtVu4RfR/lrysAhGV4UWtPUPCGVT0fMmR37ZG17mVfTXwYb9y20EjoCNmckQDUkyPj/8k/uvPccWsRZLmwzV1sXa7bKHW26vi4tCwojHHk8h48Bp+szryJYC9NWMksNgdgquWtoMiLAEm6nNylGgRQg4b1qcExLFZrJGKv+oArfQyN8UvR5TzkYUOYaKxKNANaEz758XPsbb+PdRkbRdRP/nl57ol3fEBva8ilW/IB9j5+ns/HtVhaAqBh8VGC4oW5iJHFIwJDWenrK3A83bYINkpscrH6cL9OXvdRCOTHSMfL5BcZoS//0a9sXdtxKNn7quXmQ+7hyUSowho5mSh1PLjH68jNcXU0TFWuZY9HNQkxtkyK+HSGzZvpWoL/tE2nxzoA3oaVtmdSuOxmuOruzcQK5GK9YKc9WmN9q3Sqo+ewXjyUXdW5UldD1ZUTOjsVG/SS5C13jlfXMMLm7hqgwDFZFg+g6zQzI+OrspfGkn6w0Oomx+AW29MhgbZATgDpDktDgTA/+mq0CUDpTyO3TnBC2e3wQ6dXVxxLacdkyzcEsIAsHR3qIwDuBdoLA3ZcnNkbZlfRnWtE8Ut/ttzOS8YvI1/3Mlptv+UMeeb1OWAUYCG4EN0dcgYcN3VSKOnlhKocES5PGL2CJ4iViRMLk+4lWvVJreI8Rk/wiCHqtoC7igI9Z7k6WozbBxxt0gG8WbRSYlok0zPY/j2o5+A05i6SpxQTNfqn78PvY9lKZ3ptOfuo35TiZvkpu/8w7dEqxjSNDvKEEQVyuUe1FgYH1UsbRS0a7NNg6CxqOBevVeUl6HceXfKtTcjW490/4GCM3otblTdHT5bCSlopJyfVbTiR1QG/Ten3vhXI8rNNLBwlJpQT38Z87q6R7rbNQFAJp89mzxEqUH3tsCnqBwDnOT98n8WT3yJadOU2/v5RC0Np8YGk/8FqZLAaBGScoHWRqOmEjvyNfKzaEFfyy/PiUrYr8+nDbnjeYtabL4tNjXRQgIEVtbaeTmss26L+ZnY+ELR0BAoZSV1KvGij8s8fLHt2VJBW9qzJDfhXxSWevS/q3zXkok3nJtEyzgDyBhyPcIG2fiuz2ivJWxabnVChueQv10LNnyZ8rZpMqDxSFriC/ad23u0nqvNNEDjfeMVLFxtAacbDleO8eTcZ/Ad58dTR+lEwcdxLjBTM6it2dO9Z0TyamgH6jUjUhuTIuZMthucYNxAsfaz3O9N7BKVbnU/rCRCWmAsoyq5+Ih998zNwpiwvX/biRyYhcDQc7YtZn9bNgwK6gSlaSV5U4JcBhnEI0BZYLvyGCqx11STZUu2t0giyStR8DHNMShQZJfQe5tw9SiHlZHYJyZTPsEB1k0ZX8hzRKpw9tdT0kkA4WE4R+1BsCVLb33FzonM057QB+hXIVXVAUVWxrWSDzB1L/f+gh1ctpOUg8jqgKMM5PdHMAT4VeNf4SEiPx7mtJ4DrECUMvsIgnKsL4vUK+nCWsyHTm7/QbR+38G1QcfmNtFIPP4jc7fpuqXuUKjxLPvCNk4HtW5HBKA0pNIFYiP0z/Q5QaqcHIZNA8Yc5GGNdXbtp2WnSH/4IDnYhT5jkRMus767Mst8/EwrtOCyR698lpHVbTwF1KMjNUEidAbEulNqSu4Nr8btdTJ+P4qaABCXyzI5w3FM7Tgg77Bc7gZ0ioN/2Vz92DQd8FAoDgiEhLElPMQXl8hfWp3LAJChcDbHPlwQng8sscoT9I4RuJEG9eymC07uTSlVw1LRoGYAy+Lzu4agi//QtkdAwLSWgWbfDRdUYT+gLNqXee6EP1gcn+pkpQ7aqfr1/kRr1ESDniCTkD0n+BFCtpFL62M+ySLRjQ2kcW2S+tNGNLjVQi9Jhpt1PbThHXyN80GV75EpZSb6rP50jPdveWPVkKG7S7cpolkDeQlO68XgkOabIqVGLDxwN84z6suulzksFDYByWs1couHwIJxh9xFX8LUauOIdaQ+Xwf4wjJ43akB1JCAIkZXiUmPlnL1yA9zi9tAa2tBiBeMuG3TI2v4XtfPXrithRaK3rI2aAVM/+XDus6K9djHg9k6ZExneKsZuWh9PQR+DjXoLpkXzIEhndIGx7U3EoOOYDJa3XC85Sb5m1CM3OgURWwF/HgYl3S61JjcuiEjndzkJmwHJ6Z9jXXAQsLnUrngMwRwm3EQFl4u1Gp5byEmX/akzjhmbvb9IHZjbLUn2nnxOsHeV85b1tAAssuaS06fDzwrElxCfO5AYuaPmgxYLrcUE8HUBugtQfFFjAB4Zr35ZSJqVNPGYVJyeaAh3YdyBvgJ6W/5Wt7J61/YJR4brx9ptQUAHLCfARhfSTuMZGYBH7fKMvclLOBiaPUPwxZmdit1cr6Sh8ILR2/KhhtUzjWzk6rxw+T/01U6n9O8Jxe4+xjZQk6JjQefCNkZy4WOwgqF7dlGBKV/0EJCbgQu9fdnACxvNU0iYgidAoBUwC29jWJVj/38Gyne8sbe52GrGOWHsm1DB0LHX158odagqdhqsCvpDb/DbyCYXEe/veJINwHZI94AMA2aZgPkh0XsuWUjHYE4eFG0LXzxLO2NX7chNmgG8IFyiS2MuiQ6a+aBShqDPneZJPPddk6nngS4S+xWKs1CwMOqNpMqRDAq0p82jdRJg9Y0ZM8UTkawhjCgScIs3c5cTnh3vvGZ8MPGwO5+Q4F93YOisZvU+pLlEWwhd5WIFsDeY8FkQ9yVMWYdsrfTyN6r8nkxsUdkd7fdg0wzgraorHpCrBT6GeHi8i9vF88zWu/ByGvGDNrMdyUIOIpxIPAAZOApOL8QuFafDYPnwRl5Ri/w1f3Q3b7ZK61Fq/p22VqmiTNlW/usln0RSfcXXyextsShwGYotEx8e/4Sn1F5q7o1+GaFM6k2IKLLOG86EEhqP87Uo13XeqdVmXojoe0Rr/eeofEAY6oNA5LE3e54uYn6ZXtE+9j7fR2nqYrRjZqcAE9SwrCKMU1SJJ9D2NllkxSYUCr/L+FrTAm00IwJeVoOYa+keJcinhdYeRuTItPhKPESjKwxUHXaACZhG0BxHUJTkMZxAwl3hGT9DEPAeEDQtZNnB8b1r/IB7e3cDeXWt5JTS9f06+ORz4V4Vl0dcDVnHmleDaIgMQljBsee44DWOMItgOc2Y60Z4y9DSPq2G7Ry7tyWN/t5o/MPMxcUIxPcbDP1jXYgmwHaon7HPSOBnjNAxxn5jwaEsN1AzpQAcet2hyoWEvTIouaMAECGqlZsb+Hz5/+E9EFfOvfixBRHXxhF1DgE0cT55fyN5zHdMABnxgNrL3Qfpr9h+KTtOXVC2OhevHkZSpEA18IpCqJopjbI3JYPIJ+gfI4E/v8DKh4ohqy1Y7BYvt0Ql02EaS6fd44Dccav6ZvEgLCfaLgpkW2PTKz4MCPq+N6w6XqZzN5MrMciM23RvxFnFo0vuBOZYshkOAka3US0Hhj1WXgi2BzNqxKO3zI4DD8C/vtPE6NOnUuYYZp9VmWSM5BgwmzCbOwImgwfsyNVV/E8Yx4UAUsSeWmVXsRGTM7rksskEO/YONl05r1+4rdjtvFdd1urmO8WTPKfNQIxs9WRNqCv8wb0wasYv1ZZJkn7pUy7kNQYYPMHI4NL5Vg1d6ff9u8uTxlF5d6yTbH9J381A0XRBK/ubAdrWGGfWx2wi5vYFCr65Anjyguci2sUsKAH9P1skfWn1IT1R1n425onTWyY8RGBkMYwYXdYVJLlbxGDanJnVfzNea5ObA0AynzhTSx0TT3ncB+dzMYSPM3GKtgAd3TSXpRjo1QYGjt0qXecqOU9sY5O+fsD2W14m0WdQCP1ojXpRd9JfdoiAWt/gXjIef8KSEjpLtzpeEh0diKvxt7yvLhBUBhEXGuQlNFNtygadR4npDI39bd+cq5CtJ1wlIG8aje7zrTU3Fr6EwBGnr6Q1vMKTmQm2/kRG0IckJ968jr9YtcbVp+Hni+FIRGGMEwRiWKffMo7oOUT1I3Vu0AV7k2wafra7Cg+R6cnAbm1xWcjBpPDDAa2VSL16KkHqZH2ybSv30EypZgtEknsZVBmfYGLbdlb59pfK2JQ5CTHdMDXVYg80dER62YOj/m1HwVVC692HjVKGOOw0s/IZlpn6gms/3XrMEO4cKGXgeW994s7euMM+e9Ep+Sdbq2Z00aM/awjPcscajXENk5nLzDX5dXfKeBFA/7R10pTWTM24JVyyJ6sT3GsTwdSzNxCFw/xkUD9F+/H7FA8iAW9dcc9cUN6XE3SWhGMedQ+qTP4cfBp7kxeoImyxu/9jNjjgyISz0BNhh0HueZTIovPpW+kAy1wpGC+0aBxYL1DijP088ooB6lvbKzDk7ePjYaSYTdhbb5YnetAepmLkNeULh07eWaajP028mjnIn/fTOSa2IA6Qb+oowZKWJR0TFzQOesx9xpAgPmxZxP60h3mPrvh9z+vZOSaQndgM4UNTDvoXW0xYWqxbmMdo8vl61vvqXosnSqe4mwQbmfBoJaKaqUYRENqTcES7cT2BJXvdpCDOEPWHPx+M0LMfMjLN/Lu58BCko1ffu6HRI5ExgcKAQUJZ8/uiWSeffA9pvdTuc9SCR+kOlZhafBw+Lf49SpcybfQr4nH6bOCdtwoG+BAsj98IeO0fqH9InD1R6UErpHJJDtSggyXU39M4hLJ4N9TNqbfIKsUkNN5uK5orzvNaMSRiCAXHQBkaJ3lu5cU1/j4UPGkN4P+owFxwPgPTHklXZiiYHw0c0osZFY4mp/z48VaxQ0trLvo9FVIewhRqEv2nb28kU2m5iqXmFkqPYzt4jFusoDZa0zAu1ZzvYtUxnL/uzDVOMaBbbWetJ3Gz9tPiyOK/47u+ToQqQ9HxixGuJOTcMWFy5iXn6oFabAGdZ0D+bYMC5zOP5zcKHOIjZ0kAECTb1p+atEWN0GY8x7qeH5zqTOnQ8e7xhfs1dLzVJxfLBozlNORGSGF6HYLw8J/gBHty8PSY3fOvTvRi5S1vaxlOJiMVRK5KMCoUpqgj1ZdiKZJcHeYt538hej6kj+dCAiaL1rXsHBIzH5RL96Ap3MMCY+HvJxHV6DD1HufFeN1QSdMtQEI4xwSBUiUvJGl7/ruqDq4j3RoYjY45IGrkjZUtccev7ECDRRVVzDVwszjnf7hmIje3nU1UsHIMwBkrH8SJ/4XkalFdqwOsXgaJgh+yswn4/c412DDI2vUwAGN7x5OEnVpoirL7p/Jmz8DbwFItqP16a01nk6eFUMKEvgQ6gieQW0QwKydqdDMta1b5oGj1CzqIHDtMyWq3iipPu384Hvm9bu7lzQ/cJKsQKP6pW01CkIfJ1iX1/9fv9Ado08lCjwicRpv8MLsVHLBU+Sx0H5S3PzcQTDgSt9cPC1huxYUO6BnOCdEEu08Z71Y+fw7OkHzXCgpHxaaREpBfblNT3JOANg2ZRfOSyusmEt3cqBnoWVJd5XvKI06HtWhZNyEeLtDM6BcylwUUqnxwJ4WoI+mVhuJl5vm12DMaU1JWwMxDoMZoFHZGPzAHLvCfksnCBFPZ/LiqMZPi9vaScW65jrmHImq53LJwHfpk5FjyN66Q/OZWH8z4VOP+uSROEuekCVuRAARQ1vSnExkGHN8cywuI0nAy7piiMP9SKBucN7s95njxNWEV7+DOIJt1sOJ9huWlwaQrLK+e3iV0Y8WdlKKd+u1GngMg5MOeHXry1nauuiQ3cxTu8ONv4EJpYt+y9FpkSVa9o6WxVFMJ+SQi8Z/7UhvgYA+Yh5QS+hHl2JVMo/tdJo2xMyPA0ZvxSa50NX/Qc16vc2/NXdLZps737//ZMDFmhqgm8zDT9xSTBFhtHsXyXusenCpF2RnsGLK0d1+Sy1J6zMbGMIhpvmx3EgLGccqRoAuGluN4zendY8ySLhXjC1xLgPbkud/tFkl3TkD0XEutKMMXDq/4PumD6dmMy1q+yZ6/WbT9vqf5iyQ/LWtkkZqZlOl+0Qld4Ujtutm0DJ+8+QPKeWwmHfF3Cg+FbcDJOX7II5ptS+z9Nwn60/aZjoLLYIVs0coRZpxY1gXxen/l8Sh8kyd0t+Ck447o9AtE0je/dTnaNDKghW8KAwXxsPEEtazstAf2JdMF9cYYOQCk1vd3RIjvmOWE8DJZNJBQu6BdscJaMQKFLT7fcQO59ySR5SuV8cdESrokNpoLV/4O4AQMu6lSxCoFQeL5R7q5iLaNyCq2pLS/Adg1xWKZIbifej9y3nEISL1AwgPg9jsD9lWUKNe0Iqg6eZ9AgjuWsKN58+ucnwaD0CKEg2ZVbOq38vJDiA+Fhlx20bYyztqXydLGlLCG0cDypneEIPGl0xFXSRCkWQgzSUAEY9k0mA/8Sujnhe2lawIpVzQupHgd1yyOxJ+GGanN52dBaszh5n+gTV48WzpzPhqYEfcQTm9/S4YjB9xu47V8HTOFqK/WO7zeiUASYyrovRczbGsujxK5rMvst0rWFMq+JchqwW3ew9S0jeFw2iQgimqis/MTSdldyRtX7z8t2e8IyL3JuAZOX8aRiFSQ5w8zxOgMEnnxoZ3BUET/Gg9sT6Rho7zu2cBEm8hdZe7EC+0T9qGZ8xPk82Ldj3J9UrGWxP1mOhTpTcp62ot+msauPrT81FTcWpp/IOm8bNA7/qbpTcgXMwD6sdW/YG8i0+7ILnM6550tNP8EYsf80zpuqfZgrWL6ksDY4Tbn2SJWdc9NR5nDW9a0WxsDoV+BLHJ66rckB+Ttben2g6QM2i+q5b9tObcaBNYKEMbf2k59KYSR/Bg3z1M78zZw2R8gtNwC5HPDa7KjeuQP78TGghFDwcwyLHxL5FJYP7aRtmK2oREaPoR6wjlwvlHiUhoPLLRZrqEw1EGkzdTBhBDV+tk5oHihhyCcmQCESVUf7yN5TXYzeAg/zhN226f/HVH0LHKwBxt4o1f0kjNQXTOHd9cm1U1Aaso8LZv20AhG3b5CuORPYHKkO4ezi2IiI0StVNdg/zw5anfBLp5NHGfXRDHYTY86n8Ywm76PC5GXit4ha3GMmNugoSs3DoVGpsdnxNeukGW3PZLg7y468PycUpB3o/rliEuCYXErhfmPGYBHELFpeANhT1jPPBIzH0vvqItP9rSX4i1dIHmOpaiURq9VAeLAZryY6YDuRixDTZ+gCcYk8gGPMJphJbzDgudJcMvqnKcJvWlq+1uktV9mBO3W9OEsU3fh5CARDv9TI0apu/Uak2MO9o8UA6jFu6Uezt2k4gEW2mo3918gOQkxyF9ymnYTt2riHVDiUGKVNfYNc/IffX5Tfgr4FngqdMwGrqjRmJwNhRTTOeE0hsf+gqoiFxlkjPXuolS03+xTKF1gTeRcBRV7aVIHEmbELcnPun5uANnn/r+HflNyraNciaEola3uXeSAcHm2fnYHZeNHwEpdH5DnhWvWjT79hxCf2hOixhnAaLS3dvnEPFh6KD7pILNe2ee+cp8CKakKQRgXVTHY1ak/Rxt6vHKnBW/Bxu+ZbGVQgBTH0/yPCuSeweEKdv96KXgsc/ZayhP2hftRiAqizRLcnppX5N9Ah7JTxQ3cQipbyb1vYX0QFp18Y6l9TPz3vmLEL2gGcUKESfnmYOgs4YzRC6doBoGF5XkqMLkALqoB9wrTidU3GuqD0bEH5uZH5o2jVrLK5ujoKQVgPN0hI1LqdOj8Zzk2QWFL6QDxfrQIyM73XfFaripbldVa/nzDGeFIXpw6ScUZn5QY+UZRgJ+hd6j/CSSUtswEkjAaY3bdwUzNodGP4THM6+M0LAtvJBwd5f2WBCQcdswtnZ8dbpapgTflGtydCYJSLWA2TiDQI/5d2gpYGT+dw79ln+cAhRhcmNLVbGBwFAteIrZq6L7OCZPcBcq2t/QXejWv/T8oQeZZwjhrig1fcFjzvk1FObhHGWxsE++XNv7beYrtrQdq3vXugugh8PUmttxo8FAzBHO7gVowCNyr6x+lpVbuqsoXFwYoQEqPS/EbB7eBdQNnZrO+DmMwhyHwOY9cHOGKndZ7fq+yI7kyMHQKFK5XfwToT5hr7fGBtSrXhAjgb9vUA0bTDq+iepXAGM4Jk5BY5O1auCe8YAKGaput4m3U5orxiBlA1yMOuskdICX5uLleQ6kaYlHuhA676NJZQx3RoknSZIIeA7yfgXDdhhrXy+99O7pV8ZG1WDhq7oWQI+TqNYySzbafItmyws7NBJ807a5jgqY/cewhYhcw5TQ4mw1LfqmOJWKNY5EmuB+VkP+5J89T+cWZ7R40Zi7iS6+k29+r/1ldu/ehywww6s1cVL0I8PpFcYJ5vy0pRLn2y0sIqdiy0gytRkZTnezG8HI2b3N36CvgShsiKtGoGGlqX1eW5sy72YzJGS2OcITGjOtI/UXDUr8LLXenVfiLwVpX/to8pUhIFM/x5M3LeVZjoqV/h3m0fqRb+TwATlp9elPKa+nfVezftEOu29uJ00ETBwNQh7M2GPVQOUfT1zMHnMJ+LyWo1lHoJ+U9aUU3g4Lw+jaQuPnx0+iNSpbxJP6+mp3WgLQSJ/OjHJONyFFIoprlefoaR4USZ4Cl9tDu8xyiNp6vS8tt8jBGsl+KFjOdN0xegTzv9WhCfQ7vN0mhEm8F0umR5aVPhq11e4eTc9nCK3BLuCh6VvUlJLmgVbhgpMSFbfwDHcv1Dlpm8PtNUw0dCQFH5phnQ4RvA4llNGo48Uy9zl1HIEwihQztjLmpZSPnfbg0jJ/SoynwtulpQt2ryL6qGHHpvOQu/JjvFJMGJoF+jhASlX4/Pur6SURsKhWMTShAKV6exx2F8KAOHXyY5FArfwNPgHGizrqKA47bHxU7zsPpnfq1TpfRU7/2I85UnpeBQb1iTs7PD3wrOLgw85639YUzLWgkZN/Yv/886rC+N9Cne5KlTz6CrwcAQHRfdEvtNha4ws6wikxMkcy55m8xFvIb2xtRGj2y01HYyT1KRgoz60FzPItMiQK3MeGsAMVNITnX+5e4DIBR3vQ0D2xrR0ZlT1bH1UMe6ZyYwjVMy3Kx5bDxvzS1iVBG7ffh5HJuU5MuZbor9i2mYlcsWzyVi22I9+G3npXkl0D9kOSaecH6yKhASLvodHNFp4JhL0o+S+bR0AhEvAUcJKq2joiLi7h1gG2b2m/0OWhpB42TakVxMBLjLoIhs5Ychk2TQyKVTZfy7lcwh7yua5JwIYOP2mnNNMbQRwHDAspYJK+1hMH0zcUuvNj6CPSD0xQsfBjcDtD+RHqmJvNAzo7NhGHD1R4L54nGOdenqTVtwo8PPoJVCBUE92gIPNJWCnoOSXXR12JsYCpsFpAuaWdL///dr1Qn+eD/fn7O6q2+dxgjOzCqNXRHOMbOdEiDKLn3JS1ZBHsED7Zm6LNqC1oTb8rgebC40QWwE9KTLfNLPeQqZDX5wq/Z8wozZpx93kJfPEkJhYIoVNh28NxBmSCuvjhSc/BNIIiKllZUF6riiH9ZWemoG7zE/Af0dpTj12SzoLO6ErCc3280Hm8F3ZOLWf+w8wZUXoEY4Q5CFy9JlrKW0aaPZHgFe9ZNARy0Ht68XorBMSYrBuUSlNP7a2++8gBvP10YP4hUfmxdVKwrkTcoj3Dm6tdoFSS1rYLNWcGrulCubMURH96DQcbE9UOQLyp8X7oimFvDujxRlOHZSeXan3Hr8OXn6jrF1eApTIp7N5nd1l1P052T0/oGBlF9aBujP17VCeEa7nsQOa9sCYN4RJABalSNP20+Kh6DzLckFOxy8JfV9rIUHaiEAyg7RN5xN47CK9hMOGf3ooBkg+u/Ign1tN5p1gSw8ByufnFYKcQoGgyMGWUXS50o66EEo5+5vZEyxOx61Pz+WIrwm4yRCycJM7FQ8gqV16AGKa0ePUWkPPRN+EP38vDurG4lq7OrVO42z8Hqx7bfzHg4XpIiJRc81bkL1BEqj0p2W2u7pqmObrAAHofXjxZTDLP6pNC9gowg+rwV3tW05H4aKN+We1rlCFf8nEvMEXwRCMRu91m7P/LoSxlPj5mMLiBo+AxvRXsny1NZDT3tm6PBK93sOprqIHNsby9hW/4eX+XZJMPT8zBOnsF3jTP6YqdT604Vv6xP6/KiZJauFS5ky//cRa5i1VZyLgJiJ/nNWZXllaGYa/ZJojIm6CDGa5gDvQPOB9lX/66BotQ2GCgze77cGLVj5nAhKYK/dIr0Fqt3TmBtrYoYhwiWpLbjKCBOpllkavx8eFJN6h0yZjctV67hQCTT7OjP2gVWO5545iOkx0LIKHf5PaGUojWuRyrHscesoHl6828+EJbtehImc9+feeEt077TqBnoWl9MF81CGskO6Ckgjx6j0suC9Yj5vuI6NwJVMph2uKebCv/SaxFho92yVXyoaoKQJH6i/h1Zv5YNyGR4vJdA0fPrzpRaIQCV+dPlp8hWkc5ftfQLfSs+o8O4qwgOmWduxw5IFN/gmnwP3b0mSz70oiPjISHs/Bf+zxQq22mSG+OWoCktzEk4gtyx+fRBdcIXZL8ZIWQJMK8Bz2h15ZgnRDMIht9dsKFQVjjs4qhm7yFWxCS8SaXWZQJZqG5kWmJeAst4BkxuT3e59xH5Ex6Q6ouCxPtgKUrLUDCmdb3vgDqdxlv99GPOqSLFhFzOkJhJtoQgbWpo4w3t+GHHqE6h7CX5gmyqxRp/SRzghRXKc2AGhmjKfvKpe5jJIHCZVbplInr18d4jsEvKPMLT8fHPDwTYOA82MiK3K+z0YBN461/QXhO8oMAM1EBeP0E5+vNPnWrWBrisg4p5/+WCCF2J/FfUwyWCQNDb87mEUkbD5xvMtaCdM61Xlk9s/qAxZt6hCBWFpd7gflrrTrxvbvxazdgmrpelfj3AkXhN+MWly0kkq2DPI59xL10wxzFkmsSiJZcO9VTcNmjd9LYmvjvQ85jxMxhCrqvDNArrj22Hkm1CPGur7cx23m+CrCuCaG/9Ws396QznfR4dpTMTwRIsZgJRP8ZaEyYA2/REzJoFp5xIiPYqd0eVyYs0yMmrW+RHG3zoYGAUr/lFojSTsRJJg7Bx2PlalLvdOtIJ61DQDU4qDWXJBCySSvmFtLiXderMjN2soGO9Ayz+spJiEHpyJvgdzoagfDJ03S8FI9Ps08ORuRnsY8eywHVG5zXUn+nJldni08SE66p9uWYypxe0sJ33bpzlOCquXQZrpwUNOuZXREDFXkBRtiL4LiY+rfOkCXApbYFeZFnyQZVqxQlyURwSeNwWE1notKw5N8xcdkT0hxEAubULRPo+bzP5eLi1cQbYCOI9dfwVNKZCzeCV+TqZo7EM4db2EzIYo9xg4Fzgvbubvl1QHVlKrfZwWxYO557rTWIzJMS92jJINoQJTz4dxMvSUmC8kiP6Shwnd4d3RwnseubaWxI9p1Uca48OZfsN1/Z4kZDSZvWSgY2PvcEi3Y+oQZHMzwprAH+W6mePoaj1mXsoe0agyoW4ezHrucumj4enSarTGvctVKg2Kz4ZYFxk7k+92mct6jbWN2tWEB5n+o9C6QFdQmQ+oNmth7lyrwQG8RHrnFVz7lkfsHz/RbdAhl1+SKNwInoqEokwaLQ/2ksyHe0WYVOUtUPfdGFbGB6eIe8WXr7APzCy8egw1u/R8GSVAYirDqNLaR0NjFviPTvu+WuZPCc0Id9CkUAQACtS8EjSTjuQnE2zfWjdJR44dVQeAGX9qttTADkuYT0gqOlAkrlHdq6reX/vBP53h9GZ7RTNR4Km8IZmeRtNwTqIIjw/SLuOeKl35DjPolXPz3wpTtfk8DkwCe6TSGfMMpur49OiDKSM9WNj8RR39KdV+CTzz4VWakL+5TttWol1O6AOK4VUu+1qZt4LoyqjD4/f47/fFeH3aCgf+xJirXtIRIomiT46qOLZQAGkyKGs/N+rGt5jwAE74+kWKMW7wrCvFlQCGuhH1BV7GWI0WYmoCEgzcKqU4/jLznKNmrB9DaaEtxJfZhGcKee18XQE1VGf9kRElud7q9gHvl171VioVHw2fkuA92wWybpNRy2+H4MHvX9Qd8ZZ8yZSsRBxSLkgaBrfO15gzttC+QSdZDAgZSsxEjyiTRxM48FfnAg5tUd9f7EGI2Z++ZdcxepC9EqYTEiSayLP+BgOUimONZC7+EK3Mf40UGBqsTxeozOVc/vH9INLFKeUYoHHZLQl7xzS+kps4WQgkYeVTJx/Qa3yRqrrdRH1fnU9tS5zhLqSHBAp5waEDCbbd0/cIswd8QSU1uwVP9dpt6qujbMFQVjlaMMQnyTaY1fzsChMQbHA4bOwf4ybPgKuWzAuT+1Lq2jG5V6Zl7qxX9MtHIVVqR4EClI5sEUlwxVGz+gzelikOkvO9XNOEiYNWqOlxq7sF3VRXdm7klnQcaDZGmxaMD9fbCjIaqdeGshxrRHg+brSz5HDg9eY5HB96HKRIxF6If4CmIxat3vHWQjD0DLzDt5NPeFDwIUVXC2NLbtjIXjZylzZbGaNOk/KEy6/2UMBsUvgxXjb6DSAn0lUqH2YTtkMkY6434VGMswvBCPnBNYT6GR13iJ15orpbj5CQXE3UxrgJMgrzSDVDnFmZLro3rmmcW7t5Q6VuVwkgFR2+FC27P7ljOuNodP+JQyD3tXkupAsps8sXZ9m+ptXtXNelNW8b4y8q3jBFqo3beTFkp/LXBtqWKrnrPH/A2eQd/q26WMTt5fHCZoQD1rZB81dkGFhKMsKtfeXW8GQthdRhLIJkpA17/pgwo28uSbalQNIEIyUFP8g12Rbx0ugCCO97b8GXQ/+tWh6k7FxB7ALb5JfIg9btwjBtvYUswMY6uHTwpVLbR+MaRS89uDhn+aJV5rqgLrTQHxu46V08e+PmC6GNif+hr2C4D7hJHMngVlGs++j9OVP1fjaG0qc6vsNv9+Y6mrWnb7tsmFjZhFzdst8wMJT8iWbYwYof8cWkprK3aeTONXx767SqAgpDZGuAIS8HmFat3i9XWjygZJqFFche05BxVxsIbDBgIPpusO8xXVv+S5PM9e0ZnZuNXO1VEy9r2WhKQMoD+wt7od4BIs99qVeEOZZUuPhCRveVPVKqgHMWuLzCUgnJPw3Se3KR9nm7yfLOYadkGWLjQNePLHmC8o+jE88cR52MePqdno/tH7am9nBeSf6TY6bANZykEykMjcZnlKldn4wiD7JIs2kB/tc/nKJl0V6Vj/LOe3+rcnFHgzbGMe9IaQWDXeHrfcKRb6u0jaixiZQUaqgaeBpNJ7fnzNk7K6Jm/EHs+qArdWI+uB4E6mjE4mN76ZGUvVdrlbYHWbS5AVN2mumWjz8THzQLwa4Gs5JtLCoMpl83GTyJByqIStgSZbEbxy47SO4ramQpZu7d/RuK8yTxSDeGtkEqPKFe1rHNu4RSCLl3QpVYI9hbXU0Oa2TgsqJeNhH6O22kPL5uGVo4jje1m0Sbwgj1UueRZwii4v6sVBZ4uk16zk3QioQ5B6KX9B1n5hOHEfT2rXD4QWLL7GtSZn2NTPpF9lGCgooGSRxq7n+3cC6e+I0L2F6p+5j6JWAa9rS/3pHYepNLM/Kl2eGT/x7XntpSm8PXQ8tIM+W/YSPZg1SghckDlWZDrS0O6DHGb31X4qJ/xcQAVr/yOMyWmjItO6hsKNRisbb48ZkVQqN+BAVd16/pi6+QFEYYESemPpPkXu8KmLsIn5VykP6SkbWUciNlqdc8SBnDJLgFyeoqrHQC8emC7p6RzKwn9Kbd5K0g8RbaqsYfYnxDvk60XFdj+iXg2b7J+0ps4WyJSgOYwtWnyKI8X1YMGni4BIs4mPwfChAKINuSFEYz2ea7vnA/BDfSLzWtDnlSWH6IA37bZbHnrvV4LOBMaWUwrqJJp44+bnXNxSqsskcIWAWITpWofLCaf7mhWrXJCZybQg6hBEsykZLIWCvqQr5fFwMJYeHzxJNvkPQ5rgzvBQ9Hd0Blr8S436kkJ+ZwXtoq9PNih+K64/p6+XQecAA3o7ZhJK6zmMgZcwiTh20NLYkJuwTLtBQIhS2RnoNiE4KAheIcv830W13/Y3KoF9VW/n254bEy95HJ7HxAljZ93YeHzYnXJHKkZn6f3QFij5pg2YsaqucfwIN35dcdsAXpaoDW0Yj1Tc0C/zyPKpfKBkjpvXm3gVl0u7KeEVHbPtqOhTmfoOgBxTztR22/lpaYaVqAE7uWX5iN6oAzK0Iane+6wg1vmV23FSMw90PcbjupHaYetuYvGu/xpJTE0chsi17jQGh+B4TPA1MRB3J3Zgf1efC8Lc3hYoFHPCjsiLR3WwKTdMZ0vRyd05LjYoOl7EvdeEGQ/CBRTdKoyxSsqOku6aSlPOAjgZjf5oD2tEQPRKeSfCypEgaKENYlpyE2/TyF7TfG8+21gYdYTv4U0QqyIwyC5cj25eODi/dHWK7IHm2lcoxvVXTZg6wyH+pM/NA7kdz06Yvhy3aMph6/TNwT6VxBZTjNqgaGCmvtZ8PoOpg5FroHi4tGSw7pHeK1tBjpTkjJK56m7nVFMMr3uuyBZWg/RlCgOLwPJFU0dsK8SW8hMTLp+6Vy4ySyf7WqXtgdYJON2KKIrNyqJB5w0ju8mcXLnQsjsbFxTGGPg13rDsCVuNLZghedN6VRGOLEIQYedBZ3cF0yQBSK7qNBQw+uK3jjzCummRBLr3FpWe+z90xB2AuQvJYsz2qTjqU4S1dCsGmc4a9mM3NPfxjpUN4kINnKJ4n4p1AJqwk89Edeal9s+gPDV0y1PlPjtqyileflQPyeDpnkWwbPQLzQ5/V8/R4LC97PWBaB+S+7Vmcc8R7uiQzi9lknXUrBkjLB04m3LEgdGVwzWYPAlQWUKZV6Wiakkx1T5OjFvCrua8tpN1OfcwpFghIQ7W5+qeQu67C1Iq9qCD5kGWrGGqiazmIOAL6WuR5H+75pHRMFGvWhvINndtFoeq+UW1V4i3oh3T7qaQppbTEkcBEMJMM/bo98VNZW0sS157eYVCIhBOMViNjBd3cNPucnFLuqJ9f+1IUddyJgD1RF90DSz6W9ata3lbc9fkaarR+Mur5Eqr3edc3kOmkT5i7NNgTCsW+mShl1nR2H52hezJ3VIJvg9V2JU3Z1xz8uD07OzCDrDDGIryAjm9qPE3g4DwQbLPrHs6YBD6ENhykCOrzH+mku1qnFuT85jqH1XiuWX0DBbeU8Pw+09Qv90spoIb3qLfo2LV2CRKuT8CmbwOgLF7oHd4/wI5dvKibRHWzJ7lRoEzdZ4sXKYt/N+LV1VzmWHPWxqe97azmR4V73s4sRHC0qqGeM9kQCXnMe3l1L7pXB7cA6yFQjiYXbJcQoegSTcMSL5Xw7oBG/6DiuNpaRATIlk856ak5vyH7T84hncBudF7QSbSIjpo6dt883q3bjQuOm/hW748NfEBSg8lfWNankumZ33HkNxQywYIDYVevJFshGmTXMjV6+tGVNVZIvZw5BLA0VTASnBpe3kuVc6N/e11jda0scSAsRfIUhMC/2SZmbKETd71i+czprMNxLbAgMpiHAz6FAKvfCTLL600ywAyxbAKwFqsLKiPFerU18sgVXcz5ZZWXjUb+lM6U8dQa+YXfpBUzCxyuV89guLLGA0/fiHMHxCbjaxz6/fuMX3EhX3kzvyU14Rb7eVDoIC/KDMvYXgj0THwn4ld+PIznx6NXJdQjQFH8IYUYOytSfJdjLdzn6GFWemQmb6fgVmKZPA5bFiGq63p2QIZH6A3RPWFwhSUF9M5zXukc9yK1kjXogZhpnLEV98Nl2ZVz7GPnWB+7K0igb96ouxlhkIg0YJpzG6JKW9waSrPgJDj+IPnHDv8uWWUIIEZmOQt1b4eq1BKWPVaJyI5lZVvpHTM36xPHii9lQBDUtVHoYK/r1mRzo2d+KSggi9ukZRhl1IzDAkBJwsiFgCxxrhrCP5fcE0VZLZFf3vTRqwLseaoPTH5mClSgJF+F4nVxg5HaY4emIbAjxA0yGud3MmhZLpb1xxd5dbove/0eHUQ6vheK+St1V0q932h00hI76b2Uv/xccs7+HeSRdWuYr0//Yh96dQRJFlDUMrJB/1fS8qVvNOsW76L9SgXF8sEVr++E+U1mOYwMhwsAhoUcWZHWbiwdrLcOm62Ih12b3M5kQaefSFxnUHIp6Wel6svPge+N+apVY7hwrHgfbvL8SBHA7AoBWAsjpJ4UNkmeSwJCaijsilkj9EK8k8KAKQEmrGdNtATD4Jj7nDANFy4y/YPzS5cLimwS/EStNDq77Cg2KYJed6971W/BODjQDglSPT99GOTwXV7amZlS/5Nu6QyXezEmvROJ/e/lImcCZIiarisl1jfoCww0SSSbSEqvldFCEUdcxDRsIteBjQN9KXWf7hXnK4uss8GQA23q9IDNpY1AXFlGDcgJTUCn7BSUmb6NdM+isnGWTC29MiUYA3V8ebfy2loIaRoB6A3utBq6a3K47UPH57E6HOIkau90wQZl32P0bqkhzkjPrRtY+dDsKVG5mbwmNOIEjVZuOpMrtnLfkQ1L9go9OTv//3hwsG/8uTn0woId7z+AseO0dZSiidYIcG4WBZZdfzSH0Viy2aDQMusZUnv93zhm07y7ZSucHubg2z9kn1aB/eJAahpyahctLQHCR+vgFKNHf4CuhHDUKFErQf7hFt7N8Ugp8plOCWzanxpwKCiLYk6QCWxUL+ZqzgG2NFGI6CZ/FoY7fXGNcKOmXq6jP6Ckrp92/I6UY3YflR6gkkzouU5RCXSl+YGlp43TOO2+2dRisGyEFnWS1tuDSlKU3AteiPOyYww9A7nzp+iTV1p77hb6CQtGz6Snq/UhN6/p1q85YZlsbT3J2xHUZKXczy3ukRz/1bVmC6HWOjqWGTEVn+gdehqKCKILErU+XAk6CvLUBqQrtiYWGr8xt2OL0n4Hxr2LmY+VA9Q2sg3hW1qVXV7MJUE6R3PlrxFYT3d+d2yENPdezEJ7HJCaivt+ScRj5kgyru1iCOVb1Y2q5dW5w5PP/o41P9iOsOmvtL2h9sRqUaMdHOMtNeLrYNwpMTcFccCggNa+MW2BueeRSpXH7Lz2G9/mu68/BlTySM9Dm0oo/TD3lY5KxvchhSu7epNp+GLWLtlmuo3/c1q8IRLRDeDqUkeyb+o7yTNiYiqiLUWvIZ8LlQxqh4WGKFWrqu/zMoRiCy2zd+k4SSl9hnruQeNxxelM6G8LXufPjOl7q458dK1msqk44LVmFby+WxQ7sPgPOd9RD3oK+Y587495xttALYPnCX3ZXURTtXCgUANHtH0L9vx63cEO9mNW7FyklRVy5ykcL71qjWXq03A34agJVgSQLlayxjaivHxTlLSyZdUv+nT/rz4g6UyIU6mC5i/6pnKq8RZFs5sSy0ixQdG8VfvqmxQgyGhI0Rw2JpNqJokhF/fr9Prpd0LrdHMkaK1hJSvxrYludmUbBWHILJh4eY9gW5xMaCwqubMot5eL2zYMOKNcCuZ4aUEXRzLB+9ulbicAbzB2VRNg64U75aHWNy/rgk5wDqRup8VAMFyZflJO+yFUSmLYIJDOcQ3ytYkf07jnKyQAlY2OtriK5evNemMlby6+DU1cNTQ08H+vBeyLMI8QuEaL/Nc3Wb/9l/W0IUiGYObcKZPf2DowOpzQw+ATuo/eFncWcPtmRrhudPpqjZTOqHLU47DC2vNpyMGP4rL2JVRYRKyShR3j8JNWZ7HMvyYLpZbbzVID3NA8I+sVnoz8es35sMHc7rHDqeVpej/Oo03+BpgXXDDZIvfG5QimasDz6a11aUCWNpuDrjUgJg8b9wVliwlaggxJH1M9fYN/oLGWoX6OBOuO2xAV0Imn1rNeAplM7CpoH3sBv2DtgsbkNwMQqO1J0aSmLZC4/YUX/xZ8E36/Hbn8CPiHKIL50zuf31MkeKyI2utjAio+rpXeBiiaHnm7OpNBQxtNP930c/vtziIveieiGDARnvSWl6LyGO3hF08pdv35kLFI3u9vsH7OrVAiZNLs/6Rhr1LebrymKaoMweVOOniAjnVjcQ0NCTCwrEbrZ+RAH+mgZAwxjl8+tPDTIm4Ggd2q12ElsR/+IKpDNpzseVbScnrx0vaDMocyOdnHNmv1ZhL9Jg6cH6JlYntPtWb5ZFRmHjheEKgQ5ENKAk7n/L6krClZLaBQaRWk2j73SdMtxqtPv8PcHmnHpQBvqpj6M1qGMZSHJGXEwgvF3984DgGgMqRGtat51kzYr7wkZaPit3YCMeFJbCnTiDd0DuNIAcjedsU+pQqKUjBMF2khVa4+oYP1f9Z2X0uKjeXpSYh1CAsm4KmbviD/gTCmev2gTI6YdzYaiZGWb8HRNjHWgN5ZgsA8mDRD5r9t7FXoDhwCnadLRjZFRA+RaZKLjvVbnuHe3ZzqWjC3alJjK5nWbOLklNbAGPJkd0Wb9wniG/ZQvXBjcvCdC9D7XJqd4oHHB5fB5cQmYty/PDXN15Z8SjrRi+en1PkhK0uo/x0RcM/9SbjTY7GtJx+cQ96MCvXvpVWI+GGuzsTmurAY0JVsLgFBwPOYUGCfl0EkRNZvwdvt/ZJLMhPXRBSWnE2PHmxzQtdA183og8bdjwrNDCmpirQh8EchWP1LlMIAVt+u3thHm5lxeFKKCuh//+7/wYq7HZQFhGNleQZapoItg45+WXW1J+WRW9hbaXSPJRbJGTJNPKzQxxdDh14L/l0+HlVk2m7WCC3xZZ0qRDy+XQCeAa1lfFaNoup8qfH/+aHAm3lnB1C7c/9a9PjRlpQPyPNtnvjODJsfKbxpPvOWpF43Km9zfbpNWhC4tqPl+AE40px/MQ3se5wcC9vHl+LwDPlGatXel3JAi+pJKEDVd3cNSG9nPzL/sY3WTdXoYM1ap1SLEdHkYNXPK3QCEtshlY3lF1Ze34yIP3uJT3qLjl4iHZ3Ms9Ny30QV7SGIAA0E4ZTSUcl2WYz9dVc5fWf6Jz60DFQRVV4JRBuzostekRZcjFkTqwAcviCsAm8+kIuYyjjwODUeO8SxKZ5u3u5ujGSaIjvp7kKKLrEsrxwjmEta6YGC4T+N+hg5E+T30mJCCkt+9+3V5Y2ueX/s9wJla8yEj5KBxxOAexcEj2Pc//i18jkl8PvalMaSh5IRoDcr5zdmQwx2KRF+HLKsAfuNh6qTS4rGtsTgrq7bRIIM4QWszIGzJo7hG4w2mThW3KrSNGGszRp4WolAlDSucrnOmfcfQ6idbqz8WUsNJID/Jkh+RPsMMMw6eX3HZfYfTcfzUaI2vY4S+k6ey3J+O5BKgWjOaLVIoEba8n40cgY+rSFThCTtJPuZxinvGmcHc6mhEau+NBHgrP/zSkypuA86w/hN551+2abRfmSVoVFYOHUITeo8o6gGz9FAXTksPiUP779LSQSGwJGYo7LipBLHkNSCdZmGpYbnje92WlCLaYpjodQEt/F830J5qa7pgYz3/7pNuKlP9YCkfJ0OnsBqBD5ZCL4pi9CyJBhIXfJ4fv771JjsIYEYYmg2Y/55KJOGZgdzm5x41q7XrFHNtsby4M8/aewz9L11mmZORjDzb1B5Iz12nKU0HhZcN+k27tJu4Y2DytxeOoKz9JNh7f0dQEXXsbxIo2TIH0nsGIsVDupE6swrJO+xnF+YNadII0qGcS7XxzO2ofu6caul50XgfoAjdTm9fbyctC1gHed3KEyj1YcKu9XTAPb8GVO/EW4r2MY2UQt9xfDg5SLIkmCvUpXvBPEiNRffrQfqq+SBlB68HWE7ZrSMWcMx8zyIDezyOPS80VZ2kQDzSw8X9HRNkJNp8XzOi2EJl97NKznwQ/eckZK5lYwJexlrqUyQYWtweIlr8bxRT0MgU+PoeN7Ugf8DvhsZUWC6Z4Z9vOHbYDpibg7tFcN57bHOGjWZzW7VKPVmoNqpF2DHwEDfB3E0SiCB3tsmVgGPBAPu3E3PWMn2BvW18w9HUxtrcUi4IbF84J9yI5rkY7pQVbBZ/YKFyApXFrHFZgNY/N0cA84vPGNmuSe7bGXUtnnvmmZ5YAzSgOatdp5EZRStjTfw9xP1xOOlCKvz704A1QWDsZyH2D2bzDz13qL9ww1Rfh1pxhF26rP4Ny2+cIyjGTDkaMIipQ2dkf3mZlKeeKo5pjonKtWoJpX0kfcArEf8mCr0q+wSuIhDX7rLa/aX3XFDPcQX8qJbOZdv3lp5DpaS8mLRUJkv4xyVIILaAZ1GXc4qy+21bw/r/1l2zqBY3jIET3qvniARIC7IAg0pSW4NMUtKnbyvmEScuqXGwGiwSYY30SS1V85pbHTYPdPU0YVeF555I1U7M5S2P0d8jhXuXsBMJtxytcCTJcCMqdBQGoCOSIGVVmOanZRoqrsXwhXNRgCWq/nY97504WC5RVBYpKg7K7+DH7oE57O3JxJERg2SDs7/VpnjOMA3rCp83AUjmMWEQ6p7V/tY6k7N2inidKMkZZXM5HG+9fI6BHd34e1nVBTQtmrc5NLAoCxtPwLoHHkYm5C04+aL4pyok2BkAxF4Ldv+sl/aiycsc6317AZxl/eaIEyz9BZWnDfVhYiWOEoQ2QrtOTgp1Mj8ptPDgbStnf4TVugqXZtkFENgH4jCSyU+54ZP3rzv+6OVU7fS1l1qsl6uygr5xu3dBcgiKNIrH+7zwvKITq/StOn1M97R5QiuQSiL6tnxHQSFkkMT+6QGu8yz7QZ6S5+jBp3Q63pu4x6kIz7FHUG6ab4gjN8YNPfV2YqIasPSAq8WXmQ7PVzGe5Al2rGtcPhSEJFiUrrGMpWk4C3ZhuZwgJERu7LM1DDcP/zGah1ZvxYMjdjugsMXHDWY0K3ofE6LU+n866M1h1t9z1XUdEVy7VkivMrV2B6GyA58SCMAuA1HfPD7H5gv6bvA3vY5Xrynq01ZljUA/WioRlW9+T/ZmP9Lht6k1fvvVMPEPpB4+oE2Mv6Ou1sKk/WNIT/0K4vgu3eqCwTz0gRN3iRyn4krDvpPSN52fX8tHiY2XtZdQThnBg6qmgw5rXO/wcqJhHjxpA+ntszT6KTWWlLGaW60lOTEuEu9fDOpvm7YxHWIeSpbQbjJnJDQgS0RQr9pDLL9npwojc4TOKCQ9QJWH29si2X9ZWt4zpkwVG6qDchuyo6QasCazWxtmNkWLHB6ExpVtw8Gp9UpDCm0kT06Ad3vDxrfR05dDuD7uBqtLbCcaa8pEzQd30h24Tz+4BKmYr0+4qjuHZivNifzWlSqvV99otEpb0FiykvIGnG6lE7Wm4MqUCCF5zShqXna+nU/DAKJ+sdtxGRa22r3IygwRBPNYNSipiz38P1xkJjUJYVht+BQiekUt02D4UTYsnZVBtLaWkXB/qui4cOO2RBqR7KYEeff1MVs9JaloFQ8l4zNBRlt+okVgYkLCYpOJgnLIqTNpSZKi0kMYLhrRp/qy274uXpnFOVECN68+papD8L+87qMf6QEltP/B5LfnMwLILtzlWi+YKp8EGfVSKK1LAcMeVzddA3Q5w+DsULr4GIkQ94pkwe9Y4/jp3/XJIlcZdUCaatJvySYI+kVrf4ULM6PdIsslG9amApaI3WJbXb9YRjFT67cM+PXJBNxsaSqC4L0yS9xp1Mf1l8/GpdzIonobllHZ7d863VpyRRLOGBsUmVecDsHjvVAfhBMZoGei6GwxJlk/QEzVBgfJNuiJBVk4eG3nZXqZ/XMFCEkMDqscAXgNBLrj9EdoQ9x614E4AuzUADtpwaD7HsEczq87kZQfMyZhnGMzQFtDP83/68M8aSKvctY9mKiIkG8824ACkKvibR9nByQuyHpCugM0SM3FapUGnVrNB4wVQZfV08QAU6XPQOkKqoZW02nfcjacEEFBOV3a1jFB4FIRYeyGnYv58W8V3HaxTowUEsrn7k7H3rLiLxUtHgY7+0K7mRvSu4TIMqet9fF+zbfq9bi9ZisdJcR2HEbAsN36y8P6c0JGvlPgT8jvkFtB+AIxzI2n2EDaezcpe5UH2CpMyqZx8aO95ydNAvuwKv9qOOnp9m0VaPiHBoAzh3KPQqzALk/n4N58UKW+pnJGg/dGLqSM2QWd0zdBUDNF11KCNXZYb5h9Jg9h9f7A5RBO0Dk9pezZjFHe6nkZisKr5dxNklgL40Vr1CJynxW73p/b4LgXOt0ob/RSRNHPDv8Ypg5gE5nu4TnhpPK5jt1ldWV6OvCkFwNsBZR3hWU4wLpZ3F072ns9Ywe99mBjyIDXfsoY3xADA7pf8gBiduzdRhnJAOsOkUpt7ofzWYgCVZqHByHa1yPMR/Dwk1zM2F/QBZrPiFWu6OwSbYlWjJakegFWxUSEs1FrgXLyDJGivwcfwgGOj0gRrMfdzZvCvnE7ih2M/7dps5xF7Cc8qPzM0PDS8LMHFbD0gBDN+KdBUIZOlk857y+A+yxNmKckJ26yIsSqihA3KA8ZHJg3bIHH1q1N811M7Kzpk/jo3ufYwEmClaGSsrYyfzRIlObuyQqjgp3GkFL59uXOMd7XvNF/iOt8G6IVramISwrFywAetoaoW/VJztLHOVh2RHRdN25bFNJUfpRG6jmlWL8ByYPr+F9qbB5TLpJ+41wLU8mhX9cd2jvy7bCWrC4lbtukAriShrsVHex+8VRGasva9nWqmWrDMHGCSfp1mpBWm+utta4ZL5omsUBkgpJ4GFGipZECqh6/Tzst9SDlXmcTOHSO3h+LBkq2g9bBEEnL+ZfDxqfEVbT5v+gsKwHM298FWBaTib0Rz1B+AnSFO+Rhk3PPxp/uHo0O3ZCr7Y0CItfoJWawEI9kxoLSUgzc3HzCEsYf/OCNi5ZVIT0j6FlhZcQcxasNyI+CYHpVFSgXrBgrGnfLz+HgO7bab5MbOn6gl8oOg4PIx2p6RHtNPADsAAkL1Xb8MDC6AHFbkjHYiYHKWBlWZhd0ZL5uGGcYgFfuI7dDm+kWclMksqxA6LV41vr1kJUp/WVI9ZJLsDqmJLr0IbfIXFCihh0mLPlXQqL2PTNq9+1ZWj3iAHgbtljLMhoRFDUACQ6A1REyZZRWbQNGENSJz3+G0BnPt7IIYL50iJDUHUwqVjdrODDWJoZGBiUXSJL4oiclyUeY3kHI9oAB3LUfrn+A5Kmyw4t/y3GW7PJzaU8SBcnU8AQkjK5tCl0NIBSFG0mXd6PLE1Hl2nuZyA6kvbncBrCnCU3aMQ6b/zR/KLB9BcNV7WyLQkc4nmOHNEjChPl3iueToCEyfde8i1rQNc5sOHfMjNGrwGHqenYSoOghIuY0s7lktebWkey4BtbeYwkESXlpWC6GgJDe18+zZhvGgTONY+mvEfayi6PqmwSh3Z0jTJXoGoveUQWH5idu3eIGdx8/tEoEC2Ay7rjzbb72r/Il/+tQG6a86VjNfJUwgI2BNcV7GWnp7Jn9sLLlP0qAwLtHqU8H+dAOZyLAgldPHwaHSR47roaRKPPPxYs9Cs1O4deIDshzrN/g7k/SFT1EVSbV782kWI2iHEyV9CEt/gZ8zgNNx5QtdTroOBSiCTnnBUMCVdyLZExrnCEiNPvwayVEpbkpAPMPJ5Uk+QbR5sOXa9VfZyXeGjnVZSoXMg1r5S2RbOKHYAoPCIWPqcqE82snI/4HT4sEOSGrMoKfA3O63eWuVatJbyqbu7i4b/DZ0pZDmmpgIPOzFIOvD63K3zSFl6He/qityjfouOVL4ox/U+G7HD3JUsK804CJjz4MxpsJ7ofeMgvrEnhnamXWYdbqgql0bg2D5Cmb2hmR2v7Qb/X3C+qb0odMvu+QMo4vFRXkShUafN6i4NTAraivOATMc6waDT2T9cYwHPViHqBCEu+Rn51f3cEPfSb3fBGBOR6pOmhUlfYH1H+91RD1nxqrS9t6Z4a8pLwBpjMRzipAjXctyoK+ePrTYq/0U4zc6rSzSgfQGDxMNCt7kvZUxMkB5p4eXGp0YOWbR/WWqTjGqrwQgie3qjCXECjiABSJA9r/2zZope/5zRxConkmTBPIBxdAgWCEliXj7E5QqrbsAbIT3x4+KDi4SRc4ZSzaMy8+vnDfRAh0ai+u1uPiSnf6DgdFscvs3zpCd8ItwRYVAhL1fSH6KiyCWFMfe2AQQR3Fi7b+bHlz7iVQ8LzrIVMn7V/4WMCWAChQJK4DM4I9WX0VNvJq1bkJ5cwJwKPcPtXShc9/EXLJgI2XeDn0RpLwaH6Sm4KXMStPbiMj4MjehrECmSIVNu6b052VK2I9x8G6Yiew7dQDyKinVI/k3T/thKqAypDpocl5A2zjM99Y4a6go9fQKkLEP05ApxbL1BcV4xmdDT3w/lyF5HhjbRy9tS2iYMt/UE8BrsgPzFsugRn4s3qmiKiFNY2R+KUlzFY5d0uL8lQrXdY9/mMqj2UVEBg+HLRdryC9BRxzO+bklD3v7xOnsnTKGNapIRzEjefKnyweRFbTppmgERqz7uPFVChbyVZZfEhgZb4hND0OdGpv6uxOWzszhs9kqWhm7NDZha68SazYbxKwz2G+JAv1+7m+XKMiTNJIkUltxNpw+C0AWb66ExMzaxUGJMlePjJ+4h6jHN1AH+YBntiYAv4uSQK8j0qHTjUa2lOb6jG+6nc2M+MViJStQVC0vUxGFRSWZ5zipq91Vo8e4/vl2z7R6x3hTCG8z2imVsJbmMeO36qE0cumGUDIAvl0YZZXj+V+NJnZ//qu0QxJEVSWCBmcZ/5BxMu1ieQnck8QbQYBJC1jL3XSlVeTa3FES188b18ON57cZA/bSreoxeGBpggK4q2fWe04MUpNim1OozTAyMnetPn8hNQgO+LlwDJfrPFpXqopLakkBgkKKmU97fVF63r/GXshuzvLQ18hI46IBBqwXg/zAJ9M66rftVUVrpxvwmHz2wGxYB/a2eL92arVGw2RwPp25YjXiJGdeP+vP/gocjcpNp4ENft0i6uPDwZbahKiyNIZYI9wtkI421FcRLHSy/I3qMyHEkRaAU8D3ZLAoL/gLauxj5Hzs69DC9ZjxuDiDaOvM6bXEJuihIPLQ+cuknbav26FhWDo/+bHC8WLGihIxhKGNj8nkdS1xfKvP3LVjGALuqpk3+HfbNu/+NhI5Jxaxv6mXWNOr1t4lpdeo2wix6wrj/DS2BmhrT2uId1QZSP1Zjt2GobLE1qARciYjpmqxoCvoYH0Ulr/Cp1KCVU5pk1kcNk6o1mJV2br9CjcfZ1fggMSvQ29s8tzLmTaPXIqF9Idz0vHYTB+oTR8NAuOTefaSHO55nHF91pznPsqZM5hjaJdQIA/23oJddz8P9ktmVuanFH4CSis5l1Vd71OURVxrLSMx6tIBZmM/0/7iW1UqDNqO4KoWxgOCkQsZKD6QoJ7XoTKoaVQToUabX23DN+chaDwxxpaP15S9y3zrgCAO40vb8Gvq+XvSnyfaPAtUL7yeCfQ4TrFc0Hpl3YPsunOCuRx6lU5oweeWpc6r9+iDLBF1u4w+BiaLkXEMlYJAq/8tfn8N6VbqAZ/mBijOsRnrjVYJhHR1gPhY4CDQ46B5ZzmoOQUYSj8TSvpz9sAYfrjE2+ZDoevZA3TZJyCTHMzMGxftK4BLSE+6BXtKzGMrXGkEs9ABpzUywisSGAorNHerbpT8CjoHcB5Ra5pmPZeNIdTFFvdh+niWWCHjxdB3asTYjXPsLdgOjcJrCS5ZoinbhfrHgN1vrmST0X9wjz+KubUctVp5xFlZ3wcWVe4O1id8eqOVmqKbDe2azJ0I1Ro9k9MOUtTGLt8KicDhP5YVEFIM2vKBCBfZt2w0caNitHgTgdimIbFkpaGmjGlFoyQtNVWE9A8GnL6SPOd1tJvoyPutpacZ21tsK5ztebGGr4sFcXE69Ws94metPij4MHwSbmOfZ5mOcJ7OgYIqDJSVMwaeR/OqPbRJlZWDjvIbZNEEjkHcORte89GdFkAKafnQBueFgzV6Pa9rfCNUqolS/W8ZnwEffdcq+bLiVQdQKNP2K7WuLlVACra+uBGO55Gi7DhFOiDqW6POX6zLZGjtEuWQfEgLl3u3vW2Bx1mq1mDPRVvAuM97p5GGRFKhjQHBrNOQNbUts9e86y7SujlweMMCUWB3S5MiATOF3USoPLNP/dgnfHoxy8rgTxMpP3YBksB/001D6BFfL0vIEUimxSmMoK2ev6EMUa5Yc1pHbUuFLvEU1b2BILcUtprEWmmzktK5HQ3KYyFjMBfh4UtqV60cfbJxlRoKXc39zb8HnFNRobiY/zOZ6VGiaBcefg5Gpclx1R0d+5LqThgl99u6Q14Ydkg8L0rYF2LFTbIYA6LKZFn0ELUean/T7fcubyK4iE2XHfOF8nBXCICn3UswVbufb682tdEeUu/iZ2PEyvLNY1TNnQiQRKAZq5KBeVJpbLBwAUYI09c2Yimezhl3Qqfl+6nWkj3qfa2p2buqD+5ouSk33Meh3v+Oh30mYOy2xQH8qSpE364FrrTZB1z6ZBeOLxB94RRAgn6BM+sNCxYfPPB/CSd3f5v4NxOlCECioG8GIO9CzeP1e8/92ODkCDoJ0QCHGdO4kxQvf542KBgQzKmZ4OacAEFYeFZqO1nlnai7VWpebUIqz6s47oCFmBfRYvnKA+uJ0TleUb4Ac+Ml2JRQqk/CDSo36fu/6h5TwUUaDH6EciLiJBMptS0AzNeOxK+8dnJfYhkJQvwHhKnoC3MKyeHU+DiJnewFElWwG5P2FACPVzmg88HcQ/5FmDNb2QirP0PjBDxVFJ4YOwDMXNZBTC/GWIZ2lqsenlpy2TMYVgfAZn1Yy62vS82bJlRyLKz8MmEAzu7eQ8kyTlWpFj9TY1CNYx3DYa4k/HbzUbagF/sbeHFDBur1lrPZo03wyAnuijcm6JJ67LUxZ+fhaJ3tV49ebZ8LZkJL1hxzLsuu9eom9Erq0q9dvbuL3kTsJlLjEsqOG8Usj3QiZMai69GZ0Jznu+Ap1Hpk9ubcDTCu1HPJ6V/5aq+/rVbSoKGxtEsfK3gdLVSS7GcJu/kD1StSXy51bmL0GsF8A/XTagAAihhmusC/7AbOQyK2tdhv2W1C8EsvQF4i7s+AhF9eJ114R+/pwp+HfUs9Bz7Avx2PjVgYljwyJ2OjSA9MwO/qMkXKz0y9Lw4eJdyy1sLvaW4JsDRL/0LYBFFaeWM9+03Eelqr12RajuG4ofR6FuTkzM9HEqhA67w6esRFTDCKrNQPOzXvsK2WtXZOvAqVeFHKOU9BnrOlo0yxPmIrxPsAuxmZzERJ319/8sMfncggLNVCziVIUhYqNleaGSFN2ak97BzqRMObe6eCLOg2zgFjkbF8DzZt70NVQZNMcyaFL+A7sYpFeffF+IGHQ6MmRru0VwgLV4fo/BR6xdyfO48l1SfWKuUcZzlgxtLLrxHehWOBHhbgTLyp3uyHKO15FMoUIzOiRzEuA0qXlAq05eDOpxmqVlYSNCwvxUTWt5gM9Dnzl9CI8KrJa4NnIjlp9BtS/Qkay4TNoKiSq4LjCMFiFfINz3UYSHEhn1FDnGHfSmire7Z/mQsfh9dOYrMNKTTctHx1F4k2BBcI9fHL/hNjjCJItJhrLUo2pOcU4kGWLySXKfr5WGnnhZ/BcvUgUdKHaqGVpEYEZBoeba4QG8JdUhuLJG51V9pU6QxX908oIXqjB1s0evzgfu0vWJGEPbB9hk8Kt4MsMAzBw/q5CHQTKW0cGgxQfKtzzDAK5qLMfVX7+qfoJmVxdlHyI6a+Lq3PN6GlbYVccvT4CisOvIadiRxlPQEiy5tWamA1ELSsGf01udS8P58iaAYcHlw4ZEJynUvLHTQDSKPLQ8iKr5KI9/VIGnKnQtjoQLx5nsUIuTFK4u7D4u95LcFng2rLipTGLOr9b7qXhX6yv+HVaf4YJIiJs6bY8ZYoL3PYd2/NC/40pny23YbV8dmO/BQGdUjO0jwuoI3ADXpXoxLbujg3eUkUwSArQvNszZPMIYs50G3vyBjt02IIYuXGJUd4Pb9pUXAi9DMDQOPJU+xrkXcq5nijno/aWpDAN4qHbdQlTtOLH8UTN3LllNEDAu07zgPX7VIuZNykgZNR+soXmfcVsPn2dnAVMhmwLHSYru9Zrh7WvOrmBL91yOfMUUx+gwUJgIliNi08eSg3z5KWSIYJ3DRSRyaMO6q4wesJwhOaPri/xVy1bLOD4QFBArP4lg0oYfTE17ntYkeVjbYdeMLtdNFhLp2ip7CR7dbjJPiU/GqM+wQXPg/YC+9U1vmShNeJZu0wSJDBUu5FDSdv6M/m7q9AVkgLCDCSB+FIokwVEC9XMmZ6mCAI0gg1GDFa3CwCnBeMV4rtr0ijkJbJWg0vR6/kG2TpbtRKuZWZLT34kQIlLPGvA8z4w2YV3tudjW2WmcRYQrj6e2X6LCKdPFwfDMapy/ByUt0bWtPlANAPWKEh2QxKI2MvpUt0Ry4KJ//rpEE2hLDF2kLW7QTb0ViTOj3fD8KRywln4kaJZVZlD2wgW5nunblvaYaars0DVsNiLMePfdbIj6Jaq+tVVpXB8Yt5ZlpCKFM0t4lSeqvfordulEQimgoMQMi+bDDzSqGZPqQqLKrbmCdZgNj9Bk7uKG17f4HmwB+6ZAs6SbDHyKlzLnAmiACjXp//vEzL/DaTidVQpyzSHzvagzXNmM3uACkRKGbzlyVHskHfbnmkO4qUEA2XsqgN4kAAXAVrcGBzYD8LxCITczBL5Q1OZuYAtvYPmqzvOIda+eD5/yM2u1aRlSNF2TBz67VmhkM42IfevE+1esFEnRsTwvGjLMiwgy6GJsR9Uo/8R77xoiArzLeIPGsu0x/gCnmg6qPDtHJXC29vkZ3RXTFkoQZuk2AVHLaDVvbHiyStz7VubYNvIgSb3tqnGjEGTKEEjd0eUk9b21zcMDJ0Fvh+DBE4p4gr6Oq1RUEgAorutawYJvM1K1eL6jNfQBh7vE09D/9zDgvQzkbcWEfL60DHukDPMr/nMLOJw6MZPoCY713SwKaQONtGWmtrIFkQxpiliFR7hfZBxfztQ0JbWy54FXpiKzHmk+JqCadL15IBs5udMu/QsGu+5AWFKcAXi6q194gca23EJ9YBNUBlrZbruPtCvP/Q7cGuZfhaX/XDArhtvxIOmcfH/Q5MteGHHVJ6RGM/e0+wUf6DQ5e2d14ATJ9015+2niEnGd5cvbrEgdz0GkWR47M7Tndu+dmqW1Ww3bCejFQbSGgL29N8gHn8elALKOK3k8AxsyfcszUsqMcYy7ZW8teGWF1JXd1m3ZK+g1G2HFi+BkU+0wkrf8GodcuaYegvhJIz6frMvb4Y2JrWIHIg0m0EwW1rnfmIbmlA+VWmnozf0ai/wbjKrN/KYu3+AOv2ZQSxfZ4e7e2M1d8TLrPspTxzrXPqi+Fisc0bnoSJmmFRRUtIGp5Un7rdZ2t+I+V+XWbm2/OhVP/OWK/yKJ4iWacO1v5S3x8zcDalS3hc2cQZHTfae3jVZA8WdDi0RkYlVZCeOYR7JYLoko7iTL/kJsy1I1UE1AW0KzQE4ed+bOuaBu5SvYmAin0W8k6HlSPuC51KpbT98T7TJozD8Cd4IE3SGbTmDvbRM16eP2KUZv/LQ+wY28rG5TL3mEYI+50b210083objoYAEeWEgUPFUwXIGGW9/Z74ZVYxvN+QrGWnqHeGPah21r54iU7dboOUPJyd4GMJnZzGH/vTdzuKTv2mKEP8pJ+QLHk4UuZK+Bqn/f0FoNJf8qk0ayyDuMQ1FXloovoo1q+UccSOYblRGRh+yR7699RIhnr00zXwBMTeNdYwclqOCRpaKqohrofRawl+6MzVezP2z2F7wdMUkW1e9uJfFZ6Khj27rPzqKbANJHcLfkXdAX1OCJ2LaKXJFi6ojtqDkgOBz8xxW1YJMWfiWLTrg3xJy2nWqWAq7LvhxaaPrHpjonT9f1MhmSJcd2Yhs7wIMgI94dXHan7u5d/GFpCyB8Y5xxCfjBLRuyzfxs140Jp6joEnM13gS29FMxxJDgyIjo4QE2zdi3c9jA7lEgGhItv7MCCR+yHQ6CMBhJc/FrUHO47s6A34IfMP2b4mX0kEP0uA+SlNzaLKOzQA+0AJFqP7M4ouhvm2hdCehoSyndj8G/CITR0lPZIuEE5y+oyBxU6ejKJ2OGc72hA63fX3SQg1bj4R/ADbcmGYgtKBjLJWqXOlg9cg7lzV4Z3lMxtys3LwvpYXxHhWXK85CprUxcjkByI8VexqIXLrg2aVnj8dys3dbWh2LhcSVoUgjZWopCNJAIIzHqgMZJug62vWRkd8edC4bnh5DJP5XSg1ZjW5F1wWlvhiVX3+ibgqx72fcObp0weyyS6+DOKXKcWuXRW8Z5uEpAh9EucP0/qQ/Rs1tIMS2S/zxOIaNnwolMtYhPFXvf1Y/GUt4E9kyPWUVhBBqJqs/kxW5Z55jgJfSArTpXNldB1GwaaS1WhHJbQoPWoYYWxpP5DvHbM63/Hh+lT8zZj5RN+Zu4eQsD5iM1YjLxtIh5Dk1SPu+VyszX1tMhQSbXT9jlB+ud4QZ91YyM6AvG4yP8GlfDawGzsVitpexJURnj1xCasTLYU65HQL8fLIbN83Wv3YrgJ0CVE4v6yHD2N8uuVTiAzJw/XaRH0SQGrnWk9Tr3AQByoqwSOJ9HP89gap6ZNDCp4S3wA21DppcAIFX7AcwFn+i0ezOIpR0d98+KGkksuHHqeWa5A0dXUXIVNB9aix44dIdUXIT1fxollT8VER4rFbTrguZOlxLB71gHOYAPY4ubfn/DZCmD90vI7WKJsZJOHcLH+wi9g+3JhOk/ixyOKbb/lJKCGr87gImQFXvio1aPn3EXlpXNbKhLZiUB8vWFiJuYR3d1n3iMP7tmaGPmo4xTa2trRFQ9gwvQKumpsEaAV7aILxJgSmEGG3K9Z+qr45BItR5WG+lUcXzMJEZv0S8dlQS2K8VZI9EpxwdHE1RDIqcF5n+Of1xS4wnhfHnTy1Liv5oXqQ2bIqBCLwK35hu2ol2jvhFlzkmtGOsNG8ZJ4AlDDrfP8NqC5dyLTbgE5vGnxFPoy5R5lWdOejMZ555FDOHB2dkkluNWOzo/OOV5sa0KQt0zw7BmCsvjeVWsm8BJdccF+CCGBZgUwdCk91N/vU6Gmlm8QCr2zz9V9TIYt4SUyzM3gA/QVDopq3hV2DysZt5FA5WWe+cp4oHPHVaOWE+3/e7wDy9buuhN8D41bRC/i5rT/ldM5t/G2ocZQ3KNATRzICmiGqTO0jPOO7nn/+SZ60KZ8znjut2zzpI+K7ZImpDfsEbxGaZr1jA3cGPwa1FqhXh4B7ZTKm4bONBDhQ/3IIGpYyUZwqKxCK5JS/Ylfo1zT41c3/6SwWsAO81aJwWz1V4xqc8OaHnruX3lJRljvgRwukRfBkwC8Dum3EsCjcaRfPke1W4WJURliOy+Jza7tMNLBvBVUCjQFIXaucRM55YQlNImUXqfO8fKYCtwFDLb55+1yVIupWTRlNBQxUMSjkqnIEdACF0Io9HkP4D/xYwdmf8qKoiUPpetULhN5kbjMzNxEimP4ik8n+VltZImDjIORQRSbHvxzcu0zQ5LPDDzs3QXhnvx6grd22Hpba46moP2OY1Uu8M+K7mo2dPkaZqsylFur8LPaTl7YA0G8zn10YzJS1jrdMS1BybKuKOXpyy7gouo5nktPD93YEU3HPmMdIQRAXJbYNSz27GPYTyPbTWUz40BX6Ip0i5srsMNATHvjIPhQy/XvLLUbrCLXVqPbfziUQF1zzS76IVzpFfo6WADwVi6fbSXD4LPnDl057eL+7oyec72knlrrPHAjs4vFGI9t8oJ1Nm0ZTECy2ei1MGkOs8s1gXDqq0sZF6jGLBlQ0d0jnkfY8uHmpIAmdMQ5qwvXNMFXdZTu55SkslAfhJsGK3P3/ypuO93qGcpXPW6YHpqakxlH57CUDLWWYXGgBW/Sj40c17kIFkm1OYr/FI7x6EE9xW39mtcFTYxN8L2ZRstyoCiIga5cTiZj8rGvuuKmbvEYYLRO8nkyBQ49HgmG+hqe7t8FUdFVZilRyV7C9V9QZUO/JKGH5sKn7Siskhwf1O2+UJBmhyTYAovr04yf6miswxODfG2SIt8HofzB+KONlWROc9oBUeafKXQOHlDmeavEaw2YUoT4q3uYfWd7h9dn3S6b3JMbFlEb2JOcSMtKJlVz4pcPpDnyn212R8Db+/rAm3VzOwvKTL+kKTV8D+k9RGyOO5Bf54Egu2PgwjfkWhqLVd8gVAnGn99WGXa+jiFS7YNcAkHx636zUlmUYt8q6Jt16C79ccqob5HMI6PYv+oMVAdJ7JhDFYHFb7ZvdfCe5oBeTpkkTNo7rAO3/f+aCYClksACRNzf4lbL9cC8tSc9DwaqJBuSG+PZkmsjFekGASkKiTVkW/rYZV/KjoU6eYgnLPHjO+eRdwfK05y5L5losJOmqlR5ViwWoe2JeqkwuIvHq+Sf6rC/4o/cPnBveM1aEH6Q7TD1JsL7+18tjivENZDywp9SNFIq9CxYYttM7D9K+1JcvaFtcO1CDe0oBRfrjvDG5IeZ51yOqm0EpmAV4feOCPxFVGwIz4SnEWmjxCLThrFIaz7/1SPhKMWk7l79d86EzEso8EkjTobIYef20GDAH0pcFHHVfvuTzDqVEhxRhMbhl0KCE6f/IwXGoSv+POb4Lo9zp3BWJ7c2dfuccUC6A3SKTmF/N8hnfuItGA93xd2rrhYVwOqpigp+pG19Qu4kvgh8H9sDi6CHhkJx0q7/nZ6HSEaEPOzgT83iqKs2HgWe1fo3uSqSkJOQXi3XmbyAGRIMASIFCfmEkQoFszWVIeQrUbXnCvYBxkrDO2RFZlH7iJedhV3TUhdDWc4u5rVxivObIOJ/z5oY3vNsN79i3jAbSDwpf2Ea5APc48i4sWQrDOTdBNHqrB/IKd5XyMLbKZ5FTBbved/XeW9TdlcexVP2ncUIbWBRFiCIOX+wZo+2N0uABWWHNce8lxO4pBoQN8QoSYni1qRVPX96/5ewJ2yQLcUcMG8FLxvZllMCwpja93oM2tqobEDEuHekj/4/Axo92OQ+gOG1AuwOFsBki3e53WS4sAkkDUj8leRb6JIvaY0JjhJbOfaJ4+BZA4psI9nR9WUpLsdi6yZeU39TIjPJkCcxX/0kUexbSCpJy7xd46T3KeVX8rvv8bnWMDUAW1SbY29iwuZ7mmyT1GEx0hIlxTHhp+mTDp/lwKgiacWo8SAJXRSeqTHowtdRO4P/Ex1CvwfgotTuwtRXh2v9hF1qGmQdGLladqV8rT/rSxAb2cmG7xmJUqQBAtPfbZZWRZ+EYcnXPkLHLfNCmylLrBnAQVHfEo8rGV1X56Uy9BDQUx6Ge9ssLTRsYYsDQ4l7kClwfxKYDy3vrNWyUIKODEx4rYAA/8si6BuTtVgRnPHZwZwclxQvLZap9CBd11joBZ5K+nXRM+yXxPafjV3KAwlt1/TlOc5HA15vCWxNMkqb5BlZ+QTRPWhs4xEn7bWI4eG0M4B3cnsL/p70eX+arI1zwR8+WsjOMW1K0CNNkTRIeuTXuMtJtAqH71NXk2ErvLW+IkEck823Ck75g2zxeI7fnP1+DVi0EAqQ0uj05+CkyWzAgVZOOM88IXIcGavPtOymVv9YFqb7StwmvQ4lNA6f0Ds6Fv9q7sXArTI5ijtAOzYZDkS14xdKikYsHRVZcBSOI9EYLqes+w+lBdWaeMK8yAKwvsIFjeSMjCIcgBLuN82xfNXUBI1J74uRWyxRMcKvPe69oL1fN/B2jXstfYzWHv25o2X1812VJchQWAtu8mq2C/8ztpknbKG6F2DJ5DhQRQsk1+ZtGzb6KQV4BY3VwuUBgOg2yT3OZgdtLsxtLEvKxYbCzFZpzypcM4Sb6KUX/bN/lCZxoW9rXcgdV8E20ciRcSI727P8vXZKU1q6lqL85/eH7iynNZQ4X0y0wIA3DHQcc1rdznHMqhSr71EvgvmqC47Or2VB4uPI4SZmtyhfJfIUlRng7nGbmzylryrxLx8aDFK9tVnma7vC6Fcv0/bIiO6o1Awl1ej1EU1znHdcX07f+1rq83DhJ3iwVQf2DA5UpCYOCECzf8V/FC1GZxmVa9HJTur9Hrb7im2IK7tbHERtwLT0mPk2M8O3xOuB+yBQo5epTap+H3qbSiy+zrO3ad+6qoOjMFO/7xe5N30Ux4RMhi8kOdzcf5jgA84pPEPBD3kNdwqoR2vudzR5lGKT0FX8j4vTGFsgvjmhOCRsdqSY0AEHchCdVuOn3PB68bg8GdjBZlZCLX440VghYLPu64m6aopZRAxWZtWYif4UXzCy7cXOSHqnE+YtccsUHhm5EbE3RjIeWzg849CVbIGIKlY8xNEV2kLt0XXxuOxC+CHSzgIMYJpf//rRcwK4ulqUSnhFBU3lWqWBX0x/I0w3zeq9UwMrbjA5pfTsa/udPJgU2Ur7qoqWMVGm9p3rXr6RPgQW/zyvk+6SNvJ3WiqYJOTBRrylRkRf1UtU4ufX4EaGM/VPDVrybvZhjPfww0H540NGuvxN4bCeDlxYK4I73LBySkUgMznjJ+gqvEsuYyoE1AJBZ6+zCfiKrRSW5QtU7eR3f4M+EaQ2MZUfSBYYDUF4scZ78JdBtvGIgifaJ8D02P2XHFjeaL+9PaMlmQ9YjG5MTFPHAh34Rgqnjcon9oKut4yB2Hbtn2gwLOC45f8Y2/+RioaTUPfKT9O1eMXiId5T4f/tc5v2BuC/308CSRRn9jebqjnuaexnsAYzT8wJf5Em1hrhr6NEVsD4XkZNwWVyTobol5JrSxAK+EYpfI8Mc0XZ+G0sMt8mK8enrwmUvcbJz+JmrFAfqRSKqa9ZDkBx3k4Y2oG8NTtssjhScueNfqeciZkrwhyxec/mqfxGWBCNH7idjFlFE6XEuGJFPpZDin7uOMG45MfWdF5E/2fymXN53v4pvWOaXawPECrJbgCh5Q/4GR1yiVOfM3RSDTGcYxRu3LpqbyUCFrUB8jUxUyngKprBLnO+Hh/+ixsBVcjA2fla1isDUbdB22F9Iyf64hfJx8A/4Hm8WFnfU+lGkZbo3ogyYcBOWZuejWlRa0yECXCdKca5H8xP+Ulc6kZappEE5tDlkrpNDiajOcZPCdQQG5IqSNWszUy3jigJ991ceU+1DaVFUGVmnlUutgTLi1q6fEZiNnsmvvcjaZURH0np00ySBIbngFz4khuD6TEZMbma59+t3d3GeWFlL5cfY/NKZfQp87Jn8dRcoP3mhN21f8Me2vCJyAeAO/oZ2oiGciBxAp43GLQ5lDXTBaN6wptKdfzZwc6et1YTsOwdzCdSsIZLrJ8eTY5QZ1Pr0SLmiMHvKeM5NK+kMYXLFSgf1Te6itR8FUNJCjyly+koelTmB6fGnHAl8duag2YYx4rHkBtHP823vXC1ZtPl9GdlO/l6nZYmTE0ngQEpr85IxhOOLAbQEIZtEko2csno/BbC7QUhxYTLrSIs4QpxCj0/PpD2KgmI70dordeXLOkt3Zx4ipNi25ErR0pRc59GOTFaJ5zILqecE033kUGErjOkgISA5Q3lz/a/BsiLBi0IrKw2sXKqprMtANQ8by0+FqIRZ5k8URYRr5ydY6XmxBwVcemC4g31g/NmQCrJdOY8QlGQ3L7s4PYN4MvY2rzXvoXe3Jwbo1525f2fZxzB2lLJm7zZTq6V8Q07CmQi5RlUkgc4zNao1VEnm7ogumSZwZgznhh4vilSzUUXpeKMRYWjG+sz5MO8Ukwv27Jp1svidxrcAk+pF9nNkWdiVQrMOrs3fiiaW8s8pe/Yy/NWnsmvCbVZ7GOanvu5HlrORxEUXn6lguVOi7dZAEYkg0A2FD04SCH/bYEwg/hQnyhRIbe7W/2PxdNbisX2Ca6gUUgodTJmsmmQM2icuK/ugHqP6a6H6CuNkuXk4KsXTU8qo7uy+AR9IqphTwLqPbZ66gB6SYN//P+UsWk5ffggh5ORNhlPmeEIAOO/fI1pjYBuRW1w5EL/e4oj91NSz2mLAFR7BZ9dIJmB5H+9mZOJH09J+tRppmd8ww7WO/8VaoTZDmSuHgB/SmaHh3+myLhn6Ep65bTGTDj5ciqsxph2GNdqEevnIs/4nW3NTzTlTa51jMSYWfvC0+TSlANeC65zw3t3sXJoYYz1yg+HJvE2bg08JONT/fH2gs7udLoWGwBsR1UfWclpDT0CnOShQbRNVGNcamrcuf/3CEFJLCG8gi1tcfO7h17ipf77a7yiyvfk/EyYbP0lS0oBkbgDSK6bNjSo0Hzy4SH9s0hPFEU6RqQYSMvDbE9zBkt4e8KeC6ZfZIPDlTChBtxrD8PWbESJ7l8OApg8gczke/1rUmTeMoa0Pn6Y5Wq1eklFMPVWCvUoT+keYdTBF6Blj6Tkmogtl9j3g4hngeom/nUbH/Uvl9xPcLqz/Zs2qiEpemL9ZOG7f95801LrVIcEkojgq0gudJ0aZtvdgi7n0ILp/lyc6vk+YIIK395RKy2KBgv5eTRdZPcDWh5JZM/utb84ScQ/oImHnZ9NOOX0tfsHyra96S/4xztZDHB6zfBffSwTOw0d4x8mCWypQfCQJuoy9et5GBQZNzYuIxLqNwiyd9zFTpH7Mk4hN7vNqwLpkqJPIRTZ5rVaCsxzhsdJJ9HG1S8rPWrWu/6/5AR725thaoR9MRaqlobPHVK0JkFmB+WnrLXA3zR1upWazKDW0t7f6aMMfjl6Xmo/vGldNUr0R+5cXb6zBl4iuF1GmtFxCrngRdkn2PpnH32nj4WIQRZNcAQ6+TmRXz8XtDEsCByS6L9TkamWvj6Apsey4gHch7O3CF9IHYY8EbbHPl95IciJ/7MZsKoM5wGM0bkUofjpL7XmzsVxB0015nvv79Ne9tQHk0vAx25ptVAsgIz2lefj9j15f4QJ3rbUFwU40iJGQwwMrhT1bxSkrpVgJT1Qbz6d49ah8PdnCLPskasq5lb+lAGLDmdJZXk87AAPX0mGoR/yR6nPDJpiF7HqOHBNIs3ajCsIin1pqbNqI0LhiBf7+dhNQswjbkM+/E8tupCzGC+SGNRvxoHZSKh/v7c7OUiBN5QloUEqEpV08+pD3G6nuooFwufG7QTLJoONEGGmNGIjQsSx3k9gzRcvDPxrfQKP3XDgkWPPn876dg3Z6zAD8Xw8n3/ZUq3hqLCtVdvhx0yrPErzQ5zmtEekTgGJpjoXPOu883hvdB3TlzwBzz4gIYcd1EBzXCJ6MsRDvrIpzNCGD45hBjeMvoGW9HRg3Huho+KOiKk/1p2VTecIxO4ABk8onGyxuWocGICcytAPaHCb3ItUgyQzJq7T9YyS605cK46kqd0F1yYm94oUh1zE8KFypkBiw0bCYhjsdjyOuKvZMl6armQasa0Oj2+ccxyzud2/xYf62chE6zGf/l38jpOBjuhPzCp14SrFksH7x6pEuhi/NwRBbjE5+oe+74Or2u+vW+vJkA2y77addBtlBHbl/Dgv6FjuHay7rUreZESn65gbdm5dhB/znQJGqoiVQ/51q6WrfjQnDgecpcqpyW9jHCHOMykHmTu1Q7MNXryPq+k5IDOTEglrwceV5fhNn6SufNfC3jgOhEuSl0Pe36LfiNPH6HfT8oILprYw8xmEt6xTG+W63zCjO5UDk9lmzXLSCxwkII8lG5xFxuVsrcx1Z5LbhrIwgwIb3yV/bnOUvot2JuKA6u725gxuWA8Pya9900ilnjAJ5MuHFfZxqRybpRfjbfbd+2+y29xmHlT55Hf0RbtmLftKnJe6lLfm3oAXmScQ2O3wb+J+nu8BMOwfWXi5DbOYRTei6YDclpYUR/y9DmE6YFHDCZbWYR2DXr8FNcpP91oUilYpOlN1G5Ol8ml8ipK5XMWyav1vg4YfEFdbSVl3aYlL3GGRe6bAc08YPRnpzSmE1TEDCpQ2CwSLR2wBO8S6AmRI6wmfhPOXO5Mbl4CiGP4CyKP0OV9Ek5NnewMP/YCYzqDzrbNIk7OVWOGwI3lEJd1gcvgljP5pJI+78ezMEnkJkw2+0lcWlklS+GV8RC+CyUT1LuQnlV8j0K5SwM2ocoMR4WwZoTSiFVV+Ayji7heblpLNVj7t50KhlkTJidiFQI7wCKPA7k3UBHdqeZw5dlFxjsSyPm3ZWDTHq+TgH8sdokNAhNazcN025FAv2ydV9wamTr596YT22NODhhOmBTzUY0ddlA0YtO5ofSu+O6mTfZIUjsOmcQCL3BM3R45dmGPf5ZvXJOgDLK1BI5dapkUHwUeIz5rmOWkGHur33272UkNBv6dEsDKyIYriGvfrkvgL0xK1si0FT1EHdWwZZWmKfu8W2uQTUyRl44OeE0RIm11PZ/dNsCDgwPf/b7Ezj9KH5sx9To2JvG3FKFh+e96IzMhsLWREEF4uXK3F8FjDhy8bZYDz/LouU5FkdHE0hhJSn8S+I6GPNPjAIbB/BphjF1HW9EXvFu7gpugA+CkExeObPGW51k9vn6s7hovN9e5iIuFpfionzXtQU0+EqfGlCtt3zUfDdZMr3kocMaohRulwqc0dn7GwrJSrjY34I/HFyJFpHWmG4gnYmPXykZFjgr1rJ1ri39SzD6XCVk+mBhENQRL1nhHAdLu/REYVzOm7+LgzaZDzNduUZEAwsXdrP7E4LQIk/GNzhBE6cwykjQHZeUogW5p5tCf9awtkbkAtBc4dR+CeqA6mlUNdsNnARSSV1euE88T5b81ZB6nRDMGGw7lE9cU7hmuf+PuhZ07hbAPWJNhEy0owAo3QCES0ejt8HoaQB3Shc1IUCiE8GHfcZwdISEuVRp4YZlltbEzOPlOxCkg+TuA5GWqm9VeXGd4QvKKmYfvDqkPSZ58DUWQMfFq4SteMHp9S/cdMh1hIgCEpJeiuW7T4jbGYIGzCX2Rys1iejFIFiHjiWKy2Z5BAGa9DGaNNvRlz+IbwTDi3nbJj/KdCNXh9zbzu42dDPVpXkVWkygRKCEsDicpQQFJqzE2ANMoNEwcNg1Olhp7+c2Ecbaq3eAOvbNBJYLhzv+gt9oJRaPXMy/3dZxE/zm8a0s9x2j9J3ZSD0RWDqATO9OnjlDy5JsGe6vAkTgWmCax6p+IQy7MAowgOIQHici3Mm+OJ1mRbKIOpqNmFXkFI40G5dK5s+uciZ2CItaDXZ/prSqvkY0F6skRdumj9DElKISom/1P6jIZ7k8fexc6CUlq00YfIExgEVpFMiKtAD3GolVu6zv7ecPMeHA51QxYIbcM3Gr614Ib/1W/qWGuoo7+8RWujXlUMDXsbD8Ck0qYDH+5CjNWpph3il7fmi8TSBEjq3MrBaKiDO1uzpREzcS0Wb+QdpnFsWgTyop7VFhXccLq/p9vWxQwTY0E58JARTe9vyrn3gH6AbErtp217o90NHbl90dvAyFJPeP5jKKSNgLwzPhWIaSFU5TIrbDdmPvYe4c1EoQHsVinxTAIa7UbSTLjte5yvh9YYsNTThrTlbzAFTn/DHmz7Z4TbRRiMiZ2N8m9mcQqkhOKrTaHL65NBsIPibmmAPqca/sAcVHks/7/Zf1oX1ovGZVTtAJJY1O6XMm3ZFiSs5NsUcbkhYnMlCQQy4KJ+PHB9xTmsOCt5FHD53cx5ZDIvNi5NSjaaFXvdVkw+UGxgKA6wAo+CY3dlzr7LLIDLxCyuQnhjXo0Payg1bch/DoETb6HVSKG6TgCcgaFwFBlFhvjmIBNdTx+gQsL9Rabj/O1XD2FgXN9E+f3fUf/slddgDa2n8mKTiICxSMecl/evtldPF9cFWmUZ3uKNF4eyE62bYQa070MQDhJISf9rkF82d6KFxtDdI8beAoJlv/CjM2+ADCNvJ1cA+UBT6koxmNv5MR5MYoChaVH3s8G6uctbRY4m1yYCBt0BHDB2PBv2C+iZ1j7r4q8UKi4znLlGNGmbn03ng9oTLdjddXrqLfn0aUsJssfiQIwEwpek+lKEU823fCR0+SwAdZRJ30w+snoc4+HnpVmJHKQ30TZ/iJvRjhMUZvvaLPy367DdSaS8gTIoZrtsL9Mkrja3lVV6p0Fl6GT4PrpXfGOXC11uzhFg1SP2ku15cojV9IVnquIuakRICDI/ZYaT+P9F89MDhbZbZtNYasRctO2lZZAPffPQx5VKPdme5wW4xPp5yrqH/rmBEIKN4a8XLRyIRIr2Zmrml/e2D1uKVRuoIdoXoYtXOUTQqcbJI4irIuT0da9fgghowAwValD/gI6ZJspiDagwJlh6ty1bSctuPFvGOczgRag233DkZFjarUf8MerV3tyNSMAccX4ELqtgqDzTtPBmw+d7nhFxwnYjsGbZfV3R9ZBmSYY0q06PHyKn9xAPM5i8nx5zvMqW1kif1A5+oevfPcdpMazJ9K2LYfnXEtE0ab7WQi5fyNnvJQhCbnbVVUD0W9CY40m0bQO8eOLa95uSti0CeIeotMutlSIKpP9sg+bLNbnzEUC1luzMNRk+K2A7PMNBbC4rZFjen05xcFSG3K/ZxJdV0Qn6mn7NBSy237I+1+oZ4Q63NY+rhd1xjVWpV6kyW02ZdXlIIfX7WCsn+Sb3y5MPeSIw1T9k87ZEOLmchRnFj4dNFr/XDpG3xIyHa30ApXhkj3qfjv8u0un6kyExofAT9WxBMRhvLUfC51F8B6QVZoKqcQfwbseMZmRqOioZrdqRVrs/5+KqmmQ5GRhh3BtSZ924Wfh3zITE5yOQgvTR+vmQKAY1hmND5dd9jQju41ceAeuNti8C6FuPYVCuRf3F+TxYBUhwXeghZmxUO4chHl/5AlAjmKAVVTlngGXfo2DCqYSlZSDoXaXZ7uSlWHLNdvYx1JpYTul9NFBqvTU5AIFKpuJsiLsCp+OYP/px0m9CgoYtTY+I8bs63cz+qeY7LUa5ENJPZ+TlPMnzBTP8Qh0xwzwX7Hbk5ggXms9GZotNqscI1eT0AZc7ycwPLdcoSBenfntkN/SfcN+HA49o92RO4Vf8bLrvOVNhcGpW+JWqaTLzk1UcbN4gooKPkDlJJhxjb8n9qC0QDMGidP3lVUP3t7IqtxxM6oAJP0XObfTaCPvqE/85L470TLk129bpV4aKMzX8GOBY2m15SV3aAjVhH5KJ6ESN3D9RJ23DEy/b88EGUkHTOygcTbVav9Ywocypu8XsCNUB2kwJJtGIngu9PCXg1OQlaNcnCWFEKKG7BAHu3+BY913P4TFc3LOOCLElkMnDcOWnAj46rSntVqCTlaG+lMHSqsaLhw2ns7CyeE1DWxYCfy1dvbSP/A+8yG8Vt3oTItzKjPvb5Td7kQlLBzi1d5rp7xo06UEa7Z52vmizyKbaoNBubuR6S1aa774y9+NDEEoC/xPvLG+MC5a/LpHRWEa4zqCU+gjfmNURa2D19qwp2GnwcYwLpHuuzdMj4/65jLAN3omL56Mf3Tk1CdUrpUQ59lXyyQId9QTpyPAaUgw86jc6dEcSAqt0UjD2lpTZ6yV/9FOOPIoXimd6SCvmWIPjQIMiJqMr3ZFidqoabuMfANuddrbfl3I7olcvbLx231a4gkmFIfWGvTY4RVLF9GPLFQdVdPcgrFT0Q9XfOamE6XXzPcFrZPnWneoA0DLBi/JrT7oP0FJ+duh5InT51n0okFTyDm5oFpbFOoXUFkRSShREcaImDqnfmuu+9ZOU5NF14Yco0RMDjUE8JW9gxVpV+SXA29V7GEg3rw2hCDGSZk0Pz/1Inv15KXaHDr8XB3hKAw05MWEUbZxcZlr3bJf3tZccM7L1uViN4qKSMwFUX72vFvFGld+bXIXp4lgwD+Lx1RJxpparqececqzjykaQ12KJuk3lP/wdoaVKD80jasGq/vAmJ6xx177ABtzpidMc/aQtCyjN7gt/HrAoH1WQxbN9+X5Hh+LQvGvzuxnB6qaW4FwEy8GGZ02Fn4S5hcAm/DyivMhzBhMZBesDjJr7tAVVAqA4SUpULywiwIC06zc+8O0oeIziYfk4TL+jSG+AHxtJlb89cF8wR6qm+sbPg6PWk/TeWwK9C3gvwtHmaLsSzAHN4b1f5waMTCSmZxko5CHibQub+T//UaNbXqWkPo/w8+ISBQijghRzLiEwaGD5xH7j6e6TMZNwr0kVTU+zp9lOfEB5o6J1GvM+jKN3AGSCm3IBD+uZyHvcIsPhgjNlApEYHba/ctCxXya+NwAt5p93pHwnr8c5wRGx7GYSo0LMuslooVV9tgCE8YhTRFfZ2fynjMCM1eLw6zgh0vGCCnfpqzXwXGlhPFj1B+f7tY0UDMlmzepEcKbl17+y12PpIxA1DPTTQAeUhdXUuGTJD8U6FHFDSiIZxDdQWVmpRlNOrHn0wociC3orhP1B7gQOveLX5bcmKIwSUIUrXcr+rKMGN2XYWKSYQ0tSEGqV7XeomAks3/+lH3M3o5lqagKdHkBZodKHWVP4ofXFInnzQcLn2F8QRc4MvoUHY5QvNEWz+2qMWntiD33P22N5aueUHqbN9sPqd8yatkUJEp21VCx/jDfQjvwqSF1O2m/ZHauCki0KooxHpI13QvF2uReTyiDb9zcSzhaFHJW5AVpeaxKvOag8LU4rA9JVgl/H2bB3TuysiVLGAddFu+UTQphbBVcUqkG4vslEnRm+HBAXAZCt1uN7Mbd0wB6Fs23jdI2ziRj0jevdcccpMRvXniNiG3QK5wbWKkwPimQCh4FyP2nKl+N90Mnn2aMvFfEeZ1gcTkOrl/d66VQ5BjzXUf55qHvknBU+cB+GhFwT/Pg3TOJ5c4Rl3ijTjXbxhCWJ/gd+oo0fJS4FgWIFiVfrn/RFxQWsVN7ET36z1XMtLVMU5ML5m5CPDEEYFYygCbakwsMZk185RvifjRVmoAv5+lne3kqsL9HaoXH33YvELXS4Z5T/KvMHpFeDyE3CULWfsyNbpPMsf1qKBDDQK/20wrnINEfFqgKSXgZTDkrdt4ncqPTLaMfUtE5L+2fag2gKB5vP+7ggR34yMeT5nV+lt99y15Za+iOBQzBRT9F/MioxBed3uu91pi7IQfWz/hAMK6ZTe+Ou/8sAIU+bk1g4PKUEXG84Cic+TKge8XqLxPAim9edJQQTSSK6jAgn0/YaCU9LTHJ4/ndUY24/YwdQEIPGqAk5tnWSHjggDjEOoKrjsBZHm2gi8cDOvj8CzMgqgBjoYGrDNy0jqred3E4nDESt1z2vtGT6TMWx9tfuHeaijS9oOPTtINeyam+dOtZELgMfoHRskt7W6Hf50qK8D90pDD6YG/Z/aL3cbHMvhLR3yRNz7napO+x5CkfRF986UcTqsuSC6yjfwD9MvVkP81NFf9s4d8nZg33MeXyHRCTgwEjAAtQcb+3nj2g22GmQbSBvwZKn+CFcgJ93yUQV8Z9d3OLImKDExm8l7pKbVzPOD8R9A5sYdKvf9ywTb0jxSPs29DGPbtL9phgidaXgo5C1TN1oUQ5fiIsCB83umGHX1CFPHx70Dg2LFuQ15GLwERguRLYLBEUgU5W2j4drL7ePkOjyKXbpit38/LfF3ZXo1I+ZXMZfKe7Sw3IyDu5ZkjZB8lC+YUsY1XexXkzpTNYyqTC1ijayWZ964xRkceg2vd6bBryMk0FoxCdmJ0gucN8FLo/IPwdL5Kb4vLxbd//ZhzvBfdBdxNGhDwneDDFTp5HOsKbHjMM6gB4W2HnM+lh1Er7Vzj4kIDm5VzUIdG0hZageSWQ0Yr4xhZEOS7cqrX3+Bmi5FdBDUh15zeQhxYP+zs0RBoeydc7vFeuNhfmef62eM2MVbuIA1WqE/7zcmVbD1uX+Bn2zHQILGZv547mUO4S9px68tMgMaE5IEz1E6bpoBAVGRaPOFsgognCQFUjDm2YnyQG7fh+2VX6yztbX+1UEXK3yiyOfA4Inz/QlfuUuHV2irTPGzYGKB3LDy3gHBaiLg7Pbhctpp7ErZwYUrx7WPV70rwcMwG+mf3zWn6Of4IqAgvyhTh8UWuEWZ+4FPE/59ResCkDX1wISsD84tIY2HqjubK9PwhWYFID+bAV9RmJcr7NiBBnCFGAy+OO25a0bJjthbOilUE51HGS2FUOEYUwqArraUMaSe9pJkapc7OGnNv6Vkq5Qjjm9VoUea9HGZcjVeaMu6MWhgB+FYblBm4J6hf4omOI2UIWfgcyGZb2310sh2TSGBoMC7WpxDWCN6b15cNtheaRqXeLtSLGTWVzUOBfjbxRLUKHOz8LcrEpcQs3s5INuUi7wgTDIBxWqwbcwF+6nb5Qin93CI/xd8jSiM+hHGL4GJGt5X1VCFtKCqlLgWPa76bSIJSiE/6YwjtO4snO7QPAjJrpED40ZrB1f7lWluyd0XtWSxCcO0r13lKrbusVNRoB8bZ83+exviDZjcGVBfyKfjushLnAJa00gx2F3UvgkPs9scDrguANqC4+9+rQJ77EiWcCEM7geFy9zZFGRRzD/H+rgl/p4FxbaUyqxWmh4JPJ7dwFl1uSqVDopEkAEldeFRLuBw83Y1SPDVCnyGJsbdNMgkNptRKFuGim13vSKsE+/G1u8mDY2Na+sEBo6bLJIjPbYhNyeLVihWuG/q07VIzrWpkfwh6MR9qyLkOMX5ufe9YN4rIYcjE5M6w0C1dDpRq3XmSuZBbIo9n954gS9PJtYnRKR0IN8v7ec+oYHCxftDixL7pSpQ8QAdTHozYetonpezqp+ZJ6ly92Ij947qOJ+iWyT6j9awe7ewS/ZKVGMf76TU7eXRCl0LX7IOCPvdnehckUoQfU6yPoW+vBlmuMGhKJVNvJyC6QuwvD+YMb61b/8mnOB+/csAFhO5nOdAwl7E6fNyhvjZ8Zmk5QwoZ+dl1sPYLawIfLgzVircIvgwf+roGYnlW5QOjpe5KeU6JImem85EynBUIF6ziwRS9C6pZ3nZ2E7aYuiWVy1VfgbURUAtnDoyD4YjnrZHcutuKByaTGzX/hSuTThzON7h/NuDcemO5FCoxUfCvkvkdMkxnJm15xR/eFnkieViPkcjrBFvcqt61uKpZADJkLkv4EJXUX3pm9A2OCkDJeNF0QQzh5FUvo4jJpq0/KijhEeD1TA78+FCeRd1P6xwPOuDHVmULlV2hMHSzlNIshNh23ACnVeNtA4pEOEJ3SynpmXtRhJsgT5QNE390srQHR6SToPbqdH4nZ5I+iBTJHCf2AcycpUZBLtm/st0vH6x433R70CruH75od/DfZHPOQzk7RNVnw2VEjpyGP1AG8nR+WutcZxp6rzm3zNdDAXMWJziUQsiy6TBihQQKr4liRZqmJuzhmETfu4EsusDGqeWNArx41GMkYqjPyBwkofJBBwHjJ2N6zoZsJd1PbV3gnot9hBUCqA3hNgLFcZdxYlssuoaoyOdLQgV9MeGWfvLva4os816X/AEraYJKu0Y4Io0K9XcHZiFRCW/UM39feAUAdAxFQqw54pzmJJ27Q0P47vsZnt1Crh9O0uFZeGYD+i/T5UG7yZaVts8L75CbYgyCDbRVQXWsFqpT83Bupcn5rihhBkI2kcX1Kgxj8FhGX8aAF54YS7lEE1yt4OmcpAvwUwKIuT/amhXtbYKgFknVoMtUOYHslCpplNHVwE4Z5pobLy6VbV8cSK5gSQhXkVcNosqrO2dH5cY5yHd3raTPAHm6EDoDGD1282Pizmx0MUrZEGQQpFGD8TNSmRbJzcxlELPpzIZRo1M05Ttlk4Z5ITXGdppZK/m9ROMv9cpr5kNl7TNY0S08lJe7o30mIdm/WQLnptA3rpcfh4KVEdfgpYYsMfWoXg/kLbHQMkkXwO2Ifle+5KFiGsgL5ADkYfY4BTri0amKzpgtHZHzlM+pxmumrEhe2snC/GYry2oJ8Vyuhq5Kh3T6jAKJhmeQPWy1h6BUxHXPBBPBbyF5G09eyI9l6GAxG44RX11cKxyT3+USr5tJwoczlwD343ZJ/LcUze5E7JRujpza4meu/B79td5XyizsiOUtx+BdxArJ47Ohp1YnfzOrYEQJU4jBMgA8n6CFLYwK1VomSzTUlXzwry5CP4DqWsrNEtOtC1DX0OXBvYAjoxX6M9Awt9uvfzb9jYMDjgkDzxhCmul+c4t+4QISTFM6UvKgG6wkwL/TKZojOi33+Wu6D4nySU5jDVCl/oeekm1JuI113tJg9VCKMZUSdZ5aQ6HUA2xy5nITnGq8mi2XQDkujEqKLPyFmcgMJTc8+S6VtUm3x7qlhcgadT8PaGmt0A98mYffWFx30X5tyf5TDlR6bNzoPPwkc1vd0UH7dnzlF3/OtNdwoO2GSBH+NrejR/2MCW7o8hC9JQHdzq9G6SJsI9jVF+9wkGgP6JH/Ep1rgeLwv3YHdQ+tUpwn2Ky0FXJHPMghnp31fk51CkKgTOz5t5VPHt/ny5Lv9I696et0NEZa2gX7wxkRqVjKfZdZTHS0D1oy7q+xZPlL7N+9W3jRMcSiXWg8Dn14y96ZF6UWiIhOF+x2DoDShiIlcTexvnEamP/0kRP2oDFooeDldR8VLb/TrM5hXD2kc9aukn3rgbaFx+pEyM6n/X0zDtPqvBs56hXdDY8K3kmBhtp5URQz1ksC20dO3QzmBuaXXqTQhWVmJy5KFPV1Cx0vPwz9kO+0zE4YLLUKZhkOQrCybW0kEDS6ENDorp8O1ZBWa40urV9Komo9AVqQlvbdKJmniWC/W0eToOigHhmJa+xChlk6rpWVwE8l64jW2bgBr0QwL8h45aO6mKYEesO8m8YZBwjjkO+9Er7RBvO/bZTcTw1zWR6OrWAZnvQjCTCiV+i58vUoZjC2CIQngnO7jlfiXaruPB1kvCjlc4m8VaW1lswOhk0nAnq1gSQDbJ8qS1ogmCiJfKGYeu3zRqQ/I4wf55rRxLUDe/6xx2J5CAFmYymygWXQ6aZX2/G+JHqE9j5HOc9Ibfe/uEAUdyOy+BWEM0ZhCLvTc4QWkHcq/GKqJiWtm/rQ1qJz8EAqrJQDiA+iqt0bMUtKipPunqp3YWc3b7bW5Q38DfYGlP1j+zE6SHaPhtfth9CMZwxQtrzJTQ4S7hKgn4bfZiH/dyNt45jDs76hWbXQnFy5QQDN+FGngsFccnMNibMhpHi2h4KHODpXhpZ2EwgAIbHa64wiORSG1h5jFTKXmZJj3bDwi53SAu/ktxidENUbjhuSdMBmHGYQhl71ShKu5jqjWO20JNSC9puPRXTJ6HHxc/cm69RoN2jV/0dVbw7bYaMW7MoLNH9kgYf69oO/KgQx//E2T8B/zs6EtOVWUqcZAZGJrEXRGbg1tgEoxrFb6BuuTBs0gQmfwnWTHnLaNROGQvAnxC8nDUbcHKcgPufA1eI+ot21kirkG8nn7V8J30qZspzCItV7HPydO6Cxbg7q8uQbESILgn88EqtA/5yzISzTEOEAKgsHQZSysg8KHdNzifbXV03x9/s5sabrNUdONWkBfBZj5pk8qW+av3/yulIgsuQJJiphoyd1dTSm1J+pPI/7r0GpZKMhXl4zKKlyMgCDDpvOzbyh1251PrfZ0W2VbQ4D+YdLTAzyaalH+ZYKaqinMzgOgfjwrjN5V8SRjWtXDUJYkFvnsHbsoeN40YECqeA9gViUsniG3FLLWhMAvmPs2xtUqwNfxbrNamnGzIOdgmwAXJv/cSkeKbL+/pkEVZfBRMa5FBkDs49UzzmcIICr0Bw1FNBN5an8WTaJ3sjkXWf5LtQzW1z4qGGuUjBnMOkmXHbFZpLy68msAVUsHrKzB5YYbwL3HYEhbwkz7vPN54EuOAm893ufIDE4CxR1pBmTPBvOU9kKJK7y2ISofhggjQLFT6eUmrg3aRBFrI4fIVmAKTuiRg9QkQ5Uj7sf2U5qsdH1EborLWb7dtExwx6ehbm4GHYw/8UPC9K4aKKX7xU8SI64vS/6ogLHlDBDdosK8twBvY1asrbWAw7yXfXzwkSQb6o2rcRu5Pu9HYPAXx3X1naafbaXkyv/INPKYQak7ozR7YbxoEhiZH/WEcVABEv2Il7oeSZX/obB+cNf/He9rEik7bnaHsjgueRF3MeRQvN6K09v5EFvACFUVdW0geaRUq55i1XbU/is2uBNczlhmVHCHpgunUXMJAZVQTOji/80QQywuEYJUNWUv12UgCTb+4Dry5/IKBf8eGNst9GyuUW5uR054wE4FXeldWLo4PE7Goz0CZ3WOfPooPWiVhB5lgSKLPHyKzqpJZNL89It7WV74Iga1o1YyZ8Ju/Q9loxFuZGOlp1aYgdo3vAvEhM+nXb5S6//j37f6nWgZIFJtT/f41lqy/HQUptnLDd+kIrUEA1DmukwhQNYLhJ5PYAaIIugtNcaFbSKBSIZEfRJ92gCvj5H7+F8C/IqzYo8J69umGcsPaxQZrMQpfqAs3aHUXaQc76wd+rtjD3uu0wW91zXKXgfJPg/vsrtMaxZZ4xmVT9gjPtcndqP5rn5iPI5sDHFfbDw0S+yFtWw7sIWtvnYiCLW1VQsS48nfhqslfmrMbWEtKDmnvy8yDoo0AZCSg7lq0t/vaQNDjsjmOQlMMfs4wQrR/1VtOoLDv89+5G7g9k6R9D80ZOCc/VTFubXS3WqDo1dDJ5W9D2GE3ytsUpf2cAIdg3imuUi0h7UETTjpdd7Vt4Zc8wCthb8LQ8SPIZLoUfMVpBQuX8roMkwerZB7KohXtNkGVm4sk6eizySRYIgB5q24xlMjoGxpHwe36LyQV4JLHkKjzdyLNx+KsEX/8lGRxiEyUof1tClEBnqFy7suGPQ7FO2eKT9HCt/VwrpRU7U6w4ArF57vCaWzwo2fT4Gio36p6VPvl0iVdxJ0r79Tq3yd2vMKT3RmdjODouruNDwdUTetPJ2Dm6aR73cl3N/6dWoSYDKJ+5ZVi6wo4dvIjoq2t7/FwVglyQz9mn79oxqGtsmTZwgm9wKHKUsczn3DetovymYkQWJm3IcmiwMyfdOFzlKh204WIrWW1hHSS7tVQk33RnJ5XmB2/02nYzu0xoDKAyrJY3jij/9z6vim6tuFloM75Ru5uEzckesUc7sszEtQfYS0dhBv2FkfgTCfIShPuiEjpJVK4V1Q29OteSiwG+SNX1+MDVcxwgoWjkPiJ8XLZsfUWDV/1tlF5JsITD38lGIK8LayDJzBt784+NbX+NC/KhjWuSoIQnT15rXqbOAwysizHsNwoAEmdd9cJgbZhj7az26MHJzUJa1Rb1Wur+C+QaKqLt5l5BCSjMGQBAyHintjKFLpLfMZMNbKJR9fRjuuk2QS9hJaI3/gS5MBObcfS3laWFsQ8uR2ufthL5QF4Z7BKnzvmBWVNyZtuH3/rmPjE3FwPiqwU5dUVdm3aelhgXvOI6iizy3cQfoMjLxgRroXPobzXkRv+gVrRvOe8nf4xBu7iUKaGUbhEiE4oXoPyo9L2egz+51svUgSowX6S6FijqjtXDDKs0QL6cfzuSv47eCU6DcGuG8ZKbv3rtQdBJHhvEPLkj7J7PZnK3FEwx1j2KvkTBecpXRn1mRAtBhQmvvv5plEGyWXvqETJK8/gMJzrYHfHCIf1mh675PKUkC7NyRCL6SKHV5SmWDFNGSau0sx3bgO7Atab+JPCX4JXLxyzLVgJxq/DQDFE4EFqwqMSiBcaNKT+o5jaKxSmPf9vnzCcWEsQ+VttttwgYFbtc8ZgyFofQC4Fx5deaCyqrCmQ97nSV2EAW0YUeAAkp+NIPNt35RKW97Qcg2nzzrI70DQ5DOI/xwYHNAEbBYic71fy7dlevnfbbu19bK1Tas9wbZFNgNQh8dUd3B00ONcTo/Fjaope3EL9IKD4PIqxn70iLy2Rctcv4A93AwV7d5cwIiPORGRIxcxXbaCPwvy1Hyi6vknGIgEBtDnRYYnv4+kL5vCvCkf9T7wUG3xSbtD/d4zdj7NYXJjzywlYkDCEFl7Q+ula8asYF4AQoYne6kaEJVXjiygo5VF9e1ahEV83ZERG0kEGOF4CMsyteq8BArnf40AUDUZOwkd9AiApN2+ujSgoAtONSHB+3VqSzxwdu1qdC/8qMSoKxVXYieuZXdR5uigpRTjtegRb9za9qjRuqem7R7pW4VGwRypH7QgM5lDs4dreO07ldFTbGEvvkuxgdEVQ92mo1lLZqkRRfAjpwg4OowhE+/86qYPRsh60vd/pIhBVG463SvXwnLIOHRIHbcDTJQo1/Ju+QuxNKExrLOtr9I1KocCnmJpy/2DtR80pyrRu7WTqAw5uFlzRh8MXlZNMXAAriFe+pf4dQb6alj7IDwShJtT92X9bGgbWFxZTiGkT5CDj/lpLR8rVHkINTJFC8nQwV5IEH4o3Pal0TYd4wgtouO7XN8wq5fUs1oNePxQ9MqImOayhqs/NnIxjwzMN2JUgevScg9WBvLz6niObFHzoHxmM2K1q0L1kEQFJvCjfUFaqw64fvshLH6ytBf4ql5hA3S5qArFHw6MxBMlfChUSH2pVM0IQKA6JhkHLxPDYxp5e2GdKxZ09C4bUMqnqSEFBNamwbjutdp97CCtRDogRt9qJ0xfdTla1EMgqWWUl7HmI9z0vqg6dVKjMt5cMlD+9ygv5joH0tSiqNVe4sdRr2uEkdfqKHrAKZ5PkcOhvgZKbvb0jlwT/P6IyzspFEYjyJ4NCGis4BeSjIblB7w8a5Z3VJUj0S1AQTNFfnAbRK0f7V4ozuxS+G77cUlWpDpabl3gfC7xRuOKEuM37IWLJQ4HFgU/fl+t3Pjqdi1OE/DEd2F163ynvLsR/F6A7PJdmd3sh3BonPEkMSkczSbuHPHlUGeoE3yETz6xenu+VF9hRWTarpvYWXh1/ankbh29/NClG2P4MKSEcxSvH1y1TXZcTZdqP212Y3fPcQ4svo7c51lMFEKYwrywM8XUmH2pOBYbfoGUlgSWJ9QyeyPa3D391RUrw6Bcws/lfFRjkWLQMkdwWNNoOhauBYcNaxGcr6zoZWpWaW7po8Jt4apHgC+VDL34dsNNiiJ3hXOVoWu1AtQvijXlW2YAEVgc0YozDIFsIqmG1GzSKqzdfDmfGjLLx1WT0UbUB0iQSSGbO3UN74AsogPcH5GPqnA7diich4XRvQVOujlwYICo9El9F0E9AN8PlnB8ULQF7dQQfgRbRvnSgdBbS7B7YlzBO6TMJBB9LdajBGSSbm6qjXS0Lqde8hJ9VnCjU0BYGX25W8TplMl4mjEa5L6ZVCCiZyRAJzBEWuRcGGNttQDYz0poUmic5mOENZGwpC93JFWAutTLUx0s6dXSTUHONfh6EwfpXNCSIQwMS6lfKNVdoDWS5DUcEA+CjCniZPenJcDJF5m0K4kyuIGuZDj202qUeGQP55XHD/03OzHtQ97v3RRxJ4bb8V/Rez9Wt+X521567SAEqB9+u7naaTh8RdcZytRXYUpKbcQ39Ck5ebdHicMPsjNlSTnvMKyaFMKXXchW4rrD/7NtRs5VmObF6pusTZC1gLHd0AuNlwI3ALQ9HttekCKnQvRZdafCPZLd9AY86B4Nz5pj9F+3QUj/2RGVFhujvLx1AhjQxqxutgfZRDJbT41SGpHX0v0X0CNnjudFbpsGU87HcJRkUx1lTY2qu1Z6rpzqMxlZwD/L6n3dEDEB+SW3IM6KrNhUuulcQAQtEVE4K/Iyli3eQ+OGIVUk4Lr9JNq++0ZQdP+PNGqFFs3DCb6gad+nnYJFpo1dKrQiJ3N/gqZwPnjihStqcBheYWFjf4R49dcnT1nhGyH78Ub09i7kXnP1HqoQ0U2iOxXlt0X0gGcDffbC/P14NJ/O3DJOwyOJh2AheBqpf/1x86kCy/bR+J7244P/mczeO79SOqqyrbjcDuA6Tzb0fCfqhhmteMrSUwqvKr+N5Zrjit+78bGnJOzejhlbux0zaCx2ulAXbv30VGBPiNlVGC3hLPAWSaruzajnVPPbTNVYW9AfXc431M/Jh9wkRc1aAPVewCAJr+s8hcJWjFk7yg4Vv4IWf+JaD+Aa+v4Yd4nn07DU/vFJERAGT5aiOR6iF8vn8QSPhJP8W1UZ4wnPatsj8yj3F0WxLq1dZVfkcvOEKBLBmHXBb0xnvGp8uZaPSKdD82OOqr8AmSTkh/eoiPCr3HcJJJM9mle7UbLTQVCYpLQ4fXYYH7Li5XKLeZDHW7WgYJJuTU1zH0B2DEcD/WmLIMbXcYXeic/RKNmfkVefRJIn4DfUzRXqS857GerU5tZNl+ThwFUlOH2ywWM7sZ4Noj1IG8VsR7cixhZudabEitUyGs0Bv6Q+kMz7xPvIALUqvCsV6XvvIMKOKVBFzwCLkw09ywnEVzfCL4SV+dYC9FIxMsucMa5jU2UTJzsRPuzQ8qLDNUJ+PU6700uA3UcT/gFIMBwxAat0JV5sMPb9h3nIsaC8sXs9vvgQZDXLWtq1WFgF8DczXDjwMolDlwcF6/RL7q+4S/AgNu3aFKXK1suqVhlqmzflyxxWELCKWNpWozLcEt2yWdb1rGPEkab4XcyGP3M4cUyf8SgIYGesVpjRRw9rHF+Bo6zPCB2wePu/UJGoAsMHZYF1fkLIKEYmDPdXyjrXkhdfMI60SA3+rcXZtufr4QdtgknNc0EjOUuq2sAB98CZo+MBtSoucuO/aGWaOr2SXdPn5nzw+0PVZo7pdIjfJzxzCpEqPS7H4uJnRRFYFElyqHs6LdDbq2oeH+QOuZPzBn7z+v4VQQQUSkbWJXCfa+DbZgCND21vMVdQ6tsiAHOvT5oDyVUlC/B+/zumr2qlRvlZZh5c2MjpBDINN3lna0ua5FGSvrku7/sIHCwQDwahmeYf5BBv/mR/YAbwM8UXRNo2uS1WwTd8JGIBGQwKZgwh5YKiLwCML7iNmpzTwWXLB6HEwkylA4VDwIGx2UMNFZ/nltTIziPaWpraYIMfqGSMIUmSj6TiNNdpy0H3kZiTrvMeJiHxlS/eUescIvRAMc9l7QRPZONxnPMQ8dnilbwav6FYmY7TjUz+PzoFGCvbksdFh62Mt9z3r6Lo/IDNxcH5EupZhoYVvTuydUVPGrWO6i0DaTjHJkudhz2u+W462212+/zP4fPVb3sIOj91y+10v9eXez+siVm1OHO8m4/Dqg7o6j1OVtSuqX6Xu0Y5CgGsNHbZGUoLNrLU2Y1hX6H2c3EwuaE75JymMgS6KSRIqCHfXbCj4CXP318eIBq0TypTg/0u0ZfMHUAxSTbdFI/FXKn3tx4V7pJYQpDyZGbWnCNMbmakKkP510RO79G1lr9UQw8eOXCG2NEV6QBLbvrDmXmZSVPlobvZRn4E2CRAsvWlC6gNMcVbKZqXOz9pWLvC0M9VsmVd9saWCryJ9A9bEG5mzL7RghGixjbelbyqtrdWok/q8HnVfC7a3IvNJY7rRofbPHHcydf7FFdr1pTmqhUou+iXHP4hCdphGmWk7cxrBr7jq7ChZkn3qg0ZSGRLOAJFcJm2Tk6vwo82LIgmhI2/IdXZZupscljrwwl4bIq3y70e102GWkt3NfT6cTo240iCaypEyaJIhr012ner9gU8VD55qr9/oh/Sl3WWgLDmHwhobGBB4X0kImZjV4/23JtzYAkCclDOQKMOGdspucrUPTdF/G2tNMZL+xwr9CfyVESwXeX1T4XzZWNqcGhORz3br0mGMFijqveniTsrKPfUSkk4Zcbj0Jxm8d0FgOqvG9BBOa0QulRo/w/huz/pc2QfiqUY7lyZSR4THuPI6pa7ChbbaVJAWRCXq6us07O1t+AHnfzIg2OlNVxOEDpHMBxxZTQL1Z+I9Q9izgJf+Zr/tDODij/p0TO6j+gATNYLc+GCjUAks1oSYYT3gl0jST8ujg7+nXh3OkMBGKH/tgKMJwRVMmwJp3kWbhdPbexJIN6EK7dJPVqO0VTQ30b5HWFC4eBIoqJpDFUSXmDPKJJ4KwvngtCpAtEeKiVTI732xRuf7EFW91AnjKF3rKnP030iKFq+x9liQ7PACTwjy6/AtqKSCs+MMRRtejv9E60kDodVxHeIb19FGABEzYUWoIX5Pv+h1/DTG4GZOebW0TKgFT0qI+tYeISrYF8emTtT15ZED5vLX5GUvWNVBfMMaq10TKMu/4XQbjCWNiSfuGpZ7j2Jbi4vpLae99lbeeFnf7vh0fh1aK2qalOemcmIgilcFvEL+sY7P2pl3MhMqQu958g9UMSnrNsYNUlnx+9bC64M5I56p1ETyLqi8/uRkChKpS7jVEZBWwYe5/2xxZxngTjx6/Wy7Vrzbp36uXLSFP++f+KOE3jaFmcROKH6tq8lct4tqKuBusl9jhrtfXM0zYgPMeqyIyKFyYi0U0tunFqafu4J4BiNxN14g3H74HLLebi7L9MOxmFvl3grcB6Wg1LUPweG/eoLTO5CgTHsZqKWT1eMWIuxv75gDTzB0RfloI2/5knhIksF98dAKXRgM/vsHNmmcv2RryNgIwfPaTwKobNVkrF/R3LrQFo5c4CZRkmTysMqu/KqtBSq/HFr7USF0PbcOFia/krnzM7fdDy4hmzCwBcHe4EYu0K687hWxz6XFysNMy8lSfgXK5/6AwunDCpZrNJEm19Hs4KXiHibY6xeSX13t5C0hKjR97/7Nv9OE4xZuH2S1aOSnakLMyKJZCYQg/g1KYjU5gLpVg6rke2wJJ+kowjlhxcZi/qsoRHOlPDdC2mfoNR/NREce4v8YXPAoX5D9yms+CoqRauhobE1MT8n7Hi330z5suUEelliv/VIConVUggZd+AfoZuUBP4Aj3+Y7th8Xg9ECJfvLAMbmbnTvHQIGRF1yrXFEG0wlTDBZlFUgcCgzZOlfpL0IMU8TSOsj+Sd5+5Sdz0aqBQzKtnDAOsUGapH06uWxI/UPDO8uO9vo7XodU317i3tDKvJvtsVq/dzTVPqn1D+XiDh+OxNz+6ZI3C7+x5mm5p3PVao2HpCt9fSZ6VrhTRjSHpkijQgTAggdBTHAE3Xp34LhE9cuR1Uw+Clxo+nnIKYZMMVxetyLwN3G4QM6vxO8yZjp2vBFJsQeS/se3x/cauZaPfamHvvvLMISMHPqXbKnDcl5GmgMTvtxzfqr6EItY7RsKQivbVtHAiRg0uHB7kRGeLuv3RnaFF6cLFIRdXciCduTr9IosyjGGRm8l59p3YQmc1uBHN9hWx3vNSjdCnlcC2vHqnavI/0KzmnY1JibGP/HV0Jy5mJpipuqd6Soc203zG6ilQmnDpL7kaqlIbCwFRvlAT+nud3AgIFMsoHU82BNWAz3wgz3SmIbgiNCSoWNiPYiDTom7+DW732pAG6wL+LZWz59mslkeBGGDgiEKeXRTsQitEoEm4sJflINdXZMpuZatOmb48+lnyOJrzf8zgY1i894GSTzcacIDrqpIU6AcHB9LXaAOlXzmOgTwDUkuEjPVk6NesovEGt91rw9LL+PR0xQPeQ9GNCWuR+1uAGZWHqTmRb+KMSuJD5LYHzpV5AbIcITZOddVMRheGQt3vJO852z2NlNwpPB1J6JSAQXF1kfHtgiAQyTPxnAw9xu3UyXkJcioZSy5En0lfGOs15nQHwSc1oqqcFTV0rH6DnuAqZW0nhPbxRVYUH9nQ0EHvSG7uiYKVo8KWY5/F+Kxpcv0EwnLuA7rLavB8wZI1qLAZHJws/VbTG8y/OWThgrLgMFv5RZ57L+El7q6zUjivT8Mv47wYOxM5PMUDNzP7nJvb3SX/usOK78xVuoXt5kDH2b0IGgb5voRhaYeMHT2jisYzNrBn2hWg3xtDWNneM2dI5SPQj4tQWpOQlbSmftvuSSKK4B3cPpiQU/9lYRKDUSfeWMsF762Fi0tF8drAc7t6GKGRb22QQHNyumD7l+vCrw8l7mqEP8OstTi6WQM5Il64BuYJsdqvAVEsZwUhrJGJG0FB2jYsFk4BrajA4Db/MsbMnRThn4CX8DJUCt6/eJfYZ1NZYtqI8IVCU1SuqpNYYgkPH85iyeE0xzqrcJ2cM4UCfLXl21slWpIJwE9If5pxveVHfvME39UOGZRYjsMBUH+E13LQTq2aq5lL92kwH8vOEsoG1ZDx+einVNTr01pCRLzN4q5FpHLDr963MiVNLNNwroR0/JFO1+rsO5TN4CxDrQmBfSIcOP0KysYfCdbWROMsjBHpdPfcn4SBs/bmuwuDihQgHft4wCD2w6WVofARmPfTCoUrdRJ9HklhcEfas8kPPdEx/32qctw5ndM0GTXDc1J6oOPrzlqKtoLnDkYhk8R3iHw/QCqrqZnnPgpx994w61IYK9D+33nGSxKSaQLKIcdrvAOFHdrs1HDHkqDe/X4Bw7FACubbc1aNQvIfhLHEa9P5hmoB4DUJ6xhMaWAjrLDB4GRRwDumOWkk7WMpCaPtjYJfwPgh6DJAjq4Z+eeC1CMkmUlRQ7U/b5Z+QdcYW0F7us+3nGhS0v6nUdKNgQj3gige0VS7RrQ6JePLRns5LJsBqBbuLzdGHvJLJD0GcYeX+bF+5QxpktmX7qs+J56Pi3dxtz1HdixlK/KzCgjNEQxIokRBMXwNKkW2TDMvnxRrEY9/9xfYOYMy+aP1n1Tsbh6mcZ+v4fgYl5+B3hohT//X4Ud0vEeZEXz8Iszde2HbyUtobPQzXVfd/BWRGWYrv3puFLEEDA/mwo8HgjiJBSG9M05ps7PpPmraxqzNceuKziy29/DcCoOWDQMDAHmtAigVPBay5DJfcPpth7fjJ+1FVm/JpWPlrMFVibhalIfeLvwmP3NevuWKU0M/JlWDefNgDdlo3CYGCNebol8Q2pXTDN+f+L3uI9yxBwFEg6r2+z4UcigeMGM2fuFj6KVzkWqeHOpjwkcPiDjCrn5VJHVJymQTyV8nUVXptqPjF1mKm2ysjJh7z3pFb/oRsSXrLsp49FUbTEsAf7CTKyGRdHPXE0V/HVq7042OW2hNQEdPwr2unFk5ny0s6N5P+ke4QRw7L9Q9ukyZMbRg95fV7UPDkijMlmgEjDHpOKNanIWw1L426ISPRGFV0xD5stfLocpK8SPxgU0qtMGCFiFgH1CDTcHdRl9xS365vceuyiRMdFA1375puNTEv7P/CKz7NBKmDARBMRgj2KstaHA/CvsUZowwcLtfFXmLA5p3KZibedqT2VwVAgCFpoRDhl+YrWhfT4wzNO6Bq0kjKfWD77XOD4VDd3N4hetqt09e4OyidCCjVSZSTICKLTuZahPw+d71cnTnlLm3Iz0cgEU4tTReCZlYEy5eno569C//nHjzSq2AV3eDpnOYNfFtZz4Y72EbM4EFk1p0S67M8fjjYl/A+IpmyhOCqXxfq6dM/KIK3rA6RS6IrI/1qeZR9+/xEol3l+8eoTakVOF4KY7c+waLa/9r6i/QG3joLW7bXjbSiRQ3oaSmeaCbq3rq4WyE+VILbs+bDXdonLqH8TfMORMuIP4aVFJ5YlSYFtu54JzuUM3417CnI6ETpukvd0xwSNlvPSup9ggdmxl1vJXljmbqfFzCwMMjoJvZ7lhQ3ziLLEDH+IBR5PfECAAERApG24pajzMnNngdn067wtJUi3zny+fpQXYymyVAl5D4j1lPcWtw0SQgkw64CV+R87oGPDe2eXuSJG+XwIoT8jN2H+t+gBTwdnPcz2yjKesh3T6VX6dvfr7kgue4He9duMWZEVqaV/Oq23KYKlTLDE2ptrIWf0MYNy5KP83Rl5VmIx1duwVUVO0xyRZ5mJp78e5h5bBe5G4ND3ZcaBQJVRWlUU7tI2dgNhYqMyk3kjDAw8RWlq9YJ2NoC2pm/j/XRvrU/1kBA92VPSfpAdHcL42AkyWLeRT0dyGeXDa4H4cnsMZtD58rjmgBUMZwjRExaoYcM9kGb1T/dylRELipcIBPhwReEjbMHQJtxz+K+5yYJRsf9LAvgSo5hxiNM8ptMP9NLJ298Db6MRRPDHl51rqDNFiJYlXAMra2AbCkuCftfsJZ1pJSktTvUgmqM3Asf4ZDDmq8D0G5yK338RGraqDKrSLU1jqTit4aDFuY/AJlubfywK47/TL4eHQTMZrlJbiqrYxsW1fXbUSpGbUl++ByVPECA784nJnaAiTJoXOuD+tHU8ZQtjJoziV8eVTRK6kyIi+/7CxyXyuXbXyjG6jAzcrAZ7Cqg//vrOzc95WDRM2np171f2ThBx1Y2RILfX53j1t8LgmNxrafr19kb9BUo7sxXdn54wAz1SzrVnblJchQwuw0qmk/hAG2BgPtKB42XSFr3oJKmH2c+Ij2gtUqVscxsE0cXZph/I7ECx1SGRvSmQXRiG8htonW9SJ5qk5Spt45ReB/tROb7MHa8RuL5ASrwtneMIkmsZfNZhtE7PmI6tTq92mEII+pW/eGPBF+C61FQa43Vq2c6BESmFiGda2licTAZgSdt+Gkh/tmPylGW8++qHS3yY2FQIJbFVi+9HSXIU2cl79tyNLeiAyRELr/+Aor9MsbfPmaSW2wj2NT3WdjL2UtTn+SO2ChL9jG0P8+EE4ROdB98DAHfVcTTDx6EixdMrCHUsofj+J7t3V4Cj3d5aAb8wZoWx29UKt49jAHuGjVyU35AkcHQXFGSskJxRrdGlPpl4O1k8chmFcRmeJz72sHif11DveWxnfwnNJhcvVSTO9UGh8h2+uiGeAuL73Xrw9uJujY7EXppN8I6/p3HaHHOiHl8dHTUHWhiOSzVSQYwGEQqZHRMfw+SaqfymZhh2Oe+SlQrNj5V9C2ODexWPSVbzhcMxMeKzw279KcdQBgldmfA1JEi3yLhcV225P360UUaCPmZXlMhZGcijE33FOPiNn0kARo1BwW1REG66FuYqnmFzHL0hXv7jJsGCKVqQJsTmJYKFUnkg7G1ypjzGypUHg4+qFU4qPZAunqwI6lCA31TiLnMSpqjLPEKhDNdW3dipfRj+clLUnv69ulwHcgT5vmimPF8daH08eIF7CBLWZ25/yVLpKqKWY3qfrdqdls1EOb2BNXWYAcGFnyH7Rb8Qz7OZZpyttRUqGYlAu3boLIUwfhGbUqzaRPhvtiONwdJmtU12JhOR5Chg4X6i5Efc3LpKfUavqfRiaMdNB9hB5HT+Q/mYjOqEuVeJKCerqngAQvKmLIVi8WKyYXnAyVcqodMz47/UQj7DPWfh3pZsvogsMth69Frfv5xi5eud9evSbE7OZH6NCnkqiUQ4ELZKJaF53auJFarsOThInjBG4axxowzoRSvdDpMGkMpUD2fRdslNpSKC5L8tQiroUpFqZzyryGVEfW8jECuuT8wEaoQzzvLYGGPyjGcoAhJzx7OK2lcphjksLPHJoAo9R3t+JF6s/ZTYMgRZgzz6Gv+00Gl5nwpN4Z85zSl+m136MRWUZhajWgUvi4bqAzr43NiYNrWqRjnKxC5oSHee1UgPZzljZJYH0aap0032iaJeovuwKSMGxR9o7/nVtnZLikAtDMq6RMZHwjGpWR8PYq57PBle79pDTolAGwmnIoMAzycU1l2vWTybaE3eZG9JZbckf0v6EOqA3jWMQ9P8PzTvsOfsOHFdwY8NYP3vim55Wdzqd7QPpgzp17wkIwyA1hD8KcJKO13xVvwTdAbYpEMBSx6W1us0rLhkUV1+032EvTqxWt2bNlYMDM4iOqjRIUKK7ZUcAnGMvQebKLebIjhcYL7Ee+7vCVb+YqlH+JOZsz8odQi5pMtFLXrZ4HQYhrS/YlXWiMb0ro5RHg4cjqgxynXz7PNUCplyaaYnr4OXFlmcsrIewv6+XMkZlQ/dGe3STfxkIY0qkEpRPjGOr13vaHcs8RRG0CauQ+wCpIwTDck0au0IJvnpde2cAMso8M0r4hvUU8e75lSu+klpsJOByIGMfCIOU/T3CvmXiLsRRCEoxMQZZOpbpHiUX9QhqDAOlgUumnse9UXtz6YE3QZqE7SWHa/B165NA9qjbT6HhjQER1J91kzXPoIvoLfK/ujCcsjMvMWkzPMjCtLGjtTGpQVag5Sdp0DMz9QvoqK603+JpgxVXP74WWN+eU0/JtlJqto8tcBtsfQkS8ruJAQzjgmzzXbNxKv5i48cBb0BoNNZKLaOHZIJuHhLcMPyZZefZFdX6vA4Q5IOfZsU1AKHDdJ9Z8S65Gz41YrKi3uVr605CxzayC6lsVt6lrVUAvZ+j1RDzTUpRX8lzZvTV6Iv+20dqQgym/8hrkRH9x+B4gUUBlqTcuoMUhSnwuXO67bOfqke8PAetESY+CH4XRcM28BjFCO+e9Ue/HKeo4TGElfz4DkWjlCXTj5pzHHoUzQm7u1Q0F3tB06sLrQHIzRMqaGvPeLgLqbbqY69xjQjsoMhzLOuYnGxC4mTY752HWts92F3CuV6LeNDa5c9ltonMkuXgS9FVhbnXYuMTB0T7y6CQ4TcnqwiWb/ZAIBPgQDcM8H1EIGYTjVsEGLlvv9dLFGmq1KBQp+76Ms4um5O329yVG3n68U2z7TsXJcFMsVXkiI/LmP1XHxezhoztLe/ytFUhmZG/9vPBBS6jjrb6jfJp0QHUfnQqnJfkdsZTOUuxbeWcFEwd942li1vOeSsT4Ieu3a07c05Y2i8OrXsm2Lfgim2jEPN8PLjL3uSmaN7hr7So/Yh9ps1Hruz2dw7RVotvnBGiCcKlrKPOQwcWsGNB3R+nnzzm12RhuSxzN58OEr/Xp9DECO0PySZDO3ZBmnA+T2uXACHoWsqtv/3KEuhLhKTEg9YiZspy9k73dLY+P5yvTJ0l6d4CAgsXQa7hwqQk/720a+DeK98L+sIMP5CKwr99QHPtvTpGpmZN+brOUYExKcI3jkCXYns7jBEY8RxrWRR01JLXCAOIa8hq+tcSOzdQ/b1NEblAjJSlvxFWvrRYjyzR6jLm6gY3LlLLAWM5biJO8VUXBabHTir+5fXK0VTxJYLv+ag0L1gsxasWPuINeFI88HG/zL71iMmeTnt3rnxE+KFPOAG69W1LmY8LYugjCRnfY8z9rX3t0es9wGSPlb2CHSL0k64w/1i1sQ6h+g9uiCLD9KKVKcdgdYaHm+nO5s4l55GpQwRgPiuqwot0wNZgQok6pCpd1nLTa8CvYicHao2QGIl8DQc+pXBoajYq0hj05lN1HtYfV1zq4ugZgpV334JxoqQtfp0VO/tEdORFGIPBuMRO9W7QFCxuEAom/EApF12GNV/I90MFyd82fXpWd82HmV6aPEMXFC6i1h8Upl3mcYJAeeMQF7vnHKNvOjPcyicmpRUZ4XIuw21k4lViBCyntMAt1cjSZhNdX/lLpXyCpvl8U+H+idRGOEAabx8p8aljJ1p7itquY6Sxd+TDayP7vU4Zaa9SUzQ2NsZYnHWQwBjXuJZtzzZuZPYAKbI7sG7emuPn2a9gjA96rFMqiJo3zzk2z547dUODczlApaGFF8zhJ1dewmKLbGg0Gb9Y6i2FzP6qcszrMVWjw5dhfUpxnzrjHKZnGbibIvcsoMfEFMivbSQeKJM3BCVnDdxFIwXhbsLSO5lF8xRSsgrkOiWtBfcLmc9py6UY3OMJa5anz4qxRJgFDsiRK1YNjUZdfoAANQPTWwUDsQYCBvMyHWK8aCo/A/Yd9Xz4zx7mU9LNcWYusvZrWeQADysKlTKylzOZoNwRe2tM1ye1cycp621YtX2qx3/AIxykQvcfFuCMRom36Lz21gpJI38zEkQcZ3ulVo5X6j0gux5fwtuErnhQqmZqHDaBX2zuaH/tBNEOqyjVph4lehj6pY92io39zoZ7kzIBQTYQQw60iYhd0OvaQHSRpKKMkIaeTg8RFBYSzO/nOsz5br10R7D+SycNi+f5hmF2Q/HLFs3i9k1Nria++0QP/uZxx+tiIAdnMh3ZrK+Z/EL0xW1hTCAUjXc7XVT5rUsQpbxEbtgHQRwzq9druF3wKKMmMadIo2Qn5i62/c8NHoRQA0USXJJE3n/mUDwQ3RFtE9WYIqZGpqETv9sqLi+dix2jPc6PaT4OEIaq1dA/87GitG14dhHaFKEZJ7w4xjmyGDNrF42fMzxhLLv0IMrWmEi8LVOB30IS8zsJxr5GuwBZ6wYszaSIVNLaUJdpLnXINaZ+axSU9xk9TKAfwtsv8+0xZTkAF988fHr2xZtFDexXu9dGEzXFhwjXu7K3ZFWmjR3Ss1R7eq1NreGBH2wxEdmVEqaRjK098vE7l4S5RE2HMG7E//gbs6MPqb+aiFa24lcTtnUsG+W0kxOi6u2dBvSMdD3Z/TXyKHhwIQIcE+uEB6RLDFd0qV+xaf1LccFaQEdIrujI85m/+OAT4RSto52alQJZpmRrk0a0kwI70TM9JffoMY6kBMg==]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-Regex-Engine 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185118611871188118911901191119211931194119511961197119811991200120112021203120412051206120712081209121012111212121312141215121612171218121912201221122212231224122512261227122812291230123112321233123412351236123712381239124012411242124312441245124612471248124912501251125212531254125512561257125812591260126112621263126412651266126712681269#include "stdafx.h"#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;using namespace std;#define TYPE intenum ColorFlag &#123;RED, BLACK&#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode *left; RBTreeNode *right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;left; RBTreeNode&lt;T&gt; *q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;right; RBTreeNode&lt;T&gt; *q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt; *&amp;ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt; *p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt; *root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt; *p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt; *p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt; *ptr = root; RBTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt; *DelRB(RBTreeNode&lt;T&gt; *root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt; *p = root; stack&lt;RBTreeNode&lt;T&gt; *&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt; *parent = nullptr; RBTreeNode&lt;T&gt; *q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; return root; &#125; else &#123; return parent; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt; *InsertRB(RBTreeNode&lt;T&gt; *root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt; *&gt; stackforflashback; RBTreeNode&lt;T&gt; *p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt; *q = nullptr; RBTreeNode&lt;T&gt; *g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == p) stackforflashback.top()-&gt;left = g; else stackforflashback.top()-&gt;right = g; return root; &#125; else &#123; return g; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt; *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt; *ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt; *p; int direction; int last; memory(RBTreeNode&lt;T&gt; *p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt; *root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入"&lt;&lt; *p &lt;&lt;endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt; *&gt; *keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt; *&gt; *keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt; *leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt; *root, BPlusTreeNode&lt;T&gt; *head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt; *p; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first ) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt; * ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt; * root, BPlusTreeNode&lt;T&gt; * head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008#include "stdafx.h"#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode *left; AVLNode *right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;left; AVLNode&lt;T&gt; *q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;right; AVLNode&lt;T&gt; *q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt; *&amp;ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt; *&amp;ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt; *p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt; *root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt; *p; int direction; temp minmax; int lh= 0; //节点左子树高度 int rh= 0; //节点右子树高度 memory(AVLNode&lt;T&gt; *p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt; *ptr = root; AVLNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt; *DelAVL(AVLNode&lt;T&gt; *root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt; *p = root; stack&lt;AVLNode&lt;T&gt; *&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt; *parent = nullptr; AVLNode&lt;T&gt; *q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; //情形b &#125; else &#123; return root; &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; //情形b &#125; else &#123; return root; &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; if (q == stackforflashback.top()-&gt;left) &#123; stackforflashback.top()-&gt;left = parent; &#125; else &#123; stackforflashback.top()-&gt;right = parent; &#125; q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt; *InsertAVL(AVLNode&lt;T&gt; *root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt; *&gt; stackforflashback; AVLNode&lt;T&gt; *p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = new AVLNode&lt;T&gt;(0, key); //新节点插入并调整父节点平衡因子 --stackforflashback.top()-&gt;bf; &#125; else &#123; stackforflashback.top()-&gt;right = new AVLNode&lt;T&gt;(0, key); ++stackforflashback.top()-&gt;bf; &#125; if (stackforflashback.top()-&gt;bf == 0) &#123; return root; //已平衡结束,返回根节点 &#125; else &#123; p = stackforflashback.top(); stackforflashback.pop(); if (stackforflashback.empty() == false) &#123; AVLNode&lt;T&gt; *parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if(parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt; *q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt; *q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; if (stackforflashback.top()-&gt;left == q) stackforflashback.top()-&gt;left = parent; else stackforflashback.top()-&gt;right = parent; &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125; else &#123; return p; //原AVL树已平衡,返回根节点,结束 &#125; &#125; &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt; *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt; *ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt; *p; int direction; int last; memory(AVLNode&lt;T&gt; *p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt;ptr-&gt;data&lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last ==2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt; *interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt;"("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data&lt;&lt;"("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; AVLNode&lt;TYPE&gt; *root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
