<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr &amp;&amp; cur_right_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; if (work_stack.empty() == true) &#123; if (cur_left_ptr == nullptr) &#123; root = cur_right_ptr; &#125; return; &#125; if (cur_left_ptr == nullptr) //这里cur_left_ptr和cur_right_ptr不可能均为空，这是因为向下分解合并操作从两个均不为空开始 &#123; cur_ptr = cur_right_ptr; //而只要有一个指针下降为空指针循环立马退出，故两个指针不可能均为空 &#125; else &#123; cur_ptr = cur_left_ptr; &#125; &#125; while (true) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; if (work_stack.size() == 1) &#123; root = cur_ptr; return; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34 &#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fpost%2F16107.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:k-d树]]></title>
    <url>%2Fpost%2F41514.html</url>
    <content type="text"><![CDATA[k-d树是二叉搜索树在k维空间中的扩展，其定义如下：一棵k-d树要么是空树，要么是一棵满足如下性质的二叉树：(1)每一个节点的数据域为k元有序组(N0,N1,N2,—,Nk-1),(2)每一层i上的每一个节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k),二叉搜索树即为k==1时的1-d树。k-d树第i层每一个节点(数据域(N0,N1,N2,—,Nk-1))代表k维空间中的超平面X(i-1modk) = N(i-1modk),该超平面把k维空间分为X(i-1modk) &lt; N(i-1modk)和X(i-1modk) &gt; N(i-1modk)两部分，节点(数据域(N0,N1,N2,—,Nk-1))左子树中所有k元有序组在X(i-1modk) &lt; N(i-1modk)中，右子树中所有k元有序组在X(i-1modk) &gt; N(i-1modk)中。k-d树实际上是以二叉树的形式对k维空间的点集进行有序划分,它是二叉搜索树在高维空间中的表现形式. 注意，下文中所说的某棵子树为k-d树并非指该子树为独立的k-d树,即该子树可作为k-d树独立存在。因为该子树每一个节点用于分割k维空间的超平面实际上取决于该节点在该子树所属的k-d树中的层数，而不是取决于该节点在该子树中的层数，也就是说，除了这一点外，该子树实际上可以被看做一棵独立的k-d树，所以这里说该子树为k-d树实际上不甚严谨，但是如果放弃这种说法，描述证明所需语言在语义上的繁琐程度会大幅增加，所以下文采用了这一别扭的说法以简化对证明的描述，在这个意义，不妨可以把一棵k-d树的子k-d树(包括该k-d树本身)定义为:要么为空树,要么满足(1)根节点(数据域为(N0,N1,—,Nk-1))的左子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k)&lt;N (i-1 mod k),右子树中每一个节点的数据域(N’0,N’1,—,N’k-1)满足N’ (i-1 mod k) &gt;N (i-1 mod k)，这里i为根节点在k-d树中的层数 (2)左右子树均为k-d树的子k-d树 下文所说的某棵子树为k-d树即指该子树为原k-d树的子k-d树，显然如果原k-d树删除操作后就是一棵子k-d树,那么原k-d树在删除操作后仍然为一棵k-d树 k-d树的删除： 设要删除的k-d树节点为p,p在第i层，若p为叶节点直接删除，这不会破坏k-d树的性质,若p不为叶节点,如果p的右子树不为空,则在右子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最小的节点q,用q的数据域替换p的数据域，如果p的右子树为空左子树不为空，则在左子树中找到数据域(N0,N1,N2,—,Nk-1)第i-1modk个分量最大的节点q,用q的数据域替换p的数据域。替换完成后，令p=q，对p重复上述操作直到p作为叶节点被删除为止，然后删除操作结束 删除算法正确性证明,如果要删除c1层的节点p1,若p1为叶节点，不难验证直接删除p1不影响k-d树性质,若p1不为叶节点，根据k-d树定义，在用p1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c1-1 mod k)值最大或最小的节点p2数据域替换p1数据域前,以p1为根的子树显然为k-d树，且以p1到p2的路径上各节点(不包括p1,p2)为根的子树均为k-d树，替换后，设p2在第c2层，则用p2左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c2-1 mod k)值最大或最小的节点p3数据域替换p2数据域前，以p2为根的子树是k-d树，且以p2到p3的路径上各节点(不包括p2,p3)为根的子树均为k-d树，替换后，设p3在c3层——这样不断进行下去，直到用pn-1左子树或右子树中数据域(N0,N1,N2,—,Nk-1)中N(c(n-1)-1 mod k)值最大或最小的节点pn数据域替换pn-1数据域,替换前以pn-1为根的子树是k-d树，且以pn-1到pn的路径上各节点(不包括pn-1,pn)为根的子树均为k-d树，替换完成后，pn已为叶节点，不能再次被替换.此时要删除pn，在删除pn前,pn所在pn-1子树为k-d树，这是因为替换pn-1前，替换pn-2后由上述分析可知pn所在pn-1子树为k-d树，替换pn-1后pn所在pn-1子树显然仍为k-d树。删除叶节点pn后pn所在pn-1子树显然仍然为k-d树，又因为pn被删除，所以由上述分析pn-1数据域 N(c(n-1)-1 mod k) 大于(小于)pn所在pn-1右(左子树)所有节点数据域相应位置分量，且小于(大于)pn-1和pn所在pn-1子树相对的另一子树中的节点的相应数据域分量，因此以pn-1为根子树仍为k-d树。考虑pn-1不等于pn-2的父节点,由于和该父节点关联的替换操作，删除操作都在pn-1子树中进行，且由上述分析,pn-2替换后,pn-1替换前，以该父节点为根的子树为k-d树，因此此时父节点数据域中对应分量一定大于或小于它的pn-1所在子树节点数据域对应分量，又由于它的pn-1所在子树为k-d树，故以该父节点为根的子树仍然为k-d树，同理以该父节点不等于pn-2的父节点为根的子树仍然为k-d树，就这样层层向上递推可知pn-1所在pn-2的子树为k-d树，注意pn-3替换后,pn-2替换前，pn-2为k-d树，pn-2替换后，由以上分析，pn-2数据域相应分量变大(变小)，因此该分量大于(小于)与pn-2的pn-1所在子树相对的pn-2另一子树中节点的相应分量，同时该分量小于等于(大于等于)pn-1所在pn-2子树中节点的相应分量吗，又pn-1节点数据域在pn-2被替换后不是被覆盖就是作为叶节点的数据域被删除，所以此时pn-2数据域相应分量小于(大于)pn-1所在pn-2子树中相应分量，故pn-2此时为k-d树，同理可知pn-3,pn-4,—,p1均为k-d树,既然已最初要删除的节点p1为根的子树为k-d树，用和前面类似推理不难得出以p1父节点，父节点的父节点—根节点为根的子树都为k-d树，故原树仍然为k-d树，删除算法正确，证毕]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>k-d树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[部分冗余消除算法]]></title>
    <url>%2Fpost%2F63446.html</url>
    <content type="text"><![CDATA[计算每个基本块入口的最早放置集earliesti 计算流图中每条边的最早放置集earliest(i, j)(编译器设计p411) 计算每个基本块操作数被定值或表达式被使用的表达式集合used_def 初始化LaterOut(start) = 空集 LaterOut(非入口基本块) = {所有表达式} 按以下数据流方程反复迭代直到收敛 Later(i, j) =&nbsp;earliest(i, j) 并LaterOut[i] i=pred(j) &cap; Later(i, j) =LaterIn[j] i=pred(j) earliest[i]并LaterIn[i]-used_def[i] = LaterOut[i] 计算Latest(i, j) =Later(i, j)&nbsp;&cap;&nbsp;&not;(earliest[j] 并 LaterIn[i]) 如果表达式r1 op r2 在Latest(i, j)&cap;used[j].in 中，则根据(i,j)是否为关键边在i末尾或j开头或(i, j)边上插入指令temp = r1 op r2 这里used为被使用的表达式集合, 如果从给定的程序点p出发的某条路径上有对表达式的使用，且在路径上的p和p之后表达式第一次被使用的程序点之间没有对表达式操作数重新定值，则称表达式在p点活跃或被使用 接下来通过数据流分析得到每一基本块开头到达表达式值的集合，这是前向数据流问题,入口块出口处到达表达式集为空 其余基本块入口处到达表达式集也为空 对于操作x = r1 op r2 设操作执行前的程序点到达表达式值的集合为arrive,那么如果表达式r1 op r2不在arrive中，则将r1 op r2加入arrive 并删除arrive中以x为操作数的所有表达式 这就是单条操作的传递函数，组合基本块中所有操作的传递函数可得基本块的传递函数 到达表达式值集的交汇运算为并集运算 求得到达表达式值问题的数据流方程的解后 如果之前的边(i,j)插入的操作temp = r1 op r2的表达式值同时出现在基本块B入口的到达表达式值集和向上展现的表达式集中，则将基本块B中r1或r2第一次被定值前所有对r1 op r2的使用替换为temp 算法结束]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>冗余消除</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/NTRWSK-RE-ENGINE 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三路划分的快速排序算法]]></title>
    <url>%2Fpost%2F52200.html</url>
    <content type="text"><![CDATA[阅读清华大学殷人昆数据结构(第二版)c++语言描述一书时看到了三路划分的快速排序算法，书上给出的实现代码的宏观思路是正确的，但由于细节处理不当，代码本身无法运行。在网上查找了众多三路快排资料，无奈其中代码注释太少，阅读起来较为吃力，书上给出的代码无论如何修改调试都没法正常运行，一怒之下决定自己实现。以下给出的算法实现的分析细节较为繁琐，这里没有给出，如果不知道什么叫三路划分快排请查阅殷人昆数据结构第二版p412，这里直接给出c++实现 代码(C++，如有错误欢迎指出，共同学习共同进步) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321#include "stdafx.h"#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;using namespace std;typedef int type;void lmove(vector&lt;type&gt; &amp;list, type left, type p, type &amp;i) //将左侧与基准元素相等的元素移至中间&#123; type temp = i; type k = left; while (k &lt;= p) &#123; swap(list[k], list[i]); ++k; --i; if (i == p) &#123; i = temp - p - 1 + left; break; &#125; &#125;&#125;void rmove(vector&lt;type&gt; &amp;list, type right, type q, type &amp;j) //将右侧与基准元素相等的元素移至中间&#123; type temp = j; type k = right; while (k &gt;= q) &#123; swap(list[k], list[j]); --k; ++j; if (j == q) &#123; j = 3 * q - temp - right + 1; break; &#125; &#125;&#125;void quicksort(vector&lt;type&gt; &amp;list, type left, type right) //三路划分的快速排序算法&#123; if (left &gt;= right) return; type p = left - 1; type i = left - 1; type q = right; type j = right; int pv = list[right]; while (1) &#123; if (!(i == p &amp;&amp; p == left - 1)) &#123; if (j - i == 1) &#123; if (i == p &amp;&amp; p != left - 1) &#123; ++i; &#125; else &#123; --j; &#125; break; &#125; &#125; type tempi = i; if ((i == p &amp;&amp; p != left - 1)|| (i == p &amp;&amp; p == left - 1)) &#123; ++i; &#125; while (list[i] &lt; pv) &#123; ++i; if (i == j) break; &#125; if (i == j) break; if (i + 1 == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; j == q) &#123; --j; --q; break; &#125; else &#123; if (j + 1 == q) &#123; swap(list[i], list[j]); --j; --q; break; &#125; else &#123; --q; swap(list[i], list[q]); --j; break; &#125; &#125; &#125; else &#123; --j; break; &#125; &#125; type tempj = j; if ((tempi != p &amp;&amp; tempj == q) || (tempi == p &amp;&amp; p == left - 1)) --j; while (list[j] &gt; pv) &#123; --j; if (i == j) break; &#125; if (i == j) &#123; if (list[i] == pv) &#123; if (tempi != p &amp;&amp; tempj == q) &#123; if (i + 2 == q) &#123; swap(list[i], list[j+1]); --q; break; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; --q; swap(list[q], list[i]); break; &#125; &#125; else &#123; break; &#125; &#125; else &#123; swap(list[i], list[j]); type tempp = p; if (list[i] == pv) &#123; if (tempi == p) &#123; if (p + 1 == i) &#123; ++p; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; else &#123; ++p; swap(list[i], list[p]); &#125; &#125; if (list[j] == pv) &#123; if ((tempi != tempp &amp;&amp; tempj == q) || tempi == tempp &amp;&amp; (tempp == left - 1 || (tempp != left - 1 &amp;&amp; tempj == q))) &#123; if (j + 1 == q) &#123; --q; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; else &#123; --q; swap(list[j], list[q]); &#125; &#125; &#125; &#125; if (q - p &lt;= 1) return; else &#123; if (p != left - 1) &#123; if (i == p) &#123; i = left - 1; ++j; rmove(list, right, q, j); &#125; else &#123; if (i == q) &#123; j = right + 1; --i; lmove(list, left, p, i); &#125; else &#123; if (list[i] &lt; pv) &#123; lmove(list, left, p, i); if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; lmove(list, left, p, i); &#125; &#125; &#125; &#125; &#125; else &#123; if (i == q) &#123; --i; j = right + 1; &#125; else &#123; if (list[i] &lt; pv) &#123; if (j + 1 == q) &#123; j = right + 1; &#125; else &#123; ++j; rmove(list, right, q, j); &#125; &#125; else &#123; rmove(list, right, q, j); if (i - 1 == p) &#123; i = left - 1; &#125; else &#123; --i; &#125; &#125; &#125; &#125; &#125; quicksort(list, left, i); quicksort(list, j, right);&#125;int main()&#123; vector&lt;type&gt; list&#123; 2, 23, 6, 8, 5, 25, 19, 17, 25, 23, 18, 13, 25, 16, 23, 1, 9 &#125;; cout &lt;&lt; "排序前:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; quicksort(list, 0, list.size()-1); cout &lt;&lt; "排序后:"; for (const type &amp;m : list) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; return 0;&#125; &nbsp;运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670#include "stdafx.h"#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; BTreeNode *p = nullptr; map&lt;T, BTreeNode&lt;T&gt; *&gt; keyptrmap; //节点数据域和指针域&#125;;template &lt;typename T&gt;pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; SerachBTreeNode(BTreeNode&lt;T&gt; *ptr, pair&lt;typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt; *root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt; *p; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt; *p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; &amp;d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt; *ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt; *const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M-1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.nodemax = it-&gt;first; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; arrange.top().minmax.max = it-&gt;first; &#125; else &#123; arrange.top().minmax.min = ptr-&gt;keyptrmap.begin()-&gt;first; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = ptr-&gt;keyptrmap.end(); --it; arrange.top().minmax.max = it-&gt;first; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = ptr-&gt;keyptrmap.end(); --temp; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = arrange.top().p-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(arrange.top().p-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; if (SerachBTreeNode(ptr, d) != pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; ++level; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = SerachBTreeNode(ptr, d).first; if (d.first == ptr-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树"&lt;&lt;endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *InsertBTree(BTreeNode&lt;T&gt; *root, T key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;keyptrmap.insert(make_pair(key, nullptr)); return root; &#125; else &#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.insert(make_pair(key, nullptr)); break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; while (true) &#123; BTreeNode&lt;T&gt; *ptr = new BTreeNode&lt;T&gt;; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = current-&gt;keyptrmap.begin(); ptr-&gt;p = current-&gt;p; while (ptr-&gt;keyptrmap.size() &lt; (M + 1) / 2 - 1) &#123; ptr-&gt;keyptrmap.insert(*temp); temp = current-&gt;keyptrmap.erase(temp); &#125; current-&gt;p = temp-&gt;second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;; root-&gt;p = ptr; root-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); return root; &#125; else &#123; stackforback.top().first-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current)); current-&gt;keyptrmap.erase(temp); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator it = stackforback.top().second; --it; if (it == stackforback.top().first-&gt;keyptrmap.begin()) &#123; stackforback.top().first-&gt;p = ptr; &#125; else &#123; --it; it-&gt;second = ptr; &#125; if (stackforback.top().first-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt; *DelBTree(BTreeNode&lt;T&gt; *root, T key) //B树删除函数&#123; BTreeNode&lt;T&gt; *current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt; *, map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator&gt;&gt; stackforback; while (true) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator scankey = current-&gt;keyptrmap.begin(); while (key &gt; scankey-&gt;first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap.end()) &#123; break; &#125; &#125; if (scankey != current-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; if (current-&gt;p == nullptr) &#123; current-&gt;keyptrmap.erase(scankey); &#125; else &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt; *q = scankey-&gt;second; while (q-&gt;p != nullptr) &#123; stackforback.push(make_pair(q, q-&gt;keyptrmap.begin())); q = q-&gt;p; &#125; BTreeNode&lt;T&gt; *temp = scankey-&gt;second; current-&gt;keyptrmap.erase(scankey); current-&gt;keyptrmap.insert(make_pair(q-&gt;keyptrmap.begin()-&gt;first, temp)); q-&gt;keyptrmap.erase(q-&gt;keyptrmap.begin()); current = q; &#125; break; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;p; &#125; &#125; &#125; &#125; else &#123; if (current-&gt;p == nullptr) &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; &#125; if (current == root) &#123; if (current-&gt;keyptrmap.empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; while (true) &#123; if (current == root) &#123; current = current-&gt;p; delete root; return current; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); BTreeNode&lt;T&gt; *ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(ptr-&gt;keyptrmap.begin()-&gt;first, ptr)); ptr-&gt;p = ptr-&gt;keyptrmap.begin()-&gt;second; ptr-&gt;keyptrmap.erase(ptr-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, temp-&gt;second-&gt;p)); current-&gt;keyptrmap.insert(temp-&gt;second-&gt;keyptrmap.begin(), temp-&gt;second-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt; *ptr = nullptr; if (temp != stackforback.top().first-&gt;keyptrmap.begin()) &#123; typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator before = temp; --before; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;p; &#125; if (ptr-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); typename map&lt;T, BTreeNode&lt;T&gt; *&gt;::iterator left = ptr-&gt;keyptrmap.end(); --left; current-&gt;p = left-&gt;second; stackforback.top().first-&gt;keyptrmap.erase(temp); stackforback.top().first-&gt;keyptrmap.insert(make_pair(left-&gt;first, current)); ptr-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;keyptrmap.insert(make_pair(temp-&gt;first, current-&gt;p)); ptr-&gt;keyptrmap.insert(current-&gt;keyptrmap.begin(), current-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;keyptrmap.size() == 0) &#123; current = stackforback.top().first; stackforback.pop(); &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BTreeNode&lt;int&gt; *root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则对g先右后左双旋转并把p染成黑色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则对g先左后右双旋转并把p染成黑色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985986987988989990991992993994995996997998999100010011002100310041005100610071008100910101011101210131014101510161017101810191020102110221023102410251026102710281029103010311032103310341035103610371038103910401041104210431044104510461047104810491050105110521053105410551056105710581059106010611062106310641065106610671068106910701071107210731074107510761077107810791080108110821083108410851086108710881089109010911092109310941095109610971098109911001101110211031104110511061107110811091110111111121113111411151116111711181119112011211122112311241125112611271128112911301131113211331134113511361137113811391140114111421143114411451146114711481149115011511152115311541155115611571158115911601161116211631164116511661167116811691170117111721173117411751176117711781179118011811182118311841185#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; if (q-&gt;left == p) &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;left == q) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (g-&gt;right == q) &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; p = g; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; else &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; p = g; q-&gt;color = ColorFlag::BLACK; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887#include &lt;iostream&gt;#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt; *&gt; *keyandptr; //叶节点指针域和数据域 map&lt;T, BPlusTreeNode&lt;T&gt; *&gt; *keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;set&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(set&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt; *leaf)&#123; typename set&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end(); --t; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt; *root, BPlusTreeNode&lt;T&gt; *head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt; *p; typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename map&lt;T, BPlusTreeNode&lt;T&gt; *&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename set&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first ) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; BPlusTreeNode&lt;T&gt; * ptr = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); temp = stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(key, ptr)).first; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, T key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.insert(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; // p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; break; &#125; &#125; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; current-&gt;keyandptr-&gt;first.insert(key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; ++temp; if (current != root &amp;&amp; temp != current-&gt;keyandptr-&gt;first.end()) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); temp = current-&gt;keyandptr-&gt;first.begin(); while (ptr-&gt;keyandptr-&gt;first.size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyandptr-&gt;first.insert(*temp); temp = current-&gt;keyandptr-&gt;first.erase(temp); &#125; ptr-&gt;keyandptr-&gt;second = current; if (stackforback.empty() == true) &#123; head = ptr; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); temp = current-&gt;keyandptr-&gt;first.end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair(*temp, current)); return &#123; root, head &#125;; &#125; else &#123; if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = ptr; &#125; else &#123; head = ptr; &#125; temp = ptr-&gt;keyandptr-&gt;first.end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyandptr-&gt;first.end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;begin(); while (ptr-&gt;keyptrmap-&gt;size() &lt; (M + 1) / 2) &#123; ptr-&gt;keyptrmap-&gt;insert(*temp); temp = current-&gt;keyptrmap-&gt;erase(temp); &#125; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); temp = ptr-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); temp = current-&gt;keyptrmap-&gt;end(); --temp; root-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, current)); return &#123; root, head &#125;; &#125; else &#123; temp = ptr-&gt;keyptrmap-&gt;end(); --temp; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; temp = current-&gt;keyptrmap-&gt;end(); --temp; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = stackforback.top().second; --it; ptr = it-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(it); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt; * root, BPlusTreeNode&lt;T&gt; * head, T key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator&gt;&gt; stackforback; if (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator scankey = current-&gt;keyptrmap-&gt;begin(); while (key &gt; (*scankey).first) &#123; ++scankey; if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; stackforback.push(make_pair(current, scankey)); current = (*scankey).second; &#125; &#125; &#123; typename set&lt;T&gt;::iterator temp; if ((temp = current-&gt;keyandptr-&gt;first.find(key)) == current-&gt;keyandptr-&gt;first.end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(temp); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*(temp-&gt;second-&gt;keyandptr-&gt;first.begin()), current)); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); if (current != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != current; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; &#125; else &#123; head = current-&gt;keyandptr-&gt;second; &#125; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;first); BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator it = temp1-&gt;keyandptr-&gt;first.end(); --it; it = temp1-&gt;keyandptr-&gt;first.erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*it, temp1)); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); if (temp-&gt;second != head) //优化 &#123; BPlusTreeNode&lt;T&gt;* p = head; for (; p-&gt;keyandptr-&gt;second != temp-&gt;second; p = p-&gt;keyandptr-&gt;second); p-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; else &#123; head = temp-&gt;second-&gt;keyandptr-&gt;second; &#125; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename set&lt;T&gt;::iterator temp = current-&gt;keyandptr-&gt;first.end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (*temp &lt; key) &#123; updatemax(stackforback, *temp); &#125; return &#123; root, head &#125;; &#125; else &#123; if (*temp &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(*temp, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125; &#125; while (true) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(*(temp-&gt;second-&gt;keyptrmap-&gt;begin())); stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair(temp-&gt;second-&gt;keyptrmap-&gt;begin()-&gt;first, current)); temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; --temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; BPlusTreeNode&lt;T&gt;* temp1 = temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator it = temp1-&gt;keyptrmap-&gt;end(); --it; current-&gt;keyptrmap-&gt;insert(*it); it = temp1-&gt;keyptrmap-&gt;erase(it); --it; stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*it).first, temp1)); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp = current-&gt;keyptrmap-&gt;end(); --temp; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if ((*temp).first &lt; key) &#123; updatemax(stackforback, (*temp).first); &#125; return &#123; root, head &#125;; &#125; else &#123; if ((*temp).first &lt; key) &#123; typename map&lt;T, BPlusTreeNode&lt;T&gt;*&gt;::iterator temp1 = stackforback.top().second; BPlusTreeNode&lt;T&gt;* ptr = temp1-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp1); stackforback.top().first-&gt;keyptrmap-&gt;insert(make_pair((*temp).first, ptr)); &#125; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; delete stackforback.top().first; return &#123; current, head &#125;; &#125; &#125; &#125;&#125;int main()&#123; vector&lt;int&gt; seq&#123; 2, 7, 5, 19, 10, 18, 16, 12, 11, 15, 13, 14, 21, 29, 25, 20, 22, 28, 23, 26 &#125;; BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串形式的广义表的简单运算]]></title>
    <url>%2Fpost%2F3355.html</url>
    <content type="text"><![CDATA[(1)扫描广义表字符串表示获取所有子串及其深度，位置，长度，数目 基本思路和我之前写的文章 广义表的非递归深度优先遍历及相关运算的c++实现中介绍的一致，只不过遍历的对象从链表变成字符串，原先程序稍作修改就能得到如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; //子表中表元素数目 int startposition; //子表左括号位置 Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; //place广义表字符串中字符索引位置,subcount计数子表 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; //如该左括号属于子表，需要将该子表所在子表的表项数目增一 stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++subcount; if (stack[stack.size() - 1].numnode == 0 &amp;&amp; stack[stack.size() - 1].startposition == 1)//stack[stack.size() - 1].numnode值决定是否为空表，stack[stack.size() - 1].startposition &#123; //决定子表是否为广义表本身 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身且为空表):()" &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个"&lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; if (stack[stack.size() - 1].numnode == 0) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(空表):()"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt;‘ place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125; (2)获取所有子表左右括号位置和序数 和上面，思路和那篇文章中提到的完全一致，对文章中代码稍作修改即可： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0, left=0, right=0; //left左括号序数,right右括号序数 for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; ++left; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; ++right; ++subcount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; "第" &lt;&lt;left &lt;&lt; "个(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; "第" &lt;&lt; right &lt;&lt; "个)位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; endl; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; &#125; else &#123; ++place; &#125; &#125; return 0;&#125; (3)在广义表搜索给定关键字，找出含关键字的所有子表以及关键字在子表中的位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Gennode&#123;public: int numnode; int startposition; vector&lt;int&gt; position; Gennode(int s) :startposition(s), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);int main()&#123; string glist; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; char key; cout &lt;&lt; "输入要搜索的值" &lt;&lt; endl; cin &gt;&gt; key; vector&lt;Gennode&gt; stack; int place = 0, subcount = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; ++place; Gennode temp(place); if (i != glist.cbegin()) ++stack[stack.size() - 1].numnode; stack.push_back(temp); &#125; else if (*i == ')') &#123; ++place; if (stack[stack.size() - 1].position.size() != 0) &#123; ++subcount; if (stack[stack.size() - 1].numnode != 0 &amp;&amp; stack[stack.size() - 1].startposition != 1) &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含"&lt;&lt;key&lt;&lt;"的子表:"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) //输出子表 cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) //输出关键字在子表中位置 cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size()-1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:"; output(stack); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表(为广义表本身):"; for (string::size_type i = stack[stack.size() - 1].startposition - 1; i &lt; place; ++i) cout &lt;&lt; glist[i]; cout &lt;&lt; endl; cout &lt;&lt; key &lt;&lt; "的位置:"; for (vector&lt;int&gt;::size_type i = 0; i &lt; stack[stack.size() - 1].position.size(); ++i) cout &lt;&lt; "第" &lt;&lt; i + 1 &lt;&lt; "个" &lt;&lt; key &lt;&lt; "位于子表从左至右数起第" &lt;&lt; stack[stack.size() - 1].position[i] &lt;&lt; "个"; cout &lt;&lt; endl; cout &lt;&lt; "长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; " 深度:" &lt;&lt; stack.size() &lt;&lt; endl; cout &lt;&lt; "(位置:从左至右数起第" &lt;&lt; stack[stack.size() - 1].startposition &lt;&lt; "个 "; cout &lt;&lt; ")位置:从左至右数起第" &lt;&lt; place &lt;&lt; "个" &lt;&lt; endl; cout &lt;&lt; "该子表位置:广义表本身"; cout &lt;&lt; endl; &#125; &#125; stack.pop_back(); &#125; else if (*i != ',') &#123; ++place; ++stack[stack.size() - 1].numnode; if (key == *i) //搜索到关键字,需要向关键字所在子表的栈节点的position对象中压入该关键字位置 stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; else &#123; ++place; &#125; &#125; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，这就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单源最短路径]]></title>
    <url>%2Fpost%2F21078.html</url>
    <content type="text"><![CDATA[如果不了解单源最短路径问题可以自行百度或参考算法书籍，这里只给出一种解法，对问题本身不做详细介绍 在以下求解单源最短路径问题的代码中使用了重要的核心函数Findroad，它是求解该问题的基础,用它可以找出图中两顶点间的所有路径,Findroad配合筛选路径的SOperate函数即可找出最短路径.同时还使用了Fillr函数填充r矩阵,建立源顶点结构体数组,这样求解单源最短路径问题时可以少走一些歪路。Fillr函数中使用了Length递归函数求两顶点间最短路径长度，帮助判断连接两顶点的边是否为最短路径。Length函数求最短路径长度用到了一个基本事实：与图中某起始顶点有边相连的其他所有顶点到终点的最短路径和这些顶点到起始顶点的边组成的路径中长度最小的路径即为起始顶点到终点的最短路径。 以下是具体的C语言代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 7 //无环单边非负权重无向图顶点数struct Order //表示除源顶点外其他顶点参数的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; &#125;;typedef struct Order Order1;struct Link //表示除源顶点外其他到源顶点权重不为零的顶点的结构体类型&#123; int col; //顶点标号 int weight; //源顶点到顶点的权重 int mark; struct Link *next;&#125;;typedef struct Link Link1;struct Path //表示路径节点的结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //路径中与当前顶点相连的下一顶点的标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;struct assist //表示已搜索出的路径中的节点的结构体类型&#123; int tab; //顶点标号 struct assist *next;&#125;;typedef struct assist assist1;struct Shortest //用来指向已搜索出的路径的结构体类型&#123; struct Shortest *pbe; //指向自身类型的节点的指针 struct assist *passist; //指向存放已搜索出的路径的链表的指针&#125;;typedef struct Shortest Shortest1;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k); //该函数用于填充表示顶点对连线是否为顶点对之间最短路径的矩阵，同时在该函数中建立源顶点结构体数组，和求出源顶点数组中权重为零的节点的最大标号int Length(int start, int end, int q[][N], int z[][N], int node[]); //求start和end顶点之间的最短路径长度的递归函数,当最短路径存在时返回其长度，不存在时返回零void insert(Link1 *headm, Link1 *psnewm); //函数,用于将psnewm指向的Link型节点按插入排序的方式插入至Link型链表中int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[]); //函数，用于判定由顶点i是否可以前进至顶点j,可以返回1， 否则返回0int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[]); //在顶点k上依次搜索option顶点后的第一个可达的顶点，搜索成功返回顶点标号，否则返回-1void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1); //路径搜索函数,用于搜索start和end两节点间的路径void Delete(Shortest1 **heads, Shortest1 **tail); //删除搜索到的所有路径Shortest1 *Copy(Path1 *headp); //拷贝找到的路径void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p); //求最短路径的函数void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N]); //输出顶点k+1到m的所有最短路径bool PartialRoadIsNotShortestRoad(int* spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p); //用于判断路径搜索过程中已经形成的部分路径是否可能为最短路径，不可能返回true//源顶点就是单源最短路径中求路径的起始点//源顶点结构体数组即为表示源顶点和其他非源顶点组成的顶点对的结构体变量组成的数组，每一个结构体变量储存了相应的顶点对的权重，顶点对中非源顶点的标号int main()&#123; int i, j, m, k, flag; //m为源顶点标号,k为源顶点数组中权重为零的节点的最大标号 int p[N][N] = &#123; &#123;0, 1, 1, 1, 0, 0, 0&#125;, &#123;1, 0, 1, 0, 1, 0, 0&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;1, 0, 1, 0, 0, 1, 1&#125;, &#123;0, 1, 1, 0, 0, 0 ,1&#125;, &#123;0, 0, 0, 1, 0, 0, 1&#125;, &#123;0, 0, 0, 1, 1, 1, 0&#125; &#125;, q[N][N] = &#123; &#123;0, 3, 7, 5, 0, 0, 0&#125;, &#123;3, 0, 2, 0, 6, 0, 0&#125;, &#123;7, 2, 0, 3, 3, 0, 0&#125;, &#123;5, 0, 3, 0, 0, 2, 8&#125;, &#123;0, 6, 3, 0, 0, 0, 2&#125;, &#123;0, 0, 0, 2, 0, 0, 2&#125;, &#123;0, 0, 0, 8, 2, 2, 0&#125; &#125;, r[N][N], z[N][N]; /*p为单边非负权重无向无环图的邻接矩阵，q为(i,j)元为顶点i+1和顶点j+1连线的权重的权重矩阵,r为(i,j)元表示连接顶点i+1和顶点j+1的边是否为最短路径(0,表示没有边连接,1表示边非最短路径,2表示边为最短路径)的矩阵,z为标记边(i+1,j+1)是否已被访问(1已访问,0未访问)的矩阵*/ int spo; //最短路径长度 char t[N+1]; Order1 swap; Order1 Svertex[N-1]; //源顶点结构体数组 Shortest1 *head, *tail; head=(Shortest1 *) malloc(sizeof(Shortest1)); //初始化Shortest1类型链表 tail=head; head-&gt;pbe=NULL; head-&gt;passist=NULL; /*printf("请输入图的N阶邻接矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入邻接矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入邻接矩阵 for (j=0; j&lt;N; j++) p[i][j]=t[j]-48; &#125; printf("请输入图的N阶权重矩阵\n"); for (i=0; i&lt;N; i++) &#123; printf("请输入权重矩阵的第%d行\n", i+1); scanf_s ("%s", t, N); //输入权重矩阵 for (j=0; j&lt;N; j++) q[i][j]=t[j]-48; &#125; printf("请输入单源最短路径问题中的源顶点标号:\n"); scanf_s("%d", &amp;m); //输入源顶点标号 */ m = 1; for (i=0; i&lt;N; i++) /*建立r矩阵并初始化对角线*/ &#123; r[i][i]=0; &#125; for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; Fillr(m, p, q, r, z, Svertex, &amp;k); /*填充r矩阵，建立实例化源顶点数组求，最源顶点数组中权重为零的节点的最大标号*/ if (m==N) /*m=N时执行Fillr函数时源顶点数组没有实例化，源顶点数组中权重为零的节点的最大标号也没有求出,所以就在这里实例化并计算,供求单源最短路径时使用*/ &#123; for (i=0; i&lt;N-1; i++) &#123; Svertex[i].col=i; //实例化源顶点数组 Svertex[i].weight=q[N-1][i]; &#125; for (i=1; i&lt;N-1; i++) &#123; k=0; for (j=0; j&lt;N-1-i; j++) &#123; if (Svertex[j].weight&gt;Svertex[j+1].weight) &#123; swap=Svertex[j]; //按权重由小到大的顺序对源顶点数组排序 Svertex[j]=Svertex[j+1]; Svertex[j+1]=swap; k=1; &#125; &#125; if (k==0) break; &#125; if (Svertex[N-2].weight==0) k=-2; else &#123; k=-1; while (Svertex[k+1].weight==0) //求源顶点数组中权重为零的节点的最大标号 &#123; k++; &#125; &#125; &#125; if (k==-2) &#123; printf("不存在顶点V%d到顶点V%d", m, 1); //源顶点和其余各顶点无边相连，问题无解 for (i=2; i&lt;=N; i++) &#123; if (i==m) continue; printf(",V%d", i); &#125; printf("的最短路径,单源最短路径问题无解\n"); &#125; else //求源顶点到其余各顶点的最短路径 &#123; for (i=0; i&lt;=k; i++) &#123; spo=0; for (j=k+1; j&lt;N-1; j++) &#123; if (r[m-1][Svertex[j].col]!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及长度 &#125; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); if (i&lt;N-2) z[Svertex[i].col][m-1]=z[m-1][Svertex[i].col]=0; for (j=i+1; j&lt;N-1; j++) z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; for (i++; i&lt;N-1; i++) &#123; flag=0; for (j=k+1; j&lt;i-1; j++) &#123; if (Svertex[j].mark!=2) &#123; if (Svertex[j].mark==1) &#123; if (Svertex[i-1].weight!=Svertex[i].weight) &#123; Svertex[j].mark=2; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=0; flag=1; &#125; &#125; &#125; else &#123; flag=1; &#125; &#125; if (r[m-1][Svertex[j].col]!=2) &#123; Svertex[j].mark=0; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; if (Svertex[j].weight==Svertex[i].weight) &#123; Svertex[j].mark=1; z[Svertex[j].col][m-1]=z[m-1][Svertex[j].col]=1; &#125; else &#123; Svertex[j].mark=2; flag=1; &#125; &#125; spo=0; if (flag==0) &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, Svertex[i].col+1, q[m-1][Svertex[i].col]); //输出最短路径及长度 printf("源点V%d到顶点V%d的最短路径为:\n", m, Svertex[i].col+1); printf("V%d-&gt;V%d\n", m, Svertex[i].col+1); &#125; else &#123; for (j=k+1; j&lt;i; j++) //求源顶点到剩下各顶点的最短路径 &#123; if (Svertex[j].mark!=2) continue; z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=1; FindRoad(Svertex[j].col, Svertex[i].col, m, p, q, r, z, &amp;spo, &amp;head, &amp;tail, Svertex[i].col, Svertex[j].col); z[m-1][Svertex[j].col]=z[Svertex[j].col][m-1]=0; &#125; z[m-1][Svertex[i].col]=z[Svertex[i].col][m-1]=0; SOutput(&amp;spo, &amp;head, &amp;tail, Svertex[i].col, m, r, q); //输出最短路径及其长度 &#125; &#125; &#125; return 0;&#125;void Fillr(int m, int p[][N], int q[][N], int r[][N], int z[][N], Order1 *Svertex, int *k)&#123; int i, j, h, flag, mark, symbol, out; Link1 *headm, *main, *minor, *psnewm; Order1 swap; headm=(Link1 *) malloc(sizeof(Link1)); headm-&gt;next=NULL; main=headm; for (i=0; i&lt;N-1; i++) &#123; if (i!=m-1) &#123; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; else &#123; if (p[i][j]==0) &#123; if (j&gt;i) r[i][j]=0; continue; &#125; else &#123; psnewm=(Link1 *) malloc(sizeof(Link1)); //除源顶点外其他到源顶点权重不为零的顶点的标号和到源顶点权重存入Link1链表相应各节点 psnewm-&gt;col=j; psnewm-&gt;weight=q[i][j]; insert(headm, psnewm); &#125; &#125; &#125; if (headm-&gt;next!=NULL) &#123; main=headm-&gt;next; if (main-&gt;col&gt;i) *(r[i]+main-&gt;col)=2; if (main-&gt;next!=NULL) &#123; psnewm=main; main=main-&gt;next; int Node[N]=&#123;0&#125;; //初始化Node数组,Node[i]==1表示i+1节点已被访问,==0表示未被访问 Node[i]=1; //源顶点已被访问 while(main!=NULL) &#123; flag=1; j=0; if (r[i][psnewm-&gt;col]!=2) z[i][psnewm-&gt;col]=1; else z[i][psnewm-&gt;col]=0; if (psnewm-&gt;weight!=main-&gt;weight) &#123; psnewm-&gt;mark=1; j=1; if (main-&gt;col&gt;i) &#123; mark=0; if (z[i][psnewm-&gt;col]==0) &#123; z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=1; mark=1; &#125; h=Length(psnewm-&gt;col, main-&gt;col, q, z, Node); //求psnewm-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[psnewm-&gt;col][i]=z[i][psnewm-&gt;col]=0; if (h!=0) &#123; if (h+psnewm-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; else &#123; psnewm-&gt;mark=0; &#125; minor=headm-&gt;next; while (minor!=psnewm) &#123; if (minor-&gt;mark==1||minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) &#123; if (minor-&gt;mark==0&amp;&amp;psnewm-&gt;weight!=main-&gt;weight) minor-&gt;mark=1; j=1; if (flag!=0&amp;&amp;main-&gt;col&gt;i) &#123; mark=0; if (z[i][minor-&gt;col]==0) &#123; z[minor-&gt;col][i]=z[i][minor-&gt;col]=1; mark=1; &#125; h=Length(minor-&gt;col, main-&gt;col, q, z, Node); //求minor-&gt;col+1顶点到main-&gt;col+1顶点之最短路径 if (mark==1) z[minor-&gt;col][i]=z[i][minor-&gt;col]=0; if (h!=0) /*注意这里*/ &#123; if (h+minor-&gt;weight&lt;main-&gt;weight) &#123; r[i][main-&gt;col]=1; //连接i+1顶点和main-&gt;col+1的边不是最短路径 flag=0; &#125; &#125; &#125; &#125; minor=minor-&gt;next; &#125; if (main-&gt;col&gt;i) &#123; if (j==0) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 else &#123; if (flag==1) r[i][main-&gt;col]=2; //连接i+1顶点和main-&gt;col+1的边是最短路径 &#125; &#125; psnewm=psnewm-&gt;next; main=main-&gt;next; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; //将z矩阵i+1行清零 &#125; main=headm; while (main-&gt;next!=NULL) &#123; psnewm=main-&gt;next; main-&gt;next=psnewm-&gt;next; free(psnewm); &#125; /*外层循环结束后Link1型链表释放完毕*/ &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; //填充r矩阵对称与对角线的另一列 &#125; else &#123; h=0; for (j=0; j&lt;N; j++) &#123; if (j!=i) &#123; Svertex[h].col=j; Svertex[h].weight=q[i][j]; //将除源顶点外其他顶点的标号和他们到源顶点权重存入源顶点结构体数组相应各节点 h++; &#125; &#125; for (j=1; j&lt;N-1; j++) &#123; flag=0; for (h=0; h&lt;N-1-j; h++) &#123; if (Svertex[h].weight&gt;Svertex[h+1].weight) //按权重从小到大顺序对源顶点数组执行排序 &#123; swap=Svertex[h]; Svertex[h]=Svertex[h+1]; Svertex[h+1]=swap; flag=1; &#125; &#125; if (flag==0) break; &#125; if (Svertex[N-2].weight==0) //源顶点数组各节点权重均为零 &#123; *k=-2; for (j=N-1; j&gt;i; j--) r[i][j]=0; &#125; else &#123; out=-1; while (Svertex[out+1].weight==0) &#123; out++; //求源顶点数组中权重为零的节点的最大标号 if (Svertex[out].col&gt;i) r[i][Svertex[out].col]=0; &#125; *k=out; r[i][Svertex[++out].col]=2; //以下部分和i!=m-1时的情况类似 int Node[N]=&#123;0&#125;; Node[i]=1; for (out++; out&lt;N-1; out++) &#123; flag=1; j=0; if (r[i][Svertex[out-1].col]!=2) z[i][Svertex[out-1].col]=1; else z[i][Svertex[out-1].col]=0; if (Svertex[out-1].weight!=Svertex[out].weight) &#123; Svertex[out-1].mark=1; j=1; if (Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[out-1].col]==0) &#123; z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=1; mark=1; &#125; h=Length(Svertex[out-1].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[out-1].col][i]=z[i][Svertex[out-1].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[out-1].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; else &#123; Svertex[out-1].mark=0; &#125; for (symbol=*k+1; symbol&lt;out-1; symbol++) &#123; if (Svertex[symbol].mark==1||Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) &#123; if (Svertex[symbol].mark==0&amp;&amp;Svertex[out-1].weight!=Svertex[out].weight) Svertex[symbol].mark=1; j=1; if (flag!=0&amp;&amp;Svertex[out].col&gt;i) &#123; mark=0; if (z[i][Svertex[symbol].col]==0) &#123; z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=1; mark=1; &#125; h=Length(Svertex[symbol].col, Svertex[out].col, q, z, Node); if (mark==1) z[Svertex[symbol].col][i]=z[i][Svertex[symbol].col]=0; if (h!=0) /*注意这里*/ &#123; if (h+Svertex[symbol].weight&lt;Svertex[out].weight) &#123; r[i][Svertex[out].col]=1; flag=0; &#125; &#125; &#125; &#125; &#125; if (Svertex[out].col&gt;i) &#123; if (j==0) r[i][Svertex[out].col]=2; else &#123; if (flag==1) r[i][Svertex[out].col]=2; &#125; &#125; &#125; for (j=0; j&lt;N; j++) &#123; if (j==i) continue; z[i][j]=0; &#125; &#125; for (j=i+1; j&lt;N; j++) r[j][i]=r[i][j]; &#125; &#125; free(headm);&#125;int Length(int start, int end, int q[][N], int z[][N], int Node[])&#123; int i; int L, S; //L用于保存start到end的最短路径长度 L=0; //L初始化 Node[start]=1; //start标记为已访问 for (i=0; i&lt;N; i++) &#123; if (i==start) //下一个要访问的节点不能是start continue; if (z[start][i]==0&amp;&amp;q[start][i]!=0&amp;&amp;Node[i]==0) //i作为下一个要访问的顶点合法 &#123; if (i==end) //抵达终点 &#123; if (L==0) L=q[start][i]; else &#123; if (q[start][i]&lt;L) //比较大小，求最短路径长 L=q[start][i]; &#125; &#125; else //未到终点 &#123; z[start][i]=z[i][start]=1; if ((S=Length(i, end, q, z, Node))!=0) //存在i到end的最短路径 &#123; if (L==0) L=q[start][i]+S; else &#123; if (q[start][i]+S&lt;L) //比较大小，求最短路径长 L=q[start][i]+S; &#125; &#125; z[start][i]=z[i][start]=0; &#125; &#125; &#125; Node[start]=0; //还原start访问状态 return L; //返回最短路径长度&#125;void insert(Link1 *headm, Link1 *psnewm)&#123; Link1 *mainaf, *mainbe; if (headm-&gt;next==NULL) &#123; psnewm-&gt;next=NULL; headm-&gt;next=psnewm; &#125; else &#123; mainbe=headm; mainaf=headm-&gt;next; while (mainaf!=NULL) &#123; if (psnewm-&gt;weight&lt;=mainaf-&gt;weight) &#123; psnewm-&gt;next=mainaf; mainbe-&gt;next=psnewm; return; &#125; mainbe=mainbe-&gt;next; mainaf=mainaf-&gt;next; &#125; psnewm-&gt;next=NULL; mainbe-&gt;next=psnewm; &#125;&#125;int Enable(int i, int j, int p[][N], int r[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (r[i][j]!=2) return 0; else &#123; if (node[j]==1) &#123; return 0; &#125; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int r[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) //搜索option顶点后的第一个可达顶点 &#123; if (Enable(k, m, p, r, z, node)==1) return m; //搜索成功，返回 &#125; return -1; //搜索失败&#125;void FindRoad(int start, int end, int m, int p[][N], int q[][N], int r[][N], int z[][N], int *spo, Shortest1 **heads, Shortest1 **tail, int k1, int p1)&#123; int i, k; //i为当前顶点,k为当前节点的下一可达节点 int interval; int RoadLength; //搜索到的路径长度 int node[N]=&#123;0&#125;; //初始化顶点访问数组Node Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; node[m-1]=1; //m标记为已访问 node[start]=1; //start标记为已访问 i=start; k=-1; //初始化i,k while (1) &#123; if (Search(i, k, p, r, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; //回溯 psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; if (i==start) RoadLength=0; else &#123; RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 if (i != end) &#123; if (PartialRoadIsNotShortestRoad(spo, heads, k1, m, q, r, RoadLength, p1)) &#123; z[psnewaf-&gt;sign][i] = z[i][psnewaf-&gt;sign] = 0; //如果当前已形成的路径不可能是最短路径的一部分，则直接回溯 node[i] = 0; RoadLength -= q[psnewaf-&gt;sign][i]; i = psnewaf-&gt;sign; k = psnewaf-&gt;next; continue; &#125; &#125; &#125; current = (Path1*)malloc(sizeof(Path1)); current-&gt;sign = i; //建立表示当前顶点i的路径节点 current-&gt;next = interval = Search(i, k, p, r, z, node); z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, r, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; SOperate(spo, heads, tail, k1, m, r, q, RoadLength, head, p1);/*根据找到的新路径调用SOperate函数筛选路径*/ free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;Shortest1 *Copy(Path1 *headp)&#123; Shortest1 *head; assist1 *tail = NULL, *psnew = NULL; Path1 *visit = NULL; head=(Shortest1 *) malloc(sizeof(Shortest1)); //建立指向找到的新路径的头节点 head-&gt;pbe=NULL; head-&gt;passist=NULL; //头节点始化 visit=headp-&gt;pnext; //visit指向路径链表第一个节点 while (visit!=NULL) //遍历路径链表 &#123; psnew=(assist1 *) malloc(sizeof(assist1)); psnew-&gt;tab=visit-&gt;sign; //拷贝路径节点代表的顶点标号至assist1节点 psnew-&gt;next=NULL; if (head-&gt;passist==NULL) &#123; head-&gt;passist=psnew; tail=psnew; //assist1节点插入头节点指向的路径 &#125; else &#123; tail-&gt;next=psnew; tail=psnew; &#125; visit=visit-&gt;pnext; &#125; return (head); //返回指向指向找到的新路径的头节点的指针&#125;void Delete(Shortest1 **heads, Shortest1 **tail)&#123; Shortest1 *row; //用来指向待删除的指向搜索出的路径的节点的指针 assist1 *col; //用来指向待删除的路径节点 *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; while (row-&gt;passist!=NULL) //逐一删除所有路径以及指向路径的Shortest1节点 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; free(col); &#125; free(row); &#125;&#125;bool PartialRoadIsNotShortestRoad(int *spo, Shortest1** heads, int k, int m, int q[][N], int r[][N], int RoadLength, int p)&#123; if (r[m - 1][k] != 2) &#123; if (r[m - 1][k] == 1) //m-1和k有边相连 &#123; if (RoadLength + q[m - 1][p] &gt;= q[m - 1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return true; &#125; if ((*heads)-&gt;pbe != NULL) &#123; if (*spo &lt; RoadLength + q[m - 1][p]) return true; &#125; &#125; else &#123; if (RoadLength + q[m - 1][p] &gt; q[m - 1][k]) &#123; return true; &#125; &#125; return false;&#125;void SOperate(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N], int RoadLength, Path1 *headp, int p)&#123; if (r[m-1][k]!=2) //连接m-1和k的边不是最短路径 &#123; if (r[m-1][k]==1) //m-1和k有边相连 &#123; if (RoadLength+q[m-1][p]&gt;=q[m-1][k]) //m到p+1到k+1的路径不是m到k+1的最短路径 return; &#125; Shortest1 *carbon; //m到p+1到k+1的路径有可能是m到k+1的最短路径 if ((*heads)-&gt;pbe==NULL) &#123; *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); //Shortest1链表为空,直接将找到的路径插入 (*heads)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; if (*spo&lt;RoadLength+q[m-1][p]) return; else &#123; if (*spo==RoadLength+q[m-1][p]) &#123; carbon=Copy(headp); (*tail)-&gt;pbe=carbon; //将找到的路径插入Shortest1链表 *tail=carbon; &#125; else &#123; Delete(heads, tail); //删除Shortest1链表和所有路径(Shortest1链表头节点不删除) *spo=RoadLength+q[m-1][p]; carbon=Copy(headp); (*heads)-&gt;pbe=carbon; //Shortest1链表为空,直接将找到的路径插入 *tail=carbon; &#125; &#125; &#125; &#125; else &#123; if (RoadLength+q[m-1][p]==q[m-1][k]) //m到p+1到k+1的路径是m到k+1的最短路径 &#123; Shortest1 *carbon; carbon=Copy(headp); //将找到的路径插入Shortest1链表 (*tail)-&gt;pbe=carbon; *tail=carbon; &#125; else &#123; return; //m到p+1到k+1的路径不是m到k+1的最短路径，返回 &#125; &#125;&#125;void SOutput(int *spo, Shortest1 **heads, Shortest1 **tail, int k, int m, int r[][N], int q[][N])&#123; if ((*heads)-&gt;pbe==NULL) //Shortest1链表为空 &#123; if (r[m-1][k]==0) printf("源点V%d和顶点V%d间不存在最短路径,即不连通\n", m, k+1); else &#123; printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); //连接m和k+1的边即为m到k+1的唯一最短路径 printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); printf("V%d-&gt;V%d\n", m, k+1); &#125; &#125; else &#123; Shortest1 *row; assist1 *col; if (r[m-1][k]==2) printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, q[m-1][k]); else printf("源点V%d到顶点V%d的最短路径长为%d\n", m, k+1, *spo); printf("源点V%d到顶点V%d的最短路径为:\n", m, k+1); if (r[m-1][k]==2) printf("V%d-&gt;V%d\n", m, k+1); *tail=*heads; while ((*tail)-&gt;pbe!=NULL) &#123; row=(*tail)-&gt;pbe; (*tail)-&gt;pbe=row-&gt;pbe; printf("V%d", m); while (row-&gt;passist!=NULL) //逐一输出找到的m到k+1的最短路径,同时删除所有路径清空Shortest1链表 &#123; col=row-&gt;passist; row-&gt;passist=col-&gt;next; printf("-&gt;V%d", col-&gt;tab+1); free(col); &#125; printf("\n"); free(row); &#125; &#125;&#125; 对于如下的单边无向无环非负权重的图 Vi i=1,2,3,4,5,6,7表示图的顶点,数字表示各边的权重，则图的邻接矩阵为 权重矩阵为 在程序中输入以上邻接矩阵和权重矩阵，单源最短路径的源顶点输入为V1，则程序运行结果如下图： 可以验证这是正确的]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最短路径</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ACM大赛赛题数学的游戏(教徒求生)求解]]></title>
    <url>%2Fpost%2F39318.html</url>
    <content type="text"><![CDATA[问题描述：17世纪法国数学家加斯帕在《数学的游戏问题》中讲的一个故事：n个教徒和n个非教徒在深海上遇险，必须将一半的人投入海中，其余的人才能幸免于难，于是想了个办法：2n个人围成一个圆圈，从第一个人开始依次循环报数，每数到第九个人就将他扔入大海，如此循环直到仅剩n个人为止。问怎样的排法，才能使每次投入大海的都是非教徒？ &nbsp; 熟悉数据结构的人都知道，这就是约瑟夫环球旅行者问题的变形，用循环链表即可解决,属于水题，比较容易。把所有2n个教徒排成一个序列放入循环链表中，从左到右以递进的方式赋予每个教徒一个标号。然后就是简单的小朋友数数了，&nbsp;&nbsp;从第一个节点开始数，每数到第九个就把数出的异教徒节点取出，按标号有序排列在另一个链表中就行了。然后再从数出的教徒节点的后继节点开始数，以此类推，直到只剩下n个教徒为止。这样所有n个异教徒的标号都找到了，而且均有序排列在链表中。然后就可以轻松输出排列方案了,so easy C语言代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 15 //异教徒求生问题规模struct label //表示教徒标号的节点结构体类型&#123; int sign; //教徒标号 struct label *next;&#125;;typedef struct label label1;void insertsort(label1 *head1, label1 *psnew1); //利用链表进行插入排序的函数，使筛选出来的异教徒标号严格有序void main()&#123; int count, Nodenumber; //计数变量和教徒总数 label1 *psnew, *head, *tail; label1 *head1; head=(label1 *) malloc(sizeof(label1)); head-&gt;next=NULL; tail=head; head1=(label1 *) malloc(sizeof(label1)); head1-&gt;next=NULL; for (count=1; count&lt;=2*N; count++) &#123; psnew=(label1 *) malloc(sizeof(label1)); //建立教徒节点，输入标号，创建循环链表，将各教徒连成环 psnew-&gt;sign=count; tail-&gt;next=psnew; tail=psnew; if (count==2*N) psnew-&gt;next=head; &#125; Nodenumber=2*N; //初始化教徒数目 tail=head; psnew=head-&gt;next; while(Nodenumber&gt;N) //开始逐个筛选异教徒,直到只剩N个 &#123; for (count=1; count&lt;=9; count++) //从1至9依次计数 &#123; if (psnew==head) &#123; psnew=psnew-&gt;next; //遇到头结点继续向后递进，但count--使其保持不变，从而不把头节点计算在内 tail=tail-&gt;next; count--; continue; &#125; if(count!=9) //还未数到第九个，继续向后递进 &#123; psnew=psnew-&gt;next; tail=tail-&gt;next; &#125; &#125; tail-&gt;next=psnew-&gt;next; //一个异教徒找出,psnew指向该异教徒节点，将该节点从循环链表中取出 insertsort(head1, psnew); //对取出的节点执行插入排序，将其有序放入由筛选出的异教徒组成的链表 psnew=tail-&gt;next; //psnew指向原取出节点的后一节点,为下一轮计数做准备 Nodenumber--; //教徒数相应减一 &#125; for(tail=head1, psnew=head1-&gt;next; psnew!=NULL; tail=tail-&gt;next, psnew=psnew-&gt;next) //根据存放筛选出的异教徒的链表输出各教徒的排列方式 &#123; if (tail==head1) &#123; for(count=1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; else &#123; for(count=tail-&gt;sign+1; count&lt;psnew-&gt;sign; count++) printf("+"); printf("-"); &#125; &#125; if (tail-&gt;sign!=2*N) &#123; for(count=tail-&gt;sign+1; count&lt;=2*N; count++) printf("+"); &#125; printf("\n");&#125;void insertsort(label1 *head1, label1 *psnew1) //简单的插入排序函数，使筛选出的异教徒完全有序&#123; label1 *after, *front; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; front=head1; after=head1-&gt;next; while(1) &#123; if (psnew1-&gt;sign&lt;after-&gt;sign) &#123; psnew1-&gt;next=front-&gt;next; front-&gt;next=psnew1; return; &#125; if(after-&gt;next==NULL) break; after=after-&gt;next; front=front-&gt;next; &#125; after-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125;&#125; 运行结果： 其中+表示本教徒,-表示异教徒]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，约瑟夫问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个1的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#include "pch.h"#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int *)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = -1; x1 = x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; if (i == -1) //首次入栈，栈空 &#123; i++; p[i] = 1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; if ((x1 != n) &amp;&amp; (x1 + x2 + 1 != 2 * n)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125; &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
</search>
