<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二项队列实现]]></title>
    <url>%2Fpost%2Fac5eb473.html</url>
    <content type="text"><![CDATA[二项队列的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;#include &lt;stack&gt;using namespace std;template &lt;typename T&gt;struct BinomialQueueNode //二项队列节点&#123; T data; BinomialQueueNode* first_child = nullptr; BinomialQueueNode* right_sibling = nullptr; unsigned int size = 0; //节点代表的二项树高度 BinomialQueueNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(BinomialQueueNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class BinomialQueue&#123;public: bool removeMinValue(T&amp; min); //移除并将最小值保存于min void printQueue(); //广义表形式打印二项队列 void insertValue(const T&amp; key); //插入值 void merge(BinomialQueue&lt;T&gt;&amp; be_merged); //合并二项队列 bool isEmpty() &#123; return queue_size_squence.empty(); &#125; //判断二项队列是否为空 BinomialQueue() = default; ~BinomialQueue();private: vector&lt;BinomialQueueNode&lt;T&gt;*&gt; queue_array; //保存二项队列数组 set&lt;unsigned int&gt; queue_size_squence; //二项队列中二项树高度序列 BinomialQueueNode&lt;T&gt;* min = nullptr; //指向二项队列中根节点最小的二项树根节点指针&#125;;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::insertValue(const T&amp; key)&#123; BinomialQueue temp; temp.queue_array.push_back(new BinomialQueueNode&lt;T&gt;(key)); temp.queue_size_squence.insert(0); temp.min = temp.queue_array.back(); merge(temp);&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::printQueue()&#123; cout &lt;&lt; "打印二项队列结果:" &lt;&lt; endl; if (queue_size_squence.empty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; return; &#125; size_t count = 0; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; cout &lt;&lt; "第" &lt;&lt; ++count &lt;&lt; "棵二项树:"; BinomialQueueNode&lt;T&gt;* ptr = queue_array[*p]; int d = 0; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; arrange; BinomialQueueNode&lt;T&gt;* const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; &#125; cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; ptr-&gt;data; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; else &#123; cout &lt;&lt; ")"; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl; &#125;&#125;template &lt;typename T&gt;bool BinomialQueue&lt;T&gt;::removeMinValue(T &amp;save_min)&#123; if (isEmpty()) &#123; return false; &#125; save_min = min-&gt;data; if (min-&gt;first_child == nullptr) &#123; queue_size_squence.erase(min-&gt;size); queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; queue_array.clear(); &#125; else &#123; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; &#125; &#125; else &#123; queue_size_squence.erase(min-&gt;size); BinomialQueueNode&lt;T&gt;* run = min-&gt;first_child; queue_array[min-&gt;size] = nullptr; delete min; min = nullptr; if (queue_size_squence.empty()) &#123; do &#123; queue_array[run-&gt;size] = run; if (min == nullptr || min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; while (run != nullptr); &#125; else &#123; BinomialQueue temp; while (run != nullptr) &#123; temp.queue_array.resize(run-&gt;size+1, nullptr); temp.queue_array[run-&gt;size] = run; temp.queue_size_squence.insert(run-&gt;size); BinomialQueueNode&lt;T&gt;* t = run; run = run-&gt;right_sibling; t-&gt;right_sibling = nullptr; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; if (min == nullptr || min-&gt;data &gt; queue_array[*p]-&gt;data) &#123; min = queue_array[*p]; &#125; &#125; merge(temp); &#125; &#125; return true;&#125;template &lt;typename T&gt;BinomialQueue&lt;T&gt;::~BinomialQueue()&#123; if (isEmpty()) &#123; return; &#125; for (set&lt;unsigned int&gt;::iterator p = queue_size_squence.begin(); p != queue_size_squence.end(); ++p) &#123; stack&lt;BinomialQueueNode&lt;T&gt;*&gt; work_stack; work_stack.push(queue_array[*p]); while (work_stack.empty() == false) &#123; BinomialQueueNode&lt;T&gt;* run = work_stack.top()-&gt;first_child; while (run != nullptr) &#123; work_stack.top()-&gt;first_child = run-&gt;right_sibling; if (run-&gt;first_child != nullptr) &#123; work_stack.push(run); break; &#125; else &#123; delete run; run = work_stack.top()-&gt;first_child; &#125; &#125; if (run == nullptr) &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void BinomialQueue&lt;T&gt;::merge(BinomialQueue&amp; be_merged)&#123; if (isEmpty()) &#123; if (!be_merged.isEmpty()) &#123; queue_array = be_merged.queue_array; be_merged.queue_array.clear(); queue_size_squence = be_merged.queue_size_squence; be_merged.queue_size_squence.clear(); min = be_merged.min; &#125; &#125; else &#123; if (!be_merged.isEmpty()) &#123; for (set&lt;unsigned int&gt;::iterator it = be_merged.queue_size_squence.begin(); it != be_merged.queue_size_squence.end(); ++it) &#123; if (*it &gt;= queue_array.size() || queue_array[*it] == nullptr) &#123; if (*it &gt;= queue_array.size()) &#123; queue_array.resize(*it + 1, nullptr); &#125; queue_array[*it] = be_merged.queue_array[*it]; queue_size_squence.insert(*it); if (be_merged.queue_array[*it]-&gt;data &lt;= min-&gt;data) &#123; min = be_merged.queue_array[*it]; &#125; &#125; else &#123; BinomialQueueNode&lt;T&gt;* cur = nullptr; if (queue_array[*it]-&gt;data &lt;= be_merged.queue_array[*it]-&gt;data) &#123; cur = queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = be_merged.queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = be_merged.queue_array[*it]; &#125; &#125; else &#123; cur = be_merged.queue_array[*it]; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; if (run == nullptr) &#123; cur-&gt;first_child = queue_array[*it]; &#125; else &#123; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[*it]; &#125; &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; ++cur-&gt;size; unsigned int cur_index = *it + 1; queue_array[*it] = nullptr; queue_size_squence.erase(*it); while (true) &#123; if (cur_index &gt;= queue_array.size()) &#123; queue_array.push_back(nullptr); queue_array.back() = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index] == nullptr) &#123; queue_array[cur_index] = cur; queue_size_squence.insert(cur_index); break; &#125; else &#123; if (queue_array[cur_index]-&gt;data &lt;= cur-&gt;data) &#123; BinomialQueueNode&lt;T&gt;* run = queue_array[cur_index]-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = cur; ++(queue_array[cur_index]-&gt;size); cur = queue_array[cur_index]; &#125; else &#123; BinomialQueueNode&lt;T&gt;* run = cur-&gt;first_child; while (run-&gt;right_sibling != nullptr) &#123; run = run-&gt;right_sibling; &#125; run-&gt;right_sibling = queue_array[cur_index]; ++(cur-&gt;size); &#125; if (cur-&gt;data &lt;= min-&gt;data) &#123; min = cur; &#125; queue_array[cur_index] = nullptr; queue_size_squence.erase(cur_index); ++cur_index; &#125; &#125; &#125; &#125; &#125; be_merged.queue_array.clear(); be_merged.queue_size_squence.clear(); be_merged.min = nullptr; &#125; &#125;&#125;int main()&#123; BinomialQueue&lt;int&gt; obj; vector&lt;int&gt; input&#123;10, 5, 1, 99, 45, 23, 66, 12, 34, 78, 55, 34, 23, 10, 14, 12, 89, 56, 67, 66&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; obj.insertValue(i); obj.printQueue(); &#125; obj.printQueue(); while (obj.isEmpty() == false) &#123; int i = 0; if (obj.removeMinValue(i)) &#123; cout &lt;&lt; "移除最小值" &lt;&lt; i &lt;&lt; "成功" &lt;&lt; endl; obj.printQueue(); &#125; else &#123; cout &lt;&lt; "移除最小值失败" &lt;&lt; endl; &#125; &#125;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二项队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自顶向下伸展树实现]]></title>
    <url>%2Fpost%2Fbf5efd04.html</url>
    <content type="text"><![CDATA[自顶向下伸展树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 以下代码囊括了伸展树自底向上和自顶向下的所有实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr;&#125;template &lt;typename T&gt;class SplayTree&#123;public: enum OperateType &#123;INSERT, DELETE, SEARCH&#125;; SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree(bool u) :use_spread_topdown(u) &#123;&#125; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 bool spreadTopDownAndOP(OperateType operate_type, const T&amp; key); //伸展树的自顶向下展开,operate_type为要执行的操作类型 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点 bool use_spread_topdown = false; //是否使用自顶向下展开处理伸展树操作&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; if (use_spread_topdown) &#123; if (spreadTopDownAndOP(OperateType::SEARCH, key)) &#123; return root; &#125; else &#123; return nullptr; &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr; &#125;&#125;template &lt;typename T&gt;void updateLeft(SplayTreeNode&lt;T&gt;*&amp; left_tree, SplayTreeNode&lt;T&gt;*&amp; left_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (left_tree == nullptr) &#123; left_tree = change_ptr; &#125; else &#123; left_joint_point-&gt;right_child = change_ptr; &#125; left_joint_point = change_ptr;&#125;template &lt;typename T&gt;void updateRight(SplayTreeNode&lt;T&gt;*&amp; right_tree, SplayTreeNode&lt;T&gt;*&amp; right_joint_point, SplayTreeNode&lt;T&gt;* change_ptr)&#123; if (right_tree == nullptr) &#123; right_tree = change_ptr; &#125; else &#123; right_joint_point-&gt;left_child = change_ptr; &#125; right_joint_point = change_ptr;&#125;template &lt;typename T&gt;void rotate(SplayTreeNode&lt;T&gt;* &amp;cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack, SplayTreeNode&lt;T&gt;* &amp;left_tree, SplayTreeNode&lt;T&gt;* &amp;right_tree, SplayTreeNode&lt;T&gt;* &amp;left_joint_point, SplayTreeNode&lt;T&gt;* &amp;right_joint_point) //自顶向下展开的旋转操作&#123; if (work_stack.size() == 3) &#123; cur = work_stack.top(); work_stack.pop(); &#125; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; p-&gt;left_child = nullptr; updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; p-&gt;left_child = nullptr; RotateR(q); updateRight(right_tree, right_joint_point, p); &#125; else &#123; p-&gt;left_child = nullptr; q-&gt;right_child = nullptr; updateLeft(left_tree, left_joint_point, q); updateRight(right_tree, right_joint_point, p); &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; p-&gt;right_child = nullptr; q-&gt;left_child = nullptr; updateLeft(left_tree, left_joint_point, p); updateRight(right_tree, right_joint_point, q); &#125; else &#123; p-&gt;right_child = nullptr; RotateL(q); updateLeft(left_tree, left_joint_point, p); &#125; &#125; &#125;&#125;template &lt;typename T&gt;void Union(SplayTreeNode&lt;T&gt;* cur, SplayTreeNode&lt;T&gt;* left_tree, SplayTreeNode&lt;T&gt;* right_tree, SplayTreeNode&lt;T&gt;* left_joint_point, SplayTreeNode&lt;T&gt;* right_joint_point)&#123; if (left_tree != nullptr) &#123; left_joint_point-&gt;right_child = cur-&gt;left_child; cur-&gt;left_child = left_tree; &#125; if (right_tree != nullptr) &#123; right_joint_point-&gt;left_child = cur-&gt;right_child; cur-&gt;right_child = right_tree; &#125;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt; *removeAtRoot(SplayTreeNode&lt;T&gt;* cur) //删除根节点cur,并用其前驱后继值替代之&#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;left_child != nullptr) &#123; parent = run; run = run-&gt;left_child; &#125; parent-&gt;left_child = run-&gt;right_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;right_child = p-&gt;right_child; delete p; &#125; &#125; else if (cur-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;left_child; if (p-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* run = p; SplayTreeNode&lt;T&gt;* parent = nullptr; while (run-&gt;right_child != nullptr) &#123; parent = run; run = run-&gt;right_child; &#125; parent-&gt;right_child = run-&gt;left_child; cur-&gt;data = run-&gt;data; delete run; &#125; else &#123; cur-&gt;data = p-&gt;data; cur-&gt;left_child = p-&gt;left_child; delete p; &#125; &#125; else &#123; delete cur; return nullptr; &#125; return cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::spreadTopDownAndOP(SplayTree&lt;T&gt;::OperateType operate_type, const T &amp;key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; else &#123; return false; &#125; &#125; SplayTreeNode&lt;T&gt;* left_tree = nullptr; SplayTreeNode&lt;T&gt;* right_tree = nullptr; SplayTreeNode&lt;T&gt;* left_joint_point = nullptr; SplayTreeNode&lt;T&gt;* right_joint_point = nullptr; bool has_inserted = false; while (true) &#123; stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack; int i = 0; for (i = 1; i &lt;= 3; ++i) &#123; if (cur == nullptr || cur-&gt;data == key) &#123; break; &#125; temp_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; if (operate_type == OperateType::INSERT) &#123; has_inserted = true; if (key &lt; temp_stack.top()-&gt;data) &#123; cur = temp_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = temp_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; else &#123; while (temp_stack.size() != 1) &#123; temp_stack.pop(); &#125; root = temp_stack.top(); Union(root, left_tree, right_tree, left_joint_point, right_joint_point); return false; &#125; &#125; else &#123; if (i == 1) &#123; Union(cur, left_tree, right_tree, left_joint_point, right_joint_point); if (operate_type == OperateType::DELETE) &#123; root = removeAtRoot(cur); return true; &#125; else &#123; root = cur; if (operate_type == OperateType::INSERT) &#123; if (has_inserted) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; &#125; rotate(cur, temp_stack, left_tree, right_tree, left_joint_point, right_joint_point); &#125; &#125;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::INSERT, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; if (use_spread_topdown) &#123; return spreadTopDownAndOP(OperateType::DELETE, key); &#125; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj(true); vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红黑树自顶向下插入与删除实现]]></title>
    <url>%2Fpost%2F807c2f11.html</url>
    <content type="text"><![CDATA[自顶向下红黑树的详细介绍见数据结构与算法分析java语言描述第三版 Weiss著，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;//自顶向下插入和删除算法的说明见数据结构与算法分析java语言描述第三版 Weiss著enum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;#include "checkPrintRBTree.h"template &lt;typename T&gt;void adjust(RBTreeNode&lt;T&gt;*&amp; cur, RBTreeNode&lt;T&gt;*&amp; p, RBTreeNode&lt;T&gt;*&amp; pp, RBTreeNode&lt;T&gt;*&amp; ppp, RBTreeNode&lt;T&gt;*&amp; root)&#123; if (cur == p-&gt;left) &#123; if (p == pp-&gt;left) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateRL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125; else &#123; if (p == pp-&gt;right) &#123; pp-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; RotateL(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;left == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; pp = ppp; &#125; else &#123; pp-&gt;color = ColorFlag::RED; cur-&gt;color = ColorFlag::BLACK; RotateLR(pp); if (ppp == nullptr) &#123; root = pp; &#125; else &#123; if (pp-&gt;right == ppp-&gt;left) &#123; ppp-&gt;left = pp; &#125; else &#123; ppp-&gt;right = pp; &#125; &#125; cur = p; p = pp; pp = ppp; &#125; &#125;&#125;template &lt;typename T&gt;bool insertInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; root = new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); return true; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* p = nullptr; RBTreeNode&lt;T&gt;* pp = nullptr; RBTreeNode&lt;T&gt;* ppp = nullptr; while (true) &#123; if (cur-&gt;data == key) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; else &#123; if (key &lt; cur-&gt;data) &#123; if (cur-&gt;left == nullptr) &#123; cur-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;left; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;left-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;right != nullptr &amp;&amp; cur-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;right == nullptr) &#123; cur-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); if (cur-&gt;color == ColorFlag::RED) &#123; if (p != nullptr) &#123; RBTreeNode&lt;T&gt;* t = cur-&gt;right; adjust(t, cur, p, pp, root); &#125; &#125; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (cur-&gt;right-&gt;color == ColorFlag::RED &amp;&amp; cur-&gt;left != nullptr &amp;&amp; cur-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;left-&gt;color = ColorFlag::BLACK; cur-&gt;right-&gt;color = ColorFlag::BLACK; cur-&gt;color = ColorFlag::RED; if (p != nullptr &amp;&amp; p-&gt;color == ColorFlag::RED &amp;&amp; pp != nullptr) &#123; RBTreeNode&lt;T&gt;* temp = cur; adjust(cur, p, pp, ppp, root); if (cur != temp) &#123; continue; &#125; &#125; &#125; ppp = pp; pp = p; p = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void replaceDeletedValue(RBTreeNode&lt;T&gt;* root, bool left_or_right, T&amp; key) //用root左子树(右子树)最大值(最小值)替换root&#123; RBTreeNode&lt;T&gt;* p = nullptr; if (left_or_right) &#123; p = root-&gt;left; if (p-&gt;right == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;right != nullptr) &#123; p = p-&gt;right; &#125; root-&gt;data = p-&gt;data; &#125; &#125; else &#123; p = root-&gt;right; if (p-&gt;left == nullptr) &#123; root-&gt;data = p-&gt;data; &#125; else &#123; while (p-&gt;left != nullptr) &#123; p = p-&gt;left; &#125; root-&gt;data = p-&gt;data; &#125; &#125; key = root-&gt;data;&#125;template &lt;typename T&gt;void linkAfterRotate(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* cur, RBTreeNode&lt;T&gt;* &amp;root, bool left_rotate_or_right_rotate) //旋转后和上层重新链接&#123; if (parent != nullptr) &#123; if (left_rotate_or_right_rotate) &#123; if (parent-&gt;left == cur-&gt;left) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; else &#123; if (parent-&gt;left == cur-&gt;right) &#123; parent-&gt;left = cur; &#125; else &#123; parent-&gt;right = cur; &#125; &#125; &#125; else &#123; root = cur; &#125;&#125;template &lt;typename T&gt;bool adjustToStandardSituation(RBTreeNode&lt;T&gt;* &amp;down, RBTreeNode&lt;T&gt;* &amp;cur, RBTreeNode&lt;T&gt;* &amp;root, RBTreeNode&lt;T&gt;* &amp;parent, T &amp;key) //将当前情形调整为标准情形,标准情形的解释参见数据结构与算法分析 java语言描述 第三版&#123; if (down-&gt;data == key) &#123; if (down-&gt;left != nullptr &amp;&amp; down-&gt;left-&gt;color == ColorFlag::RED) &#123; replaceDeletedValue(down, true, key); cur = down-&gt;left; &#125; else &#123; replaceDeletedValue(down, false, key); cur = down-&gt;right; &#125; parent = down; down = nullptr; &#125; else &#123; if (key &lt; down-&gt;data) &#123; if (down-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;left-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;left; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;left; cur-&gt;color = ColorFlag::RED; cur-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(cur); linkAfterRotate(parent, cur, root, true); parent = cur; cur = cur-&gt;left; &#125; &#125; &#125; else &#123; if (down-&gt;right == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return true; &#125; else &#123; if (down-&gt;right-&gt;color == ColorFlag::RED) &#123; cur = down-&gt;right; parent = down; down = nullptr; &#125; else &#123; parent = cur; cur = down; down = down-&gt;right; cur-&gt;color = ColorFlag::RED; cur-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(cur); linkAfterRotate(parent, cur, root, false); parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; &#125; return false;&#125;template &lt;typename T&gt;bool DelInRBTree(RBTreeNode&lt;T&gt;* &amp;root, T &amp;key)&#123; if (root == nullptr) &#123; return false; &#125; RBTreeNode&lt;T&gt;* cur = root; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* down = nullptr; if (root-&gt;data == key) &#123; if (root-&gt;left == nullptr) &#123; if (root-&gt;right == nullptr) &#123; delete root; root = nullptr; return true; &#125; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; else &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK || root-&gt;right-&gt;color != ColorFlag::BLACK) &#123; if (root-&gt;left-&gt;color != ColorFlag::BLACK) &#123; replaceDeletedValue(root, true, key); down = root-&gt;left; &#125; else &#123; replaceDeletedValue(root, false, key); down = root-&gt;right; &#125; &#125; &#125; &#125; else &#123; if (key &lt; root-&gt;data) &#123; if (root-&gt;left != nullptr) &#123; down = root-&gt;left; &#125; else &#123; return false; &#125; &#125; else &#123; if (root-&gt;right != nullptr) &#123; down = root-&gt;right; &#125; else &#123; return false; &#125; &#125; &#125; if ((root-&gt;left == nullptr || root-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (root-&gt;right == nullptr || root-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; root-&gt;color = ColorFlag::RED; &#125; else &#123; if (down-&gt;color == ColorFlag::RED) &#123; parent = cur; cur = down; down = nullptr; &#125; else &#123; if (down == cur-&gt;left) &#123; swap(cur-&gt;color, cur-&gt;right-&gt;color); RotateL(cur); root = cur; parent = cur; cur = cur-&gt;left; &#125; else &#123; swap(cur-&gt;color, cur-&gt;left-&gt;color); RotateR(cur); root = cur; parent = cur; cur = cur-&gt;right; &#125; &#125; &#125; while (true) &#123; if (cur-&gt;data == key) &#123; if (cur-&gt;left == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left == cur) &#123; parent-&gt;left = nullptr; &#125; else &#123; parent-&gt;right = nullptr; &#125; delete cur; root-&gt;color = ColorFlag::BLACK; return true; &#125; delete cur; root = nullptr; return true; &#125; else &#123; replaceDeletedValue(cur, true, key); down = cur-&gt;left; &#125; &#125; else &#123; if (cur-&gt;left == nullptr) &#123; root-&gt;color = ColorFlag::BLACK; return false; &#125; if (down == nullptr) &#123; if (key &lt; cur-&gt;data) &#123; down = cur-&gt;left; &#125; else &#123; down = cur-&gt;right; &#125; &#125; &#125; if (down == cur-&gt;left) &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;right; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateRL(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateL(cur); &#125; linkAfterRotate(parent, cur, root, true); parent = cur-&gt;left; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; else &#123; if ((down-&gt;left == nullptr || down-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (down-&gt;right == nullptr || down-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; RBTreeNode&lt;T&gt;* p = cur-&gt;left; if ((p-&gt;left == nullptr || p-&gt;left-&gt;color == ColorFlag::BLACK) &amp;&amp; (p-&gt;right == nullptr || p-&gt;right-&gt;color == ColorFlag::BLACK)) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::RED; parent = cur; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; cur-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateLR(cur); &#125; else &#123; cur-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; down-&gt;color = ColorFlag::RED; RotateR(cur); &#125; linkAfterRotate(parent, cur, root, false); parent = cur-&gt;right; &#125; cur = down; down = nullptr; &#125; else &#123; if (adjustToStandardSituation(down, cur, root, parent, key)) &#123; return false; &#125; &#125; &#125; &#125;&#125;int main()&#123; //vector&lt;int&gt; insertvalue&#123; 1, 6, 34, 22, 16, 12, 45, 23, 25, 56, 38, 99, 11, 78, 102, 18, 74, 8, 55, 39 &#125;; vector&lt;int&gt; insertvalue&#123; 1, 6, 1, 22, 16, 12, 45, 102, 25, 39, 38, 45, 11, 78, 102, 18, 74, 8, 11, 39 &#125;; RBTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; bool result = insertInRBTree(root, t); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; if (result) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; output(root); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; int t = *p; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; bool result = DelInRBTree(root, t); if (result) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[van Emde Boas树实现]]></title>
    <url>%2Fpost%2F4d4ae75.html</url>
    <content type="text"><![CDATA[VanEmdeBoas树的详细介绍见算法导论第三版，这里只给出实现 C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896#include &lt;iostream&gt;#include &lt;memory&gt;#include &lt;vector&gt;#include &lt;deque&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;struct VanEmdeBoasTreeNode //vEB树节点定义&#123; enum NodeType &#123;SUMMARY, CLUSTER&#125; node_type; //节点类型 unsigned int global_size; //注意，这里存储的是实际全域大小关于底数2的对数，不是全域大小本身 unsigned long long *min = nullptr; //节点最大值，不存在为nullptr unsigned long long *max = nullptr; //节点最小值,不存在为nullptr VanEmdeBoasTreeNode* summary = nullptr; //当前节点的summary节点指针 vector&lt;VanEmdeBoasTreeNode*&gt; cluster; //cluster子节点指针 VanEmdeBoasTreeNode(unsigned int g, NodeType node_type) :global_size(g), node_type(node_type) &#123;&#125; ~VanEmdeBoasTreeNode() &#123; delete min; delete max; &#125;&#125;;unsigned long long low(VanEmdeBoasTreeNode *node, unsigned long long x) //调用这三个函数时总是假定node的全域大小大于等于2,即node不是叶节点,low,high,index函数的详细定义见算法导论,这里使用移位运算加快求值速度&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; unsigned long long full = 0xffffffffffffffff; full = full &gt;&gt; (64U - g); return x &amp; full;&#125;unsigned long long high(VanEmdeBoasTreeNode *node, unsigned long long x)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; return x &gt;&gt; g;&#125;unsigned long long index(VanEmdeBoasTreeNode *node, unsigned long long low, unsigned long long high)&#123; unsigned int g = node-&gt;cluster[0]-&gt;global_size; high = high &lt;&lt; g; return high | low;&#125;struct StackNode&#123; VanEmdeBoasTreeNode* cur; unsigned long long high; StackNode(VanEmdeBoasTreeNode* c, unsigned long long h) :cur(c), high(h) &#123;&#125;&#125;;class VanEmdeBoasTree&#123;public: enum class StyleOfCreatTree &#123;BFS, DFS&#125;; //建树方式，深度优先或广度优先 VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g); //g为全域大小，为实际全域大小关于底数2的对数 shared_ptr&lt;unsigned long long&gt; min() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;min); &#125; //返回最小值 shared_ptr&lt;unsigned long long&gt; max() &#123; if (isEmpty()) return nullptr; return make_shared&lt;unsigned long long&gt;(*root-&gt;max); &#125; //返回最大值 bool remove(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return removeValue(root, x); &#125; //删除值 bool insert(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return insertValue(root, x); &#125; //插入值 bool contain(unsigned long long x) &#123; if (beyondGlobalSize(x)) return false; return containValue(root, x); &#125; //判断值是否存在 bool isEmpty() &#123; return root-&gt;min == nullptr; &#125; //判断vEB树是否为空 shared_ptr&lt;unsigned long long&gt; pre(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findPrecessor(root, x); &#125; //返回x前驱 shared_ptr&lt;unsigned long long&gt; suc(unsigned long long x) &#123; if (beyondGlobalSize(x)) return nullptr; return findSuccessor(root, x); &#125; //返回x后继 void printValueInTreeFromSmallToLarge(); //从小到大打印vEB树中所有值 void printValueInTreeFromLargeToSmall(); //从大到小打印vEB树中所有值 ~VanEmdeBoasTree(); //销毁vEB树private: bool beyondGlobalSize(unsigned long long x); //判断x是否超出实际全域大小 bool removeValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool insertValue(VanEmdeBoasTreeNode* root, unsigned long long x); bool searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value); bool containValue(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x); shared_ptr&lt;unsigned long long&gt; findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x); StyleOfCreatTree style_of_build_tree = StyleOfCreatTree::DFS; //建树方式 VanEmdeBoasTreeNode* root = nullptr; //vEB树根节点&#125;;void VanEmdeBoasTree::printValueInTreeFromLargeToSmall()&#123; cout &lt;&lt; "从大到小打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = max(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = pre(*p); &#125; cout &lt;&lt; endl;&#125;void VanEmdeBoasTree::printValueInTreeFromSmallToLarge()&#123; cout &lt;&lt; "从小到大打印树中值" &lt;&lt; endl; shared_ptr&lt;unsigned long long&gt; p = min(); if (p == nullptr) &#123; cout &lt;&lt; "NULL"; cout &lt;&lt; endl; return; &#125; while (p != nullptr) &#123; cout &lt;&lt; *p &lt;&lt; " "; p = suc(*p); &#125; cout &lt;&lt; endl;&#125;bool VanEmdeBoasTree::beyondGlobalSize(unsigned long long x)&#123; unsigned int g = root-&gt;global_size; unsigned long long t = 0xffffffffffffffff; t = t &gt;&gt; (64U - g); if (0 &lt;= x &amp;&amp; x &lt;= t) &#123; return false; &#125; else &#123; return true; &#125;&#125;bool VanEmdeBoasTree::containValue(VanEmdeBoasTreeNode* root, unsigned long long x)&#123; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) //叶节点 &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; if (cur_value == *cur-&gt;max) &#123; return true; &#125; VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; //下降到下一层递归搜索 cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::insertValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中插入x,true插入成功,false插入失败&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return false; &#125; else &#123; break; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; break; &#125; if (cur_value == *cur-&gt;min) &#123; return false; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else if (cur_value &lt; *cur-&gt;min) //应当在当前节点插入比最小值更小的值,此时用当前值更新最小值，并把原先的最小值调整为要插入值 &#123; unsigned long long temp = *cur-&gt;min; *cur-&gt;min = cur_value; cur_value = temp; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); //继续向下一层寻找插入位置 VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; if (cur-&gt;min == nullptr) //在找到的插入位置插入 &#123; cur-&gt;min = new unsigned long long(cur_value); cur-&gt;max = new unsigned long long(cur_value); &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value &lt; *cur-&gt;min) &#123; *cur-&gt;min = cur_value; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, *cur-&gt;max); unsigned long long value = low(cur, *cur-&gt;max); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; &#125; else &#123; if (cur-&gt;summary != nullptr) &#123; unsigned long long high_pos = high(cur, cur_value); unsigned long long value = low(cur, cur_value); cur-&gt;cluster[high_pos]-&gt;max = new unsigned long long(value); cur-&gt;cluster[high_pos]-&gt;min = new unsigned long long(value); insertValue(cur-&gt;summary, high_pos); &#125; *cur-&gt;max = cur_value; &#125; &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (*cur-&gt;cluster[high]-&gt;min == *cur-&gt;cluster[high]-&gt;max) &#123; insertValue(cur-&gt;summary, high); &#125; if (cur_value &gt; * cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else &#123; return true; &#125; &#125; while (work_stack.empty() == false) //自底向上调整summary和max值 &#123; cur = work_stack.top().cur; unsigned long long high = work_stack.top().high; work_stack.pop(); cur_value = index(cur, cur_value, high); if (cur_value &gt; *cur-&gt;max) &#123; *cur-&gt;max = cur_value; &#125; else //如果当前层节点max值没有因插入而改变，则无需继续向上调整，直接退出 &#123; return true; &#125; &#125; return true;&#125;bool VanEmdeBoasTree::searchValueAndBuildStack(stack&lt;StackNode&gt;&amp; work_stack, VanEmdeBoasTreeNode*&amp; cur, unsigned long long&amp; cur_value) //在vEB树中搜索给定值,失败返回false,成功返回true,搜索过程中沿途遇到的节点均被压入work_stack&#123; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; return true; &#125; else &#123; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; return true; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; *cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125;&#125;bool VanEmdeBoasTree::removeValue(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中删除x,成功返回true,失败返回false&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; while (true) //从根节点向下搜索，找到叶节点或只含有单一值的分支节点且x在其中即退出，否则返回false &#123; if (cur-&gt;summary == nullptr) &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; else if (*cur-&gt;min == *cur-&gt;max) &#123; if (cur_value == *cur-&gt;min) &#123; break; &#125; else &#123; return false; &#125; &#125; else &#123; break; &#125; &#125; else &#123; if (cur-&gt;min == nullptr) &#123; return false; &#125; if (cur_value == *cur-&gt;min) &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; break; &#125; else &#123; unsigned long long t = *cur-&gt;summary-&gt;min; //这里相当关键，如果在一个包含两个或两个以上值的分支节点找到x且x恰为分支节点最小值 cur_value = *cur-&gt;cluster[t]-&gt;min; //则应用x在该节点的后继替换最小值,同时更改当前搜索值为替换后的新值,然后下降到x在当前节点的后继所在的当前节点的子vEB树继续搜索 *cur-&gt;min = index(cur, cur_value, t); work_stack.push(StackNode(cur, t)); cur = cur-&gt;cluster[t]; continue; &#125; &#125; if (*cur-&gt;min == *cur-&gt;max) &#123; return false; &#125; if (cur_value &lt; *cur-&gt;min || cur_value &gt; * cur-&gt;max) &#123; return false; &#125; work_stack.push(StackNode(cur, high(cur, cur_value))); VanEmdeBoasTreeNode* temp = cur-&gt;cluster[high(cur, cur_value)]; cur_value = low(cur, cur_value); cur = temp; &#125; &#125; unsigned long long high = 0; bool first_cycle = true; while (true) &#123; if (cur-&gt;summary == nullptr) //在叶节点删除 &#123; if (*cur-&gt;min == *cur-&gt;max) &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; &#125; else &#123; if (cur_value == *cur-&gt;min) &#123; *cur-&gt;min = *cur-&gt;max; &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; &#125; first_cycle = false; &#125; else &#123; if (first_cycle) //在只含有单一值的分支节点删除 &#123; cur-&gt;min = nullptr; cur-&gt;max = nullptr; first_cycle = false; &#125; else &#123; cur_value = index(cur, cur_value, high); if (cur_value == *cur-&gt;min) //回溯到最小值被其后继替换的最后一个节点 &#123; if (cur_value == *cur-&gt;max) &#123; removeValue(cur-&gt;summary, high); &#125; else &#123; if (cur-&gt;cluster[high]-&gt;min == nullptr) &#123; removeValue(cur-&gt;summary, high); &#125; &#125; return true; //更新该节点的summary后当前节点最大值和删除前相同，保持不变，并且当前节点对应vEB树非空，故无需向根节点调整，直接返回 &#125; else &#123; if (cur_value == *cur-&gt;max) //回溯到此时的分支节点之前的搜索过程中一定没有用某节点的最小值的后继替换最小值 &#123; //此外，一定从搜索结束时找到的叶节点或只含有单一值的分支节点中实际删除给定值后回溯到了当前分支节点,判断条件cur_value == *cur-&gt;max通过后一定 if (cur-&gt;cluster[high]-&gt;max != nullptr) //从当前节点的cluster数组的high元素对应的vEB树中删除了该vEB树的最大值cur_value,且high元素之后的元素对应的vEB子树为空,这样必须用 &#123; //当前节点的被删除的最大值的前驱更新当前节点最大值 *cur-&gt;max = index(cur, *cur-&gt;cluster[high]-&gt;max, high); &#125; else &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp != nullptr) &#123; *cur-&gt;max = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; else &#123; *cur-&gt;max = *cur-&gt;min; &#125; removeValue(cur-&gt;summary, high); &#125; &#125; else &#123; //这种情况说明从当前节点cluster数组high元素对应子树删除cur_value后,当前节点的原最大值没有被删除且现在的最大值就是原最大值，所以无需更新最大值,当然high元素对应子树被删除值后可能为空，所以需要在summary中递归删除 if (cur-&gt;cluster[high]-&gt;min == nullptr) //上述操作结束后注意到当前节点删除cur_value后不为空，故直接返回，无需向根节点调整 &#123; removeValue(cur-&gt;summary, high); &#125; return true; &#125; &#125; &#125; &#125; if (work_stack.empty() == true) &#123; return true; &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findSuccessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的后继,失败返回nullptr,否则返回后继值&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) //查找x失败,返回nullptr &#123; return nullptr; &#125; enum Result &#123; FOUND_SUC, NOT_FOUND_SUC, FIRST_CYCLE &#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) //令查找到x的叶节点或x等于其最小值的分支节点为循环开始时的当前节点,如果在当前节点能够找到x的后继，则逐级向上返回到根节点，并在根结单处最终还原出x的后继 &#123; //如果当前节点无法找到x的后继，则回溯至父节点，在父节点的summary中查找当前节点对应vEB树在父节点cluster中的对应下标的后继，如果找到该后继在父节点cluster中对应子树的最小值即 if (cur-&gt;summary == nullptr) //为x后继，然后逐级向上返回，在根节点还原后继，否则回溯至祖先节点，继续利用祖先节点的summary查找x后继，处理过程和上述相同，如果最终在根节点处仍未发现x后继，则查找失败，返回nullptr &#123; if (cur_value == *cur-&gt;max) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; else &#123; cur_value = *cur-&gt;max; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_SUC; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (*cur-&gt;min != *cur-&gt;max) &#123; unsigned long long h_min = *cur-&gt;summary-&gt;min; cur_value = index(cur, *cur-&gt;cluster[h_min]-&gt;min, h_min); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_SUC; &#125; &#125; else if (result_flag == Result::FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_SUC) &#123; cur_value = index(cur, cur_value, high); if (cur_value != *cur-&gt;max) &#123; shared_ptr&lt;unsigned long long&gt; temp = findSuccessor(cur-&gt;summary, high); cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;min, *temp); result_flag = Result::FOUND_SUC; &#125; else &#123; if (work_stack.empty() == true) &#123; return nullptr; &#125; &#125; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;shared_ptr&lt;unsigned long long&gt; VanEmdeBoasTree::findPrecessor(VanEmdeBoasTreeNode* root, unsigned long long x) //在以root为根的vEB树中寻找x的前驱,失败返回nullptr,否则返回前驱值，过程和查找后继对称&#123; stack&lt;StackNode&gt; work_stack; VanEmdeBoasTreeNode* cur = root; unsigned long long cur_value = x; if (searchValueAndBuildStack(work_stack, cur, cur_value) == false) &#123; return nullptr; &#125; enum Result &#123;FOUND_PRE, NOT_FOUND_PRE, FIRST_CYCLE&#125; result_flag = Result::FIRST_CYCLE; unsigned long long high = 0; while (true) &#123; if (cur-&gt;summary == nullptr) &#123; if (cur_value == *cur-&gt;min) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else &#123; cur_value = *cur-&gt;min; if (!work_stack.empty()) &#123; result_flag = Result::FOUND_PRE; &#125; &#125; &#125; else &#123; if (result_flag == Result::FIRST_CYCLE) &#123; if (work_stack.empty()) &#123; return nullptr; &#125; result_flag = Result::NOT_FOUND_PRE; &#125; else if (result_flag == Result::FOUND_PRE) &#123; cur_value = index(cur, cur_value, high); &#125; else if (result_flag == Result::NOT_FOUND_PRE) &#123; shared_ptr&lt;unsigned long long&gt; temp = findPrecessor(cur-&gt;summary, high); if (temp == nullptr) &#123; cur_value = *cur-&gt;min; &#125; else &#123; cur_value = index(cur, *cur-&gt;cluster[*temp]-&gt;max, *temp); &#125; result_flag = Result::FOUND_PRE; &#125; &#125; if (work_stack.empty()) &#123; return make_shared&lt;unsigned long long&gt;(cur_value); &#125; cur = work_stack.top().cur; high = work_stack.top().high; work_stack.pop(); &#125;&#125;VanEmdeBoasTree::~VanEmdeBoasTree()&#123; stack&lt;VanEmdeBoasTreeNode*&gt; work_stack; //深度优先销毁vEB树 bool trace_back_flag = true; work_stack.push(root); while (work_stack.empty() == false) &#123; if (trace_back_flag) &#123; if (work_stack.top()-&gt;global_size &gt; 1) &#123; work_stack.push(work_stack.top()-&gt;summary); &#125; else &#123; delete work_stack.top(); work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top()-&gt;cluster.empty() == false) &#123; VanEmdeBoasTreeNode* temp = work_stack.top(); work_stack.push(work_stack.top()-&gt;cluster.back()); temp-&gt;cluster.pop_back(); trace_back_flag = true; &#125; else &#123; delete work_stack.top(); work_stack.pop(); &#125; &#125; &#125;&#125;VanEmdeBoasTree::VanEmdeBoasTree(StyleOfCreatTree how_building_tree, unsigned int g)&#123; if (g &lt;= 0 || g &gt; 64) &#123; cout &lt;&lt; "ERROR:全域大小超出允许范围" &lt;&lt; endl; exit(-1); &#125; style_of_build_tree = how_building_tree; root = new VanEmdeBoasTreeNode(g, VanEmdeBoasTreeNode::NodeType::CLUSTER); //BFS方式构建vEB树 if (style_of_build_tree == StyleOfCreatTree::BFS) &#123; deque&lt;VanEmdeBoasTreeNode*&gt; work_queue; work_queue.push_back(root); while (work_queue.empty() == false) &#123; VanEmdeBoasTreeNode* cur = work_queue.front(); work_queue.pop_front(); if (cur-&gt;global_size &gt; 1) &#123; unsigned int k = cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((cur-&gt;global_size &amp; 1) == 0) &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; k; &#125; else &#123; cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); global = 1U &lt;&lt; (k + 1); &#125; work_queue.push_back(cur-&gt;summary); for (size_t i = 1; i &lt;= global; ++i) &#123; cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_queue.push_back(cur-&gt;cluster.back()); &#125; &#125; &#125; &#125; else &#123; struct StackNode &#123; VanEmdeBoasTreeNode* cur; unsigned int up_sqrt; unsigned int down_sqrt; size_t cluster_size; StackNode(VanEmdeBoasTreeNode* c) :cur(c)&#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; bool trace_back_flag = true; work_stack.push(StackNode(root)); while (work_stack.empty() == false) //DFS方式构建vEB树 &#123; if (trace_back_flag) &#123; if (work_stack.top().cur-&gt;global_size &gt; 1) &#123; unsigned int k = work_stack.top().cur-&gt;global_size &gt;&gt; 1; size_t global = 0; if ((work_stack.top().cur-&gt;global_size &amp; 1) == 0) &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k; work_stack.top().cluster_size = 1U &lt;&lt; k; &#125; else &#123; work_stack.top().cur-&gt;summary = new VanEmdeBoasTreeNode(k + 1, VanEmdeBoasTreeNode::NodeType::SUMMARY); work_stack.top().down_sqrt = k; work_stack.top().up_sqrt = k + 1; work_stack.top().cluster_size = 1U &lt;&lt; (k + 1); &#125; work_stack.push(StackNode(work_stack.top().cur-&gt;summary)); &#125; else &#123; work_stack.pop(); trace_back_flag = false; &#125; &#125; else &#123; if (work_stack.top().cur-&gt;cluster.size() &lt; work_stack.top().cluster_size) &#123; work_stack.top().cur-&gt;cluster.push_back(new VanEmdeBoasTreeNode(work_stack.top().down_sqrt, VanEmdeBoasTreeNode::NodeType::CLUSTER)); work_stack.push(work_stack.top().cur-&gt;cluster.back()); trace_back_flag = true; &#125; else &#123; work_stack.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; unsigned int global = 5; VanEmdeBoasTree obj(VanEmdeBoasTree::StyleOfCreatTree::DFS, global); vector&lt;unsigned long long&gt; input; unsigned long long j = 1ULL &lt;&lt; global; for (unsigned long long i = 1; i &lt;= j; ++i) &#123; input.push_back(i - 1); &#125; shuffle(input.begin(), input.end(), default_random_engine(time(nullptr))); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "插入" &lt;&lt; i &lt;&lt; endl; if (obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; &#125; obj.printValueInTreeFromLargeToSmall(); obj.printValueInTreeFromSmallToLarge(); for (const unsigned long long&amp; i : input) &#123; cout &lt;&lt; "删除" &lt;&lt; i &lt;&lt; endl; if (obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; obj.printValueInTreeFromSmallToLarge(); obj.printValueInTreeFromLargeToSmall(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "树空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>vanEmdeBoas树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[斐波那契堆实现]]></title>
    <url>%2Fpost%2Fd424b1b8.html</url>
    <content type="text"><![CDATA[斐波那契堆的详细介绍见算法导论第三版，这里只给出斐波那契堆的实现 C++代码: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142114311441145114611471148114911501151115211531154115511561157115811591160116111621163116411651166116711681169117011711172117311741175117611771178117911801181118211831184118511861187118811891190119111921193119411951196119711981199120012011202120312041205120612071208120912101211121212131214121512161217121812191220122112221223122412251226122712281229123012311232123312341235123612371238123912401241124212431244124512461247124812491250125112521253125412551256125712581259126012611262126312641265126612671268126912701271127212731274127512761277127812791280128112821283128412851286128712881289129012911292129312941295129612971298129913001301130213031304130513061307130813091310131113121313131413151316131713181319#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;utility&gt;#include &lt;memory&gt;#include &lt;limits.h&gt;using namespace std; //注意斐波那契堆具有最小堆序template &lt;typename T&gt;struct FibonacciHeapNode //斐波那契堆节点&#123; T data; bool mark = false; //级联标记 unsigned int degree = 0; //节点的度 FibonacciHeapNode* parent = nullptr; FibonacciHeapNode* first_child = nullptr; FibonacciHeapNode* right_sibling = nullptr; FibonacciHeapNode* left_sibling = nullptr; FibonacciHeapNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;int Searchd(FibonacciHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_sibling == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;first_child != nullptr) return 1; else &#123; if (ptr-&gt;right_sibling != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;class FibonacciHeap&#123;public: T getAndRemoveMinkey(); //返回并移除最小值 bool removeFirstNodeWithSpecificValue(const T&amp; key); //移除斐波那契堆中第一个具有给定值的节点 void insert(const T&amp; key); bool changeNodeValue(const T&amp; original_vaule, const T &amp;goal_value); //将斐波那契堆中第一个原始值改为目标值 T getMinValue() //获取最小值 &#123; if (head_ptr_for_root_list == nullptr) return min_value_for_type; else return min-&gt;data; &#125; void merge(FibonacciHeap&amp; be_merged); //合并两个斐波那契堆 ~FibonacciHeap(); FibonacciHeap(const T&amp; min_value) :min_value_for_type(min_value) &#123;&#125; void printHeap(); //以广义表形式打印斐波那契堆 bool isEmpty() &#123; return num_of_node_in_heap == 0; &#125;private: FibonacciHeapNode&lt;T&gt;* removeMinNode(); FibonacciHeapNode&lt;T&gt;* unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right); //将斐波那契堆中两个子堆合并 void insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted); //根链表中插入新节点 void changeKey(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node, const T&amp; key); void removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node); bool adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //子堆中的右兄弟链中某节点关键字增值或减值后重新维护右兄弟链各节点的大小顺序,返回true表示右兄弟链各节点父节点degree减小，false相反 pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; searchFirstAppearKey(const T&amp; key); //搜索斐波那契堆中第一个具有给定关键码的节点 bool checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;*&amp; cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease); //根据右兄弟链大小次序的维护结果即右兄弟链上各节点父节点度有无变化和级联标记判断是否需要级联剪切,true表明无需剪切,false表示需要 void destorySubHeap(FibonacciHeapNode&lt;T&gt;* root); //销毁子堆 FibonacciHeapNode&lt;T&gt;* min = nullptr; //指向最小值指针 FibonacciHeapNode&lt;T&gt;* head_ptr_for_root_list = nullptr; //指向根链表首节点指针 unsigned long long num_of_node_in_heap = 0; //斐波那契堆中节点数 unsigned long long size_of_root_list = 0; //根链表大小 T min_value_for_type; //斐波那契堆中保存类型可能具有的最小值,该最小值不能为节点关键码&#125;;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::destorySubHeap(FibonacciHeapNode&lt;T&gt;* root)&#123; FibonacciHeapNode&lt;T&gt;* cur = root-&gt;first_child; while (cur != nullptr) &#123; departRightHeap(cur); FibonacciHeapNode&lt;T&gt;* next = cur-&gt;right_sibling; if (next == cur) &#123; next = nullptr; &#125; if (cur-&gt;first_child == nullptr) &#123; delete cur; &#125; else &#123; destorySubHeap(cur); &#125; cur = next; &#125; delete root;&#125;template &lt;typename T&gt;FibonacciHeap&lt;T&gt;::~FibonacciHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; return; &#125; while (head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* cur = nullptr; cur = head_ptr_for_root_list-&gt;right_sibling; cur-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; cur-&gt;left_sibling-&gt;right_sibling = cur; if (cur == head_ptr_for_root_list) &#123; cur = nullptr; &#125; head_ptr_for_root_list-&gt;right_sibling = nullptr; destorySubHeap(head_ptr_for_root_list); head_ptr_for_root_list = cur; &#125;&#125;template&lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::changeNodeValue(const T&amp; original_vaule, const T&amp; goal_value)&#123; if (original_vaule == goal_value) &#123; return false; &#125; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(original_vaule); if (temp.first == nullptr) &#123; return false; &#125; changeKey(temp.first, temp.second, goal_value); return true;&#125;template &lt;typename T&gt;T FibonacciHeap&lt;T&gt;::getAndRemoveMinkey()&#123; shared_ptr&lt;FibonacciHeapNode&lt;T&gt;&gt; t(removeMinNode()); if (t == nullptr) &#123; return min_value_for_type; &#125; else &#123; return t-&gt;data; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::merge(FibonacciHeap&lt;T&gt;&amp; be_merged)&#123; if (head_ptr_for_root_list == nullptr) &#123; min = be_merged.min; head_ptr_for_root_list = be_merged.head_ptr_for_root_list; num_of_node_in_heap = be_merged.num_of_node_in_heap; size_of_root_list = be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125; else if (be_merged.head_ptr_for_root_list != nullptr) &#123; FibonacciHeapNode&lt;T&gt;* pre = head_ptr_for_root_list-&gt;left_sibling; pre-&gt;right_sibling = be_merged.head_ptr_for_root_list; FibonacciHeapNode&lt;T&gt;* last = be_merged.head_ptr_for_root_list-&gt;left_sibling; be_merged.head_ptr_for_root_list-&gt;left_sibling = pre; last-&gt;right_sibling = head_ptr_for_root_list; head_ptr_for_root_list-&gt;left_sibling = last; if (min-&gt;data &gt; be_merged.min-&gt;data) &#123; min = be_merged.min; &#125; num_of_node_in_heap += be_merged.num_of_node_in_heap; size_of_root_list += be_merged.size_of_root_list; be_merged.min = nullptr; be_merged.head_ptr_for_root_list = nullptr; be_merged.num_of_node_in_heap = 0; be_merged.size_of_root_list = 0; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insert(const T&amp; key)&#123; FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (head_ptr_for_root_list != nullptr) &#123; pre = head_ptr_for_root_list-&gt;left_sibling; &#125; FibonacciHeapNode&lt;T&gt;* be_inserted = new FibonacciHeapNode&lt;T&gt;(key); if (head_ptr_for_root_list == nullptr || min-&gt;data &gt; be_inserted-&gt;data) &#123; min = be_inserted; &#125; insertInRootList(pre, be_inserted); ++num_of_node_in_heap; ++size_of_root_list;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::printHeap()&#123; if (head_ptr_for_root_list == nullptr) &#123; cout&lt;&lt;"NULL"; cout &lt;&lt; endl; return; &#125; size_t num = 0; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; cout &lt;&lt; "第" &lt;&lt; ++num &lt;&lt; "棵子堆的广义表形式:"; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; int d = 0; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (d == 0) cout &lt;&lt;"(" &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (ptr-&gt;first_child != nullptr) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ptr-&gt;data; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ","; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; cout &lt;&lt; ")"; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; cout &lt;&lt; "),"; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; cout &lt;&lt; endl; cout &lt;&lt; endl; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; FibonacciHeap&lt;T&gt;::searchFirstAppearKey(const T&amp; key)&#123; if (head_ptr_for_root_list == nullptr) &#123; return &#123; nullptr, nullptr &#125;; &#125; for (FibonacciHeapNode&lt;T&gt;* run = head_ptr_for_root_list; ; run = run-&gt;right_sibling) &#123; int d = 0; stack&lt;FibonacciHeapNode&lt;T&gt;*&gt; work_stack; FibonacciHeapNode&lt;T&gt;* ptr = run; FibonacciHeapNode&lt;T&gt;* root_right_bro = run-&gt;right_sibling; run-&gt;right_sibling = nullptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (key &lt; ptr-&gt;data) &#123; if (work_stack.empty() == true) &#123; break; &#125; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else if (key == ptr-&gt;data) &#123; break; &#125; if (ptr-&gt;first_child != nullptr) &#123; work_stack.push(ptr); interval = ptr-&gt;first_child; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; &#125; else &#123; if (ptr-&gt;right_sibling == work_stack.top()-&gt;first_child) &#123; ptr = work_stack.top(); d = 1; work_stack.pop(); continue; &#125; else &#123; interval = ptr-&gt;right_sibling; &#125; &#125; d = 0; ptr = interval; &#125; &#125; run-&gt;right_sibling = root_right_bro; if (ptr-&gt;data == key) &#123; return &#123; run, ptr &#125;; &#125; if (run-&gt;right_sibling == head_ptr_for_root_list) &#123; return &#123;nullptr, nullptr&#125;; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::removeFirstNodeWithSpecificValue(const T&amp; key)&#123; pair&lt;FibonacciHeapNode&lt;T&gt;*, FibonacciHeapNode&lt;T&gt;*&gt; temp = searchFirstAppearKey(key); if (temp.first == nullptr) &#123; return false; &#125; removeNode(temp.first, temp.second); return true;&#125;template &lt;typename T&gt;void departRightHeap(FibonacciHeapNode&lt;T&gt;* right_sub_heap) //把right_sub_heap从右兄弟链中分离&#123; FibonacciHeapNode&lt;T&gt;* p = right_sub_heap-&gt;parent; if (p != nullptr) &#123; right_sub_heap-&gt;left_sibling-&gt;right_sibling = right_sub_heap-&gt;right_sibling; right_sub_heap-&gt;right_sibling-&gt;left_sibling = right_sub_heap-&gt;left_sibling; if (p-&gt;first_child == right_sub_heap) &#123; if (right_sub_heap-&gt;right_sibling == right_sub_heap) &#123; p-&gt;first_child = nullptr; &#125; else &#123; p-&gt;first_child = right_sub_heap-&gt;right_sibling; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void insertNodeInRightSibLink(FibonacciHeapNode&lt;T&gt;* post, FibonacciHeapNode&lt;T&gt;* be_inserted_root)&#123; FibonacciHeapNode&lt;T&gt;* t = post-&gt;left_sibling; post-&gt;left_sibling = be_inserted_root; be_inserted_root-&gt;left_sibling = t; be_inserted_root-&gt;right_sibling = post; t-&gt;right_sibling = be_inserted_root;&#125;template &lt;typename T&gt;FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::unionSubHeap(FibonacciHeapNode&lt;T&gt;* left, FibonacciHeapNode&lt;T&gt;* right)&#123; struct StackNode &#123; FibonacciHeapNode&lt;T&gt;* parent; FibonacciHeapNode&lt;T&gt;* insert_point; StackNode(FibonacciHeapNode&lt;T&gt;* p, FibonacciHeapNode&lt;T&gt;* i) :parent(p), insert_point(i) &#123;&#125; &#125;; stack&lt;StackNode&gt; work_stack; FibonacciHeapNode&lt;T&gt;* left_sub_heap = left; FibonacciHeapNode&lt;T&gt;* right_sub_heap = right; FibonacciHeapNode&lt;T&gt;* cur = nullptr; while (true) //合并子堆，对根节点关键码值较大子堆，在较小子堆根节点右兄弟链寻找插入位置,找到位置则插入较大子堆根节点，否则说明右兄弟链中发现与较大子堆根节点关键码重复的节点，此时递归合并该节点代表子堆和较大子堆 &#123; if (left_sub_heap-&gt;data &lt;= right_sub_heap-&gt;data) &#123; FibonacciHeapNode&lt;T&gt;* run = left_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; right_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != left_sub_heap-&gt;first_child); &#125; if (run != left_sub_heap-&gt;first_child || run != nullptr &amp;&amp; right_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != right_sub_heap-&gt;data) &#123; departRightHeap(right_sub_heap); insertNodeInRightSibLink(run, right_sub_heap); if (run == left_sub_heap-&gt;first_child) &#123; left_sub_heap-&gt;first_child = right_sub_heap; &#125; &#125; else &#123; if (run == left_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(left_sub_heap, left_sub_heap)); &#125; else &#123; work_stack.push(StackNode(left_sub_heap, run-&gt;left_sibling)); &#125; left_sub_heap = run; continue; &#125; &#125; else &#123; departRightHeap(right_sub_heap); if (run == nullptr) &#123; left_sub_heap-&gt;first_child = right_sub_heap; right_sub_heap-&gt;left_sibling = right_sub_heap; right_sub_heap-&gt;right_sibling = right_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, right_sub_heap); &#125; &#125; right_sub_heap-&gt;parent = left_sub_heap; right_sub_heap-&gt;mark = false; ++left_sub_heap-&gt;degree; left_sub_heap-&gt;mark = false; cur = left_sub_heap; break; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = right_sub_heap-&gt;first_child; if (run != nullptr) &#123; do &#123; if (run-&gt;data &lt; left_sub_heap-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != right_sub_heap-&gt;first_child); &#125; if (run != right_sub_heap-&gt;first_child || run != nullptr &amp;&amp; left_sub_heap-&gt;data &lt;= run-&gt;data) &#123; if (run-&gt;data != left_sub_heap-&gt;data) &#123; departRightHeap(left_sub_heap); insertNodeInRightSibLink(run, left_sub_heap); if (run == right_sub_heap-&gt;first_child) &#123; right_sub_heap-&gt;first_child = left_sub_heap; &#125; &#125; else &#123; if (run == right_sub_heap-&gt;first_child) &#123; work_stack.push(StackNode(right_sub_heap, right_sub_heap)); &#125; else &#123; work_stack.push(StackNode(right_sub_heap, run-&gt;left_sibling)); &#125; FibonacciHeapNode&lt;T&gt;* t = left_sub_heap; left_sub_heap = run; right_sub_heap = t; continue; &#125; &#125; else &#123; departRightHeap(left_sub_heap); if (run == nullptr) &#123; right_sub_heap-&gt;first_child = left_sub_heap; left_sub_heap-&gt;left_sibling = left_sub_heap; left_sub_heap-&gt;right_sibling = left_sub_heap; &#125; else &#123; insertNodeInRightSibLink(run, left_sub_heap); &#125; &#125; left_sub_heap-&gt;parent = right_sub_heap; left_sub_heap-&gt;mark = false; ++right_sub_heap-&gt;degree; right_sub_heap-&gt;mark = false; cur = right_sub_heap; break; &#125; &#125; while (work_stack.empty() == false) //自底向上重新链接合并结果至父节点 &#123; if (cur-&gt;parent != work_stack.top().parent) &#123; FibonacciHeapNode&lt;T&gt;* run = work_stack.top().insert_point; departRightHeap(cur); if (run != work_stack.top().parent) &#123; run-&gt;right_sibling-&gt;left_sibling = cur; cur-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = cur; cur-&gt;left_sibling = run; &#125; else &#123; if (run-&gt;first_child == nullptr) &#123; run-&gt;first_child = cur; cur-&gt;left_sibling = cur; cur-&gt;right_sibling = cur; &#125; else &#123; insertNodeInRightSibLink(run-&gt;first_child, cur); run-&gt;first_child = cur; &#125; &#125; cur-&gt;parent = work_stack.top().parent; cur-&gt;mark = false; &#125; cur = work_stack.top().parent; work_stack.pop(); &#125; return cur;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::insertInRootList(FibonacciHeapNode&lt;T&gt;* &amp;pre, FibonacciHeapNode&lt;T&gt;* be_inserted)&#123; if (pre == nullptr) &#123; pre = head_ptr_for_root_list = be_inserted; be_inserted-&gt;right_sibling = be_inserted; be_inserted-&gt;left_sibling = be_inserted; &#125; else &#123; be_inserted-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = be_inserted; be_inserted-&gt;right_sibling-&gt;left_sibling = be_inserted; be_inserted-&gt;left_sibling = pre; &#125; be_inserted-&gt;mark = false;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::adjustToRemainOrder(FibonacciHeapNode&lt;T&gt;* parent, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) //increase_or_decrease表示node值增加，否则减小&#123; if (increase_or_decrease) //node值已改变，所以需要在node所在右兄弟链上查找值等于node的节点，如果找到需要合并该节点和node节点代表的子堆 &#123; if (node-&gt;right_sibling == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;right_sibling; do &#123; if (run-&gt;data &lt; node-&gt;data) &#123; run = run-&gt;right_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child); if (run != parent-&gt;first_child) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;right_sibling == run) &#123; return false; &#125; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* t = run-&gt;left_sibling; run-&gt;left_sibling = node; node-&gt;left_sibling = t; node-&gt;right_sibling = run; t-&gt;right_sibling = node; return false; &#125; &#125; else &#123; departRightHeap(node); run = run-&gt;left_sibling; run-&gt;right_sibling = node; node-&gt;left_sibling = run; node-&gt;right_sibling = parent-&gt;first_child; parent-&gt;first_child-&gt;left_sibling = node; return false; &#125; &#125; else &#123; if (node == parent-&gt;first_child) &#123; return false; &#125; FibonacciHeapNode&lt;T&gt;* run = node-&gt;left_sibling; do &#123; if (run-&gt;data &gt; node-&gt;data) &#123; run = run-&gt;left_sibling; &#125; else &#123; break; &#125; &#125; while (run != parent-&gt;first_child-&gt;left_sibling); if (run != parent-&gt;first_child-&gt;left_sibling) &#123; if (node-&gt;data == run-&gt;data) &#123; departRightHeap(node); FibonacciHeapNode&lt;T&gt;* pre = nullptr; if (run == parent-&gt;first_child) &#123; pre = parent; &#125; else &#123; pre = run-&gt;left_sibling; &#125; departRightHeap(run); node-&gt;parent = nullptr; run-&gt;parent = nullptr; run = unionSubHeap(node, run); if (parent-&gt;first_child == nullptr) &#123; parent-&gt;first_child = run; run-&gt;left_sibling = run; run-&gt;right_sibling = run; &#125; else &#123; if (pre == parent) &#123; pre = parent-&gt;first_child; run-&gt;left_sibling = pre-&gt;left_sibling; run-&gt;right_sibling = pre; pre-&gt;left_sibling = run; run-&gt;left_sibling-&gt;right_sibling = run; parent-&gt;first_child = run; &#125; else &#123; run-&gt;right_sibling = pre-&gt;right_sibling; pre-&gt;right_sibling = run; run-&gt;right_sibling-&gt;left_sibling = run; run-&gt;left_sibling = pre; &#125; &#125; run-&gt;parent = parent; run-&gt;mark = false; --parent-&gt;degree; return true; &#125; else &#123; if (node-&gt;left_sibling == run) &#123; return false; &#125; departRightHeap(node); node-&gt;right_sibling = run-&gt;right_sibling; run-&gt;right_sibling = node; node-&gt;right_sibling-&gt;left_sibling = node; node-&gt;left_sibling = run; return false; &#125; &#125; else &#123; departRightHeap(node); run = parent-&gt;first_child; node-&gt;left_sibling = run-&gt;left_sibling; node-&gt;right_sibling = run; run-&gt;left_sibling = node; node-&gt;left_sibling-&gt;right_sibling = node; parent-&gt;first_child = node; return false; &#125; &#125;&#125;template &lt;typename T&gt;bool FibonacciHeap&lt;T&gt;::checkAndMaintainSibListOrderliness(FibonacciHeapNode&lt;T&gt;* &amp;cur, FibonacciHeapNode&lt;T&gt;* node, bool increase_or_decrease) &#123; if (node-&gt;parent != nullptr) &#123; if (!adjustToRemainOrder(node-&gt;parent, node, increase_or_decrease)) &#123; return true; &#125; else &#123; if (node-&gt;parent-&gt;mark == true) &#123; cur = node-&gt;parent; return false; &#125; else &#123; node-&gt;parent-&gt;mark = true; return true; &#125; &#125; &#125; else &#123; return true; &#125;&#125;template &lt;typename T&gt;void FibonacciHeap&lt;T&gt;::changeKey(FibonacciHeapNode&lt;T&gt; *root, FibonacciHeapNode&lt;T&gt; *node, const T&amp; key)&#123; if (key == node-&gt;data) &#123; return; &#125; FibonacciHeapNode&lt;T&gt;* cur = nullptr; FibonacciHeapNode&lt;T&gt;* pre = root; if (key &gt; node-&gt;data) //如果node的值增加,则需要将node的子女节点中不满足堆序的节点代表的子堆剪切至根链表,然后判断node是否需要级联切断 &#123; node-&gt;data = key; if (node-&gt;first_child == nullptr) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* run = node-&gt;first_child; unsigned long long num_of_lossing_node = 0; bool finish = false; while (finish == false) &#123; if (run-&gt;data &gt;= node-&gt;data) &#123; node-&gt;first_child = run; break; &#125; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; --node-&gt;degree; ++num_of_lossing_node; run-&gt;parent = nullptr; FibonacciHeapNode&lt;T&gt;* temp = nullptr; if (run-&gt;right_sibling == run) &#123; finish = true; &#125; else &#123; temp = run-&gt;right_sibling; &#125; insertInRootList(pre, run); ++size_of_root_list; if (min-&gt;data &gt; run-&gt;data) &#123; min = run; &#125; run = temp; pre = pre-&gt;right_sibling; &#125; if (node-&gt;degree == 0) &#123; node-&gt;first_child = nullptr; &#125; if (finish == false) &#123; if (node-&gt;mark == false) &#123; if (num_of_lossing_node == 0 || num_of_lossing_node == 1) &#123; if (num_of_lossing_node == 1) &#123; node-&gt;mark = true; &#125; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; else &#123; if (num_of_lossing_node == 0) &#123; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; else &#123; if (node-&gt;mark == false &amp;&amp; num_of_lossing_node == 1) &#123; node-&gt;mark = true; if (checkAndMaintainSibListOrderliness(cur, node, true)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; &#125; &#125; else &#123; node-&gt;data = key; if (node-&gt;parent == nullptr) &#123; if (min-&gt;data &gt; node-&gt;data) &#123; min = node; &#125; return; &#125; if (node-&gt;parent-&gt;data &lt;= node-&gt;data) //node值减小，则应判断node与其父节点是否满足最小堆序,若满足则调整node所在右兄弟链上节点的大小次序并判断node的父节点是否需要级联切断 若不满足则node代表子堆应当被剪切至根链表 &#123; if (checkAndMaintainSibListOrderliness(cur, node, false)) &#123; return; &#125; &#125; else &#123; cur = node; &#125; &#125; while (true) //从当前节点cur开始，向上进行级联切断操作 &#123; if (cur-&gt;parent == nullptr) &#123; cur-&gt;mark = false; break; &#125; departRightHeap(cur); insertInRootList(pre, cur); pre = pre-&gt;right_sibling; node = cur-&gt;parent; cur-&gt;parent = nullptr; if (cur-&gt;data &lt; min-&gt;data) &#123; min = cur; &#125; ++size_of_root_list; --node-&gt;degree; if (node-&gt;mark == false) &#123; cur-&gt;mark = true; break; &#125; cur = node; &#125;&#125; template &lt;typename T&gt; FibonacciHeapNode&lt;T&gt;* FibonacciHeap&lt;T&gt;::removeMinNode() //该操作的详细说明参见算法导论 &#123; if (head_ptr_for_root_list == nullptr) &#123; return nullptr; &#125; FibonacciHeapNode&lt;T&gt;* pre = min-&gt;left_sibling; FibonacciHeapNode&lt;T&gt;* original_min = min; if (pre == min) &#123; pre = nullptr; head_ptr_for_root_list = nullptr; &#125; else &#123; pre-&gt;right_sibling = min-&gt;right_sibling; min-&gt;right_sibling-&gt;left_sibling = pre; &#125; FibonacciHeapNode&lt;T&gt;* run = min-&gt;first_child; if (run == nullptr) &#123; min-&gt;left_sibling = min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = pre-&gt;right_sibling; &#125; if (head_ptr_for_root_list != nullptr) &#123; min = head_ptr_for_root_list; for (FibonacciHeapNode&lt;T&gt;* tra = head_ptr_for_root_list; ; tra = tra-&gt;right_sibling) &#123; if (min-&gt;data &gt; tra-&gt;data) &#123; min = tra; &#125; if (tra-&gt;right_sibling == head_ptr_for_root_list) &#123; break; &#125; &#125; &#125; else &#123; min = nullptr; --num_of_node_in_heap; --size_of_root_list; return original_min; &#125; &#125; else &#123; FibonacciHeapNode&lt;T&gt;* tail_or_head = pre; while (true) &#123; run-&gt;right_sibling-&gt;left_sibling = run-&gt;left_sibling; run-&gt;left_sibling-&gt;right_sibling = run-&gt;right_sibling; run-&gt;parent = nullptr; if (run-&gt;right_sibling == run) &#123; insertInRootList(pre, run); break; &#125; FibonacciHeapNode&lt;T&gt;* temp = run-&gt;right_sibling; insertInRootList(pre, run); run = temp; pre = pre-&gt;right_sibling; &#125; min-&gt;first_child = nullptr; min-&gt;left_sibling = nullptr; min-&gt;right_sibling = nullptr; if (head_ptr_for_root_list == nullptr) &#123; head_ptr_for_root_list = pre; &#125; else if (head_ptr_for_root_list == min) &#123; head_ptr_for_root_list = tail_or_head-&gt;right_sibling; &#125; &#125; vector&lt;FibonacciHeapNode&lt;T&gt;*&gt; be_merged_sub_heap; bool finish = false; while (finish == false) //合并根链表上根节点度数相等的子堆 &#123; head_ptr_for_root_list-&gt;right_sibling-&gt;left_sibling = head_ptr_for_root_list-&gt;left_sibling; head_ptr_for_root_list-&gt;left_sibling-&gt;right_sibling = head_ptr_for_root_list-&gt;right_sibling; FibonacciHeapNode&lt;T&gt;* temp = head_ptr_for_root_list; if (temp-&gt;right_sibling == temp) &#123; finish = true; head_ptr_for_root_list = nullptr; &#125; else &#123; head_ptr_for_root_list = head_ptr_for_root_list-&gt;right_sibling; &#125; temp-&gt;left_sibling = temp-&gt;right_sibling = nullptr; while (true) &#123; if (be_merged_sub_heap.empty() == true || be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; unsigned int pre_degree = temp-&gt;degree; temp = unionSubHeap(be_merged_sub_heap[temp-&gt;degree], temp); if (temp-&gt;degree == pre_degree) &#123; be_merged_sub_heap[pre_degree] = temp; break; &#125; be_merged_sub_heap[pre_degree] = nullptr; if (be_merged_sub_heap.size() &lt; temp-&gt;degree + 1) &#123; be_merged_sub_heap.resize(temp-&gt;degree + 1, nullptr); &#125; if (be_merged_sub_heap[temp-&gt;degree] == nullptr) &#123; be_merged_sub_heap[temp-&gt;degree] = temp; break; &#125; &#125; &#125; min = nullptr; pre = nullptr; size_of_root_list = 0; for (size_t i = 0; i &lt; be_merged_sub_heap.size(); ++i) //合并后还原根链表 &#123; if (be_merged_sub_heap[i] != nullptr) &#123; ++size_of_root_list; insertInRootList(pre, be_merged_sub_heap[i]); pre = pre-&gt;right_sibling; if (min == nullptr || min-&gt;data &gt; pre-&gt;data) &#123; min = pre; &#125; &#125; &#125; --num_of_node_in_heap; return original_min; &#125; template &lt;typename T&gt; void FibonacciHeap&lt;T&gt;::removeNode(FibonacciHeapNode&lt;T&gt;* root, FibonacciHeapNode&lt;T&gt;* node) &#123; changeKey(root, node, min_value_for_type); removeMinNode(); &#125;int main()&#123; FibonacciHeap&lt;int&gt; obj(INT_MIN); vector&lt;int&gt; input&#123;3, 9, 1, 23, 67, 14, 7, 35, 15, 78, 99, 12, 16&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); cout &lt;&lt; endl; &#125; while(true) &#123; int t = obj.getAndRemoveMinkey(); cout &lt;&lt; "移除最小值" &lt;&lt; endl; if (t == INT_MIN) &#123; cout &lt;&lt; "移除失败" &lt;&lt; endl; break; &#125; else &#123; cout &lt;&lt; "移除最小值" &lt;&lt; t &lt;&lt; "成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; obj.printHeap(); &#125; &#125; vector&lt;int&gt; input2&#123; 9, 13, 34, 12, 90, 32, 16, 78, 56, 23, 45 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; obj.insert(i); &#125; /*cout &lt;&lt; "删除关键码" &lt;&lt; 9 &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(9)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; for (size_t i = 1; i&lt;input2.size(); ++i) &#123; while (true) &#123; if (!obj.changeNodeValue(input2[i], 14)) break; else &#123; cout &lt;&lt; "将值" &lt;&lt; input2[i] &lt;&lt; "更改为14" &lt;&lt; endl; obj.printHeap(); &#125; &#125; &#125; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; */ for (const int&amp; i : input2) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (obj.removeFirstNodeWithSpecificValue(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; cout &lt;&lt; "当前最小值" &lt;&lt; obj.getMinValue() &lt;&lt; endl; cout &lt;&lt; "斐波那契堆打印结果" &lt;&lt; endl; obj.printHeap(); &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; &#125; if (obj.isEmpty()) &#123; cout &lt;&lt; "当前堆为空" &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>斐波那契堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修剪二叉搜索树的非递归解法]]></title>
    <url>%2Fpost%2F623e708f.html</url>
    <content type="text"><![CDATA[LeetCode 669 修剪二叉搜索树问题&nbsp;该题要求保留BST中节点值在给定区间范围内的所有节点，其他超出范围的节点全部剔除 网上的解法基本为递归，本文给出了非递归解法，相关说明见https://www.zhihu.com/question/329696898/answer/719919857 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct BSTNode //二叉搜索树节点定义&#123; int data; //数据域 BSTNode* left_child = nullptr; BSTNode* right_child = nullptr; BSTNode(int d) :data(d) &#123;&#125; BSTNode(const BSTNode&amp; be_copy) :data(be_copy.data), left_child(nullptr), right_child(nullptr) &#123;&#125;&#125;;BSTNode *trimBST(BSTNode* root, int left, int right) //修剪二叉搜索树，只保留区间[left, right]内的节点&#123; enum ProcessRate &#123;START, LEFT_SUB_TREE, RIGHT_SUB_TREE&#125;; //处理状态，尚未修剪任何子树，已修剪过左子树，两棵子树均已修剪 struct StackNode &#123; BSTNode* ptr_to_node_every_layer; //需修剪的BST根节点指针 ProcessRate rate = ProcessRate::START; //修剪状态 BSTNode* ptr_to_root_beconstructed; //修剪后形成的新的BST根节点指针 StackNode(BSTNode* p) :ptr_to_node_every_layer(p) &#123; ptr_to_root_beconstructed = new BSTNode(*ptr_to_node_every_layer); &#125; &#125;; stack&lt;StackNode&gt; work_stack; BSTNode* cur = root; while (cur != nullptr) &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); break; &#125; &#125; if (cur == nullptr) &#123; return nullptr; &#125; while (true) &#123; if (work_stack.top().rate != ProcessRate::RIGHT_SUB_TREE) &#123; if (work_stack.top().rate == ProcessRate::START) //左子树尚未修剪，修剪左子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;left_child; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) //右子树尚未修剪，修剪右子树 &#123; cur = work_stack.top().ptr_to_node_every_layer-&gt;right_child; &#125; while (cur != nullptr) //向下搜索，抛弃修剪掉的部分 &#123; if (right &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else if (cur-&gt;data &lt; left) &#123; cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(StackNode(cur)); //找到根节点无需修剪，但子树需修剪的BST子树 break; &#125; &#125; if (cur == nullptr) //被修剪的子树为空或子树中所有节点值都在[L,R]外 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else &#123; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; &#125; else //当前BST左右子树均修剪完毕 &#123; StackNode temp = work_stack.top(); work_stack.pop(); if (work_stack.empty() == false) //栈不为空,将已经修剪完毕的当前BST链接至上一层需修剪的BST的子女指针域，并更新上一层修剪状态 &#123; if (work_stack.top().rate == ProcessRate::START) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;left_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::LEFT_SUB_TREE; &#125; else if (work_stack.top().rate == ProcessRate::LEFT_SUB_TREE) &#123; work_stack.top().ptr_to_root_beconstructed-&gt;right_child = temp.ptr_to_root_beconstructed; work_stack.top().rate = ProcessRate::RIGHT_SUB_TREE; &#125; &#125; else &#123; return temp.ptr_to_root_beconstructed; //如果栈为空，说明当前已经修剪完毕的BST子树就是最终修剪结果，直接返回 &#125; &#125; &#125;&#125;void inorderTraverse(BSTNode* root) //输出中序序列&#123; if (root != nullptr) &#123; inorderTraverse(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraverse(root-&gt;right_child); &#125;&#125;int main()&#123; BSTNode* root = nullptr; vector&lt;int&gt; input&#123;4, 89, 23, 46, 12, 3, 56, 78, 34, 45, 11&#125;; //插入BST中的数据 for (const int&amp; i : input) &#123; BSTNode* temp = root; if (temp == nullptr) &#123; root = new BSTNode(i); &#125; else &#123; BSTNode* parent = nullptr; while (temp != nullptr) &#123; if (temp-&gt;data == i) break; parent = temp; if (temp-&gt;data &lt; i) &#123; temp = temp-&gt;right_child; &#125; else if (temp-&gt;data &gt; i) &#123; temp = temp-&gt;left_child; &#125; &#125; if (temp == nullptr) &#123; if (i &lt; parent-&gt;data) &#123; parent-&gt;left_child = new BSTNode(i); &#125; else &#123; parent-&gt;right_child = new BSTNode(i); &#125; &#125; &#125; &#125; BSTNode* _new = trimBST(root, 5, 50); cout &lt;&lt; "修剪后的二叉树的中序序列为:"; if (_new == nullptr) &#123; cout &lt;&lt; "NULL"; &#125; else &#123; inorderTraverse(_new); &#125; cout &lt;&lt; endl; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉搜索树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆合并操作时间界的证明]]></title>
    <url>%2Fpost%2Fd1fc1482.html</url>
    <content type="text"><![CDATA[阅读《数据结构与算法分析:java语言描述》一书时看到了对左式堆合并操作时间界的说明，但书中没有给出详细证明，这里自己思考并补全了证明细节，如下文(全文假定讨论的左式堆具有最小堆序，最大堆序的讨论是类似的)证法一：我们用&nbsp;&nbsp;表示右路径(从左式堆的根节点出发抵达根节点或以其右子女为根的子树中子女数不为2的节点的最短路径)长度为i的左式堆L1和右路径长度为j的左式堆R1合并的平均时间代价。现设i&gt;=0 且 j&gt;=0 , L1和R1合并时存在两种可能，如果R1的根节点关键码值大于等于L1根节点关键码值，则应将L1右子树代表的左式堆LR1和左式堆R1合并，此时由于L1的右路径长度为i,故LR1根节点的零路径长度为i-1,而LR1根节点的零路径长度是LR1左路径(定义类似右路径)长度和右路径长度中的较小值，且由左式堆的性质，LR1左路径长度应当大于等于右路径长度，于是LR1的右路径长度即为i-1,这样将左式堆LR1和左式堆R1合并的平均时间代价可以表示为&nbsp;&nbsp;。如果R1的根节点关键码值小于L1根节点关键码值，则应将左式堆L1和R1右子树代表的左式堆RR1合并，通过和上文类似的分析可知合并的平均时间代价可以表示为&nbsp;另外一个空左式堆和任意一个左式堆合并的时间代价显然为&nbsp;&nbsp;,因此&nbsp;现在考虑由平面上整点&nbsp;&nbsp;&nbsp;&nbsp;以及这些整点中相邻点之间的垂直水平连线构成的矩形网格 ，由上文分析知，从整点&nbsp;&nbsp;出发，首先右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作对应于整点&nbsp;&nbsp;,且在整点&nbsp;&nbsp;对应的合并操作中要么右路径长度为i的左式堆根节点的右子树和右路径长度为j的左式堆合并，此时该合并操作对应于整点&nbsp;&nbsp;，要么右路径长度为i的左式堆和右路径长度为j的左式堆根节点的右子树合并，此时该合并操作对应于整点&nbsp;&nbsp;,完成整点&nbsp;&nbsp;对应的合并操作相当于首先完成整点&nbsp;&nbsp;或&nbsp;&nbsp;的合并操作，然后再将这一合并操作的合并结果(一颗左式堆)链接至i或j的右子树并在必要时调换i,或j的左右子树，因此整点&nbsp;&nbsp;对应的合并操作也可视为连接&nbsp;&nbsp;或&nbsp;&nbsp;和&nbsp;&nbsp;的一条垂直(水平边)，更确切地说整点&nbsp;&nbsp;对应的合并操作完全可以看做先完成&nbsp;&nbsp;或&nbsp;&nbsp;对应的合并操作再沿这一垂直(水平边)回溯至整点&nbsp;&nbsp;. 类似地，对代表完成整点&nbsp;&nbsp;对应的合并操作之前需要完成的合并操作的整点&nbsp;&nbsp;或整点&nbsp;&nbsp;,可以用和上文所述完全相同的方法继续分析，不断地抵达新的整点并选择连接这些整点中相邻整点的垂直水平边，这一过程中抵达一个新的整点后会向左或向下移动至下一个相邻整点，最终就可以得到向矩形网格左下方延伸的递降路径M，从&nbsp;&nbsp;出发沿M向左下方前进抵达的每个整点(除&nbsp;&nbsp;外)的纵坐标均小于等于其M上前驱整点的纵坐标,横坐标均小于等于其M上前驱整点的横坐标。如果令&nbsp;&nbsp;为M的出发点，则M的终点最终必然会在&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;之一,设其为&nbsp;&nbsp;,这样对右路径长度为i的左式堆和右路径长度为j的左式堆的合并操作可以用M描述为首先完成&nbsp;&nbsp;对应的合并操作，操作必然有一个被合并左式堆为空堆，时间代价为1，然后对&nbsp;在M上的前驱节点&nbsp;&nbsp;将合并得到的左式堆链接至右路径长为a2或b2(这取决于构造M时从&nbsp;&nbsp;抵达&nbsp;&nbsp;的方向(垂直或水平),即完成&nbsp;&nbsp;对应的合并操作前最后需要完成的合并操作是什么)的左式堆的根节点右指针域并在必要时调换根节点左右子树的位置，这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为2，随后从&nbsp;出发,对&nbsp;&nbsp;在路径M上的前驱节点&nbsp;&nbsp;而言将&nbsp;&nbsp;对应的合并操作的合并结果链接至右路径长为a3或b3的左式堆的根节点右指针域并在必要是调换根节点左右子树位置这一操作时间复杂度显然为&nbsp;,该操作完成后&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度为3.随后从&nbsp;&nbsp;按照这一过程继续沿M向&nbsp;&nbsp;回溯，当最终回溯至&nbsp;&nbsp;后,&nbsp;&nbsp;对应的合并操作即完成，此时的累计时间复杂度恰为M上整点个数，即为M的路径长度加一若&nbsp;&nbsp;&nbsp;则M路径长为&nbsp;M上整点个数即M的累计时间复杂度为&nbsp;&nbsp;由于M为向左下角延伸递降路径，出发点为&nbsp;&nbsp;,终点为&nbsp;&nbsp;故所有可能的M的数量为组合数&nbsp;,理想情况下可以认为每一种路径可能出现的概率是相等的，均为&nbsp;&nbsp;,于是每条路径M的期望时间复杂度为&nbsp;&nbsp;， 对所有可能的M的期望时间复杂度求和得到出发点在&nbsp;&nbsp;终点在&nbsp;&nbsp;的所有路径的期望时间复杂度&nbsp;可以认为当M的出发点为&nbsp;&nbsp;时，终点落在&nbsp;&nbsp;上每一点的可能性是相等的，概率均为&nbsp;于是出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;同理出发点在&nbsp;&nbsp;终点在每一个整点&nbsp;&nbsp;&nbsp;的所有路径的期望时间复杂度为&nbsp;累加以上两式得到整点&nbsp;&nbsp;对应的左式堆合并操作对应的期望时间复杂度&nbsp;当i,j充分大时，由最后一个不等式可见&nbsp;故&nbsp;&nbsp;设右路径长度为i的左式堆节点数为N,右路径长度为j的左式堆节点数为H，有&nbsp;&nbsp;&nbsp;故&nbsp;&nbsp;证毕证法二：的含义如证法一开头所述，这里i&gt;=0,j&gt;=0,T的边界条件和证法一所述相同，根据证法一开头的分析，我们可以认为L1右子树代表的左式堆LR1和左式堆R1合并以及左式堆L1和R1右子树代表的左式堆RR1合并的可能性相同，概率均为&nbsp;.从而可以认为&nbsp;&nbsp;这里1表示完成对[i-1,j]或[i,j-1]对应的合并操作后在[i,j]对应的合并操作中链接和调换子树位置所需的常量时间于是&nbsp;由上式知，倘若有&nbsp;&nbsp;—&nbsp;&nbsp;均&nbsp;则&nbsp;+&nbsp;&lt;=&nbsp;而由边界条件知&nbsp;&nbsp;均&nbsp;故由以上结论知&nbsp;&nbsp;均&nbsp;于是进一步可推得&nbsp;&nbsp;均&nbsp;这样层层向上递推，最终得到&nbsp;&nbsp;均&nbsp;即&nbsp;&nbsp;&nbsp;现在取max(i,j)=n,首先我们有&nbsp;&nbsp;&nbsp;然后我们有&nbsp;接着&nbsp;按照这一步骤向前递推最终得到&nbsp;&nbsp;利用(4)并采用和以上和相同的步骤又可得到&nbsp;&nbsp;继续递推，最终得到&nbsp;&nbsp;综上,对任意&nbsp;&nbsp;&nbsp;必有&nbsp;而&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;故&nbsp;这样对&nbsp;&nbsp;用(3)我们有&nbsp;从而&nbsp;于是我们最终得到&nbsp;&nbsp;从而得到时间界&nbsp;&nbsp;&nbsp;即(由证法一结尾的说明)&nbsp;&nbsp;证完]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[左式堆实现]]></title>
    <url>%2Fpost%2Fa33a7370.html</url>
    <content type="text"><![CDATA[左式堆是满足如下性质的二叉树(最小堆序): 要么为空树，要么根节点的左右子树均为左式堆，且根节点的关键码值小于等于左右子树所有节点的关键码值，此外左子树代表的左式堆的零路径长度大于等于右子树代表的左式堆的零路径长度 一个左式堆的零路径长度定义为:左式堆的根节点到达左式堆中任意至少有一个子女节点为空的节点的路径长度的最小值，如果左式堆为空，其零路径长度规定为-1,如果左式堆根节点至少有一个子女节点为空，则左式堆的零路径长度为0 显然，由零路径长度的定义，当左式堆不为空时，它的零路径长度为根节点的左右子树代表的左式堆的零路径长度中的较小值加1 左式堆的核心操作为合并操作，插入删除操作均为合并操作的特殊情形。合并时如果待合并的左式堆L1,L2有一个为空，则直接返回另一个左式堆，否则若L1根节点关键码小于等于L2根节点，则递归合并L2和L1根节点右子树，若不然则递归合并L1和L2右子树 合并操作由递归描述，但实际实现时采用非递归方法。此外左式堆还支持改变节点关键码值的操作，如果改变后堆序仍然满足，则操作结束，否则若节点值增大，则修改节点零路径长度，若零路径长度改变(减小)则沿父节点链向根节点调整，直到恢复左式堆性质，否则不用调整，然后将节点值改变的节点的左右子树和原左式堆在该节点的左右子树被剪除后形成的新的左式堆合并。若节点值减小，则分离出以该节点为根的子树，并沿该节点的父节点链向根节点调整直到恢复左式堆性质，然后将分离出的子树和调整后的原左式堆合并。 实现左式堆的C++代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;memory&gt;using namespace std; //实现的左式堆默认为最小堆序template &lt;typename T&gt;struct LeftIstHeapNode //左式堆节点定义&#123; T* data_field; //数据域 LeftIstHeapNode *left_node_ptr = nullptr; //左子女指针 LeftIstHeapNode* right_node_ptr = nullptr; //右子女指针 long long zero_road_length = 0; //左式堆节点的零路径长度 LeftIstHeapNode(T* d) :data_field(d) &#123;&#125; ~LeftIstHeapNode() &#123;delete data_field; &#125;&#125;;template &lt;typename T&gt;struct StackNodeInfo&#123; LeftIstHeapNode&lt;T&gt;* p; int direction; StackNodeInfo(LeftIstHeapNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125;&#125;;struct JudgeResult&#123; bool isLeftIstHeap = true; long long zero_road_length = -1;&#125;;template &lt;typename T&gt;class LeftIstHeap&#123;public: bool empty() &#123; return root == nullptr; &#125; //判断左式堆是否为空 bool satisfyLeftIstHeapNature() &#123; return isLeftIstHeap(root).isLeftIstHeap; &#125; T* getMinValue() &#123; return new T(*(root-&gt;data_field)); &#125; //获取左式堆中最小节点值 void insert(T *data); //左式堆中插入数据 T *removeMinValue(); //移除左式堆总最小值 bool changeNodeVauleForNodeHaveSepecificValue(T *original_node_value, T * change_value); //改变左式堆中节点，被改变的节点是搜索过程中遇到的第一个具有给定节点值的节点 LeftIstHeap() = default; ~LeftIstHeap() &#123; destoryHeap(root); &#125;private: void merge(LeftIstHeapNode&lt;T&gt;* root); //合并左式堆 void changeNodeValue(LeftIstHeapNode&lt;T&gt;* bechanged, T* change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack); //改变左式堆中指定节点的节点值 static JudgeResult isLeftIstHeap(LeftIstHeapNode&lt;T&gt;* root); void destoryHeap(LeftIstHeapNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryHeap(root-&gt;left_node_ptr); destoryHeap(root-&gt;right_node_ptr); delete root; &#125; &#125; LeftIstHeapNode&lt;T&gt; *root = nullptr;&#125;;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::merge(LeftIstHeapNode&lt;T&gt; *bemerged_root)&#123; if (root == nullptr) &#123; root = bemerged_root; return; &#125; else if (bemerged_root == nullptr) &#123; return; &#125; struct StackNodeinfo &#123; LeftIstHeapNode&lt;T&gt;* left_ptr_to_heap_be_merged_sub_tree_in = nullptr; //本次合并操作中根节点值较小的被合并左式堆的根节点 StackNodeinfo(LeftIstHeapNode&lt;T&gt;* l) :left_ptr_to_heap_be_merged_sub_tree_in(l)&#123;&#125; &#125;; LeftIstHeapNode&lt;T&gt;* cur_ptr = nullptr; //自底向上合并过程中指向当前合并结果对应的左式堆根节点的指针 stack&lt;StackNodeinfo&gt; work_stack; &#123; LeftIstHeapNode&lt;T&gt;* cur_left_ptr = root; //自顶向下分解合并操作的过程中当前需要合并的两个左式堆的根节点指针cur_left_ptr,cur_right_ptr LeftIstHeapNode&lt;T&gt;* cur_right_ptr = bemerged_root; while (cur_left_ptr != nullptr) //自顶向下分解合并操作 &#123; if (*(cur_right_ptr-&gt;data_field) &gt;= *(cur_left_ptr-&gt;data_field)) //cur_right_ptr和cur_left_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_left_ptr)); cur_left_ptr = cur_left_ptr-&gt;right_node_ptr; &#125; else //cur_left_ptr和cur_right_ptr右子树合并 &#123; work_stack.push(StackNodeinfo(cur_right_ptr)); LeftIstHeapNode&lt;T&gt;* temp = cur_left_ptr; cur_left_ptr = cur_right_ptr-&gt;right_node_ptr; cur_right_ptr = temp; &#125; &#125; //这里cur_left_ptr必定为空, cur_right_ptr必定不为空,work_stack必不为空 cur_ptr = cur_right_ptr; &#125; while (work_stack.empty() == false) //自底向上合并左式堆 &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr = cur_ptr; //当前合并结果链接至上一层在向下分解合并操作时根节点值较小的左式堆根节点右指针域 if (work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr == nullptr || cur_ptr-&gt;zero_road_length &gt; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr-&gt;zero_road_length) //交换左右子树恢复左式堆性质 &#123; swap(work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;left_node_ptr, work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;right_node_ptr); &#125; else &#123; work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in-&gt;zero_road_length = cur_ptr-&gt;zero_road_length + 1; //右子树零路径长度可能减小，故需更新根节点零路径长 &#125; cur_ptr = work_stack.top().left_ptr_to_heap_be_merged_sub_tree_in; work_stack.pop(); &#125; root = cur_ptr;&#125;template &lt;typename T&gt;int Searchd(LeftIstHeapNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right_node_ptr == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left_node_ptr != nullptr) return 1; else &#123; if (ptr-&gt;right_node_ptr != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void adjustUntilRoot(stack&lt;StackNodeInfo&lt;T&gt;&gt;&amp; work_stack) //向上调整，恢复左式堆性质，指导根节点&#123; while (work_stack.empty() == false) //循环不变式,每一轮循环开始时,栈顶节点按direction方向指向的子节点的零路径长一定减小，循环过程中该不变式一直维持 &#123; if (work_stack.top().direction == 1) //循环过程中break是因为栈顶节点的零路径长度不变，没有必要继续向根节点调整 &#123; if (work_stack.top().p-&gt;left_node_ptr != nullptr) &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr &amp;&amp; work_stack.top().p-&gt;left_node_ptr-&gt;zero_road_length &lt; work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; else &#123; break; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr != nullptr) &#123; swap(work_stack.top().p-&gt;left_node_ptr, work_stack.top().p-&gt;right_node_ptr); work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (work_stack.top().p-&gt;right_node_ptr == nullptr) &#123; work_stack.top().p-&gt;zero_road_length = 0; &#125; else &#123; work_stack.top().p-&gt;zero_road_length = work_stack.top().p-&gt;right_node_ptr-&gt;zero_road_length + 1; &#125; &#125; work_stack.pop(); &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::changeNodeValue(LeftIstHeapNode&lt;T&gt; *bechanged, T *change_value, stack&lt;StackNodeInfo&lt;T&gt;&gt; &amp;work_stack)&#123; if (*(bechanged-&gt;data_field) == *change_value) &#123; return; &#125; if (*(bechanged-&gt;data_field) &lt; *change_value) &#123; *(bechanged-&gt;data_field) = *change_value; if ((bechanged-&gt;left_node_ptr == nullptr || *(bechanged-&gt;left_node_ptr-&gt;data_field) &gt;= *change_value) &amp;&amp; (bechanged-&gt;right_node_ptr == nullptr || *(bechanged-&gt;right_node_ptr-&gt;data_field) &gt;= *change_value)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; LeftIstHeapNode&lt;T&gt;* left_ptr = bechanged-&gt;left_node_ptr; LeftIstHeapNode&lt;T&gt;* right_ptr = bechanged-&gt;right_node_ptr; bechanged-&gt;left_node_ptr = bechanged-&gt;right_node_ptr = nullptr; if (bechanged-&gt;zero_road_length &gt; 0) &#123; bechanged-&gt;zero_road_length = 0; adjustUntilRoot(work_stack); &#125; merge(left_ptr); merge(right_ptr); &#125; else &#123; *(bechanged-&gt;data_field) = *change_value; if (work_stack.empty() == false) &#123; if (*(work_stack.top().p-&gt;data_field) &lt;= *(bechanged-&gt;data_field)) //堆序仍然满足，无需做任何操作直接返回 &#123; return; &#125; if (work_stack.top().direction == 1) &#123; work_stack.top().p-&gt;left_node_ptr = nullptr; &#125; else &#123; work_stack.top().p-&gt;right_node_ptr = nullptr; &#125; adjustUntilRoot(work_stack); merge(bechanged); &#125; &#125;&#125;template &lt;typename T&gt;bool LeftIstHeap&lt;T&gt;::changeNodeVauleForNodeHaveSepecificValue(T* original_node_value, T* change_value) //在左式堆中搜索值为original_node_value的节点，将其更改为change_value并恢复左式堆性质&#123; LeftIstHeapNode&lt;T&gt;* cur_ptr = root; if (cur_ptr == nullptr) &#123; return false; &#125; int d = 0; stack&lt;StackNodeInfo&lt;T&gt;&gt; work_stack; while (true) &#123; if (Searchd(cur_ptr, d) == 0) &#123; if (cur_ptr == root) &#123; if (d == 0) &#123; if (*(root-&gt;data_field) == *original_node_value) &#123; changeNodeValue(root, change_value, work_stack); return true; &#125; else &#123; return false; &#125; &#125; else &#123; return false; &#125; &#125; else &#123; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; &#125; else &#123; work_stack.pop(); &#125; cur_ptr = work_stack.top().p; d = work_stack.top().direction; &#125; &#125; else &#123; LeftIstHeapNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (*(cur_ptr-&gt;data_field) &gt; *original_node_value) //original_node_value小于当前节点值，无需向当前节点及其子树搜索，直接回溯至上一层 &#123; if (work_stack.empty() == true) //original_node_value小于左式堆最小值，搜索失败 return false; cur_ptr = work_stack.top().p; d = work_stack.top().direction; continue; &#125; else if (*(cur_ptr-&gt;data_field) == *original_node_value) &#123; changeNodeValue(cur_ptr, change_value, work_stack); return true; &#125; work_stack.push(StackNodeInfo&lt;T&gt;(cur_ptr, Searchd(cur_ptr, d))); //original_node_value大于当前节点值，继续向当前节点子树搜索 if (work_stack.top().direction == 1) interval = cur_ptr-&gt;left_node_ptr; else interval = cur_ptr-&gt;right_node_ptr; &#125; else &#123; work_stack.top().direction = 2; interval = cur_ptr-&gt;right_node_ptr; &#125; d = 0; cur_ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void LeftIstHeap&lt;T&gt;::insert(T* data)&#123; LeftIstHeapNode&lt;T&gt;* ptr = new LeftIstHeapNode&lt;T&gt;(data); merge(ptr);&#125;template &lt;typename T&gt;T* LeftIstHeap&lt;T&gt;::removeMinValue()&#123; T* data = new T(*(root-&gt;data_field)); LeftIstHeapNode&lt;T&gt;* ptr_right = root-&gt;right_node_ptr; LeftIstHeapNode&lt;T&gt;* ptr_left = root-&gt;left_node_ptr; delete root; root = ptr_left; merge(ptr_right); return data;&#125;template &lt;typename T&gt;JudgeResult LeftIstHeap&lt;T&gt;::isLeftIstHeap(LeftIstHeapNode&lt;T&gt; *root) //判断以root为根的二叉树是否为左式堆&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; long long zero_road_length = -1; if (root-&gt;left_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;left_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;left_node_ptr-&gt;data_field)) &#123; zero_road_length = temp.zero_road_length; &#125; else &#123; result.isLeftIstHeap = false; return result; &#125; &#125; if (root-&gt;right_node_ptr != nullptr) &#123; JudgeResult temp = isLeftIstHeap(root-&gt;right_node_ptr); if (temp.isLeftIstHeap &amp;&amp; *(root-&gt;data_field) &lt;= *(root-&gt;right_node_ptr-&gt;data_field) &amp;&amp; zero_road_length &gt;= temp.zero_road_length) &#123; result.zero_road_length = temp.zero_road_length + 1; &#125; else &#123; result.isLeftIstHeap = false; &#125; &#125; else &#123; result.zero_road_length = 0; &#125; return result;&#125;int main()&#123; LeftIstHeap&lt;int&gt; test_obj; vector&lt;int&gt; input = &#123; 5, 6, 3, 1, 8, 4, 6, 12, 67, 34, 76, 32, 17, 45, 89, 26&#125;; for (const int&amp; i : input) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; while (test_obj.empty() == false) &#123; shared_ptr&lt;int&gt; min_value(test_obj.removeMinValue()); cout &lt;&lt; "删除左式堆中最小关键码" &lt;&lt; *min_value &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "左式堆为空" &lt;&lt; endl; cout &lt;&lt; endl; vector&lt;int&gt; input2 = &#123; 9, 4, 12, 1, 8, 6, 6, 13, 45, 23 &#125;; for (const int&amp; i : input2) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; test_obj.insert(new int(i)); &#125; cout &lt;&lt; "将左式堆中各元素增加到最大值前左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()) &lt;&lt; endl; cout &lt;&lt; endl; int* t = new int(45); for (int&amp; i : input2) &#123; cout &lt;&lt; "将左式堆中关键码" &lt;&lt; i &lt;&lt; "增大为" &lt;&lt; 45 &lt;&lt; endl; cout &lt;&lt; endl; test_obj.changeNodeVauleForNodeHaveSepecificValue(&amp;i, t); if (test_obj.satisfyLeftIstHeapNature()) &#123; cout &lt;&lt; "当前树为左式堆" &lt;&lt; endl; cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不为左式堆" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "现在左式堆的最小关键码为" &lt;&lt; *(test_obj.getMinValue()); return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>左式堆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伸展树实现]]></title>
    <url>%2Fpost%2F7bf4fbbc.html</url>
    <content type="text"><![CDATA[伸展树是一种根据节点访问频率调整树结构的自平衡树，当对数据的访问遵循局部性原理时，使用伸展树具有较高的效率。伸展树的展开操作中每一步分为单旋转，之字形旋转(异构),和一字形旋转，旋转操作会反复进行直到被调整节点上升到树根为止。有关伸展树的知识和伸展树的相关介绍请参看数据结构教材，本文的目的不是详细介绍伸展树，而是只给出伸展树的实现 C++代码:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;struct JudgeResult //对二叉树的判断结果&#123; bool isBST = true; //是否为二叉搜索树 int max_value_in_BST = 0; //二叉搜索树中最大节点值 int min_value_in_BST = 0; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;struct SplayTreeNode //伸展树节点定义&#123; T data; SplayTreeNode* left_child = nullptr; SplayTreeNode* right_child = nullptr; SplayTreeNode(const T&amp; d) :data(d) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先左后右双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; SplayTreeNode&lt;T&gt;* q = p-&gt;right_child; p-&gt;right_child = q-&gt;left_child; q-&gt;left_child = p; ptr-&gt;left_child = q-&gt;right_child; q-&gt;right_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行先右后左双旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; SplayTreeNode&lt;T&gt;* q = p-&gt;left_child; p-&gt;left_child = q-&gt;right_child; q-&gt;right_child = p; ptr-&gt;right_child = q-&gt;left_child; q-&gt;left_child = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(SplayTreeNode&lt;T&gt;* ptr) //对以ptr为根的子树执行右单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(SplayTreeNode&lt;T&gt;* ptr) ////对以ptr为根的子树执行左单旋转&#123; SplayTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;class SplayTree&#123;public: SplayTreeNode&lt;T&gt;* search(const T &amp;key); //伸展树中搜索关键码 T getRootValue() &#123; return root-&gt;data; &#125; bool isEmpty() &#123; return root == nullptr; &#125; bool insert(const T&amp; key); //伸展树中插入关键码 bool remove(const T&amp; key); //伸展树中移除关键码 bool curTreeIsBST() &#123; return isBST(root).isBST; &#125; void outputInorderSeq() &#123; if (root == nullptr) &#123; cout &lt;&lt; "NULL"; return; &#125; inorderTraversal(root); &#125; //打印伸展树中序序列 SplayTree() = default; ~SplayTree() &#123; destoryTree(root); &#125;private: JudgeResult isBST(SplayTreeNode&lt;T&gt;* root); void inorderTraversal(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; inorderTraversal(root-&gt;left_child); cout &lt;&lt; root-&gt;data &lt;&lt; " "; inorderTraversal(root-&gt;right_child); &#125; &#125; void destoryTree(SplayTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destoryTree(root-&gt;left_child); destoryTree(root-&gt;right_child); delete root; &#125; &#125; void adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt;&amp; work_stack); //从cur节点开始反复旋转，直到将cur调整至根节点 SplayTreeNode&lt;T&gt;* root = nullptr; //伸展树根节点&#125;;template &lt;typename T&gt;JudgeResult SplayTree&lt;T&gt;::isBST(SplayTreeNode&lt;T&gt;* root) //判断二叉树是否为二叉搜索树&#123; if (root == nullptr) &#123; return JudgeResult(); &#125; JudgeResult result; if (root-&gt;left_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;left_child); if (temp.isBST == true &amp;&amp; temp.max_value_in_BST &lt; root-&gt;data) &#123; result.min_value_in_BST = temp.min_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.min_value_in_BST = root-&gt;data; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult temp = isBST(root-&gt;right_child); if (temp.isBST == true &amp;&amp; temp.min_value_in_BST &gt; root-&gt;data) &#123; result.max_value_in_BST = temp.max_value_in_BST; &#125; else &#123; result.isBST = false; &#125; &#125; else &#123; result.max_value_in_BST = root-&gt;data; &#125; return result;&#125;template &lt;typename T&gt;SplayTreeNode&lt;T&gt;* SplayTree&lt;T&gt;::search(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; return nullptr; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; adjustUntilRoot(cur, work_stack); return root; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; return nullptr;&#125;template &lt;typename T&gt;void SplayTree&lt;T&gt;::adjustUntilRoot(SplayTreeNode&lt;T&gt;* cur, stack&lt;SplayTreeNode&lt;T&gt;*&gt; &amp;work_stack)&#123; while (work_stack.empty() == false) &#123; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); if (work_stack.empty() == true) &#123; if (p-&gt;left_child == cur) &#123; RotateR(p); &#125; else &#123; RotateL(p); &#125; &#125; else &#123; SplayTreeNode&lt;T&gt;* q = work_stack.top(); work_stack.pop(); if (p-&gt;left_child == cur) &#123; if (q-&gt;left_child == p) &#123; RotateR(q); //一字形旋转 RotateR(p); &#125; else &#123; RotateRL(q); //之字形旋转 &#125; &#125; else &#123; if (q-&gt;left_child == p) &#123; RotateLR(q); //之字形旋转 &#125; else &#123; RotateL(q); //一字形旋转 RotateL(p); &#125; &#125; if (work_stack.empty() == false) //与上层重新连接 &#123; if (work_stack.top()-&gt;left_child == q) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; &#125; &#125; root = cur;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::insert(const T&amp; key)&#123; SplayTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new SplayTreeNode&lt;T&gt;(key); return true; &#125; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; return false; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (key &lt; work_stack.top()-&gt;data) &#123; cur = work_stack.top()-&gt;left_child = new SplayTreeNode&lt;T&gt;(key); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new SplayTreeNode&lt;T&gt;(key); &#125; adjustUntilRoot(cur, work_stack); return true;&#125;template &lt;typename T&gt;bool SplayTree&lt;T&gt;::remove(const T&amp; key) //从伸展树中移除节点后，如果中序序列中该节点存在后继节点，则把后继节点调整至树根，否则如果存在前驱节点，则把前驱节点调整至树根，否则直接删除该节点&#123; SplayTreeNode&lt;T&gt;* cur = root; stack&lt;SplayTreeNode&lt;T&gt;*&gt; work_stack; while (cur != nullptr) &#123; if (cur-&gt;data == key) &#123; break; &#125; work_stack.push(cur); if (key &lt; cur-&gt;data) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; if (cur-&gt;left_child != nullptr) &#123; if (cur-&gt;right_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* p = cur-&gt;right_child; if (p-&gt;left_child != nullptr) &#123; SplayTreeNode&lt;T&gt;* parent = nullptr; while (p-&gt;left_child != nullptr) &#123; parent = p; p = p-&gt;left_child; &#125; parent-&gt;left_child = p-&gt;right_child; &#125; else &#123; p-&gt;right_child = cur-&gt;right_child; &#125; cur-&gt;data = p-&gt;data; delete p; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;left_child; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;left_child; SplayTreeNode&lt;T&gt;* p = work_stack.top(); work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; temp_stack.push(cur-&gt;left_child); delete cur; cur = temp_stack.top(); temp_stack.pop(); while (cur-&gt;right_child != nullptr) &#123; temp_stack.push(cur); cur = cur-&gt;right_child; &#125; &#125; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; else &#123; root = cur-&gt;left_child; delete cur; cur = root; &#125; &#125; &#125; else &#123; if (cur-&gt;right_child != nullptr) &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;left_child; &#125; else &#123; work_stack.top()-&gt;right_child = cur-&gt;right_child; delete cur; cur = work_stack.top()-&gt;right_child; &#125; while (cur-&gt;left_child != nullptr) &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;right_child; delete cur; cur = root; &#125; &#125; else &#123; if (work_stack.empty() == false) &#123; if (cur == work_stack.top()-&gt;left_child) &#123; work_stack.top()-&gt;left_child = nullptr; delete cur; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; work_stack.top()-&gt;right_child = nullptr; delete cur; SplayTreeNode&lt;T&gt;* p = work_stack.top(); cur = p; work_stack.pop(); stack&lt;SplayTreeNode&lt;T&gt;*&gt; temp_stack(work_stack); while (work_stack.empty() == false) // 寻找原cur在中序序列中的后继节点 &#123; if (work_stack.top()-&gt;left_child == p) &#123; break; &#125; p = work_stack.top(); work_stack.pop(); &#125; if (work_stack.empty() == false) &#123; cur = work_stack.top(); work_stack.pop(); &#125; else &#123; adjustUntilRoot(cur, temp_stack); return true; &#125; &#125; &#125; else &#123; delete cur; cur = root = nullptr; &#125; &#125; &#125; adjustUntilRoot(cur, work_stack); return true;&#125;int main()&#123; SplayTree&lt;int&gt; test_obj; vector&lt;int&gt; test_data&#123;89, 23, 1, 5, 78, 45, 16, 99, 34, 56&#125;; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "插入关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.insert(i)) &#123; cout &lt;&lt; "插入成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "插入失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; for (const int &amp;i : test_data) &#123; cout &lt;&lt; "删除关键码" &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; endl; if (test_obj.remove(i)) &#123; cout &lt;&lt; "删除成功" &lt;&lt; endl; if (test_obj.curTreeIsBST()) &#123; cout &lt;&lt; "当前树是二叉搜索树" &lt;&lt; endl; cout &lt;&lt; "根节点关键码"; if (test_obj.isEmpty()) &#123; cout &lt;&lt; "NULL" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; test_obj.getRootValue() &lt;&lt; endl; &#125; cout &lt;&lt; "中序序列为"; test_obj.outputInorderSeq(); cout &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "ERROR:当前树不是二叉搜索树" &lt;&lt; endl; exit(-1); &#125; &#125; else &#123; cout &lt;&lt; "删除失败" &lt;&lt; endl; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>伸展树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于优先级的车间作业调度算法实现]]></title>
    <url>%2Fpost%2F2e81f00.html</url>
    <content type="text"><![CDATA[本文内容为个人知识产权,请输入密码查看文章 密码错误!拒绝访问 无可展示内容! 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]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>车间作业调度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树和2-3-4树的相互转换]]></title>
    <url>%2Fpost%2F60217.html</url>
    <content type="text"><![CDATA[&nbsp;由于红黑树的每一处结构都能唯一的转换为2-3-4树(即4阶B树)中对应的结构因此每一棵红黑树都唯一对应一棵2-3-4树，但反之，对应于只有两个关键码的2-3-4树节点的2-3-4树结构能够转换为两种不同的红黑树结构(两个关键码左边为红黑树中黑色节点，右边为红色节点或相反)，所以一般情况下对于一棵2-3-4树，往往有多棵红黑树与之对应。本文要介绍的就是将红黑树转换为2-3-4树或将2-3-4树转换为与之对应的多棵红黑树的算法。算法的基本思想是后序遍历红黑树或2-3-4树，自底向下将每一种红黑树(2-3-4树)构造转换为与之对应的2-3-4树(红黑树)构造，转换构造的过程中需要使用自底向下的过程中已经完成转换的构造，并把这些构造进行组合以生成新的高层构造，该过程会一直持续到红黑树或2-3-4树的根节点。 由于红黑树对应的2-3-4树中总是把黑色节点的红色子节点提升到和黑色节点同一层的同一个2-3-4树节点中，而由红黑树的特性，红色节点没有红色子节点，这就使得在2-3-4树中，红黑树从根节点到叶节点任意一条路径上的单个红色节点都被压缩到了上一层的黑色父节点上，这意味着与红黑树对应的2-3-4树高度(不包括失败节点)恰为红黑树的黑高度(红黑树任意一条从根节点到外节点的路径上黑色节点总数)。此外，以下算法还可以保证红黑树转换所得的2-3-4树满足4阶B树的所有特性,由2-3-4树转换所得红黑树也满足红黑树的所有特性，要证明一点只要从下至上使用归纳法，证明在低层转换构造满足2-3-4树或红黑树的某些特性的情况下由低层构造生成的高层构造同样满足这些特性，证明会一直持续到红黑树或2-3-4树根节点，从而确定转换所得树确实满足红黑树和2-3-4树的所有要求。证明是简单的，机械的，这里就不详细说明了。 用归纳法可以自底向上证明如果2-3-4树对应多棵红黑树，则算法转换得到的红黑树必两两不同，因此无需剔除重复的红黑树 将红黑树的插入与删除 以及B树的插入与删除 这两篇文章中的代码中的main函数部分删除，并去掉不相关的函数，就可得到以下代码中头文件RBTree.h和BTree.h中的内容 C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;#include "RBTree.h"#include "BTree.h"enum class Type &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RedSubTreeInfo&#123; RBTreeNode&lt;T&gt; *RedNode_ptr = nullptr; //红黑树红色节点指针 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_left = nullptr; //红色节点左子树转换生成的2-3-4树构造 BTreeNode&lt;T&gt; *partBTreeForBlackSubTree_right = nullptr; //红色节点右子树转换生成的2-3-4树构造 RedSubTreeInfo(RBTreeNode&lt;T&gt; *R, BTreeNode&lt;T&gt; *pl, BTreeNode&lt;T&gt; *pr) :RedNode_ptr(R), partBTreeForBlackSubTree_left(pl), partBTreeForBlackSubTree_right(pr) &#123;&#125;&#125;;template &lt;typename T&gt;struct SubTreeInfo //红黑树某节点的低层2-3-4树构造信息&#123; Type id; //该构造对应红黑树红色节点还是黑色节点 union &#123; RedSubTreeInfo&lt;T&gt; red_sub_tree_info; //红色节点对应的2-3-4树构造 BTreeNode&lt;T&gt;* partBTreeForBlackSubTree; //黑色节点对应的2-3-4树构造 &#125;; SubTreeInfo(Type t, BTreeNode&lt;T&gt;* p) : id(t), partBTreeForBlackSubTree(p) &#123;&#125; SubTreeInfo(Type t, RBTreeNode&lt;T&gt;* R, BTreeNode&lt;T&gt;* pl, BTreeNode&lt;T&gt;* pr):id(t) &#123; new (&amp;red_sub_tree_info) RedSubTreeInfo&lt;T&gt;(R, pl, pr); &#125; ~SubTreeInfo() &#123; if (id == Type::RED) &#123; red_sub_tree_info.~RedSubTreeInfo(); &#125; &#125;&#125;;template &lt;typename T&gt;vector&lt;RBTreeNode&lt;T&gt;*&gt;* BTreeToRBTree(BTreeNode&lt;T&gt; *root) //将2-3-4树转换为与之对应的所有红黑树&#123; struct memory &#123; BTreeNode&lt;T&gt;* p; //遍历2-3-4树时对应层节点指针 pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; direction; //遍历时在该层的前进方向(此时正在向下遍历那一棵2-3-4子树) vector&lt;vector&lt;RBTreeNode&lt;T&gt; *&gt;&gt; RBTreeForEverySubTree; //存放2-3-4树节点的每一个子节点对应的所有红黑树构造 size_t index = 0; //当前需要生成红黑树构造的子节点对应的RBTreeForEverySubTree下标 memory(BTreeNode&lt;T&gt;* p, const pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d), RBTreeForEverySubTree(p-&gt;keyptrmap.size()+1, vector&lt;RBTreeNode&lt;T&gt;*&gt;())&#123;&#125; &#125;; vector&lt;RBTreeNode&lt;T&gt;*&gt; *AllRBTreeForBTree = new vector&lt;RBTreeNode&lt;T&gt;*&gt;; //存放当前2-3-4树对应的所有红黑树 BTreeNode&lt;T&gt;* ptr = root; pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt; d(ptr-&gt;keyptrmap.end(), true); BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (SerachBTreeNode(ptr, d) == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator it = ptr-&gt;keyptrmap.begin(); if (d == pair&lt;map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) //生成2-3-4树叶节点对应的红黑树构造，若该叶节点不为根节点 &#123; //则把构造信息传递至上层节点，若为根节点，直接返回2-3-4树对应的所有红黑树 RBTreeNode&lt;T&gt;* temp = nullptr; if (ptr-&gt;keyptrmap.size() == 1) //节点只有一个关键码，生成单一黑节点构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); &#125; else if (ptr-&gt;keyptrmap.size() == 2) //两个关键码，生成红-黑或黑-红构造 &#123; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); &#125; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; else if (ptr-&gt;keyptrmap.size() == 3) //三个关键码，生成红-黑-红构造 &#123; ++it; temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); &#125; if (ptr == dest) &#123; (*(AllRBTreeForBTree)).push_back(temp); return AllRBTreeForBTree; &#125; else &#123; arrange.top().RBTreeForEverySubTree[arrange.top().index].push_back(temp); //本层节点对应构造传递至上层节点,若该分支节点不为根节点 &#125; //则把构造信息传递至上层节点，若为根节点直接返回根节点对应红黑树构造 &#125; else &#123; vector&lt;RBTreeNode&lt;T&gt;*&gt; *RBTreePtr = new vector&lt;RBTreeNode&lt;T&gt;*&gt;(); //生成2-3-4树分支节点对应红黑树构造 if (ptr-&gt;keyptrmap.size() == 1) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 2) //同上 &#123; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; ++it; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); temp-&gt;right = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; else if (ptr-&gt;keyptrmap.size() == 3) //同上 &#123; ++it; for (size_t q = 0; q != arrange.top().RBTreeForEverySubTree[0].size(); ++q) &#123; for (size_t p = 0; p != arrange.top().RBTreeForEverySubTree[1].size(); ++p) &#123; for (size_t m = 0; m != arrange.top().RBTreeForEverySubTree[2].size(); ++m) &#123; for (size_t v = 0; v != arrange.top().RBTreeForEverySubTree[3].size(); ++v) &#123; RBTreeNode&lt;T&gt;* temp = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::BLACK); --it; temp-&gt;left = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); ++it; ++it; temp-&gt;right = new RBTreeNode&lt;T&gt;(it-&gt;first, ColorFlag::RED); --it; temp-&gt;left-&gt;left = arrange.top().RBTreeForEverySubTree[0][q]; temp-&gt;left-&gt;right = arrange.top().RBTreeForEverySubTree[1][p]; temp-&gt;right-&gt;left = arrange.top().RBTreeForEverySubTree[2][m]; temp-&gt;right-&gt;right = arrange.top().RBTreeForEverySubTree[3][v]; RBTreePtr-&gt;push_back(temp); &#125; &#125; &#125; &#125; &#125; arrange.pop(); if (arrange.empty() == true) &#123; return RBTreePtr; &#125; arrange.top().RBTreeForEverySubTree[arrange.top().index] = *RBTreePtr; delete RBTreePtr; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; else &#123; BTreeNode&lt;T&gt; *interval = nullptr; if (d == pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true)) &#123; arrange.push(memory(ptr, SerachBTreeNode(ptr, d))); interval = ptr-&gt;p; &#125; else &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator temp = SerachBTreeNode(ptr, d).first; arrange.top().direction = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(temp, true); ++(arrange.top().index); interval = temp-&gt;second; &#125; ptr = interval; d = pair&lt;typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator, bool&gt;(ptr-&gt;keyptrmap.end(), true); &#125; &#125;&#125;template &lt;typename T&gt;struct StackNode&#123; RBTreeNode&lt;T&gt;* ptr = nullptr; //每一层红黑树节点指针 int direction = 0; SubTreeInfo&lt;T&gt; *left_sub = nullptr; //左子树2-3-4树构造 SubTreeInfo&lt;T&gt; *right_sub = nullptr; //右子树2-3-4树构造 StackNode(RBTreeNode&lt;T&gt;* p, int d) :ptr(p), direction(d) &#123;&#125; ~StackNode() &#123; delete left_sub; delete right_sub; &#125;&#125;;template &lt;typename T&gt;BTreeNode&lt;T&gt; *RBTreeToBTree(RBTreeNode&lt;T&gt; *root) //将红黑树转换为对应2-3-4树&#123; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;StackNode&lt;T&gt;&gt; work_stack; int d = 0; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) //根节点为叶节点，直接返回对应2-3-4树构造 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); temp_ptr-&gt;p = nullptr; return temp_ptr; &#125; &#125; if (d == 0) //非根叶节点，将叶节点转换为对应2-3-4树构造并传递至上层栈节点 &#123; if (ptr-&gt;color == ColorFlag::RED) &#123; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, nullptr, nullptr); &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; &#125; else //分支节点，可以为根节点，为根节点时生成根节点对应2-3-4树并返回，否则生成分支节点对应2-3-4树构造并传递至上层栈节点 &#123; BTreeNode&lt;T&gt;* temp_ptr = new BTreeNode&lt;T&gt;(); if (ptr-&gt;color == ColorFlag::BLACK) &#123; typename map&lt;T, BTreeNode&lt;T&gt;*&gt;::iterator itp = temp_ptr-&gt;keyptrmap.insert(make_pair(ptr-&gt;data, nullptr)).first; if (work_stack.top().left_sub == nullptr || work_stack.top().left_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().left_sub == nullptr) &#123; temp_ptr-&gt;p = nullptr; &#125; else &#123; temp_ptr-&gt;p = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().left_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); temp_ptr-&gt;p = work_stack.top().left_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; if (work_stack.top().right_sub == nullptr || work_stack.top().right_sub-&gt;id == Type::BLACK) &#123; if (work_stack.top().right_sub == nullptr) &#123; itp-&gt;second = nullptr; &#125; else &#123; itp-&gt;second = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; &#125; &#125; else &#123; temp_ptr-&gt;keyptrmap.insert(make_pair(work_stack.top().right_sub-&gt;red_sub_tree_info.RedNode_ptr-&gt;data, work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_right)); itp-&gt;second = work_stack.top().right_sub-&gt;red_sub_tree_info.partBTreeForBlackSubTree_left; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* temp1 = work_stack.top().left_sub-&gt;partBTreeForBlackSubTree; BTreeNode&lt;T&gt;* temp2 = work_stack.top().right_sub-&gt;partBTreeForBlackSubTree; work_stack.pop(); if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::RED, ptr, temp1, temp2); &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; continue; &#125; work_stack.pop(); if (work_stack.empty() == true) return temp_ptr; if (work_stack.top().direction == 1) &#123; work_stack.top().left_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; else if (work_stack.top().direction == 2) &#123; work_stack.top().right_sub = new SubTreeInfo&lt;T&gt;(Type::BLACK, temp_ptr); &#125; &#125; ptr = work_stack.top().ptr; d = work_stack.top().direction; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; work_stack.push(StackNode&lt;T&gt;(ptr, Searchd(ptr, d))); if (work_stack.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; work_stack.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main() //测试main函数&#123; vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) //插入建立红黑树 &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; &#125; cout &lt;&lt; endl; BTreeNode&lt;TYPE&gt;* t = RBTreeToBTree(root); //红黑树转换为2-3-4树 cout &lt;&lt; "已将红黑树转换为对应2-3-4树" &lt;&lt; endl; vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;* v = BTreeToRBTree(t); //2-3-4树转换为对应所有红黑树 cout &lt;&lt; "已将2-3-4树转换为其对应的所有红黑树" &lt;&lt; endl; for (vector&lt;RBTreeNode&lt;TYPE&gt;*&gt;::iterator m = v-&gt;begin(); m != v-&gt;end(); ++m) //判断转换所得树是否满足红黑树所有特性 &#123; if (!isRB(*m)) &#123; cout &lt;&lt; "2-3-4到红黑树转换错误" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; "2-3-4树到红黑树转换正确!" &lt;&lt; endl; cout &lt;&lt; "转换后的红黑树共有" &lt;&lt; v-&gt;size() &lt;&lt; "棵"; delete v; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树,B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对Tarjan LCA算法的理解]]></title>
    <url>%2Fpost%2F53168.html</url>
    <content type="text"><![CDATA[这个算法也是我想了一段时间后才理解的，不得不承认Tarjan非常聪明，算法很简单但设计得极为巧妙 首先总结一下算法的执行过程： 首先读入所有的询问关系(u,v)(即要求LCA的树节点对u,v)保存在某种数据结构里，然后初始化并查集，每个树节点自成一个单元素集合，最后将每一个树节点的visited标志位置为false(表示该节点尚未访问) 接着对树进行后根次序遍历,每当对以一个树节点u的每一个子女节点v为根的子树后根遍历完成后，将并查集中以该子女节点v为根的集合(该集合包含了以该子女节点v为根的子树中的所有节点)并入并查集中以u为根的集合中(并入前该集合包含了u和以v之前所有子女节点为根的子树中的所有节点) 当后根遍历完以u的所有子女节点v为根的子树并回溯至u本身后,将u的visited置true(表示已访问)，然后，查找包含u的询问关系(u,i)或(i,u)，如果没有这样的询问关系，什么都不做进行最后一步，如果有这样的询问关系(u,i)或(i,u),检查i的visited标志位,如果该标志位为false，什么也不做,进行最后一步,如果为true,查找并查集中i所在集合的根节点L,L即为u和i的LCA。最后一步,如果u有父节点k，将以u为根的集合并入以k为根的集合中。 接着继续后根遍历u的后继结点 当整棵树后根遍历完成后，所有询问关系的LCA就全部求出了，算法结束 下面说明一下为什么该算法能够求出某个询问关系(u,v)的LCA,设(u,v)的LCA为T,u在以T的某个子女节点为根的子树T1中,v在以T的某个子女节点为根的子树T2中,如果T1在T2的左侧，那么在后根遍历中当我回溯到u时，按后根遍历的次序，此时T2所有节点均未被访问，v的visited为false,T2的所有节点(包括v)都自成一个单元素集合，因此此时从v所在的集合中无法得出LCA的任何信息,故什么都不做，继续后根遍历。当回溯到v时，按后根遍历的访问顺序,u的visited为true,且根据算法的执行过程,以T1根节点为根的集合(它包括了T1中所有的节点)已经被并入了以u,v的LCA为根的集合中，而按后根遍历的访问顺序，此时尚未回溯到LCA的祖先节点，所以以u,v的LCA为根的集合没有并入以LCA祖先节点为根的集合，这就意味着T1中节点u所在集合的根节点就是u,v的LCA，所以对u执行查找并查集中u所在结合的根节点的操作find(u)所得的结果就是u,v的LCA T1在T2右侧的情形可类似讨论 如果u为v的祖先，采用和以上分析类似的思想,回溯到v时，显然尚未回溯至u,u的visited为false,设以u的某个子女节点为根的子树为T,v在T中,按照后根遍历次序和算法的执行过程,算法只把T左侧的以u的某一个子女节点为根的子树的根代表的集合(包含了以该子女节点为根的子树的所有节点)并入以u为根的集合,并且以u为根的结合尚未并入以u祖父节点为根的集合，此时find(u) = u,是u,v的LCA,但在算法中无法判断u,v的祖先后代关系，为保证操作的统一性(和u,v不是祖先后代关系的情形相适应)，这里什么都不做.当回溯到u时，按后根遍历次序,v的visited为true，此时以u为根的集合包含了以u为根的子树的所有节点(包括v)，并且根据算法的执行过程，此时以u为根的集合尚未并入以u祖父节点为根的集合中，这意味着find(v)=u,即为u,v的LCA v为u的祖先的讨论是类似的 该算法设计得极为精妙，是巧妙运用并查集和DFS的经典范例，值得学习，总之Tarjan太强啦]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最近公共祖先</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于求无向连通图割点的Tarjan算法的一点说明]]></title>
    <url>%2Fpost%2F57832.html</url>
    <content type="text"><![CDATA[Tarjan算法中的数组dfn[],即为图中各顶点的深度优先数，即各顶点在DFS过程中被访问的次序 low[]数组，图中顶点v的low[v]应理解为dfn[v],v通过回边(DFS树中由后代节点指向祖先节点的非树边)所能到达的DFS树中v的祖先的深度优先数以及DFS树中v的后代节点通过回边所能到达的DFS树中它们的祖先的深度优先数中的最小值 另外DFS中如果现在访问顶点V,接着我们访问DFS树中V的各个子女节点，如果我现在试图访问与V邻接的顶点U，但是发现U已经被访问过了，那么对U而言有如下三种情形： (1)我们正在访问U，并没有访问完U在DFS树中所有子女节点并回溯到U结束对U的访问。根据图的深度优先遍历的特点，由于我现在结束对DFS树中V在U之前的某个未被访问子女节点的访问(注意，由于U已经被访问，故U并非DFS树中V的子女节点)并回溯到V或对V在U之前的所有邻接顶点的访问都失败了(它们都已经被访问) ,然后再访问U，那么毫无疑问的，V在DFS树上所有的祖先节点就是当前除V以外正在被访问的所有节点，但U和V显然不是同一个顶点，故U就是V在DFS树上的祖先 (2)之前在DFS的过程中已经回溯到U,并结束对U的访问，但当我回溯到U时顶点V尚未被访问。根据深度优先遍历的访问次序，此时若U是V的祖先，当我回溯到U时V显然已经被访问过了，矛盾。若V是U的祖先，当我回溯到U时顶点V正在被访问，当然访问过了，同样矛盾。故U，V之间不可能是祖先后代关系。于是设U，V在DFS树中的最近公共祖先(LCA)为L,U在DFS树中以L的子女节点M1为根的子树T1中，V在DFS树中以L的子女节点M2为根的子树T2中，若T1在T2右侧，则根据DFS遍历顺序，回溯至U时V显然已被访问，矛盾。于是T1只能在T2左侧。当然此时无向边(u,v)不可能是回边 (3)之前在DFS的过程中已经回溯到U,并结束对U的访问,但当我回溯到U时顶点V已经被访问，注意我们当前正在访问在DFS树中深度最深的顶点V，并试图访问顶点U，也就是说回溯到U的时间点必然在此之前，但回溯到U时V已经被访问，故回溯到U的时间点必然在V被首次访问之后，这意味着当回溯到U时，V一定正在被访问，事实上我们正在访问以DFS树中V的某个子女节点为根的V的子树T，而U就在T中，于是显然的，DFS树中V是U的祖先，对V而言无向边(V,U)不是回边 综上，DFS中，当首次访问一个节点V时把V入栈，回溯至节点V并结束对V的访问时出栈，那么如果正在访问V，并即将尝试访问与V邻接的下一个顶点U，而尝试访问U时U已经被访问，由情形(1)U是V在DFS树中的祖先,而U正在被访问，尚未回溯到U并退出，由前述入栈出栈方法，U一定在栈中而未出栈，故U在栈中。由情形(2)U已被出栈，故U不在栈中，由情形(3)V是U的祖先，而回溯至U的时间点必然在从顶点V尝试访问邻接顶点U之前，故U必定已经出栈因而不在栈中 所以，尝试访问U时，若U不在栈中则对V而言(V,U)不是回边,若U在栈中，则U是V在DFS树上的祖先，此时对V而言，(V,U)可能是回边也可能不是回边，注意此时V在栈顶，如果栈顶之下的第一个节点就是U，则(V,U)为DFS树上的一条边，不是回边，否则(V,U)必然是一条回边 由此再根据low数组的定义总结出Tarjan算法中求low[] dfn[]数组的算法如下： 从无向连通图G的某一顶点出发深度优先遍历，首次访问顶点V时，将V的visited修改为TRUE(表示已访问),并将V入栈,为V分配dfn[V]值，置low[V]=dfn[V]，然后依次访问V的各个邻接顶点U，对每一个邻接顶点U，若U尚未被访问，则对U递归DFS(这一步相当于递归地求DFS树上子女节点的low值)，从U退出后更新low[V]=min(low[V],low[U]),若U已被访问，检查U是否在栈中，若U不在栈中什么都不做，继续访问下一个邻接顶点，否则检查栈中的V的下方第一个节点是否是U，若是，什么都不做，继续访问下一个邻接顶点，否则更新low[V] = min(low[V],dfn[U]) 所有的邻接顶点都访问完后，出栈 当回溯至 遍历的开始顶点并结束对该顶点的访问时，DFS结束，算法同样结束]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>无向图，割点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[破环法(破圈法)求最小生成树算法正确性证明]]></title>
    <url>%2Fpost%2F5146.html</url>
    <content type="text"><![CDATA[所谓破环法(破圈法)是指对 于一个每一条环上权值均不相同的无向连通图，若图中有环，则删掉环上权重最大的边。如果由此得到的新图仍然有环，再删掉环上权值最大的边，如此不断进行下去，直到图中无环为止，此时的图即为原图的最小生成树 PS:该破圈法来自于2020年王道数据结构考研单科书p223,书上证明太简略，实在看不懂，于是自己思考了一下证明方法，给出如下证明 定理一：每一条环上权值均不相同的无向连通图G的任意环上权值最大的边一定不在它的最小生成树中 证明：假如某一环R上权值最大的边E在G的最小生成树T中,在T中去掉E得到两个连通分支T1,T2,E的两端分别位于T1,T2中，我们断言，环R上从E的一个端点出发不经过E抵达E的另一个端点的路径L上一定存在这样一条边E’,E’的两个端点分别位于T1,T2中，假如不是这样，L上与E的一端关联的边(u1,u2)(u1与E的一端关联)的两个端点u1,u2均位于T1，T2中相同的连通分支中,L与u2关联的边(u2,u3)的两个端点v2,u3均位于T1，T2中相同的连通分支中,(u3,u4)也是如此，以此类推知L上与E与u1相对的另一端点um关联的边(um-1,um)的两个端点um-1,um均位于T1,T2中相同的连通分支中，故u1,um均位于T1,T2中相同的连通分支中,这和E的两个端点分别位于T1,T2中矛盾。 注意E’在R上,E为R上权值最大的边且R上边权值两两不等故E’权值小于E的权值，在T中掉E后加入E’，E’将T1，T2两个连通分支连接起来得到生成树T’= T-E+E’,T’的权值小于T的权值，这和T为最小生成树矛盾，证毕 定理二：在破圈法中，如果删除无向连通图G中某一环R上某一边E前G是连通的，那么删除E后得到的新图G’仍然是连通的 证明：超级简单 对G中任意两个不同的顶点h,k(h k)，如果h到k的某一路径上不包含R上的边E，那么在R中删除E后h,k仍有路径相连，故是连通的。否则设R=v1v2—vn,E=(vi,vi+1)1&lt;=I&lt;=n-1或(vn,v1),删除前G中顶点h有到vi(1&lt;=i&lt;=n-1)或vn的路径p1，同时有vi+1(1&lt;=i&lt;=n-1)或v1到顶点k的路径p2,删除后有h到k的路径p1-&gt;(vi,vi-1,vi-2,—,v1,vn,vn-1,—,vi+2,vi+1)Or(vn,vn-1,vn-2,—,v2,v1)-&gt;p2 故h,k之间仍然连通 证毕 定理三：在破圈法中，删除每一条环上权值均不相同的无向连通图G中某一环R上权值最大的边E前G的最小生成树和删除后得到的新图G’的最小生成树相同 证明：同样超级简单。由定理二,G’连通，故必然存在最小生成树,再由定理一，对G的任意最小生成树T,E不在T中,但T是G的极小连通子图，所以T同样是G’=G-E的极小连通子图，即生成树 T必然是G’的最小生成树，如若不然，设G’的最小生成树为T’,由于T’为G’的极小连通子图,G’为G的子图，故T’是G的极小连通子图即生成树，从而T’的权值应当大于等于T的权值，但由假设T不是G’的最小生成树，故T的权值一定大于G’的最小生成树T’的权值，这是一个矛盾，故T必然是G’的最小生成树，同样G’的最小生成树必然是G的最小生成树，因为G’是G的子图，故G’的任意最小生成树T’一定是G的生成树，假若T’不是G的最小生成树,设G的最小生成树为T’’,则T’的权值大于T’’,但由上述证明知T’’是G’的最小生成树，故应有T’’权值等于T’，矛盾，故G’的最小生成树都是G的最小生成树 证毕 定理四：在破圈法中，：每一条环上权值均不相同的无向连通图G的任意环R中权值最大的边E必然会删去 证明：假设存在G某环R上权值最大的边E在破圈法中自始至终都不会被删去，由于破圈法运行结束时没有环，所以R上必然有不为E的若干边被先后删去，设这些边按删除时间从早到晚排序为e1,e2,—,en。删除e1时，e1必然在不为R的另一环R1中，且e1是R1中权值最大的边，显然E不在R1中，否则因E的权值大于e1,这样e1不是R1中权值最大的边，矛盾。设R1与R公共边的集合为S,这里e1属于S,E不属于S。于是我们从E的两个端点沿环R沿彼此相反方向延伸，沿每一个方向延伸的过程中抵达S中某条边的端点时停止延伸，记每一个方向停止延伸时抵达的端点分别为l和r.E在R上l到r不包含S中边的路径pl上,e1在R上l到r包含S中的边的路径pr上。设pr上包含e1,e2,—,en中的边em1,em2,—,emq, pl和pr将R1分为两部分，其中有且仅有一部分包含边e1,记不包含e1的部分为路径p.我们将p和pl组合 得到新环R1’,R1’上不包含e1但包含E,E的权值大于pl上其他任意边的权值,E的权值大于e1,e1的权值大于p上任意边的权值，故E的权值大于R1’上除E外任意边的权值 考察新环R1’,如果R1’上的E最终会被删去则定理证毕，否则注意上文的p可能包含了em1,em2,—,emq中的某些边ek1,ek2,—,eks,且边{e1,e2,—,en}-{em1,em2,—,emq} = {el1,el2,—,eln-q}在pl上,故在R1’上。ek1,ek2,—,eks和el1,el2,—,eln-q会在R1’上按某种次序被先后删除,但对于R1’来说，可能还有其它会在e1被删除后被删除的边ej1,ej2,—,ejh,把ek1,ek2,—,eks, el1,el2,—,eln-q和ej1,ej2,—,ejh按删除的先后次序从早到晚排列起来得到删除序列eq1,eq2,—,eq(s+n-q+h),显然它们均不为E,然后考察R1’上对eq1删除，该过程可以重复以上对R中删除e1的讨论，最后可知删除eq1后，我们将得到新环R2’，E在R2’上且E的权值大于R2’上任意边的权值,如果R2’上的E最终会被删去则定理证毕，否则对R2’再重复上述讨论，又得到新环R3’—以此类推。 由于G中的边数目是有限的，所以这一讨论不可能无限进行下去，于是就可以断言如果E始终未被删除则当边的删除操作停止也就是破圈法结束时，E必然在删除结束后所得的结果图G’的环Rs’中，且E是Rs’中权值最大的边，这和删除操作结束后G’不存在环矛盾 这就证明了任意环上权值最大的边在破圈法中必然会被删去 定理五 破圈法运行结束后，所得的最终图T一定为生成树，且必然为执行算法前原图G的最小生成树 证法一：绕开定理 三，由 定理二，T是连通的，显然T无环，且边数为G的定点数减一，故T为生成树，如若T不是G的最小生成树，设G的最小生成树为T’,T一定有边E不在T’中，将边E加入T’中，于是T’中出现环R’且E在R’上，由定理四，E一定不是R’上权值最大的边E’(否则E会被删去，不会出现在T中)，E’在T’中，于是从T’中去除E’并加入E得到生成树T’’,T’’的权值小于T’,这和T’是G的最小生成树矛盾,故T是G的最小生成树 证法二：由证法一证明前半部分和定理三立即得到 推论：如果无向连通图G的每一条边的权值都不相同，那么G的最小生成树唯一 证明：设G的顶点数为n,若G的边数为n-1,则G本身就是它的最小生成树，若G的边数大于n-1,则G中必有环，又因为G的每一条边的权值均不相同，故G每一条环上权值均不相同，由定理三和定理五，最终图T就是G的全部最小生成树，即G的唯一最小生成树，证毕 以上是全部证明，如有错误欢迎在评论区指出]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[给定树的层次次序序列和节点度数创建子女右兄弟链表示]]></title>
    <url>%2Fpost%2F37534.html</url>
    <content type="text"><![CDATA[最近在准备考研，阅读王道数据结构单科书时看到一个问题，问题是给定一棵树(不一定是二叉树)所有节点的层次次序序列和度数，创建该树的子女右兄弟链表示 书中给出的参考答案略显繁琐，所以自己考虑了一个算法，运用层次次序的特点和队列解决问题。尽管代码简单，但详述这一算法非常费劲，可能吃力不讨好，如果想要理解这一算法可以选较简单的测试样例自己手动模拟一遍，这样效果可能更好。 C++代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;struct ChildRightBrotherNode //子女右兄弟链节点&#123; char data; //数据域 ChildRightBrotherNode *first_child = nullptr; //长子指针 ChildRightBrotherNode *next_sibling = nullptr; //右兄弟指针 ChildRightBrotherNode(char d) :data(d) &#123;&#125;&#125;;struct DequeNode&#123; ChildRightBrotherNode *tree_node; //每一层的树节点指针 string::size_type degree; //该树节点的度数 DequeNode(ChildRightBrotherNode *t, int d) :tree_node(t), degree(d) &#123;&#125;&#125;;void preOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; preOutPut(root-&gt;first_child); preOutPut(root-&gt;next_sibling); &#125;&#125;void inOrderOutPut(ChildRightBrotherNode *root)&#123; if (root != nullptr) &#123; inOrderOutPut(root-&gt;first_child); cout &lt;&lt; root-&gt;data; inOrderOutPut(root-&gt;next_sibling); &#125;&#125;int main()&#123; deque&lt;DequeNode&gt; work_queue; vector&lt;pair&lt;char, string::size_type&gt;&gt; node_degree_array = &#123; &#123;'A', 3&#125;, &#123;'B', 2&#125;, &#123;'C', 1&#125;, &#123;'D', 2&#125;, &#123;'E', 0&#125;, &#123;'F', 0&#125;, &#123;'G', 0&#125;, &#123;'H', 0&#125;, &#123;'I', 0&#125; &#125;; //节点数据域-度数数组，各树节点从左到右按层次序排列 string::size_type i = 0; ChildRightBrotherNode *root = new ChildRightBrotherNode(node_degree_array[0].first); //创建根节点 work_queue.push_back(DequeNode(root, node_degree_array[0].second)); //根节点及其度数入队 while (work_queue.empty() == false) //队列不为空重复迭代 &#123; DequeNode p = work_queue.front(); //出队一个队列节点 work_queue.pop_front(); ChildRightBrotherNode *q = p.tree_node; //获取当前层的树节点指针 string::size_type j = 1; for (; j &lt;= p.degree; ++j) //将当前树节点的所有子女节点以右兄弟链的形式链接至当前树节点 &#123; if (j == 1) &#123; q-&gt;first_child = new ChildRightBrotherNode(node_degree_array[i+j].first); //创建当前树节点的长子节点 work_queue.push_back(DequeNode(q-&gt;first_child, node_degree_array[i + j].second)); //长子节点及度数入队 q = q-&gt;first_child; &#125; else &#123; q-&gt;next_sibling = new ChildRightBrotherNode(node_degree_array[i + j].first); //创建当前树节点长子节点之后的兄弟节点 work_queue.push_back(DequeNode(q-&gt;next_sibling, node_degree_array[i + j].second)); //兄弟节点及度数入队 q = q-&gt;next_sibling; &#125; &#125; i = i + j-1; //将i更新为当前树节点的直接子女节点中最右侧的子女节点在node_degree_array数组中的下标 &#125; cout &lt;&lt; "普通树的先根次序序列为:"; preOutPut(root); //先序遍历子女右兄弟链输出先根次序序列 cout &lt;&lt; endl; cout &lt;&lt; "普通树的后根次序序列为:"; inOrderOutPut(root); //中序遍历子女右兄弟链输出后根次序序列 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由二叉树的层次次序序列和中序序列还原二叉树的算法]]></title>
    <url>%2Fpost%2F51800.html</url>
    <content type="text"><![CDATA[我们知道，二叉树的层次次序序列和中序序列可以唯一确定一棵二叉树，现在我们要编写程序由二叉树的层次次序序列和中序序列还原一棵二叉树。 二叉树的三种遍历序列，前序中序后序均可递归定义，因此由前序中序还原二叉树，后序中序还原二叉树很容易用递归算法实现。但二叉树的层次次序序列并非递归定义的，所以用递归很难由层次次序序列和中序序列还原二叉树，必须使用新的方法 我们可以由层次次序的第一个元素找到二叉树的根节点，在中序序列中找到这个根节点，中序序列中该根节点的左侧右侧子序列分别为根节点左右子树的中序序列，如果左子树中序序列不为空，那么层次次序的第2个元素就是根节点左子树的根节点，此时如果右子树中序序列也不为空，层次徐第三个元素就是右子树根节点，如果左子树为空，但右子树不为空，那么层次次序的第二个元素就是右子树的根节点。直到左右子树根节点后，我们可以在根节点左右子树的中序序列中找到这个根节点，这样二叉树中序序列中根节点和根节点左右子树根节点把中序序列从左到右划分为四部分，第1部分根节点就是根节点右子树根节点在层次序中的下一个元素x,第二部分的根节点就是x1在层次序中的下一个元素x2,—-以此类推可知四部分的根节点。根节点，根节点左右子树，以及以上四部分根节点把中序序列划分为8部分，第一部分根节点就是上述四部分的第4部分根节点在层次序中的后继元素—-以此类推 按照以上步骤可以确定二叉树所有子树(包括二叉树本身在内)在中序序列中的根节点，这样二叉树就可以构建了 把以上描述总结出算法如下：我们需要两个队列，队列inorder_of_subtree用于存放各子树中序序列,队列seq_tree_node_queue用于存放每一层子树的根节点指针 层次次序序列为字符串sequence 中序序列为字符串 inorder 算法开始： 初始化：在inorder中找到sequence[0]所在下标index，将字符串inorder[0, index-1]和inorder[index+1, inorder.size-1]加入队列inorder_of_subtree 新建代表节点sequence[0]的二叉树节点，指针Node指向该节点,将Node加入队列seq_tree_node_queue，同时令root = Node并置j = 1; 迭代： while(seq_tree_node_queue.empty() == false) 从seq_tree_node_queue中出对一个由指针cur_tree_node指向的节点 从inorder_of_subtree中出队中序序列left_sub_inorder 从inorder_of_subtree中出队中序序列right_sub_inorder if (left_sub_inorder为空串) 将空指针赋予cur_tree_node left__child域 else 在left_sub_inorder中找到sequence[j]所在下标i 将left_sub_inorder[0,i-1]入队inorder_of_subtree 将left_sub_inorder[ i+1,left_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表left_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 leftchild域，并将该指针入队seq_tree_node_queue j = j+1 endif if (right_sub_inorder为空串) 将空指针赋予cur_tree_node right__child域 else 在right_sub_inorder中找到sequence[j]所在下标i 将right_sub_inorder[0,i-1]入队inorder_of_subtree 将right_sub_inorder[ i+1,right_sub_inorder.size-1]入队inorder_of_subtree 新建一个代表right_sub_inorder[i]的二叉树节点，并将其指针链入cur_tree_node 的 rightchild域，并将该指针入队seq_tree_node_queue j = j+1 endif endwhile 算法结束 后,root指向创建的二叉树的根节点 完整C++代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "pch.h"#include &lt;deque&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct BinaryTree&#123; char data; BinaryTree *leftchild = nullptr; BinaryTree *rightchild = nullptr; BinaryTree(char d) :data(d) &#123;&#125;&#125;;void outPutPre(BinaryTree *root)&#123; if (root != nullptr) &#123; cout &lt;&lt; root-&gt;data; outPutPre(root-&gt;leftchild); outPutPre(root-&gt;rightchild); &#125;&#125;void outPutPost(BinaryTree *root)&#123; if (root != nullptr) &#123; outPutPost(root-&gt;leftchild); outPutPost(root-&gt;rightchild); cout &lt;&lt; root-&gt;data; &#125;&#125;int main()&#123; string sequence = "ABCD"; string inorder = "BDCA"; deque&lt;string&gt; inorder_of_subtree; deque&lt;BinaryTree *&gt; seq_tree_node_queue; string::size_type index; for (index = 0; index &lt; inorder.size(); ++index) &#123; if (inorder[index] == sequence[0]) break; &#125; inorder_of_subtree.push_back(inorder.substr(0, index)); inorder_of_subtree.push_back(inorder.substr(index+1, inorder.size()-index)); BinaryTree *root = new BinaryTree(sequence[0]); seq_tree_node_queue.push_back(root); string::size_type j = 1; while (seq_tree_node_queue.empty() == false) &#123; BinaryTree *cur_tree_node = seq_tree_node_queue.front(); seq_tree_node_queue.pop_front(); string left_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); string right_sub_inorder = inorder_of_subtree.front(); inorder_of_subtree.pop_front(); if (left_sub_inorder == "") &#123; cur_tree_node-&gt;leftchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; left_sub_inorder.size(); ++i) &#123; if (left_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(left_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(left_sub_inorder.substr(i+1, left_sub_inorder.size()-i)); cur_tree_node-&gt;leftchild = new BinaryTree(left_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;leftchild); ++j; &#125; if (right_sub_inorder == "") &#123; cur_tree_node-&gt;rightchild = nullptr; &#125; else &#123; string::size_type i = 0; for (; i &lt; right_sub_inorder.size(); ++i) &#123; if (right_sub_inorder[i] == sequence[j]) break; &#125; inorder_of_subtree.push_back(right_sub_inorder.substr(0, i)); inorder_of_subtree.push_back(right_sub_inorder.substr(i + 1, right_sub_inorder.size() - i)); cur_tree_node-&gt;rightchild = new BinaryTree(right_sub_inorder[i]); seq_tree_node_queue.push_back(cur_tree_node-&gt;rightchild); ++j; &#125; &#125; cout &lt;&lt; "前序序列是:"; outPutPre(root); cout &lt;&lt; endl; cout &lt;&lt; "后序序列是:"; outPutPost(root); cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二叉树，层次序序列，中序序列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:treap树的插入与删除]]></title>
    <url>%2Fpost%2F26349.html</url>
    <content type="text"><![CDATA[为避免普通的二叉搜索树在最坏情况下退化为单链表,引入了使二叉搜索树近似保持平衡的treap树,treap是一棵二叉搜索树，和普通的二叉搜索树不同的是,treap树每一个节点有一个附加的数据域pri,各节点的pri满足最大或最小堆序，treap树各节点按关键码组织为二叉搜索树，按pri数据域组织为最小堆或最大堆，只要在插入或删除时保证堆性质不被破坏，就能使二叉搜索树尽可能保持近似平衡，保证搜索效率，treap树就是二叉搜索树和堆合二为一的产物 treap树删除: 以最小堆序为例 设被删节点为p,若p为叶节点直接删除，结束。若p只有一颗子树，删除p，并把唯一一棵子树链接至p父节点对应指针域，结束.若p有两棵子树，在两棵子树的根节点中选择pri值较小的节点，若该节点是p左子女，对p右单旋转,若该节点是p的右子女，对p左单旋转，旋转完毕后,p应仍然指向旋转前它指向的节点，然后对p继续实行以上操作直到结束为止 &nbsp; treap树插入 以最小堆序为例 根据要插入的关键码用二叉搜索树插入算法往treap树中插入新节点，然后为新节点生成随机的pri值 令p为新插入的节点,算法开始 若p为根节点，结束算法,否则若p的pri值大于等于p的父节点pri值，则结束算法，否则，若p为父节点的左子女，对父节点作右单旋转,若p为父节点右子女，对父节点作左单旋转,旋转结束后，应令p指向旋转前p指向的节点。然后对p重复前述操作直到结束为止 仔细想想不难证明，插入删除算法都能保证treap树的性质(二叉搜索树和堆)不被破坏 以下是实现treap树的C++代码: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;vector&gt;using namespace std;template &lt;typename T&gt;struct TreapTreeNode //Treap树节点定义&#123; T data_field; unsigned long long priority = 0; //堆中优先级 TreapTreeNode* left_child = nullptr; TreapTreeNode* right_child = nullptr; TreapTreeNode(const T&amp; d, unsigned long long p) :data_field(d), priority(p) &#123;&#125;&#125;;template &lt;typename T&gt;void leftRotate(TreapTreeNode&lt;T&gt; *ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;right_child; ptr-&gt;right_child = p-&gt;left_child; p-&gt;left_child = ptr; ptr = p;&#125;template &lt;typename T&gt;void rightRotate(TreapTreeNode&lt;T&gt;* ptr)&#123; TreapTreeNode&lt;T&gt;* p = ptr-&gt;left_child; ptr-&gt;left_child = p-&gt;right_child; p-&gt;right_child = ptr; ptr = p;&#125;template &lt;typename T&gt;struct JudgeResult //对二叉树的判断结果&#123; bool isTreap = true; //是否为二叉搜索树 T max_value_in_Treap; //二叉搜索树中最大节点值 T min_value_in_Treap; //二叉搜索树中的最小节点值&#125;;template &lt;typename T&gt;class TreapTree&#123;public: bool insert(const T&amp; key); //插入关键码 bool remove(const T&amp; key); //移除关键码 bool judgeTreap() &#123; return isTreap(root).isTreap; &#125; TreapTree() = default; TreapTree(unsigned long long seed) :make_priority(seed) &#123;&#125; ~TreapTree() &#123; destory(root); &#125;private: JudgeResult&lt;T&gt; isTreap(TreapTreeNode&lt;T&gt;* root); //判断当前二叉树是否为Treap树 void destory(TreapTreeNode&lt;T&gt;* root) &#123; if (root != nullptr) &#123; destory(root-&gt;left_child); destory(root-&gt;right_child); delete root; &#125; &#125; TreapTreeNode&lt;T&gt;* root = nullptr; //Treap树根节点 default_random_engine make_priority; //为新插入节点生成堆优先级的随机数引擎&#125;;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::insert(const T&amp; key)&#123; stack&lt;TreapTreeNode&lt;T&gt;*&gt; work_stack; TreapTreeNode&lt;T&gt;* cur = root; if (cur == nullptr) &#123; root = new TreapTreeNode&lt;T&gt;(key, make_priority()); return true; &#125; else &#123; while (cur != nullptr) &#123; if (key == cur-&gt;data_field) &#123; return false; &#125; if (key &gt; cur-&gt;data_field) &#123; work_stack.push(cur); cur = cur-&gt;right_child; &#125; else &#123; work_stack.push(cur); cur = cur-&gt;left_child; &#125; &#125; &#125; if (key &lt; work_stack.top()-&gt;data_field) &#123; cur = work_stack.top()-&gt;left_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; else &#123; cur = work_stack.top()-&gt;right_child = new TreapTreeNode&lt;T&gt;(key, make_priority()); &#125; while (true) &#123; if (cur-&gt;priority &lt; work_stack.top()-&gt;priority) &#123; if (work_stack.top()-&gt;left_child == cur) &#123; rightRotate(work_stack.top()); &#125; else &#123; leftRotate(work_stack.top()); &#125; work_stack.pop(); if (work_stack.empty() == false) &#123; if (cur-&gt;data_field &lt; work_stack.top()-&gt;data_field) &#123; work_stack.top()-&gt;left_child = cur; &#125; else &#123; work_stack.top()-&gt;right_child = cur; &#125; &#125; else &#123; root = cur; return true; &#125; &#125; else &#123; return true; &#125; &#125;&#125;template &lt;typename T&gt;bool TreapTree&lt;T&gt;::remove(const T&amp; key)&#123; TreapTreeNode&lt;T&gt;* cur = root; TreapTreeNode&lt;T&gt;* parent = nullptr; while (cur != nullptr) &#123; if (cur-&gt;data_field == key) &#123; break; &#125; parent = cur; if (key &lt; cur-&gt;data_field) &#123; cur = cur-&gt;left_child; &#125; else &#123; cur = cur-&gt;right_child; &#125; &#125; if (cur == nullptr) &#123; return false; &#125; while (true) &#123; if (cur-&gt;left_child == nullptr) &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = nullptr; &#125; else &#123; parent-&gt;right_child = nullptr; &#125; delete cur; &#125; else &#123; root = nullptr; &#125; &#125; else &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;right_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;right_child; &#125; &#125; else &#123; root = cur-&gt;right_child; &#125; delete cur; &#125; return true; &#125; else &#123; if (cur-&gt;right_child == nullptr) &#123; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = cur-&gt;left_child; &#125; else &#123; parent-&gt;right_child = cur-&gt;left_child; &#125; &#125; else &#123; root = cur-&gt;left_child; &#125; delete cur; return true; &#125; else &#123; TreapTreeNode&lt;T&gt;* p = nullptr; if (cur-&gt;left_child-&gt;priority &lt;= cur-&gt;right_child-&gt;priority) &#123; p = cur-&gt;left_child; rightRotate(cur); &#125; else &#123; p = cur-&gt;right_child; leftRotate(cur); &#125; if (parent != nullptr) &#123; if (parent-&gt;left_child == cur) &#123; parent-&gt;left_child = p; &#125; else &#123; parent-&gt;right_child = p; &#125; &#125; else &#123; root = p; &#125; parent = p; &#125; &#125; &#125;&#125;template &lt;typename T&gt;JudgeResult&lt;T&gt; TreapTree&lt;T&gt;::isTreap(TreapTreeNode&lt;T&gt; *root)&#123; if (root == nullptr) &#123; return JudgeResult&lt;T&gt;(); &#125; JudgeResult&lt;T&gt; result; if (root-&gt;left_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;left_child); if (temp.isTreap == true &amp;&amp; temp.max_value_in_Treap &lt; root-&gt;data_field &amp;&amp; root-&gt;priority&lt;= root-&gt;left_child-&gt;priority) &#123; result.min_value_in_Treap = temp.min_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.min_value_in_Treap = root-&gt;data_field; &#125; if (root-&gt;right_child != nullptr) &#123; JudgeResult&lt;T&gt; temp = isTreap(root-&gt;right_child); if (temp.isTreap == true &amp;&amp; temp.min_value_in_Treap &gt; root-&gt;data_field &amp;&amp; root-&gt;priority &lt;= root-&gt;right_child-&gt;priority) &#123; result.max_value_in_Treap = temp.max_value_in_Treap; &#125; else &#123; result.isTreap = false; &#125; &#125; else &#123; result.max_value_in_Treap = root-&gt;data_field; &#125; return result;&#125;int main()&#123; TreapTree&lt;int&gt; test_obj; vector&lt;int&gt; data&#123;4, 9, 1, 15, 3, 99, 34, 78&#125;; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中插入关键码" &lt;&lt; i &lt;&lt; endl; test_obj.insert(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; for (const int&amp; i : data) &#123; cout &lt;&lt; "在Treap树中删除关键码" &lt;&lt; i &lt;&lt; endl; test_obj.remove(i); if (!test_obj.judgeTreap()) &#123; cout &lt;&lt; "ERROR:当前树不为Treap树" &lt;&lt; endl; exit(-1); &#125; else &#123; cout &lt;&lt; "当前树为Treap树" &lt;&lt; endl; cout &lt;&lt; endl; &#125; &#125; return 0;&#125; 运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>treap树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:Trie树基本操作]]></title>
    <url>%2Fpost%2F22476.html</url>
    <content type="text"><![CDATA[Trie树是一种可以实现字符串多模匹配的数据结构，在字符串处理中有很重要的作用，本文Trie树实现参考了殷人昆数据结构与算法C++语言描述第二版中的内容。不同的是分支节点的分支结构用C++标准库map容器实现，原因是map基于红黑树，查找速度快，另外节省内存空间，避免浪费 C++实现如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411#include "pch.h"#include &lt;map&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;struct TrieTreeNode //Trie树节点类型&#123; enum NodeType &#123; DATANODE, BRANCHNODE &#125; type_flag; //节点类型标志，分支节点或存放关键字的叶节点 union &#123; string key_in_trie; //叶节点关键字 map&lt;string, TrieTreeNode *&gt; sub_ptr; //分支节点的分支字符和对应的指向分支字符对应的子节点的指针之间的映射关系 &#125;; TrieTreeNode(const string &amp;k) :type_flag(NodeType::DATANODE), key_in_trie(k) &#123;&#125; TrieTreeNode() :type_flag(NodeType::BRANCHNODE), sub_ptr() &#123;&#125; TrieTreeNode(TrieTreeNode &amp;be_copied) &#123; switch (be_copied.type_flag) &#123; case NodeType::DATANODE: new (&amp;key_in_trie) string(be_copied.key_in_trie); break; case NodeType::BRANCHNODE: &#123; new (&amp;sub_ptr) map&lt;string, TrieTreeNode *&gt;(); for (map&lt;string, TrieTreeNode *&gt;::iterator p = be_copied.sub_ptr.begin(); p != be_copied.sub_ptr.end(); ++p) &#123; sub_ptr.insert(make_pair(p-&gt;first, nullptr)); &#125; &#125; break; &#125; &#125; ~TrieTreeNode() &#123; switch (type_flag) &#123; case NodeType::DATANODE : key_in_trie.~string(); break; case NodeType::BRANCHNODE: break; &#125; &#125;&#125;;class TrieTree&#123;public: bool insert(const string &amp;be_inserted) const; //Trie树中插入关键字,true成功false失败 bool deleteElem(const string &amp;be_deleted) const; //Trie树中删除指定关键字,true成功false失败 TrieTreeNode *copy(); //拷贝Trie树，返回指向副本Trie树的指针 TrieTree() &#123; root = new TrieTreeNode(); &#125; TrieTree(TrieTree &amp;be_copied) &#123; root = be_copied.copy(); &#125; ~TrieTree();private: bool static strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i); TrieTreeNode *root; //Trie树根节点&#125;;bool TrieTree::strCompare(const string &amp;left, const string &amp;right, const size_t &amp;i)&#123; for (size_t j = i; ; ++j) &#123; if (j &gt;= left.size() &amp;&amp; j &gt;= right.size()) return true; else if (j &gt;= left.size() || j &gt;= right.size()) return false; else if (left[j] != right[j]) return false; &#125;&#125;bool TrieTree::deleteElem(const string &amp;be_deleted) const&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_deleted.size()) &#123; string temp = be_deleted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; &#125; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(""); if (it != run-&gt;sub_ptr.end()) &#123; work_stack.push(make_pair(run, it)); run = it-&gt;second; break; &#125; else &#123; return false; &#125; &#125; &#125; if (work_stack.top().second-&gt;first != "" &amp;&amp; strCompare(be_deleted, run-&gt;key_in_trie, i) == false) &#123; return false; &#125; bool delete_or_not = true; while (work_stack.top().first != root) &#123; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; if (work_stack.top().second-&gt;second-&gt;type_flag == TrieTreeNode::NodeType::DATANODE) &#123; run = nullptr; &#125; work_stack.top().first-&gt;sub_ptr.erase(work_stack.top().second); if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; return true; &#125; else if (work_stack.top().first-&gt;sub_ptr.size() == 1) &#123; if (work_stack.top().first-&gt;sub_ptr.begin()-&gt;second-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; return true; &#125; else &#123; run = work_stack.top().first-&gt;sub_ptr.begin()-&gt;second; delete work_stack.top().first; delete_or_not = false; &#125; &#125; work_stack.pop(); &#125; else &#123; if (work_stack.top().first-&gt;sub_ptr.size() &gt;= 2) &#123; work_stack.top().second-&gt;second = run; return true; &#125; else &#123; delete work_stack.top().first; work_stack.pop(); &#125; &#125; &#125; if (delete_or_not == true) &#123; delete work_stack.top().second-&gt;second; root-&gt;sub_ptr.erase(work_stack.top().second); &#125; else &#123; work_stack.top().second-&gt;second = run; &#125; return true;&#125;bool TrieTree::insert(const string &amp;be_inserted) const &#123; TrieTreeNode *run = root; map&lt;string, TrieTreeNode *&gt;::iterator father; string::size_type i = 0; while (run-&gt;type_flag != TrieTreeNode::NodeType::DATANODE) &#123; if (i &lt; be_inserted.size()) &#123; string temp = be_inserted.substr(i, 1); ++i; map&lt;string, TrieTreeNode *&gt;::iterator it = run-&gt;sub_ptr.find(temp); if (it == run-&gt;sub_ptr.end()) &#123; run-&gt;sub_ptr.insert(make_pair(temp, new TrieTreeNode(be_inserted))); return true; &#125; else &#123; father = it; run = it-&gt;second; &#125; &#125; else &#123; if (run-&gt;sub_ptr.find("") != run-&gt;sub_ptr.end()) &#123; return false; &#125; else &#123; run-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); return true; &#125; &#125; &#125; if (strCompare(be_inserted, run-&gt;key_in_trie, i) == true) &#123; return false; &#125; else &#123; while (true) &#123; father-&gt;second = new TrieTreeNode(); if (i &gt;= be_inserted.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", new TrieTreeNode(be_inserted))); father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); &#125; else if (i &gt;= run-&gt;key_in_trie.size()) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair("", run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else if (be_inserted[i] != run-&gt;key_in_trie[i]) &#123; father-&gt;second-&gt;sub_ptr.insert(make_pair(run-&gt;key_in_trie.substr(i, 1), run)); father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode(be_inserted))); &#125; else &#123; father = father-&gt;second-&gt;sub_ptr.insert(make_pair(be_inserted.substr(i, 1), new TrieTreeNode())).first; ++i; continue; &#125; return true; &#125; &#125;&#125;TrieTree::~TrieTree()&#123; TrieTreeNode *run = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (run == root) &#123; if (run-&gt;sub_ptr.begin() == run-&gt;sub_ptr.end()) &#123; delete root; return; &#125; &#125; else &#123; if (run-&gt;type_flag == TrieTreeNode::DATANODE) &#123; delete run; run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(run, run-&gt;sub_ptr.begin())); run = run-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; if (run == root) &#123; if (work_stack.top().second == root-&gt;sub_ptr.end()) &#123; delete root; return; &#125; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (work_stack.top().second != run-&gt;sub_ptr.end()) &#123; run = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; delete run; work_stack.pop(); run = work_stack.top().first; work_stack.top().second = run-&gt;sub_ptr.erase(work_stack.top().second); &#125; &#125; &#125; &#125;&#125;TrieTreeNode *TrieTree::copy()&#123; TrieTreeNode *be_copied = root; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; work_stack; stack&lt;pair&lt;TrieTreeNode *, map&lt;string, TrieTreeNode *&gt;::iterator&gt;&gt; copy_trace_stack; TrieTreeNode *root_of_copy = nullptr; bool trace_back_flag = true; while (true) &#123; if (trace_back_flag == true) &#123; if (be_copied == root) &#123; root_of_copy = new TrieTreeNode(*be_copied); if (be_copied-&gt;sub_ptr.begin() == be_copied-&gt;sub_ptr.end()) &#123; break; &#125; copy_trace_stack.push(make_pair(root_of_copy, root_of_copy-&gt;sub_ptr.begin())); &#125; else &#123; if (work_stack.top().second == work_stack.top().first-&gt;sub_ptr.begin()) &#123; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; else &#123; ++copy_trace_stack.top().second; copy_trace_stack.top().second-&gt;second = new TrieTreeNode(*be_copied); &#125; if (be_copied-&gt;type_flag != TrieTreeNode::DATANODE) copy_trace_stack.push(make_pair(copy_trace_stack.top().second-&gt;second, copy_trace_stack.top().second-&gt;second-&gt;sub_ptr.begin())); else &#123; be_copied = work_stack.top().first; trace_back_flag = false; continue; &#125; &#125; work_stack.push(make_pair(be_copied, be_copied-&gt;sub_ptr.begin())); be_copied = be_copied-&gt;sub_ptr.begin()-&gt;second; &#125; else &#123; map&lt;string, TrieTreeNode *&gt;::iterator tempit = work_stack.top().second; if (tempit-&gt;second-&gt;type_flag != TrieTreeNode::DATANODE) &#123; copy_trace_stack.pop(); &#125; if (be_copied == root) &#123; if (++(work_stack.top().second) == root-&gt;sub_ptr.end()) break; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; if (++(work_stack.top().second) != be_copied-&gt;sub_ptr.end()) &#123; be_copied = work_stack.top().second-&gt;second; trace_back_flag = true; &#125; else &#123; work_stack.pop(); be_copied = work_stack.top().first; &#125; &#125; &#125; &#125; return root_of_copy;&#125;int main()&#123; vector&lt;string&gt; test = &#123;"abcd", "abydb", "ary", "AFD", "abyc", "AFDGH", "AFMGB", "AFMGRQ", "cdfg", "cdgkn", "cdgkmq"&#125;; TrieTree test_obj; for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "插入字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.insert(*p); &#125; cout &lt;&lt; endl; // TrieTreeNode *copy = test_ptr.copy(); for (vector&lt;string&gt;::iterator p = test.begin(); p != test.end(); ++p) &#123; cout &lt;&lt; "删除字符串" &lt;&lt; *p &lt;&lt; endl; test_obj.deleteElem(*p); &#125; cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LALR(1)分析实现一个简易的正则表达式引擎]]></title>
    <url>%2Fpost%2F56078.html</url>
    <content type="text"><![CDATA[首先给出博主自己编写的正则表达式文法(在编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现这篇文章里已经出现过)： **#1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e** 部分终结符和非终结符的含义是： S’:增广文法开始符号 S:原文法开始符号 preSurvey:预查表达式 outSquare：方括号外的直接量 inSquareRange:方括号内中 - 表示的范围的一端 inSquare：方括号内的直接量 SPECTRANMETA：特殊转义元字符 - \^ POSITIVE-SURE-PRE：正向肯定预查运算符(?= POSITIVE-NEGA-PRE：正向否定预查运算符(?! NEGATIVE-SURE-PRE：反向肯定预查运算符(?&lt;= NEGATIVE-NEGA-PRE：反向否定预查运算符(?&lt;! CLOSURE：闭包*和+ GIVEN：指定重复次数{n} LBOUND:指定最小重复次数{n, } ULBOUND:对重复次数指定上下界{n, m} CLOSURE-NONGREEDY:非贪婪闭包+? *? LBOUND-NONGREEDY：指定最小重复次数的非贪婪版本{n, }? ULBOUND-NONGREEDY：指定最大最小重复次数的非贪婪版本{n, m}? CAP：子表达式左括号( NONPRECAP：非捕获匹配(?: SPECTRAN：特殊转义字符\b单词边界 \B非单词边界 \d数字 \D非数字 \f 换页 \n 换行 \r 回车 \s 空白 \S 非空白\t 制表\v 垂直制表 \w 单词字符 \W 非单词字符 TRANMETA：转义元字符 * + \? \$ . ( ) \: \= ! \&lt; | [ ] { } UPPERALPHA:大写字母 LOWERALPHA：小写字母 DIGIT：数字 SPECMETA：特殊元字符 . $ REVERSEREF：反向引用 OTHERMETA：其他元字符 : = ! &lt; { } &nbsp;了解终结符非终结符的含义后，产生式也就不难理解了 本正则表达式引擎要求方括号外的直接量只能为SPECTRAN、TRANMETA、\、SPECTRANMETA、UPPERALPHA、LOWERALPHA、DIGIT、SPECMETA、REVERSEREF、^之一，不相符的书写形式都会报告语法错误。因此任何出现在方括号代表本身的元字符必须使用转义书写(即加). 文法对预查的处理还是存在一些问题，因为它不支持预查表达式(不可自嵌套)和其他预查表达式以及E的任意组合，如果要支持这一点必须大改文法，且要做不少重复工作，比较麻烦，所以本引擎对预查只支持单一的没有自嵌套的预查表达式。此外对非贪婪匹配的处理还是存在一些问题的，回溯引擎处理非贪婪匹配会由少到多逐一尝试，但是本引擎并发地模拟所有可能的转移路径，回溯引擎的做法在本引擎中行不通，所以博主采用了比较笨有待斟酌的做法-闭包和指定重复次数的运算符为非贪婪时让其匹配最少的几种可能，如+?转换为NFA时将匹配1次，这种做法是有一些问题的，在回溯引擎中若匹配aaab，则a+?b和aaab匹配，但本引擎只能匹配子串ab,虽然逻辑上也讲得通，但和非贪婪匹配的预期行为不一致。暂时不知道有什么更好的解决方法，暂时就这样吧 引擎的总体执行逻辑并不复杂，语法分析器读入词法分析器传入的Token进行移入归约，在此过程中使用S属性的语法制导翻译方案将正则表达式翻译为等价NFA，每当进行一次对句柄的归约时，将用与句柄匹配的产生式体中非终结符的综合属性构造产生头非终结符的综合属性(可能为NFA也可能不为)，实际上就是执行与产生式关联的语义动作。当对句柄S在向前看符号$下归约即接受时,S对应的NFA即为翻译结果。随后采用模拟NFA(并发地考察所有可能的转移状态)的方法进行无回溯的匹配，得到匹配结果。 每一个子表达式的接受态都有一个指向相应开始态的指针，匹配过程中抵达子表达式接受态时使用该指针确定子匹配结果，模拟过程中可能先后多次抵达同一个子表达式的开始态，我采用开始态编号加抵达开始态时栈顶下标来唯一标识每一个到达，对于每一个到达都会生成与到达相关的传播项，该传播项沿匹配路径不断向前传播，当传播到对应子表达式接受态时就可以利用与接受态对应的传播项确定与特定子表达式开始的到达对应的子匹配结果，当该传播项流动至生成该传播项的子表达式开始态时就发生了回环，此时传播项会被杀死以阻止其进一步传播，避免其对子匹配结果的截取造成影响。另外在算法中计算出从当前字符转移至的新状态的闭包时，会检查是否有传播项从闭包中消失，如果有会在相关的数据结构中删去和消失的传播项关联的项以节省内存空间。对反向引用的处理是，保存文件指针当前位置，然后不断向前读入字符匹配反向引用，若匹配成功则把此时文件指针的位置，反向引用转移至的状态和和反向引用关联的传播项加入表，如果匹配过程中文件指针到达了相同位置，则把反向引用转移至的新状态加入会成为栈顶的newstacknode的状态集，然后将传播项并入当前传播项集合并更新相关数据结构。 最后说明一下，如果匹配成功，每一个匹配结果都是整个正则表达式所能匹配的最长子串。 另外，这个引擎写得真的很烂，博主自己就很不满意，它对预查的支持不完善，对非贪婪的处理存在问题，也未能支持一些本可以支持的特性，和google的RE2引擎实在没法比(代码量上已经输给它)，仅能满足常见的匹配需求，后续可能会继续改正 本项目的github地址:https://github.com/naturerun/RTNWSK-RE-ENGINE 自己编写的正则表达式引擎可能有未知的缺陷、错误和漏洞，博主自己没有那么多精力进行详尽的测试和维护，如果发现错误愿意提就提出，没有奖励，只有感谢，谢谢大家 &nbsp; 2019.4.25更新 新增对非贪婪匹配的支持]]></content>
      <categories>
        <category>基础库</category>
      </categories>
      <tags>
        <tag>正则表达式，LALR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：邻接多重表操作实现]]></title>
    <url>%2Fpost%2F40489.html</url>
    <content type="text"><![CDATA[邻接多重表是一种比较重要的无向简单图存储结构，鉴于无向图在数据结构课程中的重要性，邻接表多重操作实现必须要予以解决。图论及其算法在编译原理中具有很重要的地位，图着色的寄存器分配就要用到无向简单图，所以自己尝试实现一下邻接多重表的操作。 一开始很天真的以为邻接多重表的实现难度和十字链表应该相差不大，十字链表能够实现邻接多重表应该也不成问题，但实际开始动手后才发现情况并非如此，邻接多重表实现比十字链表更为复杂。不得不承认自己实在太笨，问题没考虑全面就急匆匆敲代码，结果运行后不是发现这里没考虑到就是那里存在错误，于是就反反复复修改编译修改编译，真是被折磨死了。图结构及其算法确实是数据结构中最难的部分之一，我已经深有体会了。用了整整两天时间总算正确实现了邻接多重表的操作，实现了添加边，删除边，删除顶点，复制，合并，销毁，添加顶点这些重要的API，其他接口应该没有那么重要，需要的话以后还可以添加。 C++代码清单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973974975976977978979980981982983984985#include "pch.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;template &lt;typename V, typename E&gt;class Graph //无向简单图类，存储结构为多重邻接表&#123; friend vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph);public: struct VertexNode; struct EdgeNode //边节点类型 &#123; E *edge_data_field = nullptr; //边节点数据域 typename vector&lt;VertexNode *&gt;::size_type left = 0; //边一端对应顶点 typename vector&lt;VertexNode *&gt;::size_type right = 0; //边另一端对应顶点 EdgeNode *same_left_ptr = nullptr; //指向一端仍为left的下一个边节点的指针 EdgeNode *same_right_ptr = nullptr; //指向另一端仍为right的下一个边节点的指针 EdgeNode() = default; EdgeNode(typename vector&lt;VertexNode *&gt;::size_type l, typename vector&lt;VertexNode *&gt;::size_type r, E *e) :left(l), right(r), edge_data_field(e) &#123;&#125; ~EdgeNode() &#123; delete edge_data_field; &#125; &#125;; struct VertexNode //顶点节点 &#123; V *vertex_data_field = nullptr; //顶点数据域 typename vector&lt;VertexNode *&gt;::size_type number = 0; //顶点编号 EdgeNode *first_ptr = nullptr; //指向和该顶点关联的第一条边的指针 VertexNode *seilring = nullptr; //指向当前顶点，表示存在自环 E *Edgeseilring = nullptr; //自环边 VertexNode() = default; VertexNode(typename vector&lt;VertexNode *&gt;::size_type n, V *v) :number(n), vertex_data_field(v) &#123;&#125; ~VertexNode() &#123; delete vertex_data_field; delete Edgeseilring; &#125; &#125;; Graph() = default; Graph(typename vector&lt;VertexNode *&gt;::size_type n) :set_of_vertex(n, nullptr) &#123;&#125; virtual ~Graph(); //释放多重邻接表并销毁图 Graph&lt;V, E&gt; *copy(); //拷贝当前无向图并返回指向副本的指针 typename vector&lt;typename VertexNode *&gt;::size_type addVertex(V *vertex); //添加顶点,vertex为顶点数据域 bool addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge); //添加边(left, right),edge为边数据域 void deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex); //删除顶点vertex bool deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right); //删除边(left, right) Graph&lt;V, E&gt; *merge(Graph&lt;V, E&gt;&amp; Bemerged, bool copyOrNot); //将Bemerged和当前无向图合并,copyOrNot=true拷贝当前图返回合并后得到的新的无向图的指针,=false直接合并至当前图返回空指针 typename vector&lt;VertexNode *&gt;::size_type getVertexNum() &#123; return set_of_vertex.size(); &#125; //获取无向图中顶点数目protected: vector&lt;VertexNode *&gt; set_of_vertex; //无向图顶点集&#125;;template &lt;typename V, typename E&gt;typename vector&lt;typename Graph&lt;V, E&gt;::VertexNode *&gt;::size_type Graph&lt;V, E&gt;::addVertex(V *vertex)&#123; set_of_vertex.push_back(new VertexNode(set_of_vertex.size(), vertex)); return set_of_vertex.size() - 1;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::addEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right, E *edge) //从left和right顶点节点开始检索插入位置并插入，该过程会保持和left或right关联的边节点的另一端顶点的编号的有序性(从小到大)&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = set_of_vertex[left]; set_of_vertex[left]-&gt;Edgeseilring = new E(*edge); return true; &#125; EdgeNode *start = set_of_vertex[left]-&gt;first_ptr; EdgeNode *pre = nullptr; if (start == nullptr) &#123; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; &#125; else &#123; for (; start != nullptr; ) &#123; if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) == right) return false; else if ((start-&gt;left == left ? start-&gt;right : start-&gt;left) &lt; right) &#123; pre = start; if (start-&gt;left == left) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; else &#123; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; set_of_vertex[left]-&gt;first_ptr = new EdgeNode(left, right, edge); set_of_vertex[left]-&gt;first_ptr-&gt;same_left_ptr = pre; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = set_of_vertex[left]-&gt;first_ptr; return true; &#125; pre = set_of_vertex[left]-&gt;first_ptr; &#125; else &#123; if (pre-&gt;left == left) &#123; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); pre-&gt;same_left_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); pre-&gt;same_right_ptr-&gt;same_left_ptr = start; if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; break; &#125; &#125; if (start == nullptr) &#123; if (pre-&gt;left == left) &#123; if (pre-&gt;right == right) return false; pre-&gt;same_left_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_left_ptr; return true; &#125; pre = pre-&gt;same_left_ptr; &#125; else &#123; if (pre-&gt;left == right) return false; pre-&gt;same_right_ptr = new EdgeNode(left, right, edge); if (set_of_vertex[right]-&gt;first_ptr == nullptr) &#123; set_of_vertex[right]-&gt;first_ptr = pre-&gt;same_right_ptr; return true; &#125; pre = pre-&gt;same_right_ptr; &#125; &#125; &#125; if (pre == nullptr) &#123; pre = set_of_vertex[left]-&gt;first_ptr; &#125; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[right]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;right == right ? start-&gt;left : start-&gt;right) &lt; left) &#123; p = start; if (start-&gt;right == right) &#123; start = start-&gt;same_right_ptr; &#125; else &#123; start = start-&gt;same_left_ptr; &#125; &#125; else &#123; if (p == nullptr) &#123; p = set_of_vertex[right]-&gt;first_ptr; set_of_vertex[right]-&gt;first_ptr = pre; pre-&gt;same_right_ptr = p; &#125; else &#123; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; pre-&gt;same_right_ptr = start; &#125; return true; &#125; &#125; if (p-&gt;right == right) &#123; p-&gt;same_right_ptr = pre; &#125; else &#123; p-&gt;same_left_ptr = pre; &#125; return true;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt;::~Graph() //删除算法较为简洁，原因是和顶点关联的所有边另一端的顶点编号保持有序,这样我们只需从小到大考察每个顶点,如果和顶点关联的边全部删除,first_ptr指针为空，算法会自动跳过，否则依次分离出和顶点关联的每一条边，从该边关联的非当前顶点的另一&#123; //顶点处对分离出的边节点进行摘链(根据删除算法的执行顺序，被摘链的边节点一定是和另一顶点关联的边链表中的第一个节点),然后释放分离出的边节点，所有顶点处理完后销毁set_of_vertex for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; EdgeNode *ptr = nullptr; while (set_of_vertex[run]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[run]-&gt;first_ptr; if (ptr-&gt;left == run) &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_left_ptr; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[run]-&gt;first_ptr = ptr-&gt;same_right_ptr; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; delete ptr; &#125; &#125; while (set_of_vertex.empty() == false) &#123; delete set_of_vertex.back(); set_of_vertex.pop_back(); &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::copy() //依次考察原图每一个顶点，对每一个顶点依次考察关联的每一边节点，如果该边节点副本已在尚未拷贝完成的图副本中，则将边节点副本链接至图副本对应顶点副本的边链表的尾部，否则创建新节点(为当前边节点副本)链接至图副本对应顶点副本的边链表的尾部&#123; //同时搜索图副本中已部分形成的通过和新边节点关联的另一端顶点(非原图中当前遍历到的顶点)对应的链接指针链接形成的边链表的第一个边节点，由该边节点循链找到部分形成的边链表尾部，将新节点链接至尾部即可 Graph&lt;V, E&gt; *temp = new Graph&lt;V, E&gt;(set_of_vertex.size()); for (typename vector&lt;VertexNode *&gt;::size_type run = 0; run &lt; set_of_vertex.size(); ++run) &#123; temp-&gt;set_of_vertex[run] = new VertexNode(set_of_vertex[run]-&gt;number, new V(*(set_of_vertex[run]-&gt;vertex_data_field))); if (set_of_vertex[run]-&gt;seilring != nullptr) &#123; temp-&gt;set_of_vertex[run]-&gt;seilring = temp-&gt;set_of_vertex[run]; temp-&gt;set_of_vertex[run]-&gt;Edgeseilring = new E(*(set_of_vertex[run]-&gt;Edgeseilring)); &#125; if (set_of_vertex[run]-&gt;first_ptr == nullptr) continue; EdgeNode *p = nullptr; for (EdgeNode *start = set_of_vertex[run]-&gt;first_ptr; start != nullptr; ) &#123; if ((start-&gt;left == run ? start-&gt;right : start-&gt;left) &lt; run) &#123; EdgeNode *q = nullptr; if (start-&gt;left == run) &#123; q = temp-&gt;set_of_vertex[start-&gt;right]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;right) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; q = temp-&gt;set_of_vertex[start-&gt;left]-&gt;first_ptr; for (; q != nullptr; ) &#123; if (q-&gt;left == start-&gt;left) &#123; if (q-&gt;right == run) break; q = q-&gt;same_left_ptr; &#125; else &#123; if (q-&gt;left == run) break; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = q; &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = q; &#125; else &#123; p = p-&gt;same_right_ptr = q; &#125; &#125; &#125; else &#123; if (p == nullptr) &#123; p = temp-&gt;set_of_vertex[run]-&gt;first_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; if (p-&gt;left == run) &#123; p = p-&gt;same_left_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; else &#123; p = p-&gt;same_right_ptr = new EdgeNode(start-&gt;left, start-&gt;right, new E(*(start-&gt;edge_data_field))); &#125; &#125; if (start-&gt;left == run) &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for ( ; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;right) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;right) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;right) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;right) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; else &#123; EdgeNode *m = nullptr; typename vector&lt;VertexNode *&gt;::size_type i = 0; for (; i &lt; run; ++i) &#123; for (m = temp-&gt;set_of_vertex[i]-&gt;first_ptr; m != nullptr;) &#123; if (m-&gt;left == i) &#123; if (m-&gt;right == start-&gt;left) break; m = m-&gt;same_left_ptr; &#125; else &#123; if (m-&gt;left == start-&gt;left) break; m = m-&gt;same_right_ptr; &#125; &#125; if (m != nullptr) break; &#125; if (i != run) &#123; while (true) &#123; if (m-&gt;right == start-&gt;left) &#123; if (m-&gt;same_right_ptr == nullptr) break; m = m-&gt;same_right_ptr; &#125; else &#123; if (m-&gt;same_left_ptr == nullptr) break; m = m-&gt;same_left_ptr; &#125; &#125; if (m-&gt;right == start-&gt;left) &#123; m-&gt;same_right_ptr = p; &#125; else &#123; m-&gt;same_left_ptr = p; &#125; &#125; &#125; &#125; if (start-&gt;left == run) &#123; start = start-&gt;same_left_ptr; &#125; else &#123; start = start-&gt;same_right_ptr; &#125; &#125; &#125; return temp;&#125;template &lt;typename V, typename E&gt;bool Graph&lt;V, E&gt;::deleteEdge(typename vector&lt;VertexNode *&gt;::size_type left, typename vector&lt;VertexNode *&gt;::size_type right) //从顶点left,right处搜索边节点，摘链并释放边节点&#123; if (left &gt;= set_of_vertex.size() || right &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; if (left == right) &#123; set_of_vertex[left]-&gt;seilring = nullptr; delete set_of_vertex[left]-&gt;Edgeseilring; set_of_vertex[left]-&gt;Edgeseilring = nullptr; return true; &#125; if (set_of_vertex[left]-&gt;first_ptr == nullptr) return false; EdgeNode *q = nullptr; EdgeNode *p = set_of_vertex[left]-&gt;first_ptr; for (; p != nullptr; ) &#123; if (p-&gt;left == left) &#123; if (p-&gt;right == right) &#123; break; &#125; else if (p-&gt;right &lt; right) &#123; q = p; p = p-&gt;same_left_ptr; &#125; else &#123; return false; &#125; &#125; else &#123; if (p-&gt;left == right) &#123; break; &#125; else if (p-&gt;left &lt; right) &#123; q = p; p = p-&gt;same_right_ptr; &#125; else &#123; return false; &#125; &#125; &#125; if (p == nullptr) &#123; return false; &#125; else &#123; if (q == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; else &#123; set_of_vertex[left]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; &#125; else &#123; if (q-&gt;left == left &amp;&amp; p-&gt;left == left) &#123; q-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q-&gt;left != left) &#123; if (p-&gt;left != left) &#123; q-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; &#125; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[right]-&gt;first_ptr-&gt;left == left || set_of_vertex[right]-&gt;first_ptr-&gt;right == left) break; q2 = set_of_vertex[right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == right) &#123; if (q2-&gt;same_right_ptr-&gt;left == left || q2-&gt;same_right_ptr-&gt;right == left) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == left || q2-&gt;same_left_ptr-&gt;right == left) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; if (p-&gt;left == left) &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_right_ptr; &#125; else &#123; set_of_vertex[right]-&gt;first_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; if (q2-&gt;left == right &amp;&amp; p-&gt;left == left) &#123; q2-&gt;same_left_ptr = p-&gt;same_left_ptr; &#125; else if (q2-&gt;left != right) &#123; if (p-&gt;left != left) &#123; q2-&gt;same_right_ptr = p-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = p-&gt;same_left_ptr; &#125; &#125; else &#123; q2-&gt;same_left_ptr = p-&gt;same_right_ptr; &#125; &#125; delete p;&#125;template &lt;typename V, typename E&gt;void Graph&lt;V, E&gt;::deleteVertex(typename vector&lt;VertexNode *&gt;::size_type vertex) //分离出和vertex关联的每一边节点,从该边节点另一端顶点(和vertex相对应)出搜索边节点，摘链并释放边节点&#123; //随后从set_of_vertex中删去vertex并调整图中顶点编号和边节点中顶点编号 if (vertex &gt;= set_of_vertex.size()) &#123; throw new out_of_range("无效的顶点参数\\n"); &#125; EdgeNode *ptr = nullptr; while (set_of_vertex[vertex]-&gt;first_ptr != nullptr) &#123; ptr = set_of_vertex[vertex]-&gt;first_ptr; if (ptr-&gt;left == vertex) &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_left_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;right]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;right]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;right) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;right]-&gt;first_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;left == ptr-&gt;right) &#123; q2-&gt;same_left_ptr = ptr-&gt;same_right_ptr; &#125; else &#123; q2-&gt;same_right_ptr = ptr-&gt;same_right_ptr; &#125; &#125; &#125; else &#123; set_of_vertex[vertex]-&gt;first_ptr = ptr-&gt;same_right_ptr; EdgeNode *q2 = nullptr; while (true) &#123; if (q2 == nullptr) &#123; if (set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;left == vertex || set_of_vertex[ptr-&gt;left]-&gt;first_ptr-&gt;right == vertex) break; q2 = set_of_vertex[ptr-&gt;left]-&gt;first_ptr; continue; &#125; else &#123; if (q2-&gt;right == ptr-&gt;left) &#123; if (q2-&gt;same_right_ptr-&gt;left == vertex || q2-&gt;same_right_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_right_ptr; &#125; else &#123; if (q2-&gt;same_left_ptr-&gt;left == vertex || q2-&gt;same_left_ptr-&gt;right == vertex) break; q2 = q2-&gt;same_left_ptr; &#125; &#125; &#125; if (q2 == nullptr) &#123; set_of_vertex[ptr-&gt;left]-&gt;first_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; if (q2-&gt;left != ptr-&gt;left) &#123; q2-&gt;same_right_ptr = ptr-&gt;same_left_ptr; &#125; else &#123; q2-&gt;same_left_ptr = ptr-&gt;same_left_ptr; &#125; &#125; &#125; delete ptr; &#125; delete set_of_vertex[vertex]; for (typename vector&lt;VertexNode *&gt;::size_type i = vertex; i &lt; set_of_vertex.size() - 1; ++i) &#123; set_of_vertex[i] = set_of_vertex[i + 1]; --set_of_vertex[i]-&gt;number; &#125; set_of_vertex.pop_back(); set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type i = 0; i &lt; set_of_vertex.size(); ++i) &#123; for (EdgeNode *q = set_of_vertex[i]-&gt;first_ptr; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; if (q-&gt;left &gt; vertex) &#123; q-&gt;left = q-&gt;left - 1; &#125; if (q-&gt;right &gt; vertex) &#123; q-&gt;right = q-&gt;right - 1; &#125; visited.insert(q); &#125; if (q-&gt;left == i) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125;&#125;template &lt;typename V, typename E&gt;Graph&lt;V, E&gt; *Graph&lt;V, E&gt;::merge(Graph&lt;V, E&gt; &amp;Bemerged, bool copyOrNot) //合并函数比较简单，可以参考我在LALR(1)语法分析表生成程序中对十字链表的实现&#123; Graph&lt;V, E&gt; *temp1 = nullptr; typename vector&lt;VertexNode *&gt;::size_type Ca1 = 0; if (copyOrNot) &#123; temp1 = copy(); Ca1 = temp1-&gt;set_of_vertex.size(); &#125; else &#123; Ca1 = set_of_vertex.size(); &#125; &#123; Graph&lt;V, E&gt; *temp2 = Bemerged.copy(); for (typename vector&lt;VertexNode *&gt;::size_type p = 0; p &lt; temp2-&gt;set_of_vertex.size(); ++p) &#123; if (copyOrNot) &#123; temp1-&gt;set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; else &#123; set_of_vertex.push_back(temp2-&gt;set_of_vertex[p]); &#125; &#125; while (temp2-&gt;set_of_vertex.empty() == false) &#123; temp2-&gt;set_of_vertex.pop_back(); &#125; delete temp2; &#125; set&lt;EdgeNode *&gt; visited; for (typename vector&lt;VertexNode *&gt;::size_type p = Ca1; ; ++p) &#123; EdgeNode *q = nullptr; if (copyOrNot) &#123; if (p &gt;= temp1-&gt;set_of_vertex.size()) break; temp1-&gt;set_of_vertex[p]-&gt;number = p; q = temp1-&gt;set_of_vertex[p]-&gt;first_ptr; &#125; else &#123; if (p &gt;= set_of_vertex.size()) break; set_of_vertex[p]-&gt;number = p; q = set_of_vertex[p]-&gt;first_ptr; &#125; for (; q != nullptr; ) &#123; if (visited.find(q) == visited.end()) &#123; q-&gt;left = q-&gt;left + Ca1; q-&gt;right = q-&gt;right + Ca1; visited.insert(q); &#125; if (q-&gt;left == p) &#123; q = q-&gt;same_left_ptr; &#125; else &#123; q = q-&gt;same_right_ptr; &#125; &#125; &#125; if (copyOrNot) return temp1; else return nullptr;&#125;Graph&lt;size_t, size_t&gt; *convertToGraph(vector&lt;vector&lt;int&gt;&gt; &amp;adjacency_matrix) //由邻接矩阵构造基于邻接多重表的有向图并返回该图的指针&#123; vector&lt;vector&lt;int&gt;&gt;::size_type size = adjacency_matrix.size(); Graph&lt;size_t, size_t&gt; *temp = new Graph&lt;size_t, size_t&gt;(); for (size_t i = 0; i &lt; size; ++i) &#123; temp-&gt;addVertex(new size_t(i)); &#125; for (size_t i = 0; i &lt; size; ++i) &#123; for (size_t j = i; j &lt; size; ++j) &#123; if (adjacency_matrix[i][j] == 1) &#123; temp-&gt;addEdge(i, j, new size_t(j)); &#125; &#125; &#125; return temp;&#125;vector&lt;vector&lt;int&gt;&gt; *convertToAdjaMatrix(Graph&lt;size_t, size_t&gt; *undigraph) //由基于邻接多重表无向图构造邻接矩阵并返回邻接矩阵&#123; vector&lt;vector&lt;int&gt;&gt; *temp = new vector&lt;vector&lt;int&gt;&gt;(undigraph-&gt;getVertexNum(), vector&lt;int&gt;(undigraph-&gt;getVertexNum(), 0)); for (size_t i = 0; i &lt; undigraph-&gt;set_of_vertex.size(); ++i) &#123; if (undigraph-&gt;set_of_vertex[i]-&gt;seilring != nullptr) (*temp)[i][i] = 1; for (Graph&lt;size_t, size_t&gt;::EdgeNode *p = undigraph-&gt;set_of_vertex[i]-&gt;first_ptr; p != nullptr;) &#123; if (p-&gt;left == i) &#123; (*temp)[p-&gt;left][p-&gt;right] = 1; p = p-&gt;same_left_ptr; &#125; else &#123; (*temp)[p-&gt;right][p-&gt;left] = 1; p = p-&gt;same_right_ptr; &#125; &#125; &#125; delete undigraph; return temp;&#125;int main()&#123; vector&lt;vector&lt;int&gt;&gt; test = &#123; &#123;1, 0, 1, 1, 0, 1, 0&#125;, &#123;0, 1, 0, 1, 1, 0, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 0, 1, 1, 0, 0&#125;, &#123;0, 1, 1, 1, 0, 1, 1&#125;, &#123;1, 0, 1, 0, 1, 0, 1&#125;, &#123;0, 1, 1, 0, 1, 1, 0&#125; &#125;; //测试用邻接矩阵 vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(convertToGraph(test)); //测试addEdge函数 for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; delete test2; /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试copy函数 Graph&lt;size_t, size_t&gt; *temp2 = temp-&gt;copy(); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp2); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteEdge函数 for (size_t i = 0; i &lt; test.size(); ++i) &#123; for (size_t j = i; j &lt; test.size(); ++j) &#123; if (test[i][j] == 1) &#123; cout &lt;&lt; "删除边("&lt;&lt;i&lt;&lt;","&lt;&lt; j &lt;&lt; ")" &lt;&lt; endl; temp-&gt;deleteEdge(i, j); &#125; &#125; &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp = convertToGraph(test); //测试deleteVertex函数 size_t num = temp-&gt;getVertexNum(); for (size_t i = 0; i &lt; num; ++i) &#123; cout &lt;&lt; "删除顶点" &lt;&lt; i &lt;&lt; endl; temp-&gt;deleteVertex(0); &#125; vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp); if (test2-&gt;empty()) &#123; cout &lt;&lt; "图为空" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误!" &lt;&lt; endl; &#125; */ /*Graph&lt;size_t, size_t&gt; *temp1 = convertToGraph(test); //测试merge函数 Graph&lt;size_t, size_t&gt; *temp2 = convertToGraph(test); temp1-&gt;merge(*temp2, false); vector&lt;vector&lt;int&gt;&gt; *test2 = convertToAdjaMatrix(temp1); for (const auto &amp;i : *test2) &#123; for (const auto &amp;j : i) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; &#125; */ return 0;&#125; &nbsp;2018.11.12日更新&nbsp; &nbsp; 优化了deleteEdge函数第一个for循环，搜索待删除边时搜索的边链表上每一个边节点的与边链表上所有边节点共同关联的顶点对应的边节点一端相对的一端的顶点的编号严格递增，所以如果发现被删除边的前述一端的顶点编号夹在边链表上俩边节点前述一端的顶点编号之间或小于边链表上前述一端的顶点编号最小的边节点的顶点编号，则函数直接退出，没有必要继续搜索]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>邻接多重表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对求有向图强连通分量的tarjan算法原理的一点理解]]></title>
    <url>%2Fpost%2F35112.html</url>
    <content type="text"><![CDATA[先简单叙述一下tarjan算法的执行过程(其他诸如伪代码之类的相关细节可以自己网上搜索，这里就不重复贴出了)： 用到两类数组： dfs[]:DFS过程中给定节点的深度优先数，即该节点在DFS中被访问的次序 low[]：从给定节点回溯时，节点的low值为从节点在DFS树中的子树中的节点以及该节点通过后退边或横叉边可以回溯到的栈中DFS值最小的节点的dfs值 一个数据结构：栈，用于确定强连通分量 定义：横叉边：一条有向边(u,v)为横叉边，当且仅当(1)u,v之间没有祖先后代关系(2)(1)满足的条件下，设u,v的最近公共祖先为L,u在以L子女节点k1为根的子树T1中,v在以L子女节点k2为根的子树T2中,则T1在T2右侧 前进边：弧尾为祖先节点，弧头为子孙节点的有向边 后退边：弧尾为子孙节点，弧头为祖先节点的有向边 树边：对有向图进行深度优先搜索形成的DFS生成树上的有向边，该有向边始终由父节点指向子女节点 执行过程：对有向图进行深度优先搜索，每抵达一个新节点A就把该节点A入栈，并初始化dfs[A],然后将low[A]初始化为dfs[A],随后考察该节点A通过边可达的所有节点。若其中一个节点未访问，则对其递归DFS，遍历结束从该节点退出回溯至A时，用该节点low值(已确定不会再改变)更新A的low值(low[A]=min(low[A],low[该节点]))，若其中一个节点已访问，当该节点的dfs值小于dfs[A]且该节点在栈中时，用该节点dfs值更新A节点low值(low[A]=min(low[A],dfs[该节点]))，否则跳过什么也不做。当通过边与A相连的所有节点都考察完毕了，A的low值就最终确定了,不会再变，此时在从A回溯至DFS中A的前驱节点前检查low[A]是否等于dfs[A]，若是不断弹栈直到把A弹出为止，弹出的节点组成一个强连通分量，若不是什么都不做，回溯至前驱节点。 伪代码： Tarjan(v) { &nbsp; stack.push(v); &nbsp; dfs[v]=new_dfs(); &nbsp; low[v]=dfs[v]; &nbsp; visited[v] = true; &nbsp; for(v通过有向边弧头指向的每一个顶点n) &nbsp;{ &nbsp; &nbsp; &nbsp;if(!visited[n]) &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; Tarjan(n); &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],low[n]}; &nbsp; &nbsp; } &nbsp; &nbsp; else &nbsp; &nbsp;{ &nbsp; &nbsp; &nbsp; &nbsp;if (dfs[n]&lt;dfs[v] &amp;&amp; stack.contain(n)) &nbsp; &nbsp; &nbsp; { &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; low[v]=min{low[v],dfs[n]}; &nbsp; &nbsp; &nbsp; } &nbsp; &nbsp;} &nbsp;} &nbsp;if(low[v]==dfs[v]) &nbsp;{ &nbsp; &nbsp; 连续从栈中弹出节点直到v被弹出为止，被弹出的节点组成一个强连通分量 &nbsp;} } 要注意的是，算法执行过程中按DFS遍历次序入栈，退栈不影响栈中各节点的DFS访问顺序和它们在栈中位置关系的逻辑关系，所以任何时刻,若栈中B在栈中A之上则dfs[B]&gt;dfs[A]，反之也真。 还有就是从tarjan算法伪代码不难看出，当从节点A回溯时必有dfs[A]&gt;=low[A]. 并且算法中给定节点仅入栈一次出栈一次访问一次，回溯过给定节点就不会再次回溯，回溯至给定节点时节点的low值就已确定，直至算法结束都不会改变 算法中若一个节点已经入栈，则只有当回溯到该节点或该节点的祖先节点时该节点才可能出栈，而且在回溯到DFS树根节点时该节点之前若未出栈则此时必然会出栈，即对于DFS树根节点root有low[root]=dfs[root] 结合这几件简单事实可以证明下面七个命题，学习tarjan算法的关键就是理解回溯到给定节点A时对条件dfs[A]==low[A]的测试的含义以及测试成功后所执行的一系列弹栈操作，以下七个命题有助于理解 定理1：在tarjan算法中回溯到一给定节点A时，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量中的第一个被访问的节点(根节点)，则栈中A节点之上的所有节点(包括A节点)必为A节点所在强连通分量的所有节点 证明：事实上，取栈中A之上的某节点B,若节点B不属于A所在强连通分量，则B必然属于另外一个不同的强连通分量L，该强连通分量有根节点B’，B’不可能是从未被访问的节点，否则由B’为不同的强连通分量的根节点知B尚未被访问故而不会被压入栈中，矛盾。B’也不可能是已被访问压入栈中但随后又被弹出的节点，若不然当压入B’后必然会回溯至B’，此时检测到dfs[B’]==low[B’]，于是从栈中弹出B’和B’以上全部节点，由B’为不同强连通分量根节点知B要么等于B’要么在B’后压栈，故前述弹栈操作结束后无论如何B不会在栈中，而针对B’的弹栈操作在回溯至A节点之前发生(证明:由于B在A之后压栈，故dfs[B]&gt;dfs[A].B不可能尚未回溯完毕，否则B正在被访问,这样B只能是A的子孙而不可能在A的右侧(否则回溯到A时B尚未访问矛盾)，故此时还没有回溯到A，矛盾。从而回溯到A时B已经回溯完成，故B是A的子孙。显然B’不为B(否则回溯到A时B’=B已经回溯完成,B已经被弹出栈，矛盾)，故B’只能为B的祖先,B’当然不能为A(因为B’所在强连通分量和A所在强连通分量不同)，也不能为A的祖先，否则存在路径B’-&gt;A-&gt;B-&gt;B’,故A,B’相互可达,B’属于A所在强连通分量,矛盾,从而B’为A的子孙，B的祖先证毕),故回溯至A节点时B节点已不存在于栈中矛盾。这样B’必然已被访问且在栈中，由前述证明B’不为A，B’也不可能在栈中A的位置之下，这是因为前述证明指出B’为A的子孙,故B’必在A压栈后压栈，于是我们证明了B’必然位于栈中A之上，这样当回溯至B’时由于dfs[B’]=lowB’,B’及B’之上的所有节点都会被弹出，而B必然在B’后压栈，这样前述弹栈操作结束后B已不在栈中，此后我们才回溯至A，此时B已不在栈中，矛盾。这样就证明了回溯到A时栈中A之上的任一节点必属于A所在强连通分量。此外，当回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量，若不然，考虑C入栈后回溯到C的时刻，此时由于C属于A所在强连通分量，所以存在A到C的路径，又由于A为A所在强连通分量的根节点，且A和C并非同一节点(注意算法中tarjan算法中一个给定节点仅入栈一次，出栈一次，而回溯到A时C已弹出，此时如A==C，则C在弹出后又入栈回到栈中，矛盾)，所以C必为A的子孙，即C必在A被访问后访问(即dfs[C]&gt;dfs[A])，即必在A被压栈之后压栈，这样当回溯到C时A必在栈中且位于C之下，且由于C属于A所在强连通分量，所以存在C到A的路径。当回溯到C时，可以断言必有dfs[C]!=low[C],若不然C成为强连通分量M的根节点，我们有A为A所在强连通分量根节点而A不等于C,C是A的子孙,M中所有节点均为C或C的子孙，从而A不等于M中任意节点，注意到C属于A所在强连通分量，A和C相互可达,A可以和M合并组合成一个更大的强连通分支，这和M为极大强连通子图矛盾，所以就证明了必有dfs[C]!=low[C]。于是当回溯至C时，不会对C执行弹出C及栈中其上节点的弹栈操作。然后可以断言，在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作，若不然取这些弹栈操作中最早发生的一次，此时将会回溯至栈中C和A之间的节点D，且此时C及其上节点都在栈中且应有dfs[D]=low[D]，故应对D执行该弹栈操作。注意到D在栈中位于A之上，dfs[D]&gt;dfs[A],D比A后访问，这样D必位于DFS树中节点A的子树中(D比A后访问,D不可能在A的右侧，否则回溯至C后和回溯至A前D根本没有被访问故不在栈中，矛盾)，于是D位于DFS树中节点A的子树中，此外C位于DFS树中节点D的子树中,(证明：D在栈中位于C之下，C后访问，dfs[D]&lt;dfs[C]若C不在D的子树中，则C在D的右侧，这样回溯至D时C尚未访问而不在栈中矛盾）。这样D的子树中的节点C有一条指向D的祖先节点A的路径，且存在A到C的路径，&nbsp;故A和D相互可达,从而D属于A节点所在的强连通分量,&nbsp; &nbsp; 另外显然D不为A，故由引理三，回溯至D时low[D]!=dfs[D]这和dfs[D]=low[D]矛盾，这样就证明了在回溯至C后和回溯至A前不可能有针对栈中C和A之间（不包括A和C）的节点的弹栈操作。这样回溯至C之后，回溯至A之前，C不可能被弹出，故回溯至A时C仍在栈中，这和回溯至A时C已被弹出的假设矛盾，这就证明了回溯到A时，之前入栈并已被弹出的任一节点C不可能属于A所在强连通分量。另外，回溯到A时从未被访问的节点也不可能属于A所在强连通分量，若不然，由于回溯到A时这些节点尚未被访问，根据DFS搜索顺序，这些节点不可能是A的子孙节点(如果是这些节点就访问过了)，也不可能是A的祖先节点(如果是它们就正在被访问)，这样这些节点和A没有祖先后代关系，于是这些节点要么位于A左侧，要么位于A右侧，但显然不能位于A的左侧，否则对这些节点的访问已经完成，即这些节点已经回溯完毕，于是这些节点只能位于A右侧，而由定理三中的证明，A所在的强连通的分量除A以外的所有节点一定都位于A的子树中，这和这些节点位于A的右侧矛盾。这样就证明了A所在的强连通分量中所有节点都位于栈内，下面可以断言栈中位于A之下的所有节点不可能属于A所在的强连通分量，证明很简单，若不然存在A之下的某节点E属于A所在的强连通分量，注意dfs[E]&lt;dfs[A]，这样E比A先访问，而E属于A所在的强连通分量，故A不可能是DFS中A所在的强连通分量被访问的第一个节点，矛盾。这样就证明了栈中A及A之上的所有节点构成了A所在的强连通分量的全部节点，证明完毕。 定理2: 在tarjan算法中回溯到一给定节点A时，若dfsA==lowA则该节点必为通过DFS所到达的深度优先树中该节点所在的强连通分量中的第一个被访问的节点(根节点) 证明：使用反证法,若A节点不为通过DFS所到达的深度优先树中该节点所在的强连通分量L中的第一个被访问的节点(根节点),设L在深度优先树中的根节点为B,A!=B,且A属于L，由引理三，回溯至A节点时必有low[A]!=dfs[A],这和已知条件矛盾，证毕 &nbsp; 定理3：在tarjan算法中回溯到一给定节点A时，若A是它所在的强连通分量M在深度优先树中被第一个访问的节点，则必有dfs[A]==low[A] 证明：首先，回溯至节点A时，由于A为它所在强连通分量的根节点，而A所在的强连通的分量除A以外的所有节点一定都位于A的子树中(假若有节点B(A不等于B)位于A所在的强连通分量,而节点B不在A的子树中，则A不是B的祖先。另外B也不是A的祖先，否则B会比A先访问，而A是它所在的强连通分量在深度优先树中被第一个访问的节点，矛盾。故设A,B的LCA为M,A在以M的某一个子女节点L1为根的子树中,B在以M的某一个子女节点L2为根的子树中，如果L1在L2的左侧，注意存在从A到B的简单路径Q，由引理一Q必然经过A和B的某一个公共祖先U,这样存在从U到B的路径，又因为存在从A到U和从B到A的路径，故存在从B到U的路径，从而B和U相互可达，进而U和A所在的强连通分量中任意节点相互可达，从将U和A所在强连通分量合并能够得到真包含A所在强连通分量的强连通子图，这和A所在强连通分量是极大强连通子图矛盾，L1在L2右侧的讨论是类似的)，所以A的子树中有一个属于A所在强连通分量的节点，存在该节点到A的一条路径，显然回溯至A时low[A]&lt;=dfs[A].我们来证明回溯至A时必有dfs[A]==low[A]，如若不然，回溯至A时有low[A]&lt;dfs[A]，此时栈中A之上的所有节点C均满足low[C]&lt;dfsC，且根据DFS访问顺序栈中A之上的所有节点C都已经被回溯过了(而且已经回溯过的节点不会再次被访问和回溯)，回溯至A时low[A]&lt;dfs[A]，这样不会针对A执行弹栈操作，于是对A的回溯结束后，栈中A及A之上的所有节点都会保留。另外，由于根据反证法假设回溯至A时low[A]&lt;low[A],所以此时A不为DFS树根节点，根节点必然在栈中A之下，即栈中A之下必有节点，那么栈中A之下必然存在节点D，使得当回溯至D时有low[D]==dfs[D],如若不然当回溯至栈底节点F(栈中DFS值最小节点)时,仍有low[F]&lt;dfs[F],从而栈中F之下存在某个节点，该节点dfs值比dfs[F]还小，这是不可能的,因为F为根节点DFS值最小，且栈中F之下根本没有任何节点，矛盾。于是我们知道，对A的回溯结束后，必然会回溯到栈中A之下的某节点，该节点low值==dfs值，我们取最早回溯到的这样的节点E最早性质，当回溯到E时,回溯到A时栈中A及A之上的节点仍然位于栈中(这是因为对A的回溯结束后，栈中A及A之上节点仍在栈中，此后由于这些节点不会被再次回溯到，所以只有第一次对栈中A之下的节点执行弹栈操作时这些节点才会被弹出，在此之前，结束对A的回溯之后，这些节点都会被保留)，而回溯到E时有low[E]==dfs[E]，根据之前证明的定理二,E为通过DFS所到达的深度优先树中E所在的强连通分量L中的第一个被访问的节点(根节点)，然后，回溯到E时栈中A及A之上的节点仍然位于栈中，在栈中E位于A之下，这样栈中E节点之上所有节点包括了栈中A及A节点之上所有节点，由于A压栈在E之后,dfs[A]&gt;dfs[E],又对E的回溯在A之后，因此A必为DFS树中E的子孙节点。这里由假设回溯至A时dfs[A]!=low[A]，且由E的最早性质，知DFS树中E至A的路径上除E和A的任意节点p均满足low[p]!=dfs[p],故由引理四,A属于L,从而A和E相互可达，A显然不为E,所以将E和M组合得到一个真包含M的强连通分支，这和M为极大强连通子图矛盾,故必有dfs[A]==low[A]证完 引理一：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先，则有向图中从A到B的任意一条简单路径必然经过A和B的某一个公共祖先 证明：假若有向图中存在一条A到B的简单路径S，S不经过A和B的任意一个公共祖先(包括最近公共祖先)。则从S上的节点A出发，我们尝试维持以下的不变式： 对路径S上的当前节点C，存在节点M，使得C在以M的某一个子女节点M1为根的子树中，B在以M的某一个子女节点M2为根的子树中，且子树M1在子树M2的左侧，M是C和B的最近公共祖先,且DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先. 事实上，对S上的节点A，令C=A，M=L，则可见不变式对A成立，现假设不变式对S上的当前节点C成立,考虑S上由C指向C在S上的后继D的有向边(C, D),则(C, D)可以是前进边，树边，后退边，横叉边。当(C, D)为横叉边时，由引理二C不能在D的左边，故必有D在C的左边，此时设C,D的LCA(最近公共祖先)为Q，显然若Q在DFS生成树中M到C的路径上(当然不包括C本身)，则D和B的LCA就是M，若Q在DFS生成树中DFS生成树根节点到M的路径上(不包括M),则D和B的LCA即为Q，即D和B的LCA M’就在DFS生成树从根节点到M的路径上(包括M)。又由不变式知DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故从DFS树根节点到M’的路径上所有节点(包括M’)都是A和B的公共祖先。&nbsp; 同时由本轮不变式知C在B的左侧，又因为D在C的左侧，故D在B的左侧,从而DFS生成树中存在M’的子女节点M1’和M2’,使得子树M1’在子树M2’左侧且D在子树M1’中,B在子树M2’中，从而在不变式中令C=D,M=M’,M1=M1’,M2=M2’即可知不变式对C=D成立，即不变式对S上C的后继节点D仍然成立 如果(C,D)为树边或前进边，由于树边或前进边都由DFS树上的祖先指向子孙，故D仍然在以C为根的子树中，这样不难验证D和B的LCA就是C和B的LCA=M，又由不变式,M1在M2左侧，C在M1中，D在以C为根的子树中，从而D在M1中，又B在M2中，且 DFS树上从根节点到M的路径上的所有节点(包括M)都是A和B的公共祖先，故不变式对C=D仍然成立、 如果(C,D)为后退边，D当然为C在DFS树上的祖先，但路径S上根本没有A,B的任意公共祖先，因此D不是A，B的公共祖先，故D必然为M的子孙，否则D在DFS树中根节点到M的路径上，从而由不变式D是A和B的公共祖先，矛盾。从而D在DFS树上从M到C的路径上(在M和C之间)，所以由不变式D和B的LCA为M，同时D就在DFS树上M1到C的路径上(不包括C)，故D就在子树M1中，从而可知不变式对C=D依然成立 于是当沿路径S讨论到B时，不变式对C=B仍然成立，这是不可能的，因为B不可能在B的左侧，这就证明了从A到B的任意一条简单路径必然经过A和B的某一个公共祖先，证毕 引理二：对有向图的DFS生成树中的节点A和节点B，若存在节点L，使得A在以L的某一个子女节点L1为根的子树中，B在以L的某一个子女节点L2为根的子树中，且子树L1在子树L2的左侧，L是A和B的最近公共祖先， 则一定不存在从A出发指向B的有向边 证明：假若存在从A出发指向B的有向边(A,B)，由前提条件知DFS过程中A一定比B先访问，且第一次抵达A时B必然没有被访问，这样在第一次抵达A后从A出发访问有向边(A,B)的另一端节点B时,B必然没有被访问(这是因为B要么是从A出发沿以A为弧尾的有向边访问的第一个节点，要么不是第一个节点，如果是前者，那么从A出发访问B时B当然没有被访问，如果是后者，第一次抵达A后从A出发沿有向边访问B前访问的都是DFS树中以A的某个子女节点为根的子树，这些子树都在子树L1中，而B在子树L2中，所以访问这些子树时根本不可能访问B)，这样B在DFS中就会被访问，因此B必然在以A为根的子树中，故在L1中，这和B在L2中矛盾，这就证明了不可能存在从A出发指向B的有向边，证毕 引理三：在Tarjan算法中，若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点属于强连通分量L，A!=B,则回溯到B时必有low[B]!=dfs[B] 证明：由定理三开头的证明知，L中节点除A外必定全部位于以A为根的DFS树的子树中,而A!=B,A属于L，故B必定在以A为根的子树中，即A为B的祖先。而存在由B通向A的简单路径S,该路径S上所有节点均可属于L，从而均属于以A为根的子树。我们断言，S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。假若不是这样，对S上任意一条有向边(u,v)，它是前进边，或者是树边，或者是横叉边或后退边，当它为横叉边时,u,v在DFS树中的层数要么均大于等于B，要么均小于B,要么u的层数小于B,v的层数大于等于B，当它为后退边时,要么u的层数低于B，要么v的层数大于等于B，故如果u的层数大于等于B,则必有v的层数大于等于B,而路径S的起始点B的层数大于等于B,故利用前述结论沿S向前递推，可得S的终点A的层数大于等于B，而A是B的祖先，应有A的层数小于B，矛盾，这就证明了之前的断言：S上至少有一条由前驱节点指向后继节点的有向边(u,v)，该有向边要么为横叉边要么为后退边，当该有向边为横叉边时,u在v的右侧(由引理二u不可能在v的左侧)，并且v在DFS树中的层数低于B，u在DFS树中的层数大于等于B，当该边为后退边时,同样有v在DFS树中的层数低于B，u在DFS树中的层数大于等于B。 我们称以B为出发点的路径S上的有向边(u,v)满足性质A当且仅当(u,v)是横叉边且当u是B的子孙时v也是B的子孙 现在我们考虑路径S上从B出发第一条满足断言性质的有向边(u,v),如果S上从B到u的路径上不存在不满足性质A的横叉边,注意到B到u的路径上任意一条有向边均不满足断言中规定的性质，所以根据上述证明断言的过程以及B的层数大于等于B可知u的层数大于等于B，又因为B到u的路径上不存在不满足性质A的横叉边，所以u为B或B的子孙 若(u,v)不是横叉边,即(u,v)是后退边,从而v是u的祖先，假设v!=A,这样v要么等于B要么和B是祖先后代关系，而v的层数低于B，故v必然是B的祖先。这样当在算法中第一次访问u后从u访问v时,由于v是u的祖先,所以v必然正在访问且尚未回溯到v，故v必在栈中，又对u的访问后于v,dfs[u]&gt;dfs[v],从而u在v压栈后压栈，即栈中v在u的下方，这样从u访问v时v正在被访问,v在栈中且dfs[u]&gt;dfs[v]，从而算法中会执行low[u]=min(dfs[v], low[u]),这样当回溯到u时必有low[u]&lt;=dfs[v]&lt;dfs[B],注意B是u的祖先，从而回溯到B时low[B]&lt;=low[u]&lt;=dfs[v]&lt;dfs[B],即low[B]&lt;=dfs[v],low[B]!=dfs[B]。因为v!=A,且显然v属于S属于L,,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论,重复讨论的过程由下文所述。 若(u,v)是横叉边，注意B为u的祖先,A为B的祖先，故v!=A(否则(u,v会成为后退边)),而v属于L，由于(u,v)为横叉边所以v在u的左侧,这样对v而言本引理的条件得到满足,所以对v我们可以重复本证明的所有讨论，在讨论中我们令v到A的路径S为本次讨论中B到A的路径S上从v到A的路径M,在讨论中我们引出了路径M上新的点v2,v2!=v,v2!=A,v2属于M属于本讨论中路径S属于L,于是v2满足本引理的条件，故再对v2重复本证明中的讨论,在讨论中令v2到A的路径S为上一次讨论中v到A的路径M上从v2到A的路径M2，在对v2的讨论中我们引出了路径上新的点v3——&nbsp;按照这一步骤反复讨论下去，由于本次讨论中路径S长度有限,而S,M,M2.M3—的长度逐步递减，M,M1，M2—中的每一条路径都是其前一路径的后缀，故这样的重复讨论不可能无限进行下去,故若讨论没有中途终止，我们最后必然会由在对节点vn-1的讨论中引出了路径Mn-1上新的点vn,Mn-1上以vn为弧头的有向边为(h,vn),h为弧尾,有向边(h,vn)是Mn-1上从vn-1出发的第一条也是最后一条满足红字部分断言性质的有向边，断言中B为vn-1,S为Mn-1,vn恰好为节点A,即vn是路径Mn-1终点,同时Mn-1上vn-1到h的路径上的所有有向边中不存在任何不满足性质A的横叉边，并且有向边(h,vn)=(h,A)显然为后退边，不为横叉边(Mn-1是简单路径，且为本次讨论中路径S的后缀,故h!=A,h属于L属于以A为根的子树，从而h为A的后代，即(h,A)=(h,vn为后退边))。所以我们对有向边(h,vn)重复上文红字斜体部分的证明,即可推出算法中回溯到vn-1时low[vn-1]&lt;=low[h]&lt;=dfs[vn]=dfs[A],即low[vn-1]&lt;=dfs[A]&lt;dfs[vn-1],从而可知vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;=low[vn-1]&lt;=dfs[A]&lt;dfs[p]，这说明不仅当回溯到vn-1时栈中的vn-1不会出栈，且回溯到vn-1的在以A为根的子树中的祖先节点(不包括A)时都不会执行出栈操作，从而栈中vn-1不会出栈，故DFS过程中，回溯至vn-1后回溯到A之前vn-1都在栈中不会出栈。结论一 如果S上从B到u的路径上存在不满足性质A的横叉边,设这些横叉边中第一条为(q, r),则S上B到q的路径上不存在不满足性质A的横叉边且任意一条有向边均不满足红字部分断言规定的性质,所以由红字斜体部分开头的内容知必有q为B或B的子孙,注意B为q或q的祖先,A为B的祖先，故r!=A(否则(q,r)会成为后退边),而r属于L,这样对r而言本引理的条件得到满足,所以对r我们可以重复本证明的所有讨论,重复讨论的过程如上文所述 下面我们沿着递推链反向回溯,如果在上述反复讨论中我们最终抵达了节点vn-1并对vn-1展开讨论,对vn-1的讨论结束后我们回溯至之前对vn-2的讨论,在对vn-2的讨论中，我们引出了路径Mn-2上的有向边(h, vn-1),这里若设(h,vn-1)为横叉边。如果(h,vn-1)为满足红字部分断言性质的横叉边,则vn-1在DFS树中的层数低于vn-2，h在DFS树中的层数大于等于vn-2,且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。注意low[vn-1]&lt;=dfs[vn]=dfs[A],h在vn-1的右边，这样DFS中当我从h访问vn-1时,注意h!=A,h属于路径S属于L,h为A的子孙,于是访问h时尚未回溯到A且在回溯至vn-1之后，由结论一,vn-1仍在栈中，而且由dfs[h]&gt;dfs[vn-1]知栈中vn-1在h之下,这样从h访问vn-1时由于vn-1已经被访问故算法中会执行low[h]=min(low[h], dfs[vn-1]),于是必有low[h]&lt;=dfs[vn-1].由于Mn-2上vn-2到h的路径上的有向边中没有任何不满足性质A的横叉边，且这些有向边均不满足红字部分断言的性质，再由vn-2在DFS树中的层数大于等于vn-2以及斜体红字部分开头的叙述知必有h为vn-2或vn-2的子孙，而low[h]&lt;=dfs[vn-1],故low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],又vn-1在h的左侧，vn-1不为vn-2的子孙(这是因为vn-1在DFS树中测层数低于vn-2),故vn-1在vn-2的左侧，因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2] 然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps.由于vn-1在vn-2的左侧，所以vn-1要么是p1,p2—ps中某一个节点pv的子孙节点(此时，vn-1所在的以pv的子女节点为根子树一定在vn-2的以pv的子女节点pv-1为根的子树的左侧),要么在节点ps的左侧,vn-1不可能恰为p1,p2—ps中的某一个节点，否则由于h为hn-2的子孙,(h, vn-1)将成为一条返祖边，这和其为横叉边矛盾.如果vn-1是pv的子孙节点,则pv,pv+1—ps均为vn-1的祖先节点，而前面已经证明vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]，故low[pi]&lt;dis[pi]i=v,v+1,—,s.此外,pv-1,pv-2,—p1均在vn-1的右侧，而且由结论一回溯至vn-1后回溯至pv之前vn-1都在栈中不会出栈，这意味着在pv的子树第一次访问vn-2后从vn-2子孙节点h访问vn-1时vn-1仍在栈中,显然dfs[h]&gt;dfs[vn-2]&gt;dfs[vn-1]且栈中vn-1在h之下，vn-1已被访问过，于是算法中会执行low[h]=min{low[h],dfs[vn-1]},从而low[h]&lt;=dfs[vn-1],故h的祖先节点pi(i=1,2,–,v-1)的low值均满足low[pi]&lt;=dfs[vn-1]&lt;dfs[pi](最后一个不等式成立是因为pi在vn-1右侧),这样我们有low[pi]&lt;dfs[pi]i=1,2,—,s 如果vn-1在ps的左侧,则dfs[vn-1]&lt;dfs[pi]i=1,2,—,s,同样由结论一,当从h访问vn-1时vn-1仍在栈中,dfs[h]&gt;dfs[vn-1]且栈中vn-1在h之下,vn-1已被访问过,故算法中会执行low[h]=min{low[h],dfs[vn-1]}，从而low[h]&lt;=dfs[vn-1]，故h的祖先节点p1,p2,—,ps满足low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s 于是我们证明了low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)不为满足红字部分断言性质的横叉边,则(h,vn-1)必然为不满足性质A的横叉边，且Mn-2上从vn-2到h的路径上所有有向边中没有任何不满足性质A的横叉边,这些有向边均不满足红字部分断言的性质。使用和上文类似的推理知low[vn-2]&lt;=low[h]&lt;=dfs[vn-1],h为vn-2子孙.vn-1在h左侧,(h,vn-1)不满足性质A即h是vn-2子孙但vn-1不是，从而vn-1在vn-2左侧,因此dfs[vn-1]&lt;dfs[vn-2],故low[vn-2]&lt;dfs[vn-2].然后然后，设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，仿上文证明同样可证low[pi]&lt;=low[h]&lt;=dfs[vn-1]&lt;dfs[pi]i=1,2,—,s，故low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 如果(h,vn-1)为后退边,&nbsp;则Mn-2上从vn-2到h的路径上不存在不满足性质A的横叉边,且vn-2到h的路径上任意一条有向边均不满足断言中规定的性质,但(h,vn-1)满足红字部分断言性质。注意，我们在红字斜体部分已经证明了vn-1是vn-2的祖先,low[vn-2]!=dfs[vn-2],low[vn-2]&lt;=dfs[vn-1],，另外已经证明了vn-1的任意以A为根的子树中非A的祖先节点p的low值low[p]&lt;dfs[p]以及low[vn-1]&lt;dfs[vn-1].于是对任意vn-2的祖先节点vn-1的子孙节点p有low[p]&lt;=low[vn-2]&lt;=dfs[vn-1]&lt;dfs[p],设DFS树中节点A至节点vn-2的路径上除A和vn-2以外的所有节点从下至上为p1,p2—ps，我们就得到low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 总之我们有low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2] 随后我们回溯至之前对vn-3的讨论，根据low[pi]&lt;dfs[pi]i=1,2,—,s low[vn-2]&lt;dfs[vn-2],采用和上文类似的证明过程又可证得low[p2i]&lt;dfs[p2i]i=1,2,—,s low[vn-3]&lt;dfs[vn-3]，这样持续向前回溯，最终我们得到 low[pn-1i]&lt;dfs[pn-1i]i=1,2,—,s&nbsp; low[B]&lt;dfs[B]&nbsp;其中pn-1i i=1,2,—,s为DFS树中节点A至节点B的路径上除A和B以外的所有节点,故当回溯至B时必然有low[B]!=dfs[B]，证完 引理四:在Tarjan算法中,如果若A节点为通过DFS所到达的深度优先树中A节点所在的强连通分量L中的第一个被访问的节点(根节点),且B节点是A的子孙节点(B!=A),DFS树中从A到B的路径上任意节点p(不包括A)均满足low[p]!=dfs[p],则B节点必属于L 证明：只需证明存在B到A的一条路径即可。由于low[B]&lt;dfs[B],根据low的定义,存在B或B的子孙节点中一个节点p1,满足存在从p1出发的一条有向边(p1, q1),使得(p1,q1)为横叉边,dfs[q1]=low[B]&lt;dfs[B],q1在B的左侧(因为dfs[q1]&lt;dfs[B]，故q1要么为B的祖先要么在B的左侧,若q1为B的祖先,则(p1,q1)为后退边，矛盾故q1在B的左侧)low[q1]!=dfsq1&nbsp;或者使得(p1,q1)为后退边,dfs[q1]=low[B]&lt;dfs[B],q1为B的祖先节点,这里先假设low[q1]!=dfs[q1],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1,其中S1为由以B为根的子树中树边构成的路径 下面考察节点q1,由于low[q1]&lt;dfs[q1],根据low的定义仿照上述讨论可知存在q1或q1的子孙节点中一个节点p2,满足存在从p2出发的一条有向边(p2, q2),使得(p2,q2)为横叉边,dfs[q2]=low[q1]&lt;dfs[q1],q2在q1的左侧,low[q2]!=dfs[q2]或者使得(p2,q2)为后退边,dfs[q2]=low[q1]&lt;dfs[q1],q2为q1的祖先节点,这里假设low[q2]!=dfs[q2],于是我们得到路径B-&gt;S1-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2,其中S2为由以q1为根的子树中树边构成的路径 按照这一步骤反复讨论下去，得到路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3——&nbsp; 其中dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]——&nbsp;注意DFS树中各节点的深度优先数dfs存在最小值(根节点的dfs值)，故前述步骤不可能无限进行下去，所以最终必然会到达节点qn-1,low[qn-1]&lt;dfs[qn-1],在考察qn-1时发现存在qn-1或qn-1的子孙节点中一个节点pn,满足存在从pn出发的一条有向边(pn, qn),使得(pn,qn)为后退边(pn,qn不可能为横叉边，否则按照上文讨论最后必有low[qn]!=dfs[qn]，这样讨论还会从qn继续进行下去,这和设讨论终止于qn-1矛盾),dfs[qn]=low[qn-1]&lt;dfs[qn-1],qn为qn-1的祖先节点,同时我们有low[qn]==dfsqn,于是最终有路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn,其中Sn为由以qn-1为根的子树中树边构成的路径,dfs[B]&gt;dfs[q1]&gt;dfs[q2]&gt;dfs[q3]&gt;—&gt;dfs[qn-1]&gt;dfs[qn] 现在考察qn,设以qn为根的子树为C,由于qn为qn-1的祖先故qn-1在子树C中，若(pn-1,qn-1)为后退边，则由上文讨论知,qn-1为qn-2的祖先节点，故qn-2在子树C中，若(pn-1,qn-1)为横叉边则由上文讨论知qn-1在qn-2的左侧,若qn-2不在子树C中,则qn-2在qn的右侧，从而为qn-2或为qn-2的子孙节点的pn-1也在qn的右侧,这样当从pn-1访问qn-1时，qn-1之前已经在回溯到qn时被弹出栈(qn-1在子树C中且low[qn]==dfs[qn])故不在栈中,而这是不可能的，因为根据对qn-2的讨论和low的定义,当在dfs过程中从pn-1访问qn-1时,qn-1必然在栈中且在pn-1之下，矛盾.故qn-2一定在子树C中 按照以上步骤循路径B-&gt;S2-&gt;p1-&gt;q1-&gt;S2-&gt;p2-&gt;q2-&gt;S3-&gt;p3-&gt;q3—— -&gt;qn-1-&gt;Sn-&gt;pn-&gt;qn不断向前回溯，可得qn-1,qn-2,—,q1,B均在子树C中结论一 现在注意dfs[qn]&lt;dfs[B],所以qn要么为B的祖先节点，要么在以B的某个祖先节点D的子女E为根的子树T中,这里E一定在为D的子女同时为B或B的祖先的节点F的左侧。如果是后者,由结论一知B在以B的某个祖先节点D的子女E为根的子树T中,E一定在为D的子女同时为B或B的祖先的节点F的左侧，这当然是不可能的 如果是前者,由low[qn]==dfs[qn]以及DFS树中从A到B的路径上任意节点p(不包括A,B)均满足low[p]!=dfs[p]知qn不可能为DFS树中从A到B的路径上任意节点(不包括A,B)，此外qn也不可能是A节点的任意祖先节点r,否则注意到存在B到qn=r的路径，同时存在r到A以及A到B的路径，故r和A相互可达。又low[qn]=low[r]=dfs[qn]=dfs[r],所以由定理二,r必为通过DFS所到达的深度优先树中该节点所在的强连通分量L2中的第一个被访问的节点(根节点),而r和A相互可达,从而强连通分量L完全真包含于强连通分量L2，这和L为极大强连通子图矛盾。综上qn只能为A节点本身 因此我们有low[A]=low[qn]=dfs[qn]=dfs[A],且由于存在从B到qn=A的路径和A到B的路径，所以A和B相互可达，从而B属于L，证毕 定理四:Tarjan算法的正确性：Tarjan算法运行结束时，每次从栈中弹出的所有节点的集合的集合构成了有向图的所有强连通分量 证明：首先，由于每个节点仅访问一次入栈一次出栈一次，故每次出栈的节点都是不同的节点，即每次出栈时弹出的所有节点两两不同，且任意两次出栈弹出的节点集合交集为空 其次，算法中当回溯至v并检测到low[v]==dfs[v]时，由定理二，v是dfs树中v所在的强连通分量L被第一个访问的节点(根节点)，再由定理一，此时栈中v及v之上的所有节点构成L的所有节点，它们会被依次出栈，这样出栈的所有节点即为L，构成有向图的一个强连通分量 再者，对于有向图的任意一个强连通分量L,设它在DFS树中的根节点为R(根据深度优先搜索的白色路径定理,R必定存在)，由定理三，Tarjan算法中回溯至R时有low[R]==dfs[R],再由定理一,此时栈中R及R之上的所有节点构成L的所有节点，它们会被依次出栈，出栈的所有节点即为该强连通分量L 最后，有向图中任意节点都必然会出栈，从而会归入某次出栈时出栈的节点组成的集合中 综上，定理四证完 PS:博主水平有限，如果以上证明存在疏漏或错误恳请指正，谢谢.Tarjan算法简单易实现，但是原理还是比较复杂的，不容易理解，不得不说Tarjan太强啦 PS:之前完成过错误的证明，写的时候信马由缰过于匆忙，写完又没有仔细检查，结果隔了一段时间再细细检查发现漏洞百出，连循环论证这种低级错误都出现，无奈只能全部推翻重来，经过仔细思考才得到以上证明]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>有向图，强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编译器构造中自底向上的LALR(1)语法分析的语法分析表生成的实现]]></title>
    <url>%2Fpost%2F61224.html</url>
    <content type="text"><![CDATA[提示：阅读本文需掌握编译原理的相关基础知识 本文中使用C++语言系统地实现了龙书中LALR(1)语法分析表的构造算法,首先计算增广文法的LR(0)项集族，每一个项集只包含内核项，计算过程中自动生成了LR(0)自动机,该自动机使用基于十字链表存储结构的有向图表示。然后通过确定自发生成和传播的向前看符号算法计算各LR(0)内核项集自发生成的向前看符号(增广文法新增产生式的向前看符号不包括在内)并确定LR(0)内核项集之间向前看符号的传播关系。最后一遍扫描前将为增广文法新增产生式添加向前看符号即输入结束符$，然后传播向前看符号直到不能传播为止，扫描结束后就生成了LALR(1)内核项集族。随后调用函数计算各LALR(1)项集的非内核项集确定LALR(1)项集族，并得到LALR(1)自动机。最后根据LALR(1)自动机填写LALR(1)语法分析表完成语法分析表的生成工作。 程序测试用例为博主自行编写的正则表达式文法(文法部分地方写得较别扭，而且并非反映正则表达式全部特性的文法，对正反向预查的支持存在一些问题，请读者见谅)，由于文法保存在文本中，需要由计算机读入分析，为了便于计算机理解需要将书写格式标准化,博主自行设计了书写格式，具体如下： #1b 非终结符 非终结符 —- #1e （非终结符号集合）#2b 终结符 终结符 —- #2e&nbsp;&nbsp; （终结符号集合）#3b 增广文法开始符号 原文法开始符号 #3e#4b#b 非终结符(产生式头) $1($2) 非终结符或终结符 $1($2) 非终结符或终结符 —- #e&nbsp; (产生式体)&nbsp;&nbsp; （$1标志非终结符，$2标志终结符，第一个产生式必须为增广产生式，第二个产生式必须为原文法以原文法开始符号为头的产生式）—-#4e 其中省略号表示相同格式子项的重复出现，按照以上格式书写的文法(该文法修改了无数遍，说多了都是泪)为： #1b S’ S preSurvey E T M F G outSquare B V C B’ inSquare inSquareRange #1e #2b \ SPECTRANMETA POSITIVE-SURE-PRE POSITIVE-NEGA-PRE NEGATIVE-SURE-PRE NEGATIVE-NEGA-PRE ) | CLOSURE ? GIVEN LBOUND ULBOUND CLOSURE-NONGREEDY LBOUND-NONGREEDY ULBOUND-NONGREEDY CAP NONPRECAP SPECTRAN TRANMETA UPPERALPHA LOWERALPHA DIGIT SPECMETA REVERSEREF ^ [ ] - OTHERMETA $ #2e #3b S’ S #3e #4b #b S’ $1 S #e #b S $1 E #e #b S $1 preSurvey #e #b preSurvey $1 E $2 POSITIVE-SURE-PRE $1 E $2 ) #e #b preSurvey $1 E $2 POSITIVE-NEGA-PRE $1 E $2 ) #e #b preSurvey $2 NEGATIVE-SURE-PRE $1 E $2 ) $1 E #e #b preSurvey $2 NEGATIVE-NEGA-PRE $1 E $2 ) $1 E #e #b E $1 E $2 | $1 T #e #b E $1 T #e #b T $1 T $1 M #e #b T $1 M #e #b M $1 M $2 CLOSURE #e #b M $1 M $2 ? #e #b M $1 M $2 GIVEN #e #b M $1 M $2 LBOUND #e #b M $1 M $2 ULBOUND #e #b M $1 M $2 CLOSURE-NONGREEDY #e #b M $1 M $2 LBOUND-NONGREEDY #e #b M $1 M $2 ULBOUND-NONGREEDY #e #b M $1 F #e #b F $2 CAP $1 E $2 ) #e #b F $1 G #e #b F $2 NONPRECAP $1 E $2 ) #e #b F $1 outSquare #e #b outSquare $2 SPECTRAN #e #b outSquare $2 TRANMETA #e #b outSquare $2 \ #e #b outSquare $2 SPECTRANMETA #e #b outSquare $2 UPPERALPHA #e #b outSquare $2 LOWERALPHA #e #b outSquare $2 DIGIT #e #b outSquare $2 SPECMETA #e #b outSquare $2 REVERSEREF #e #b outSquare $2 ^ #e #b G $2 [ $1 B $1 V $1 C $2 ] #e #b V $2 ^ #e #b V #e #b B $1 B $1 B’ #e #b B $1 B’ #e #b B’ $1 V $1 inSquareRange $2 - $1 inSquareRange #e #b inSquareRange $2 SPECTRAN #e #b inSquareRange $2 SPECMETA #e #b inSquareRange $2 OTHERMETA #e #b inSquareRange $2 UPPERALPHA #e #b inSquareRange $2 LOWERALPHA #e #b inSquareRange $2 DIGIT #e #b inSquareRange $2 CLOSURE #e #b inSquareRange $2 \ #e #b inSquareRange $2 SPECTRANMETA #e #b inSquareRange $2 ? #e #b inSquareRange $2 CAP #e #b inSquareRange $2 | #e #b inSquareRange $2 ) #e #b C $1 C $1 inSquare #e #b C $1 inSquare #e #b inSquare $1 inSquareRange #e #b inSquare $2 NONPRECAP #e #b inSquare $2 POSITIVE-SURE-PRE #e #b inSquare $2 POSITIVE-NEGA-PRE #e #b inSquare $2 NEGATIVE-SURE-PRE #e #b inSquare $2 NEGATIVE-NEGA-PRE #e #b inSquare $2 ULBOUND #e #b inSquare $2 LBOUND #e #b inSquare $2 ULBOUND-NONGREEDY #e #b inSquare $2 LBOUND-NONGREEDY #e #b inSquare $2 CLOSURE-NONGREEDY #e #b inSquare $2 GIVEN #e #b G $2 [ $1 B $2 ] #e #b G $2 [ $1 V $1 C $2 ] #e #4e #1b和#1e之间的部分为文法非终结符,#2b和#2e之间的部分为文法终结符,S’为增广文法开始符,S为原文法开始符 #4b和#4e之间的部分为产生式,紧跟于#b之后的是产生式头,随后为产生式体, $2表示紧跟其后的文法符号为终结符,$1表示紧跟其后的文法符号为非终结符，所有这些构成了对上下文无关文法的完整描述。这里非终结符、终结符以及产生式的含义博主会在将来发布的有关构建正则表达式引擎的文章中详解，现在只需着眼于文法本身，不必关心它们的具体含义。 需要另外说明的是，文法设计不当会导致一些异常现象的发生，例如如果把以上文法第三道产生式的产生式头的非终结符S改为F(这样就允许了预查表达式任意的自嵌套)，程序会在计算follow集时陷入死循环，原因是修改过的文法第6，7道产生式直接导致程序在计算出非终结符E的follow集前必须先计算出E的follow集，导致循环计算，这样计算follow集时会陷入死循环。可以验证，如果去掉产生式6、7程序就可以正常运行并输出结果(但是存在语法分析动作冲突)。 下面贴出代码 代码清单(C++): 见github&nbsp;地址&nbsp;https://github.com/naturerun/LALRAnalysisGenerator 注意，这里有两个头文件Priority_Queue.h和assistfunction.h。Priority_Queue.h存放的是博主自己实现的优先级队列类，之所以没有使用标准库提供的容器适配器是因为适配器实现的优先级队列缺少一些操作队列成员的必要方法，如以下代码中的begin(),end()且容器适配器提供的接口的调用约定和返回值不符号程序编写要求，此外优先级队列是用堆实现的，但计算LALR闭包的算法要求优先队列必须用数组实现，其成员按优先级从小到大排序，故楼主自行实现了优先级队列。Priority_Queue.h代码如下： 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include &lt;iostream&gt;#include &lt;list&gt;#include &lt;functional&gt;using namespace std;template &lt;typename T&gt;class Priority_Queue //设备等待队列类(优先级队列),队列数据元素为t&#123;public: typedef typename list&lt;T&gt;::iterator iterator; Priority_Queue() = default; Priority_Queue(const function&lt;bool(const T&amp;,const T&amp;)&gt; &amp;com) :comparator(com) &#123;&#125; ~Priority_Queue() = default; pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Insert(const T &amp;x); //插入操作,返回的pair的first指示插入是否成功,second为指向插入元素的迭代器 bool RemoveTop(T &amp;x); //删除最高优先级元素并用x将其返回 bool GetTop(T &amp;x) const; //获取最高优先级元素并用x将其返回 void MakeEmpty() &#123; Queue.clear(); &#125; //清空队列 bool isEmpty() const &#123; return Queue.empty(); &#125; //判断队列是否为空 bool isFull() const &#123; return Queue.size() == Queue.max_size(); &#125; //判断队列是否已满 typename Priority_Queue&lt;T&gt;::iterator erase(const typename Priority_Queue&lt;T&gt;::iterator &amp;p) &#123; return Queue.erase(p); &#125; //删除队列中p所指元素返回被删元素的下一元素 typename Priority_Queue&lt;T&gt;::iterator insert(const typename Priority_Queue&lt;T&gt;::iterator &amp;p, const T &amp;c) &#123; return Queue.insert(p, c); &#125; //将c插入至p所指位置,返回指向插入元素的迭代器 typename list&lt;T&gt;::size_type GetSize() const &#123; return Queue.size(); &#125; //获取队列实际大小 iterator begin() &#123; return Queue.begin(); &#125; //获取指向队列最高优先级元素的迭代器 iterator end() &#123; return Queue.end(); &#125; //获取队列尾后迭代器private: function&lt;bool(const T&amp;, const T&amp;)&gt; comparator; //比较T类型的可调用对象，左操作数小于右操作数返回true typename list&lt;T&gt;::iterator adjust(); //新元素加入队列后调整元素位置,使队列中各元素保持优先级关系 list&lt;T&gt; Queue;&#125;;template &lt;typename T&gt;typename list&lt;T&gt;::iterator Priority_Queue&lt;T&gt;::adjust()&#123; T temp = Queue.back(); auto p = Queue.end(); --p; p = Queue.erase(p); if (Queue.begin() != p) --p; else &#123; return Queue.insert(p, temp); &#125; while (true) &#123; if (comparator(temp, (*p))) &#123; if (p != Queue.begin()) &#123; --p; if (p == Queue.begin()) continue; &#125; &#125; else &#123; ++p; return Queue.insert(p, temp); &#125; if (p == Queue.begin()) break; &#125; return Queue.insert(p, temp);&#125;template &lt;typename T&gt;pair&lt;bool, typename Priority_Queue&lt;T&gt;::iterator&gt; Priority_Queue&lt;T&gt;::Insert(const T &amp;x)&#123; if (isFull()) return &#123; false, end() &#125;; else &#123; Queue.push_back(x); return &#123; true, adjust() &#125;; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::RemoveTop(T &amp;x)&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); Queue.pop_front(); return true; &#125;&#125;template &lt;typename T&gt;bool Priority_Queue&lt;T&gt;::GetTop(T &amp;x) const&#123; if (isEmpty()) return false; else &#123; x = Queue.front(); return true; &#125;&#125; 头文件assistfunction.h中定义了一些算法需要使用的辅助例程(只有第一个函数和算法有关，其他例程用于正则表达式引擎，后续会解读)，由于代码简洁易懂，不是很重要，这里就不详细解说了。 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;set&gt;#include&lt;map&gt;#include&lt;string&gt;void setToMap(const set&lt;string&gt; &amp;source, map&lt;string, int&gt; &amp;goal, int &amp;count)&#123; for (set&lt;string&gt;::iterator p = source.cbegin(); p != source.cend(); ++p) &#123; goal.insert(make_pair(*p, count++)); &#125;&#125;char strToChar(const string &amp;m)&#123; if (m.size() == 1) return m[0]; else if (m.size() == 2) &#123; switch (m[1]) &#123; case'f': return '\f'; case'n': return '\n'; case'r': return '\r'; case't': return'\t'; case'v': return'\v'; case'^': return'^'; case'-': return'-'; case'\\': return'\\'; case'*': return'*'; case'+': return'+'; case'?': return'?'; case'$': return'$'; case'.': return'.'; case'(': return'('; case')': return')'; case':': return':'; case'=': return'='; case'!': return'!'; case'&lt;': return'&lt;'; case'|': return'|'; case'[': return'['; case']': return']'; case'&#123;': return'&#123;'; case'&#125;': return'&#125;'; &#125; &#125;&#125;void insertIntoSet(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, const size_t &amp;source, const size_t &amp;goal)&#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator it = beinserted.find(goal); if (it == beinserted.end()) &#123; beinserted.insert(make_pair(goal, set&lt;size_t&gt;())).first-&gt;second.insert(source); &#125; else &#123; it-&gt;second.insert(source); &#125;&#125;void insertIntoMap(map&lt;size_t, set&lt;size_t&gt;&gt; &amp;beinserted, map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt; &amp;from)&#123; for (map&lt;size_t, map&lt;size_t, set&lt;size_t&gt;&gt;&gt;::iterator p = from.begin(); p != from.end(); ++p) &#123; for (map&lt;size_t, set&lt;size_t&gt;&gt;::iterator q = p-&gt;second.begin(); q != p-&gt;second.end(); ++q) &#123; map&lt;size_t, set&lt;size_t&gt;&gt;::iterator m = beinserted.find(q-&gt;first); if (m == beinserted.end()) &#123; beinserted.insert(make_pair(q-&gt;first, set&lt;size_t&gt;(q-&gt;second))); &#125; else &#123; m-&gt;second.insert(q-&gt;second.begin(), q-&gt;second.end()); &#125; &#125; &#125;&#125;void insertIntoMap(map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt; &amp;end, size_t substart, size_t subend, size_t sub_start_stackindex, size_t sub_end_stackindex)&#123; map&lt;size_t, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;&gt;::iterator p = end.find(subend); if (p == end.end()) &#123; end.insert(make_pair(subend, map&lt;size_t, map&lt;size_t, size_t&gt;&gt;())).first-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; map&lt;size_t, map&lt;size_t, size_t&gt;&gt;::iterator q = p-&gt;second.find(substart); if (q == p-&gt;second.end()) &#123; p-&gt;second.insert(make_pair(substart, map&lt;size_t, size_t&gt;())).first-&gt;second.insert(make_pair(sub_start_stackindex, sub_end_stackindex)); &#125; else &#123; q-&gt;second[sub_start_stackindex] = sub_end_stackindex; &#125; &#125;&#125; &nbsp;程序的使用方法请参看main函数中的注释，分析结果会输出至指定文件，文件中加入了必要的逗号分隔符，将其扩展名改为csv用excel打开即可看到经整理的分析结果，如果文法不是LALR(1)的，程序运行时在命令行窗口上会打印语法分析动作冲突的相关信息。注意如果自定义文法进行测试文法需设计合理，避免存在逻辑错误，否则程序可能会陷入死循环或抛出异常。博主给出的示例文法可以得到分析结果且无语法分析冲突，可以把示例文法拷贝至输入文件中测试。 PS：本人微信号memoryundersun，欢迎各位同仁主动联系我，大家一起学习一起进步 2018.11.14重要更新 先前提到过改动文法会导致在计算follow集时陷入死循环,原因是循环依赖链造成的间接循环依赖，非终结符E的follow集依赖于另一个非终结符，另一个又依赖其他非终结符的follow集——这种依赖关系最终会延伸到E自身，造成E的follow集依赖于E的follow集的间接循环依赖。原先计算follow的算法不适用于间接循环依赖的情况，会陷入死循环，因而是错误的，所以简单调整一下follow集的计算算法，该算法中能够计算出follow集的非终结符最终会分离出去，剩下的是位于循环依赖链上的非终结符，此时对依赖链上的非终结符按照依赖关系反复迭代直到这些follow集的非终结符不再增大即可，最后把依赖链上非终结符follow集的计算结果加入已计算出follow集的非终结符表。分离出已计算出follow集的非终结符以避免对计算完成的非终结符的无效迭代，将非终结符依赖的其他非终结符从依赖关系中删去，并把被删去的非终结符的follow集的计算结果添加到被依赖非终结符的计算结果中以避免依赖非终结符对被依赖终结符的无效迭代。如果某一轮循环已完成follow集计算的非终结符构成的表不再增大，那么表中非终结符和尚未完成计算的非终结符依赖的非终结符集合交集始终为空集，故求交运算可以跳过，这些为必要的优化处理 修改过的follow集计算算法如下：(应该没有错误了，如果有请提出) 点击显/隐内容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; LALRAutomata::calculateFollow()&#123; enum class GeneratingCycles &#123;CURRENT_CYCLE, PREVIOUS_CYCLE&#125;; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt; temp; //非终结符,当前follow，新增follow,依赖符号,是否计算完成 map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt; pre_and_cur_cycle_finish_follow_compute_info; //非终结符 产生轮次 temp中对应项迭代器 &#123; auto h = temp.insert(make_pair(AugGraSS, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;0&gt;(h-&gt;second).insert("$"); get&lt;1&gt;(h-&gt;second).insert("$"); &#125; for (map&lt;long, tuple&lt;string, vector&lt;ProductionBodySymbol&gt;, set&lt;string&gt;&gt;&gt;::iterator p = productionSet.begin(); p != productionSet.end(); ++p) &#123; for (vector&lt;ProductionBodySymbol&gt;::size_type i = 0; i &lt; get&lt;1&gt;(p-&gt;second).size(); ++i) &#123; if (get&lt;1&gt;(p-&gt;second)[i].TerminalOrNot == false) &#123; if (i == get&lt;1&gt;(p-&gt;second).size() - 1) &#123; map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; shared_ptr&lt;set&lt;string&gt;&gt; q = calculateFirst(get&lt;1&gt;(p-&gt;second), i + 1, get&lt;1&gt;(p-&gt;second).size() - 1); map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator it = temp.insert(make_pair(get&lt;1&gt;(p-&gt;second)[i].symbol, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;())).first; if (*(q-&gt;begin()) == "") &#123; set&lt;string&gt;::iterator w = q-&gt;begin(); get&lt;0&gt;(it-&gt;second).insert(++w, q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(w, q-&gt;end()); get&lt;2&gt;(it-&gt;second).insert(get&lt;0&gt;(p-&gt;second)); &#125; else &#123; get&lt;0&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); get&lt;1&gt;(it-&gt;second).insert(q-&gt;begin(), q-&gt;end()); &#125; &#125; &#125; &#125; &#125; for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; set&lt;string&gt;::iterator tempit; if ((tempit = get&lt;2&gt;(p-&gt;second).find(p-&gt;first)) != get&lt;2&gt;(p-&gt;second).end()) &#123; get&lt;2&gt;(p-&gt;second).erase(tempit); if (get&lt;2&gt;(p-&gt;second).empty() == true) &#123; get&lt;3&gt;(p-&gt;second) = true; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::PREVIOUS_CYCLE, p))); &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; else &#123; get&lt;3&gt;(p-&gt;second) = false; &#125; &#125; &#125; bool first_set_has_changed = false; bool result_has_changed = false; bool result_has_changed_previous_run = true; bool is_first_cycle = true; while (true) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator n = pre_and_cur_cycle_finish_follow_compute_info.begin(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; if (get&lt;3&gt;(p-&gt;second) == true) &#123; if (pre_and_cur_cycle_finish_follow_compute_info.find(p-&gt;first) == pre_and_cur_cycle_finish_follow_compute_info.end()) get&lt;1&gt;(p-&gt;second).clear(); continue; &#125; if (is_first_cycle == false) &#123; get&lt;1&gt;(p-&gt;second).clear(); &#125; set&lt;string&gt;::size_type size = get&lt;0&gt;(p-&gt;second).size(); if (result_has_changed_previous_run) &#123; map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator itleft = pre_and_cur_cycle_finish_follow_compute_info.begin(); set&lt;string&gt;::iterator itright = get&lt;2&gt;(p-&gt;second).begin(); while (itleft != pre_and_cur_cycle_finish_follow_compute_info.end() &amp;&amp; itright != get&lt;2&gt;(p-&gt;second).end()) &#123; if (itleft-&gt;first == *itright) &#123; computeDifferenceSet(get&lt;1&gt;(itleft-&gt;second.second-&gt;second), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); itright = get&lt;2&gt;(p-&gt;second).erase(itright); ++itleft; &#125; else if (itleft-&gt;first &lt; *itright) &#123; ++itleft; &#125; else &#123; ++itright; &#125; &#125; if (get&lt;2&gt;(p-&gt;second).empty()) &#123; pre_and_cur_cycle_finish_follow_compute_info.insert(make_pair(p-&gt;first, make_pair(GeneratingCycles::CURRENT_CYCLE, p))); get&lt;3&gt;(p-&gt;second) = true; result_has_changed = true; continue; &#125; &#125; for (set&lt;string&gt;::iterator m = get&lt;2&gt;(p-&gt;second).begin(); m != get&lt;2&gt;(p-&gt;second).end(); ++m) &#123; computeDifferenceSet(get&lt;1&gt;(temp[*m]), get&lt;0&gt;(p-&gt;second), get&lt;1&gt;(p-&gt;second), false); &#125; if (get&lt;0&gt;(p-&gt;second).size() != size) &#123; first_set_has_changed = true; &#125; if (n != pre_and_cur_cycle_finish_follow_compute_info.end()) &#123; if (p-&gt;first == n-&gt;first) &#123; if (n-&gt;second.first == GeneratingCycles::CURRENT_CYCLE) &#123; ++n; &#125; else &#123; n = pre_and_cur_cycle_finish_follow_compute_info.erase(n); &#125; &#125; &#125; &#125; if (!first_set_has_changed &amp;&amp; !result_has_changed) &#123; break; &#125; else &#123; result_has_changed_previous_run = result_has_changed; first_set_has_changed = false; result_has_changed = false; &#125; if (is_first_cycle) is_first_cycle = false; for (map&lt;string, pair&lt;GeneratingCycles, map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator&gt;&gt;::iterator temp = pre_and_cur_cycle_finish_follow_compute_info.begin(); temp != pre_and_cur_cycle_finish_follow_compute_info.end(); ++temp) &#123; temp-&gt;second.first = GeneratingCycles::CURRENT_CYCLE; &#125; &#125; shared_ptr&lt;map&lt;string, set&lt;string&gt;&gt;&gt; result = make_shared&lt;map&lt;string, set&lt;string&gt;&gt;&gt;(); for (map&lt;string, tuple&lt;set&lt;string&gt;, set&lt;string&gt;, set&lt;string&gt;, bool&gt;&gt;::iterator p = temp.begin(); p != temp.end(); ++p) &#123; result-&gt;insert(make_pair(p-&gt;first, set&lt;string&gt;())).first-&gt;second.insert(get&lt;0&gt;(p-&gt;second).begin(), get&lt;0&gt;(p-&gt;second).end()); &#125; return result;&#125; &nbsp;78-170行为迭代求解的核心步骤 主程序代码也进行了更新 2019.1.15更新 对LALR(1)自动机构造算法进行了优化，避免明显不等LALR项之间的冗余比较，提升生成性能 优化了LALR闭包生成算法，避免对相同非内核项点号右边符号串first集不必要的计算 2019.4.25更新 新增了firstK和followK集的生成算法，详见github readme文件]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>自底向上的语法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生成所有错位排列的算法]]></title>
    <url>%2Fpost%2F43861.html</url>
    <content type="text"><![CDATA[所谓N元错位排列，就是指对应于1,2,–,N的N元排列Im(m=1,2,—,N),满足Im!=m，算法的目的是构造出所有这样的错位排列，依据的基本思想是回溯法，在沿栈向下试探的过程中逐步扩大部分错位排列的规模，当发现无法找到下一个部分错位排列的元素时就向上回溯，继续试探,当当回溯至栈空间首元素且栈空间首元素stack[0]==N+1时，表明首元素为2,–,N的所有错位排列已全部试探得到，错位排列生成完毕，退出循环。这里给出算法，该算法生成对应于1,2,—,N的所有N元错位排列 代码(C++) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;#define N 5 //问题规模，生成对应于1,2,---,N的所有N元错位排列int Search(const vector&lt;bool&gt; &amp;occupy, int i ,int j)&#123; for (; i &lt; occupy.size(); ++i) &#123; if (i + 1 != j &amp;&amp; occupy[i] == false) &#123; return i + 1; &#125; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; a(N, 0); vector&lt;bool&gt; occupy(N, false); //对于栈中已生成的错位排列中的任意值i,occupy[i-1]==true,对于1,2---,N中不在错位排列栈中的任意元素i,occupy[i-1]=false bool TF = true; //循环过程中回溯至本层为false,前进至本层为true int i = 0; //存放错位排列的栈的栈顶指针 int count = 0; //统计错位排列数 while (true) &#123; if (i == 0) &#123; if (TF == true) &#123; a[i] = 2; occupy[a[i] - 1] = true; ++i; &#125; else &#123; occupy[a[i] - 1] = false; ++a[i]; if (a[i] &gt; N) break; occupy[a[i] - 1] = true; ++i; TF = true; &#125; &#125; else &#123; int temp; if (TF == true) &#123; if ((temp = Search(occupy, 0, i + 1)) == 0) &#123; --i; TF = false; continue; &#125; else &#123; a[i] = temp; occupy[temp-1] = true; &#125; &#125; else &#123; if ((temp = Search(occupy, a[i], i + 1)) == 0) &#123; occupy[a[i] - 1] = false; --i; continue; &#125; else &#123; occupy[a[i] - 1] = false; a[i] = temp; occupy[temp - 1] = true; &#125; &#125; if (i != a.size() - 1) &#123; ++i; TF = true; &#125; else &#123; ++count; cout &lt;&lt; "第"&lt;&lt;count&lt;&lt;"个错位排列:" &lt;&lt; endl; for (const int &amp;m : a) &#123; cout &lt;&lt; m &lt;&lt; " "; &#125; cout &lt;&lt; endl; for (int j = 1; j &lt;= N; ++j) &#123; cout &lt;&lt; j &lt;&lt; " "; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; &#125; &#125; return 0;&#125; 运行结果(N=5时)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>错位排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多重全排列的生成与构造算法]]></title>
    <url>%2Fpost%2F16162.html</url>
    <content type="text"><![CDATA[设有a1+a2+—+aK=N，a1,a2,—,aK为正整数(K&gt;=2),将a[1],a[2],—,a[K]K个数排列至1,2,—N这N个排列位置上，使得a[1],a[2],—,a[K]所占据的排列位置数恰好分别为a1,a2,—,aK，这样占据1,2,—NN个排列位置的a[1],a[2],—,a[K]构成的排列为一个排列位置数为N，排列数数目为K的多重全排列。 现在介绍算法，该算法能够生成符合上述要求的所有多重全排列 说明：以下二种算法仅适用于k&gt;=2的情形,k=1为特殊情形我没有专门处理，不处理问题也不大 算法一(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：思路简单代码易于理解，代码简单。基本思路为在栈中回溯和向前试探，向前试探寻找满足容量上限的下一个候选数，从而扩大候选解的规模，候选解规模达到N即得到一个多重全排列。无法发现符合容量上限的下一个候选数即回溯 C++代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;const int K = 3;const int N = 5;int search(int start, const vector&lt;int&gt; &amp;num, const vector&lt;int&gt; &amp;count) //从start开始顺序查找满足容量限制的第一个数字，查找失败返回0，否则返回找到的数字&#123; for (; start &lt;= K; ++start) &#123; if (num[start - 1] + 1 &lt;= count[start - 1]) return start; &#125; return 0;&#125;int main()&#123; vector&lt;int&gt; count&#123; 2, 1, 2 &#125;; //a1,---,ak值 vector&lt;int&gt; num(count.size(), 0); //统计循环过程中1,---,k的数目 vector&lt;int&gt; arrange(N, 0); //存放找到的多重全排列的栈结构 int i = 1; //栈顶指针 int number = 0; bool TF = true; //回溯标志 while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; arrange[i - 1] = 1; ++num[0]; ++i; &#125; else &#123; --num[arrange[i - 1] - 1]; ++arrange[i - 1]; if (arrange[i-1] &gt; K) &#123; break; &#125; else &#123; ++num[arrange[i - 1] - 1]; ++i; TF = true; &#125; &#125; &#125; else &#123; if (TF == true) &#123; arrange[i - 1] = search(1, num, count); ++num[arrange[i - 1] - 1]; &#125; else &#123; int temp; if ((temp = search(arrange[i - 1] + 1, num, count)) == 0) &#123; --num[arrange[i - 1] - 1]; --i; continue; &#125; else &#123; --num[arrange[i - 1] - 1]; arrange[i - 1] = temp; ++num[arrange[i - 1] - 1]; &#125; &#125; if (i == N) //找到一个多重全排列输出 &#123; ++number; cout &lt;&lt; "第" &lt;&lt; number &lt;&lt; "个多重全排列:"; for (const int &amp;m : arrange) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果： 算法二(K=3,N=5,a1=2,a2=1,a3=2,a[i]=i)：代码相对而言更复杂，方法较笨，就是单纯地模拟手工寻找多重全排列的过程，该过程中按a[1],—,a[k]的顺序逐一选择子排列，成功找到子排列则向前试探扩大候选解的规模寻找下一个，当a[1],—,a[k]的所有子排列全部找到后即获得一个多重全排列，当已无新的子排列可供选择时即回溯 C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188#include "stdafx.h"#include &lt;vector&gt;#include &lt;iostream&gt;using namespace std;bool find(bool TF, int n, int k, vector&lt;int&gt; &amp;temp) //TF==true，函数从头寻找满足1&lt;=a1&lt;--&lt;ak&lt;=n的第一个排列a1,a2,--,ak存放在temp中&#123; //TF==false,函数寻找上一次找到的存放在temp中满足1&lt;=a1&lt;--&lt;ak&lt;=n的排列a1,a2,--,ak的下一个排列，找到存放在temp中返回true,找不到返回false int i; if (TF == true) &#123; i = 0; &#125; else &#123; i = k - 1; &#125; while (1) &#123; if (i == 0) &#123; if (TF == true) &#123; temp[i] = 1; &#125; else &#123; temp[i]++; &#125; if (temp[i] &gt; n - k + 1) return false; if (k == 1) return true; i++; TF = true; &#125; else &#123; if (TF == true) temp[i] = temp[i - 1] + 1; else &#123; temp[i]++; if ((temp[i] - temp[i - 1])&gt;(n - temp[i - 1]) - (k - i) + 1) &#123; i--; TF = false; continue; &#125; &#125; if (i == k - 1) &#123; return true; &#125; i++; TF = true; &#125; &#125;&#125;const int K = 3;const int N = 5;struct back&#123; vector&lt;int&gt; sub; //存放find函数找到的多重全排列中的一个子排列的排列位置 vector&lt;int&gt; father; //存放多重全排列所有N个排列位置被与其对应的sub子排列之前的所有排列占据后剩下的排列位置 back(int k) :sub(k, 0) &#123;&#125;&#125;;void diffset(vector&lt;back&gt; &amp;stack, const vector&lt;int&gt; &amp;count) //计算father和sub的差集，得到sub的下一排列可取得排列位置&#123; int i = 0; int j = 0; back temp(count[stack.size()]); while (i &lt; stack.back().father.size() &amp;&amp; j &lt; stack.back().sub.size()) &#123; if (i + 1 &lt; stack.back().sub[j]) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; else if (i + 1 &gt; stack.back().sub[j]) &#123; ++j; &#125; else &#123; ++i; ++j; &#125; &#125; while (i &lt; stack.back().father.size()) &#123; temp.father.push_back(stack.back().father[i]); ++i; &#125; stack.push_back(temp);&#125;int main()&#123; vector&lt;int&gt; count&#123;2, 1, 2&#125;; //a1,---,ak值 int i = 1; //循环当前正在处理的子排列序号 int num = 0; //多重全排列计数 bool TF = true; //回溯标志,true前进至本层,false回溯至本层 vector&lt;back&gt; stack; while (true) &#123; if (i == 1) &#123; if (TF == true) &#123; stack.push_back(back(count[0])); find(true, N, count[i - 1], stack.back().sub); for (int j = 1; j &lt;= N; j++) stack.back().father.push_back(j); ++i; &#125; else &#123; if (find(false, N, count[i-1], stack.back().sub) == true) &#123; ++i; TF = true; &#125; else &#123; break; &#125; &#125; &#125; else &#123; if (TF == true) &#123; diffset(stack, count); find(true, stack.back().father.size(), count[i - 1], stack.back().sub); &#125; else &#123; if (find(false, stack.back().father.size(), count[i - 1], stack.back().sub) == false) &#123; stack.pop_back(); --i; continue; &#125; &#125; if (i == K) //找到一个多重全排列，输出 &#123; ++num; vector&lt;int&gt; temp(N, 0); for (vector&lt;back&gt;::size_type i = 0; i &lt; stack.size(); ++i) &#123; for (vector&lt;int&gt;::size_type j = 0; j &lt; stack[i].sub.size(); ++j) &#123; temp[stack[i].father[stack[i].sub[j] - 1] - 1] = i + 1; &#125; &#125; cout &lt;&lt; "第" &lt;&lt; num &lt;&lt; "个多重排列:"; for (const int &amp;m : temp) &#123; cout &lt;&lt; m; &#125; cout &lt;&lt; endl; cout &lt;&lt; endl; TF = false; &#125; else &#123; ++i; TF = true; &#125; &#125; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>全排列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表排序结果的重排算法正确性证明]]></title>
    <url>%2Fpost%2F12324.html</url>
    <content type="text"><![CDATA[殷人昆数据结构(第二版)C++语言描述p428介绍了静态链表排序结果的重排算法，书中用具体的重排实例完整地演绎了重排算法，但是书中没有给出算法的正确性证明，本文完整地描述了重排算法并给出正确性证明。 所谓静态链表排序结果的重排，就是重新安排已完成排序的静态链表中各元素的物理存放顺序，使静态链表中各元素的物理位置关系和逻辑顺序(从小到大)保持一致，整个重排过程不能借助辅助存储空间，即直接在排好序的静态链表上进行操作，实现元素的重排 要证明重排算法的正确性，需要寻找循环不变式并证明每轮循环结束时循环不变式保持不变 算法的完整描述(该伪代码的正确性我没有验证过，如有错误请指出) 输入数据：已完成排序的静态链表L,L[0]为附加头节点，它的link域存放指向链表中已排好序的元素序列中最小元素所在数据单元的指针 初始化：head = L[0].link for (i from 1 to n-1) //n为被重排的元素序列长度，为静态链表数组长度减一 &nbsp; if (head&lt;=i-1)&nbsp; then &nbsp; &nbsp; &nbsp;j=head &nbsp; &nbsp; &nbsp;while(j&lt;=i-1) &nbsp; &nbsp; &nbsp; &nbsp; j=L[j].link &nbsp; &nbsp; &nbsp;end while &nbsp; else &nbsp; &nbsp; j=head &nbsp; end if &nbsp; if (j==i) then &nbsp; &nbsp; head=L[i].link &nbsp; &nbsp; L[i].link=i &nbsp; else &nbsp; &nbsp; swap(L[i].data, L[j].data) &nbsp; &nbsp; head=L[j].link &nbsp; &nbsp; L[j].link=L[i].link &nbsp; &nbsp; L[i].link=j &nbsp; end if end for&nbsp; &nbsp; 循环不变式是，重排过程中第i轮循环开始时,原排好序的静态链表中最小，第2小，—–第i-1小的元素已顺序存放于当前静态链表数组L[1], L[2],—,L[i-1]存储单元中,head为原排好序的静态链表中第i小的元素在原排好序的静态链表中的下标，L[i], L[i+1],—,L[n]的link域分别为L[i].data, L[i+1].data,—,L[n].data在原排好序的静态链表中的有序元素序列中的后继元素在原排好序的静态链表中的下标 此外，还需要注意算法的执行特点：在第i轮循环中，算法只执行一次交换，这次交换要么是数据单元L[i]和其自身的交换要么是L[i]和其后继数据单元Lj的交换，这次交换是在L[i]上进行的最后一次交换，一旦交换完成L[i]此后就不会发生任何交换,L[i].data值直到算法结束都保持不变,该保持不变的值所在位置下标i就是算法结束后生成的重排结果中该值所在位置下标，即i就是该值重排后在静态链表数组中的位置。了解这一点后就可以着手证明算法的正确性了，证明如下： &nbsp;显然根据初始化条件,第一轮循环开始时上述循环不变式成立，现设第i轮循环开始时循环不变式成立，此时若(head==j)&lt;=i-1,那么根据算法的执行特点,L[j]的最后一次交换已经结束，可以断言在L[j]的最后一次交换前L[j]没有发生任何交换，若不然取L[j]最后一次交换前发生的诸交换中最先发生的交换，根据算法的执行特点该交换只能是L[j]和Lbefore的交换，且很显然交换前L[j].data就是原排好序的静态链表中第i小的值,这是因为交换前L[j].data等于原排好序的静态链表中L[j]的data域，而根据循环不变式,j为第i小的元素在原排好序的静态链表中的下标，所以交换前L[j].data就是原排好序的静态链表中第i小的值。而L[j]和L[before]的交换就是L[before]发生的最后一次交换,因此根据算法的执行特点，L[j]和L[before]的交换发生后，第i小的元素值会被放置在L[before].data中，此后L[before].data始终为第i小的元素值，保持不变。这样进入第i轮循环时L[before].data&nbsp;仍为第i小元素值,但根据循环不变式此时L[before].data应为第before(1&lt;=before&lt;i)小元素值,矛盾，因此在L[j]的最后一次交换前L[j]没有发生任何交换,L[j]的最后一次交换就是L[j]发生的唯一一次交换。另外L[j]的最后一次交换不可能是和其自身的交换，否则L[j].data在最后一次交换交换前的值(根据前文分析它就是第i小的元素值)交换后仍保持不变，根据算法执行特点，该将一直保持不变，直到第i轮循环开始时L[j].data仍为L[j]和自身交换前的原值，于是原值即第i小的元素值在第i轮循环开始时位于静态链表数组的j(1&lt;=j&lt;=i-1)位置,根据循环不变式此时j位置存放的是第j小的元素值，矛盾。因此L[j]的最后一次交换是和它后继项Lm1的交换，若m1&lt;=i-1,那么在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换,否则取L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]最先发生的交换,根据算法的执行特点这一交换是L[m1]和Ltemp的交换，同时也是L[temp]的最后一次交换(该交换发生后L[temp].data为第i小元素值)，按照和以上相关分析类似的方法进行分析可知第i轮循环开始时第i小元素值存放于temp位置和循环不变式矛盾，因此在L[m1]的最后一次交换前L[j]的最后一次交换后L[m1]没有发生任何交换，这样L[m1]最后一次交换发生时L[m1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m1].link为原排好序的静态链表中L[j].link的值,类似分析知L[m1]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm2的交换，这样L[m1]的最后一次交换完成后L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值,若m2&lt;=i-1,那么同理知L[m1]的最后一次交换后L[m2]的最后一次交换前L[m2]没有发生任何交换，这样L[m2]最后一次交换发生时L[m2].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m2].link为原排好序的静态链表中L[j].link的值，类似分析知L[m2]的最后一次交换不可能是和其自身的交换，必为和其后继项Lm3的交换，这样L[m2]的最后一次交换完成后L[m3].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[m3].link为原排好序的静态链表中L[j].link的值,若m3&lt;=i-1———- 按照这一步骤反复进行下去，我们得到第i轮循环开始前,原排好序的静态链表中L[j]的data,link域通过交换从L[j]移至L[m1],然后从L[m1]移至L[m2],接着从L[m2]移至L[m3]——- j&lt;m1&lt;m2&lt;m3&lt;——&nbsp;且j&lt;=i-1 m1&lt;=i-1 m2&lt;=i-1 m3&lt;=i-1 ——— 由于i-1为有限值所以这一过程不可能无限进行下去,所以必存在k使得Lmk最后一次交换发生时L[mk].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk].link为原排好序的静态链表中L[j].link的值，类似分析知L[mk]的最后一次交换不可能是和其自身的交换，必为和其后继项Lmk+1的交换，这样L[mk]的最后一次交换完成后L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值,而mk+1&gt;i-1(这里要做一点说明,L[q]和L[s]交换时(q&lt;=s)，前者data,link送至后者对应域,后者data送至前者data,后者下标送至前者link,这是上述算法中交换操作的定义，根据以上分析，按照该定义L[j]和L[m1]交换后L[j].link==m1,L[ms]和Lms+1交换后L[ms].link==ms+1,按照算法的执行特点，交换后L[j].link和L[ms].link会一直保持不变，因此第i轮循环开始时L[j].link和L[ms].link仍为交换后的值。这样，第i轮循环开始时，我们可以从L[j]开始，循link域向后搜索最终找到L[mk+1]),另外在L[mk]和L[mk+1]交换后，第i轮循环开始之前,L[mk+1]必定没有发生过任何交换(否则取最先发生的交换，它只能是L[mk+1]和Lq的交换,这样L[mk+1].data也就是第i小元素值会被送入L[q].data,通过和上述类似的分析可以导出矛盾)，这样第i轮循环开始时L[mk+1].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，于是此时若mk+1==i,&nbsp;令head =L[i].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标,然后L[i].data不变,将i送入L[i].link，这样做的目的是保证L[i]的操作符合算法中交换操作的定义，这样在i+1轮循环和以后的循环中基于该定义的本文证明才能保持有效，另外不难验证此时i+1轮循环的循环不变式得到满足(循环不变式中也可添加L[1]—L[i-1]的移动操作符合定义，但没有必要，因为在算法中已经体现，是隐含的)。若此时,mk+1&gt;i,则令head=L[mk+1].link,这样head为第i+1小元素值在原排好序的静态链表中的存放下标，然后交换L[i]和L[mk+1]的data,L[i].link送入L[mk+1].link,mk+1送入L[i].link,这样做的理由同上，此时不难验证循环不变式同样得到满足 &nbsp; 若(head==j)&gt;i-1,可以证明第i轮循环开始之前L[j]没有发生任何交换,若不然取最先发生的交换，该交换必然为L[j]和Lq的交换，这样L[j].data即第i大元素值被送入L[q].data，通过和上述类似的分析可以导出矛盾。这样第i轮循环开始时L[j==head].data为第i小元素值(原排好序的静态链表中L[j].data的值),L[mk+1].link为原排好序的静态链表中L[j].link的值，接来进行的是L[j]和L[mk+1]的交换操作细节和理由和上文所述相同，操作结束后循环不变式成立 综上若第i轮循环开始时循环不变式成立，则算法在第i轮循环中执行完毕后，循环不变式仍成立。于是由归纳法,第n-1轮循环结束后循环不变式成立。此时经过一系列交换操作后,最小，第二小，—-，第n-1小的元素值被有序存放在数组单元L[1],L[2],L[n-1]中,数组L[n]中存放的当然为最大元素值，静态链表重排完毕，算法执行结果正确，证毕]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>静态链表，排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B树的插入和删除]]></title>
    <url>%2Fpost%2F15410.html</url>
    <content type="text"><![CDATA[B树的删除(仅考虑阶数m&gt;=3的情形) 在非叶节点中删除关键码，只需从关键码右侧指针指向的子树中寻找最小关键码(沿最左侧指针向下走到叶节点，叶节点最左侧关键码即是)替换该关键码，并从最小关键码所在叶节点删除该最小关键码即可。这样只讨论在叶节点中删除关键码。 在叶节点中删除给定关键码，先删去该关键码及其右侧空指针，然后若该叶节点为根节点，则删除操作结束(删除后的B树可能为空树)，若该叶节点不为根节点且关键码数大于等于ceil(m/2)-1,则删除操作结束。若该叶节点不为根节点且关键码数等于ceil(m/2)-2，则令该叶节点为当前节点，然后 设删除过程中当前节点关键数等于ceil(m/2)-2. 若当前节点为根节点且关键码数为0，则令根节点指针指向根节点唯一子树,删除根节点，删除操作结束 若当前节点不为根节点，则若该节点有右兄弟节点且右兄弟节点关键码数大于等于ceil(m/2)，则将父节点指向当前节点的指针右侧关键码下移至当前节点最右侧，将右兄弟节点最左侧指针移至当前节点最右侧，最后将右兄弟最左侧关键码上移至父节点指向其指针的左侧，删除操作结束。 若当前节点不为根节点，有右兄弟且右兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针右侧关键码下移至当前节点最右侧，然后将右兄弟完整拼接至当前节点右侧，随后删除右兄弟节点和父节点中指向它的指针。此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 若当前节点不为根节点，没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2),则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟最右侧关键码上移至父节点中指向它的指针右侧关键码位置，左兄弟最右侧指针移至当前节点最左端，随后删除操作结束 若当前节点不为根节点，没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2)-1,则将父节点中指向当前节点的指针左侧关键码下移至当前节点最左端，左兄弟完整拼接至当前节点左侧，删除左兄弟和父节点中指向它的指针，此时父节点关键码子树数减一，若父节点为根节点且关键码数为0则回溯至父节点否则删除操作结束；若父节点不为根节点且关键码数大于等于ceil(m/2)-1，则删除操作结束；若父节点不为根节点且关键码数等于ceil(m/2)-2,则回溯至父节点 &nbsp; B树的插入(仅考虑阶数m&gt;=3的情形) 在空树中插入直接新建根节点，两指针域置空，填入关键码,再令root指向根节点 若在非空树中插入 那么仅在叶节点上插入，通过搜索在叶节点中找到插入位置，将关键码和空指针构成的二元组插入至叶节点，若插入后叶节点关键码数小于等于m-1则插入结束，否则令叶节点为当前节点 现设插入过程中当前节点关键码数为m，以当前节点从左至右第ceil(m/2)个关键码为分割点将当前节点分隔为左右两部分(即分割点左侧和右侧的部分),左侧分割部分为原当前节点，若原当前节点为根节点，则直接新建根节点，两指针域分别指向左右分割部分，中间关键码即为原当前节点第ceil(m/2)个关键码，令root指向新根节点插入结束。 若原当前节点不为根节点，则将右侧分割部分的指针和原当前节点第ceil(m/2)个关键码构成的二元组插入至父节点中原当前节点对应的二元组右侧，此时父节点关键码子树数增一，若父节点关键码数小于等于m-1则插入结束，若父节点关键码数等于m,则以父节点为当前节点，回溯处理 &nbsp;插入和删除的C++实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;ctime&gt;#include &lt;random&gt;using namespace std;const int M = 4; //B树阶数template &lt;typename T&gt;struct BTreeNode&#123; struct BranchNode &#123; BTreeNode* p; vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt; keyptrmap; //节点数据域和指针域 BranchNode() :keyptrmap(), p(nullptr) &#123;&#125; &#125;; union &#123; vector&lt;T&gt; *leaf_data; BranchNode* branch_data; &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BTreeNode(flag type_of_node) &#123; NodeFlag = type_of_node; if (type_of_node == branch) &#123; branch_data = new BranchNode(); &#125; else &#123; leaf_data = new vector&lt;T&gt;(); &#125; &#125; ~BTreeNode() &#123; if (NodeFlag == branch) &#123; delete branch_data; &#125; else &#123; delete leaf_data; &#125; &#125;&#125;;template &lt;typename T&gt;pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; SearchBTreeNode(BTreeNode&lt;T&gt;* ptr, pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d) //返回值：尾后+fasle表示第一指针,尾后+true表示失败,非尾后+true即为对应指针&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator m; //实参pair:尾后+false表示从第一指针后一指针开始搜索,尾后+true表示从头搜索,非尾后+true表示从非尾后后一位置开始搜索 if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), true)) &#123; if (ptr-&gt;branch_data-&gt;p != nullptr) return &#123; d.first, false &#125;; m = ptr-&gt;branch_data-&gt;keyptrmap.begin(); &#125; else if (d == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), false)) &#123; m = ptr-&gt;branch_data-&gt;keyptrmap.begin(); &#125; else &#123; m = d.first; ++m; &#125; for (; m != ptr-&gt;branch_data-&gt;keyptrmap.end(); ++m) &#123; if (m-&gt;second != nullptr) return &#123; m, true &#125;; &#125; return &#123; m, true &#125;;&#125;template &lt;typename T&gt;bool isBTree(BTreeNode&lt;T&gt;* root) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BTreeNode&lt;T&gt;* p; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; direction; temp minmax; memory(BTreeNode&lt;T&gt;* p, const pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;&amp; d) :p(p), direction(d) &#123;&#125; &#125;; BTreeNode&lt;T&gt;* ptr = root; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; d; if (ptr-&gt;NodeFlag != BTreeNode&lt;T&gt;::flag::leaf) &#123; d.first = ptr-&gt;branch_data-&gt;keyptrmap.end(); d.second = true; &#125; BTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt; result; if (ptr-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::leaf ? true : (result = SearchBTreeNode(ptr, d)) == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), true)) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;leaf_data-&gt;size() &amp;&amp; ptr-&gt;leaf_data-&gt;size() &lt;= M - 1) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (1 &lt;= ptr-&gt;branch_data-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;branch_data-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;branch_data-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;leaf_data-&gt;size() &amp;&amp; ptr-&gt;leaf_data-&gt;size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;branch_data-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;branch_data-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;leaf_data-&gt;begin()); arrange.top().minmax.min = *(ptr-&gt;leaf_data-&gt;begin()); typename vector&lt;T&gt;::iterator it = ptr-&gt;leaf_data-&gt;end(); --it; arrange.top().minmax.max = *it; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; typename vector&lt;T&gt;::iterator it = ptr-&gt;leaf_data-&gt;end(); --it; arrange.top().minmax.nodemax = *(it); arrange.top().minmax.min = *(ptr-&gt;leaf_data-&gt;begin()); arrange.top().minmax.max = *it; &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;leaf_data-&gt;begin()); typename vector&lt;T&gt;::iterator it = ptr-&gt;leaf_data-&gt;end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 - 1 &lt;= ptr-&gt;branch_data-&gt;keyptrmap.size() &amp;&amp; ptr-&gt;branch_data-&gt;keyptrmap.size() &lt;= M - 1) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;branch_data-&gt;keyptrmap.end(); --temp; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; T key2 = arrange.top().minmax.nodemax; arrange.pop(); arrange.top().minmax.min = key1; arrange.top().minmax.max = key2; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;branch_data-&gt;keyptrmap.end(); --temp; if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(arrange.top().p-&gt;branch_data-&gt;keyptrmap.end(), false)) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; else if (arrange.top().direction == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true)) &#123; arrange.top().minmax.nodemax = arrange.top().minmax.max; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BTreeNode&lt;T&gt;* interval = nullptr; if (d == pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), true)) &#123; if (result != pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), false)) &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, SearchBTreeNode(ptr, d))); interval = ptr-&gt;branch_data-&gt;p; ++level; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = result.first; if (d.first == ptr-&gt;branch_data-&gt;keyptrmap.end()) &#123; if (temp == ptr-&gt;branch_data-&gt;keyptrmap.begin()) &#123; if (!(arrange.top().minmax.max &lt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; --temp; if (temp == d.first) &#123; ++temp; if (!(arrange.top().minmax.max &lt; temp-&gt;first &amp;&amp; arrange.top().minmax.min &gt; d.first-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "失败节点不在同一层,非B树" &lt;&lt; endl; return false; &#125; &#125; arrange.top().direction = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(temp, true); interval = temp-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BTreeNode&lt;T&gt;::flag::leaf) &#123; d = pair&lt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator, bool&gt;(ptr-&gt;branch_data-&gt;keyptrmap.end(), true); &#125; &#125; &#125;&#125;template &lt;typename T&gt;bool compare(const pair&lt;T, BTreeNode&lt;T&gt;*&gt;&amp; left, const pair&lt;T, BTreeNode&lt;T&gt;*&gt;&amp; right)&#123; return left.first &lt; right.first;&#125;template &lt;typename T&gt;typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator Upper_Bound(const T&amp; key, vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;&amp; list)&#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = list.begin(); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator right = list.end() - 1; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt;= (*mid).first) &#123; if (mid == list.begin()) &#123; return left; &#125; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;template &lt;typename T&gt;pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; BinarySearch(vector&lt;T&gt;&amp; list, typename vector&lt;T&gt;::iterator left, typename vector&lt;T&gt;::iterator right, const T&amp; key)&#123; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;T&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt; *mid) &#123; if (mid == list.begin()) &#123; return &#123; false, left &#125;; &#125; right = mid - 1; &#125; else if (key &gt; * mid) &#123; left = mid + 1; &#125; else &#123; return &#123; true, mid &#125;; &#125; &#125; return &#123; false, left &#125;;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* InsertBTree(BTreeNode&lt;T&gt;* root, const T&amp; key) //B树插入函数&#123; if (root == nullptr) &#123; root = new BTreeNode&lt;T&gt;(BTreeNode&lt;T&gt;::flag::leaf); root-&gt;leaf_data-&gt;push_back(key); return root; &#125; else &#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::branch) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;branch_data-&gt;keyptrmap); if (scankey != current-&gt;branch_data-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;branch_data-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;branch_data-&gt;p; &#125; &#125; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; scankey = BinarySearch(*current-&gt;leaf_data, current-&gt;leaf_data-&gt;begin(), current-&gt;leaf_data-&gt;end() - 1, key); if (scankey.first) &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在，插入失败" &lt;&lt; endl; return root; &#125; else &#123; current-&gt;leaf_data-&gt;insert(scankey.second, key); &#125; if (current-&gt;leaf_data-&gt;size() &lt;= M - 1) &#123; return root; &#125; else &#123; BTreeNode&lt;T&gt;* ptr = new BTreeNode&lt;T&gt;(BTreeNode&lt;T&gt;::flag::leaf); ptr-&gt;leaf_data-&gt;insert(ptr-&gt;leaf_data-&gt;end(), current-&gt;leaf_data-&gt;end() - M / 2, current-&gt;leaf_data-&gt;end()); current-&gt;leaf_data-&gt;erase(current-&gt;leaf_data-&gt;end() - M / 2, current-&gt;leaf_data-&gt;end()); if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;(BTreeNode&lt;T&gt;::flag::branch); root-&gt;branch_data-&gt;p = current; root-&gt;branch_data-&gt;keyptrmap.push_back(make_pair(current-&gt;leaf_data-&gt;back(), ptr)); current-&gt;leaf_data-&gt;pop_back(); return root; &#125; else &#123; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.insert(stackforback.top().second, make_pair(current-&gt;leaf_data-&gt;back(), ptr)); current-&gt;leaf_data-&gt;pop_back(); if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; while (true) &#123; BTreeNode&lt;T&gt;* ptr = new BTreeNode&lt;T&gt;(BTreeNode&lt;T&gt;::flag::branch); ptr-&gt;branch_data-&gt;keyptrmap.insert(ptr-&gt;branch_data-&gt;keyptrmap.end(), current-&gt;branch_data-&gt;keyptrmap.end() - M / 2, current-&gt;branch_data-&gt;keyptrmap.end()); current-&gt;branch_data-&gt;keyptrmap.erase(current-&gt;branch_data-&gt;keyptrmap.end() - M / 2, current-&gt;branch_data-&gt;keyptrmap.end()); ptr-&gt;branch_data-&gt;p = current-&gt;branch_data-&gt;keyptrmap.back().second; if (stackforback.empty() == true) &#123; root = new BTreeNode&lt;T&gt;(BTreeNode&lt;T&gt;::flag::branch); root-&gt;branch_data-&gt;p = current; root-&gt;branch_data-&gt;keyptrmap.push_back(make_pair(current-&gt;branch_data-&gt;keyptrmap.back().first, ptr)); current-&gt;branch_data-&gt;keyptrmap.pop_back(); return root; &#125; else &#123; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.insert(stackforback.top().second, make_pair(current-&gt;branch_data-&gt;keyptrmap.back().first, ptr)); current-&gt;branch_data-&gt;keyptrmap.pop_back(); if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &lt;= M - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125;&#125;template &lt;typename T&gt;BTreeNode&lt;T&gt;* DelBTree(BTreeNode&lt;T&gt;* root, const T&amp; key) //B树删除函数&#123; BTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; bool replace = false; while (current-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::branch) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, current-&gt;branch_data-&gt;keyptrmap); if (scankey != current-&gt;branch_data-&gt;keyptrmap.end()) &#123; if (scankey-&gt;first == key) &#123; stackforback.push(make_pair(current, ++scankey)); --scankey; BTreeNode&lt;T&gt;* q = scankey-&gt;second; while (q-&gt;NodeFlag == BTreeNode&lt;T&gt;::flag::branch) &#123; stackforback.push(make_pair(q, q-&gt;branch_data-&gt;keyptrmap.begin())); q = q-&gt;branch_data-&gt;p; &#125; scankey-&gt;first = q-&gt;leaf_data-&gt;front(); q-&gt;leaf_data-&gt;erase(q-&gt;leaf_data-&gt;begin()); current = q; replace = true; break; &#125; else &#123; stackforback.push(make_pair(current, scankey)); if (scankey != current-&gt;branch_data-&gt;keyptrmap.begin()) &#123; --scankey; current = scankey-&gt;second; &#125; else &#123; current = current-&gt;branch_data-&gt;p; &#125; &#125; &#125; else &#123; stackforback.push(make_pair(current, scankey)); --scankey; current = scankey-&gt;second; &#125; &#125; if (replace == false) &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; scankey = BinarySearch(*current-&gt;leaf_data, current-&gt;leaf_data-&gt;begin(), current-&gt;leaf_data-&gt;end() - 1, key); if (scankey.first == true) &#123; current-&gt;leaf_data-&gt;erase(scankey.second); &#125; else &#123; cout &lt;&lt; "关键字" &lt;&lt; key &lt;&lt; "不存在，删除失败" &lt;&lt; endl; return root; &#125; &#125; if (current == root) &#123; if (current-&gt;leaf_data-&gt;empty() == true) &#123; delete current; return nullptr; &#125; else &#123; return current; &#125; &#125; else &#123; if (current-&gt;leaf_data-&gt;size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;branch_data-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;leaf_data-&gt;size() &gt;= (M + 1) / 2) &#123; current-&gt;leaf_data-&gt;push_back(temp-&gt;first); BTreeNode&lt;T&gt;* ptr = temp-&gt;second; temp-&gt;first = ptr-&gt;leaf_data-&gt;front(); ptr-&gt;leaf_data-&gt;erase(ptr-&gt;leaf_data-&gt;begin()); return root; &#125; else &#123; current-&gt;leaf_data-&gt;push_back(temp-&gt;first); current-&gt;leaf_data-&gt;insert(current-&gt;leaf_data-&gt;end(), temp-&gt;second-&gt;leaf_data-&gt;begin(), temp-&gt;second-&gt;leaf_data-&gt;end()); delete temp-&gt;second; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() == 0) &#123; delete root; return current; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt;* ptr = nullptr; if (temp != stackforback.top().first-&gt;branch_data-&gt;keyptrmap.begin()) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator before = temp - 1; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;branch_data-&gt;p; &#125; if (ptr-&gt;leaf_data-&gt;size() &gt;= (M + 1) / 2) &#123; current-&gt;leaf_data-&gt;insert(current-&gt;leaf_data-&gt;begin(), temp-&gt;first); typename vector&lt;T&gt;::iterator left = ptr-&gt;leaf_data-&gt;end() - 1; temp-&gt;first = *left; ptr-&gt;leaf_data-&gt;erase(left); return root; &#125; else &#123; ptr-&gt;leaf_data-&gt;push_back(temp-&gt;first); ptr-&gt;leaf_data-&gt;insert(ptr-&gt;leaf_data-&gt;end(), current-&gt;leaf_data-&gt;begin(), current-&gt;leaf_data-&gt;end()); delete current; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() == 0) &#123; delete root; return ptr; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; while (true) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp != stackforback.top().first-&gt;branch_data-&gt;keyptrmap.end()) &#123; if (temp-&gt;second-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;branch_data-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;branch_data-&gt;p)); BTreeNode&lt;T&gt;* ptr = temp-&gt;second; temp-&gt;first = ptr-&gt;branch_data-&gt;keyptrmap.front().first; ptr-&gt;branch_data-&gt;p = ptr-&gt;branch_data-&gt;keyptrmap.front().second; ptr-&gt;branch_data-&gt;keyptrmap.erase(ptr-&gt;branch_data-&gt;keyptrmap.begin()); return root; &#125; else &#123; current-&gt;branch_data-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, temp-&gt;second-&gt;branch_data-&gt;p)); current-&gt;branch_data-&gt;keyptrmap.insert(current-&gt;branch_data-&gt;keyptrmap.end(), temp-&gt;second-&gt;branch_data-&gt;keyptrmap.begin(), temp-&gt;second-&gt;branch_data-&gt;keyptrmap.end()); delete temp-&gt;second; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() == 0) &#123; delete root; return current; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; else &#123; --temp; BTreeNode&lt;T&gt;* ptr = nullptr; if (temp != stackforback.top().first-&gt;branch_data-&gt;keyptrmap.begin()) &#123; typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator before = temp - 1; ptr = before-&gt;second; &#125; else &#123; ptr = stackforback.top().first-&gt;branch_data-&gt;p; &#125; if (ptr-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2) &#123; current-&gt;branch_data-&gt;keyptrmap.insert(current-&gt;branch_data-&gt;keyptrmap.begin(), make_pair(temp-&gt;first, current-&gt;branch_data-&gt;p)); typename vector&lt;pair&lt;T, BTreeNode&lt;T&gt;*&gt;&gt;::iterator left = ptr-&gt;branch_data-&gt;keyptrmap.end() - 1; current-&gt;branch_data-&gt;p = left-&gt;second; temp-&gt;first = left-&gt;first; ptr-&gt;branch_data-&gt;keyptrmap.erase(left); return root; &#125; else &#123; ptr-&gt;branch_data-&gt;keyptrmap.push_back(make_pair(temp-&gt;first, current-&gt;branch_data-&gt;p)); ptr-&gt;branch_data-&gt;keyptrmap.insert(ptr-&gt;branch_data-&gt;keyptrmap.end(), current-&gt;branch_data-&gt;keyptrmap.begin(), current-&gt;branch_data-&gt;keyptrmap.end()); delete current; stackforback.top().first-&gt;branch_data-&gt;keyptrmap.erase(temp); if (stackforback.top().first == root) &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() == 0) &#123; delete root; return ptr; &#125; else &#123; return root; &#125; &#125; else &#123; if (stackforback.top().first-&gt;branch_data-&gt;keyptrmap.size() &gt;= (M + 1) / 2 - 1) &#123; return root; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int main()&#123; const int N = 45; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BTreeNode&lt;int&gt;* root = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertBTree(root, *p); cout &lt;&lt; endl; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelBTree(root, *p); if (root != nullptr) &#123; if (isBTree(root) == true) &#123; cout &lt;&lt; "当前树是B树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是B树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录:红黑树自底向上的插入与删除]]></title>
    <url>%2Fpost%2F18241.html</url>
    <content type="text"><![CDATA[红黑树的删除 红黑树删除极其复杂,实现难度比AVL树删除更大，要考虑的各种分支情况繁多，编程实现时在琐碎的细节上容易出错，但只要用心，正确实现删除算法不难 对红黑树按对二叉搜索树执行删除的方式执行删除,如果实际删除的节点是红节点,按正常方式删除，删除后原树仍为红黑树，结束 若实际删除的是黑节点，该节点有父节点并且有唯一子女节点且该子女节点为红，将该子女节点染黑,并按对二叉搜索树执行删除的方式删掉实际删除的节点即可，结束 若实际删除黑节点，该节点有父节点，没有子女节点，直接删除实际删除节点，将父节点对应指针域置空，令g=父节点,u=nullptr 若实际删除黑节点，该节点有父节点，有唯一女节点，该子女节点为黑，则按对二叉搜索树执行删除的方式正常执行删除，并令g=实际删除节点父节点&nbsp; u=实际删除节点子女节点 若实际删除黑节点，该节点没有父节点，若该节点没有子树直接删除啦，若该节点有左子树没有右子树，删除该黑节点，然后若左子树根节点为红染黑，结束&nbsp; 无左子树有右子树类似 至于既有左子树又有右子树的情形已经被之前所述情形包括在内了，不用考虑 经过上述步骤后如果删除操作未结束，我们有子树g，g为其根节点,u为g左子树或右子树根节点,注意u可能为nullptr，即外节点 而且可以发现u子树满足条件A:在u中删除一个节点，并在u中做或不做颜色调整和平衡化旋转后，根节点u为黑色,从原红黑树根节点到子树u各外节点的路径上黑色节点(不包括原红黑树根节点)数目比删除前原红黑树黑高度小一,从根节点u至子树u各外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u的节点非红即黑 现设有执行删除操作的红黑树的子树g，g为其根节点，以u为根节点的子树为g左子树或右子树,u可以为nullptr，并且u子树满足条件A 首先注意，任意非外节点的节点都有两个子女，两个子女要么都是外节点，要么其中一个是，要么都不是，当然了红色节点都不是外节点所以必有两个子女，黑色节点可能为也可能不为外节点 若u为g的右子女，则有以下几种情形： &nbsp; g的左子女v为黑色,g为红色，此时v不可能是外节点,若v是外节点，注意原红黑树根节点到外节点v的路径上黑色节点(不包括原红黑树根节点)数目等于删除前原红黑树黑高度r,而原红黑树根节点到子树u的各外节点的路径上黑色节点(不包括原红黑树根节点)数目等于r-1(子树u满足条件A),因此g到v路径(节点g不算在内)上黑色节点数目减一即为g到子树u各外节点的路径(节点g不算在内)上黑色节点数目，由假设v是外节点，故g到v路径(节点g不算在内)上黑色节点数目为1，因此g到子树u各外节点的路径(节点g不算在内)上黑色节点数目为0，这是不可能的，因为u为黑色 v不是外节点所以有左子女w,这里若w为红色，即如上图所示，此时交换g,w和v的颜色,对子树g右单旋转,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为红色，对g先左后右双旋转,将g染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为红色,v的左子女w为黑色,v的有子女r为黑色,此时交换g,v颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v(由上述理由它不是外节点)的左子女w为红色,此时对g右单旋转然后将w染黑，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为红色,此时对g做先左后右双旋转然后将r染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为黑色,g为黑色,v的左子女w为黑色,v的右子女r为黑色,此时对g作右单旋转,并将g染红色，于是根据子树u满足条件A不难验证g树旋转后为红黑树而且恰好满足条件A，那么若旋转后的g树的根已为执行删除操作的红黑树根节点则可以结束平衡化过程,若不为根节点，由于旋转后的g树满足条件A，所以原红黑树仍然不平衡，于是令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化，这样做是合理的，因为旋转后的g树满足条件A。 g的左子女v为红色,g为黑色,v的右子女r为黑色(显然),按和上述同样的理由r不可能是外节点,所以r必有左子女s,若s为红色,则对g做先左后右双旋转,将s染黑,然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp; g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为红色,此时对子树r做左单旋转,旋转完后将其根节点链接至v的右指针域,然后对子树g做先左后右双旋转并把t染成黑色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 g的左子女v为红色,g为黑色,v的右子女r为黑色,r的左子女s为黑色,r的右子女t为黑色,此时对子树g做右单旋转并交换v和r的颜色，然后根据子树u满足条件A不难验证此时原树为红黑树已平衡，结束 &nbsp;若u为g的右子女，则有如下几种情形，这些情形和u为g的右子女时对应的情形是对称的，以下所列这些情形从上之下依次和上文所列各情形从上至下保持对应的对称关系，平衡化操作和颜色调整操作也保持对应，颜色调整操作不便，平衡化操作正好相反，分析是类似，就不一一分析，只简单地列出平衡化操作的类型和颜色调整操作。 &nbsp; g左单旋转,交换w,g和v颜色,结束 &nbsp; g先右后左双旋转,g染黑，结束 &nbsp; 交换g,v颜色,结束 &nbsp; g左单旋转,w染黑,结束 &nbsp; g先右后左双旋转,r染黑，结束 &nbsp; g左单旋转,g染红,若旋转后的g树的根已为执行删除操作的红黑树根节点,结束，否则令u=旋转后g树根节点&nbsp; g=旋转前g树根节点父节点,回溯至上一层按所列各情形执行平衡化 &nbsp; g先右后左双旋转,s染黑,结束 &nbsp; r右单旋转,g先右后左双旋转,t染黑结束 &nbsp; g左单旋转,改变u和r的颜色,结束 &nbsp; 从以上讨论就可以看出循环不变量了，它就是u子树满足的条件A，利用该循环不变量结合前面的介绍和博主所写的AVL树插入删除算法分析一文中的分析思路就可总结出红黑树的删除算法，这里省略，可自行分析。红黑树删除算法的具体实现请参考下方代码。 下面讨论红黑树的插入 在空树中插入可直接插入，再把插入节点染黑，如果在非空红黑树中插入，设插入的新节点为u，u在节点p下插入，那么无论u是在p的左子树还是右子树中插入,以u为根的子树(左右子树为外节点)总满足以下条件B&nbsp; 按对二叉搜索树执行插入的方式在子树u中插入新节点后，在u中做或不做颜色调整及平衡化旋转后，子树u根节点u为红色，从执行插入操作的红黑树根节点至子树u各外节点的路径上黑色节点(不包括该红黑树根节点)的数目都等于插入前原红黑树的黑高度 u至子树u任意外节点的路径上没有两个连续的红色节点,子树u为二叉搜索树,子树u所有节点非红即黑。 先设有执行插入操作的红黑树的子树u，它满足条件B,u的父节点为p,u为p的左子女或右子女。 &nbsp; 若u为p的左子女，则有如下几种情形： p为黑色,此时由子树u满足条件B不难验证执行插入操作的红黑树已恢复平衡，结束平衡化过程 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则交换g和p,r的颜色，若g已为执行插入操作的红黑树的根节点，则将g染黑，此时由子树u满足条件B不难验证子树g为红黑树，于是结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，由子树u满足条件B不难验证此时子树g满足条件B，但g的颜色由黑变红意味着g和其父节点有可能组成一对连续红节点，所以此时应令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理，以消除可能出现的一对连续红色节点，这样做是合理的，因为交换颜色后的子树g满足条件B。 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色，则同样交换g和p,r的颜色，和上一情形类似，若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时g做右单旋转并交换p,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 p为红色,p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时对g先右后左双旋转并交换v,g颜色，然后由子树u满足条件B不难验证此时执行插入操作的红黑树已恢复红黑树特性，结束平衡化过程。 &nbsp; 若u为p的右子女，也有类似诸情形，这些情形和以上对应各情形保持对称，每一种情形和其对应的以上情形相比，颜色调整操作不便，旋转操作互为镜像，下面将这些情形及相应的处理方式列出，这些情形从上至下和上述情形从上至下保持对应和对称 p为黑色，已平衡，结束 &nbsp; p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,若g的左子女r为红色则交换g和p,r颜色,若g已为执行插入操作的红黑树的根节点，则将g染黑，结束平衡化过程 。若g不为执行插入操作的红黑树的根节点，令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的左子女，g为黑色,若g的右子女r为红色，则同样交换g和p,r颜色，然后若g已为执行插入操作的红黑树的根节点，则将g染黑，结束。若g不为执行插入操作的红黑树的根节点,则令u=g&nbsp; &nbsp; p=g的父节点，回溯至上一层按所列各情形进行相同的平衡化处理 p为红色,由原红黑树的特性知p有父节点g,p为g的右子女，g为黑色,g的左子女r为黑色，此时g做左单旋转并交换p,g颜色，然后已平衡，结束平衡化过程。 p为红色,p有父节点g,p为g的左子女，g为黑色,g的右子女r为黑色，此时对g先左后右双旋转并交换v,g颜色，然后结束平衡化过程。 &nbsp; 从以上讨论就可以看出循环不变量就是u子树满足的条件B，由此可总结出红黑树的插入算法，这里省略，可自行分析。红黑树插入算法的具体实现请参考下方代码。 下面是实现红黑树插入与删除操作的具体代码(c++),代码中加入了判断节点颜色非红即黑的二叉树是否为红黑树的函数，用其在每次插入删除成功后检验插入删除后的二叉树是否仍为红黑树以判断插入删除算法的正确性 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697989910010110210310410510610710810911011111211311411511611711811912012112212312412512612712812913013113213313413513613713813914014114214314414514614714814915015115215315415515615715815916016116216316416516616716816917017117217317417517617717817918018118218318418518618718818919019119219319419519619719819920020120220320420520620720820921021121221321421521621721821922022122222322422522622722822923023123223323423523623723823924024124224324424524624724824925025125225325425525625725825926026126226326426526626726826927027127227327427527627727827928028128228328428528628728828929029129229329429529629729829930030130230330430530630730830931031131231331431531631731831932032132232332432532632732832933033133233333433533633733833934034134234334434534634734834935035135235335435535635735835936036136236336436536636736836937037137237337437537637737837938038138238338438538638738838939039139239339439539639739839940040140240340440540640740840941041141241341441541641741841942042142242342442542642742842943043143243343443543643743843944044144244344444544644744844945045145245345445545645745845946046146246346446546646746846947047147247347447547647747847948048148248348448548648748848949049149249349449549649749849950050150250350450550650750850951051151251351451551651751851952052152252352452552652752852953053153253353453553653753853954054154254354454554654754854955055155255355455555655755855956056156256356456556656756856957057157257357457557657757857958058158258358458558658758858959059159259359459559659759859960060160260360460560660760860961061161261361461561661761861962062162262362462562662762862963063163263363463563663763863964064164264364464564664764864965065165265365465565665765865966066166266366466566666766866967067167267367467567667767867968068168268368468568668768868969069169269369469569669769869970070170270370470570670770870971071171271371471571671771871972072172272372472572672772872973073173273373473573673773873974074174274374474574674774874975075175275375475575675775875976076176276376476576676776876977077177277377477577677777877978078178278378478578678778878979079179279379479579679779879980080180280380480580680780880981081181281381481581681781881982082182282382482582682782882983083183283383483583683783883984084184284384484584684784884985085185285385485585685785885986086186286386486586686786886987087187287387487587687787887988088188288388488588688788888989089189289389489589689789889990090190290390490590690790890991091191291391491591691791891992092192292392492592692792892993093193293393493593693793893994094194294394494594694794894995095195295395495595695795895996096196296396496596696796896997097197297397497597697797897998098198298398498598698798898999099199299399499599699799899910001001100210031004100510061007100810091010101110121013101410151016101710181019102010211022102310241025102610271028102910301031103210331034103510361037103810391040104110421043104410451046104710481049105010511052105310541055105610571058105910601061106210631064106510661067106810691070107110721073107410751076107710781079108010811082108310841085108610871088108910901091109210931094109510961097109810991100110111021103110411051106110711081109111011111112111311141115111611171118111911201121112211231124112511261127112811291130113111321133113411351136113711381139114011411142#include &lt;string&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE intenum ColorFlag &#123; RED, BLACK &#125;;template &lt;typename T&gt;struct RBTreeNode&#123; T data; //节点数据域 ColorFlag color; //节点颜色 RBTreeNode* left; RBTreeNode* right; RBTreeNode(T d, ColorFlag c) :data(d), color(c), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; RBTreeNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; RBTreeNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; ptr = q;&#125;template &lt;typename T&gt;void RotateR(RBTreeNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; ptr = p;&#125;template &lt;typename T&gt;void RotateL(RBTreeNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; RBTreeNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; ptr = p;&#125;template &lt;typename T&gt;bool isRB(RBTreeNode&lt;T&gt;* root) //判断以root为根的二叉树是否为红黑树(已假定节点颜色不是为红色就是为黑色)&#123; if (root-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "根节点不为黑色,非红黑树" &lt;&lt; endl; return false; &#125; struct temp &#123; T lmin; T lmax; T rmin; T rmax; &#125;; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; temp minmax; memory(RBTreeNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* ptr = root; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int blacknum = 0; //统计路径上黑节点个数的变量 int preroadblacknum = 0; //当前路径的前一路径上黑节点数目 while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; if (TF == false) &#123; TF = true; preroadblacknum = blacknum; &#125; else &#123; if (preroadblacknum != blacknum) &#123; cout &lt;&lt; "从根节点到外节点的路径上黑节点数目不等,非红黑树" &lt;&lt; endl; return false; &#125; else &#123; preroadblacknum = blacknum; &#125; &#125; if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) --blacknum; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false &amp;&amp; arrange.top().p != dest) &#123; if (ptr-&gt;color == ColorFlag::RED &amp;&amp; arrange.top().p-&gt;color == ColorFlag::RED) &#123; cout &lt;&lt; "在根节点到父节点的路径上存在两个连续红色节点,非红黑树" &lt;&lt; endl; return false; &#125; &#125; if (ptr-&gt;color == ColorFlag::BLACK) ++blacknum; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非红黑树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(RBTreeNode&lt;T&gt;* parent, RBTreeNode&lt;T&gt;* original, RBTreeNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* DelRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树删除 RBTreeNode&lt;T&gt;* p = root; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; RBTreeNode&lt;T&gt;* parent = nullptr; RBTreeNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) //如果被删节点为红色,直接删除即可 &#123; delete q; return root; //已平衡返回根节点 &#125; else &#123; if (q-&gt;right == nullptr) //被删节点为叶子黑节点,直接删除,子树q满足循环不变条件,向下进入do-while循环 &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) //被删节点右子树根节点为红色 &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; //右子树根节点染黑,删除被删节点,红黑树恢复平衡,结束 delete q; return root; &#125; else &#123; delete q; //被删节点及其右子女均为黑色,直接删除被删节点 &#125; &#125; &#125; q = parent-&gt;left; //parent为需要做或不做平衡化旋转及颜色调整的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针 p-&gt;data = q-&gt;data; if (q-&gt;color == ColorFlag::RED) &#123; delete q; return root; &#125; else &#123; if (q-&gt;right == nullptr) &#123; delete q; &#125; else &#123; if (q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; delete q; return root; &#125; else &#123; delete q; &#125; &#125; &#125; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针 else &#123; parent-&gt;right = p-&gt;left; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) //被删节点颜色为红,直接删除结束 &#123; delete p; return root; &#125; else &#123; if (p-&gt;left-&gt;color == ColorFlag::RED) //被删节点为黑但左子女为红,左子女染黑,删除被删节点,已平衡返回根节点 &#123; p-&gt;left-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; //q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,删除被删节点,进入do-while循环 &#125; &#125; &#125; else //被删节点为根节点且只有左子树 &#123; parent = p-&gt;left; delete p; //直接删除被删节点,左子女若为红直接染黑,这样左子树为红黑树,结束 if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; q = parent-&gt;right; &#125; if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else &#123; if (p-&gt;right-&gt;color == ColorFlag::RED) &#123; p-&gt;right-&gt;color = ColorFlag::BLACK; delete p; return root; &#125; else &#123; delete p; &#125; &#125; &#125; else &#123; parent = p-&gt;right; delete p; if (parent-&gt;color == ColorFlag::RED) parent-&gt;color = ColorFlag::BLACK; return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; q = parent-&gt;left; &#125; else //将叶节点的父节点对应指针域置空 &#123; parent-&gt;right = nullptr; q = parent-&gt;right; &#125; // if (p-&gt;color == ColorFlag::RED) &#123; delete p; return root; &#125; else //被删叶节点为黑,直接删除,此时q为需要做或不做平衡化旋转和颜色调整的第一棵子树根节点指针,q子树满足循环不变条件,向下进入do-while循环 &#123; delete p; &#125; &#125; else //被删叶节点为根节点,直接删除,结束 &#123; parent = nullptr; delete p; return parent; &#125; &#125; &#125; bool TF = false; do //do-while循环所做工作是,从满足循环不变条件的第一棵子树起,沿父节点到第一棵子树根节点的路径向上平衡化旋转或调整颜色,直到原红黑树重新恢复平衡为止 &#123; if (TF == true) stackforflashback.pop(); else TF = true; if (parent-&gt;right == q) &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;left; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;left; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateLR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateR(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;right; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateLR(parent); &#125; else &#123; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateL(p-&gt;right); RotateLR(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateR(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; else &#123; if (parent-&gt;color == ColorFlag::RED) &#123; p = parent-&gt;right; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; parent-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; parent-&gt;color = ColorFlag::BLACK; p-&gt;color = ColorFlag::RED; return root; &#125; &#125; &#125; else &#123; p = parent-&gt;right; if (p-&gt;color == ColorFlag::BLACK) &#123; if (p-&gt;right != nullptr &amp;&amp; p-&gt;right-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;right-&gt;color = ColorFlag::BLACK; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; if (p-&gt;left != nullptr &amp;&amp; p-&gt;left-&gt;color == ColorFlag::RED) &#123; q = parent; p-&gt;left-&gt;color = ColorFlag::BLACK; RotateRL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; else &#123; q = parent; parent-&gt;color = ColorFlag::RED; RotateL(parent); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; &#125; &#125; &#125; else &#123; q = p-&gt;left; if (q-&gt;right != nullptr &amp;&amp; q-&gt;right-&gt;color == ColorFlag::RED) &#123; q-&gt;right-&gt;color = ColorFlag::BLACK; q = parent; RotateRL(parent); &#125; else &#123; if (q-&gt;left != nullptr &amp;&amp; q-&gt;left-&gt;color == ColorFlag::RED) &#123; q-&gt;left-&gt;color = ColorFlag::BLACK; q = parent; RotateR(p-&gt;left); RotateRL(parent); &#125; else &#123; p-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::RED; q = parent; RotateL(parent); &#125; &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); return root; &#125; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return parent; &#125; else &#123; cout &lt;&lt; "红黑树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;RBTreeNode&lt;T&gt;* InsertRB(RBTreeNode&lt;T&gt;* root, T key)&#123; //红黑树插入 if (root == nullptr) return new RBTreeNode&lt;T&gt;(key, ColorFlag::BLACK); else &#123; stack&lt;RBTreeNode&lt;T&gt;*&gt; stackforflashback; RBTreeNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; if (key &lt; stackforflashback.top()-&gt;data) &#123; p = stackforflashback.top()-&gt;left = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; else &#123; p = stackforflashback.top()-&gt;right = new RBTreeNode&lt;T&gt;(key, ColorFlag::RED); &#125; RBTreeNode&lt;T&gt;* q = nullptr; RBTreeNode&lt;T&gt;* g = nullptr; while (stackforflashback.empty() == false) //从第一棵满足循环不变条件的子树(就是新插入的节点)开始逐步向上调整颜色或进行平衡化旋转,直到原红黑树重新恢复平衡为止 &#123; q = stackforflashback.top(); //进入新一轮循环后p为满足循环不变条件的子树的根节点,stackforflashback栈顶指针为其父节点指针 stackforflashback.pop(); if (q-&gt;color == ColorFlag::BLACK) return root; else &#123; g = stackforflashback.top(); stackforflashback.pop(); if (q == g-&gt;left) &#123; if (g-&gt;right != nullptr &amp;&amp; g-&gt;right-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;right-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateLR(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; else &#123; if (g-&gt;left != nullptr &amp;&amp; g-&gt;left-&gt;color == ColorFlag::RED) &#123; g-&gt;color = ColorFlag::RED; g-&gt;left-&gt;color = ColorFlag::BLACK; q-&gt;color = ColorFlag::BLACK; if (stackforflashback.empty() == false) &#123; p = g; &#125; else &#123; g-&gt;color = ColorFlag::BLACK; &#125; &#125; else &#123; if (p == q-&gt;left) &#123; g-&gt;color = ColorFlag::RED; p-&gt;color = ColorFlag::BLACK; p = g; RotateRL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; else &#123; g-&gt;color = ColorFlag::RED; q-&gt;color = ColorFlag::BLACK; p = g; RotateL(g); if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), p, g); return root; &#125; &#125; &#125; &#125; &#125; &#125; return g; &#125;&#125;template &lt;typename T&gt;int Searchd(RBTreeNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(RBTreeNode&lt;T&gt;* ptr) //输出以ptr为根的红黑树对应的广义表形式&#123; struct memory &#123; RBTreeNode&lt;T&gt;* p; int direction; int last; memory(RBTreeNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; RBTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; RBTreeNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 10; //vector&lt;TYPE&gt; insertvalue&#123; 13, 2, 6, 5, 16, 14, 1, 20, 12, 4, 3, 15, 18, 21, 30, 11, 17, 25, 19, 29 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine()); RBTreeNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; root = InsertRB(root, *p); cout &lt;&lt; "插入" &lt;&lt; *p &lt;&lt; endl; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前红黑树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelRB(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isRB(root) == true) &#123; cout &lt;&lt; "当前树是红黑树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是红黑树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>红黑树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：B+树的插入和删除]]></title>
    <url>%2Fpost%2F64730.html</url>
    <content type="text"><![CDATA[B+树删除(仅考虑阶数m&gt;=3的情形，注意叶节点合并时需要修改叶节点顺序链表的链接指针，下文并未提到) 删除仅在叶节点上进行,在叶节点上删除给定关键码后，如果叶节点为根节点则删除操作结束(此时删除后的B+树可能为空树).如果不为根节点且含有的关键码树&gt;=ceil(m/2)[ceil表示向上取整]则删除操作结束，如果删除的是叶节点最右侧的关键码，还需用新的最右侧关键码沿叶节点至根节点的路径向上更新父节点指向叶节点，父节点的父节点-指向父节点—–的索引项，直到根节点的索引项被更新或被更新的索引项不是节点最右侧索引项为止。如果删除关键码的叶节点不为根节点且关键码数等于ceil(m/2)-1，那么如果叶节点有右兄弟节点，且右兄弟节点的关键码数大于等于ceil(m/2)+1，则把右兄弟节点最左侧关键码上移替代指向叶节点索引项中的关键码，并把最左侧关键码复制至叶节点最右侧，至此删除操作结束。如果右兄弟节点的关键码数等于ceil(m/2)，则将被删叶节点完整拼接至右兄弟节点左侧，删除叶节点和指向它的索引项，然后若父节点为根或父节点不为根且关键码数大于等于ceil(m/2)则结束删除操作，否则回溯至父节点继续处理。 如果叶节点既无右兄弟节点也无左兄弟节点则删除父节点(根节点)，并令根节点指针指向叶节点，然后删除操作结束 如果叶节点没有右兄弟节点，但有左兄弟节点，且左兄弟节点关键码数大于等于ceil(m/2)+1,则将父节点指向左兄弟节点的索引项中的关键码下移至叶节点最左侧，删除左兄弟节点最右侧关键码，然后用左兄弟节点新的最右侧关键码填补父节点指向它的索引项中关键码位置，随后同样的，若叶节点最右侧关键码小于父节点最右侧关键码则向上更新祖先节点索引项，然后删除操作结束。 如果叶节点没有右兄弟节点但有左兄弟节点，且左兄弟节点关键码数等于ceil(m/2)则将左兄弟节点完整拼接至叶节点左侧，然后删除左兄弟节点和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若叶节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 现设删除操作中当前节点的关键码数为ceil(m/2)-1且不是叶节点。 那么如果它有右兄弟，且右兄弟关键码数大于等于ceil(m/2)+1则把右兄弟最左侧关键码上移取代父节点中指向当前节点的索引项中的关键码，并将该关键码复制至当前节点最右侧，此外还应将右兄弟最左侧指针移动至当前节点最右侧，然后删除操作结束 如果它有右兄弟,且右兄弟关键码数等于ceil(m/2),则当前节点拼接至右兄弟最左侧，删去当前节点和父节点中指向它的索引项，然后父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束，否则回溯至父节点进一步处理。 若果它没有右兄弟也无左兄弟则删除父节点(根节点)，并令根节点指针指向当前节点，然后删除操作结束 若果它没有右兄弟但有左兄弟，且左兄弟关键码数大于等于ceil(m/2)+1,则将父节点中指向左兄弟的索引项中的关键码下移至当前节点最左侧，删除左兄弟最右侧关键码并将左兄弟最右侧指针移至当前节点最左侧，最后用左兄弟新的最右侧关键码填补父节点中指向它的索引项中的关键码所在位置，删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项) 如果它没有右兄弟但有左兄弟，且左兄弟关键码数等于ceil(m/2),则将左兄弟完整拼接至当前节点左侧，然后删除左兄弟和父节点中指向它的索引项，随后若父节点为根节点或父节点不为根节点且关键码数大于等于ceil(m/2)则删除操作结束(注意若当前节点最右侧关键码小于父节点最右侧关键码则应向上更新祖先节点索引项),否则用叶节点最右侧关键码更新父节点最右侧关键码，然后回溯至父节点继续处理 &nbsp; B+树插入(仅考虑阶数m&gt;=3的情形，注意叶节点分裂时需要修改叶节点顺序链表的链接指针，下文并未提到) 在空树中插入，直接新建根节点并填入关键码并令root和head指针指向根节点即可 若在非空树中插入那么通过搜索在叶节点中找到插入位置直接插入，若插入后叶节点关键码数小于等于m则插入结束，否则叶节点从中间分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原叶节点。如果原叶节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原叶节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 现设插入过程中当前节点有m+1个关键码且不为叶节点，则和上述类似将当前节点分裂为长度分别为floor((m+1)/2)和ceil((m+1)/2)的两部分，长度为ceil((m+1)/2)的部分是分裂后的原当前节点，如果原当前节点没有父节点则创建新根节点，左右两关键码为两分裂部分的最大关键码，左右两指针分别指向两分裂部分，令根节点指针指向新根节点，插入结束，否则将最大关键码较小的分裂部分的指针及其最大关键码构成的二元组插入至原当前节点父节点中最大关键码较大的分裂部分对应的二元组的左侧，父节点关键码指针数加一。如果插入二元组后父节点关键码数小于等于m，则插入结束,否则以父节点为当前节点回溯至父节点 &nbsp; C++代码实现(如有错误欢迎指出) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893#include &lt;iostream&gt;#include &lt;utility&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;random&gt;#include &lt;ctime&gt;#include &lt;algorithm&gt;using namespace std;const int M = 4; //B+树阶数template &lt;typename T&gt;struct BPlusTreeNode&#123; union &#123; pair&lt;vector&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;* keyandptr; //叶节点指针域和数据域 vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;* keyptrmap; //分支节点索引项集合 &#125;; enum flag &#123; leaf, branch &#125; NodeFlag; //节点标志叶节点or分支节点 BPlusTreeNode(flag N); ~BPlusTreeNode();&#125;;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::BPlusTreeNode(flag N)&#123; NodeFlag = N; if (NodeFlag == leaf) &#123; keyandptr = new pair&lt;vector&lt;T&gt;, BPlusTreeNode&lt;T&gt;*&gt;(vector&lt;T&gt;(), nullptr); &#125; else &#123; keyptrmap = new vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;(); &#125;&#125;template &lt;typename T&gt;BPlusTreeNode&lt;T&gt;::~BPlusTreeNode()&#123; if (NodeFlag == leaf) &#123; delete keyandptr; &#125; else &#123; delete keyptrmap; &#125;&#125;template &lt;typename T&gt;typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator SearchBPlusTreeNode(BPlusTreeNode&lt;T&gt;* ptr, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d) //返回值：尾后表示失败,非尾后即为对应指针&#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator m; //实参pair:尾后表示从第一指针后一指针开始搜索,非尾后表示从非尾后后一位置开始搜索 if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; m = ptr-&gt;keyptrmap-&gt;begin(); &#125; else &#123; m = d; ++m; &#125; for (; m != ptr-&gt;keyptrmap-&gt;end(); ++m) &#123; if (m-&gt;second != nullptr) return m; &#125; return m;&#125;template &lt;typename T&gt;T getMaxValueForLeaf(BPlusTreeNode&lt;T&gt;* leaf)&#123; typename vector&lt;T&gt;::iterator t = leaf-&gt;keyandptr-&gt;first.end() - 1; return *t;&#125;template &lt;typename T&gt;bool isBPlusTree(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head) //判断给定多叉树是否为B树&#123; struct temp &#123; T min; //节点某子树中最小节点值 T max; //节点某子树中最大节点值 T nodemin; //节点代表子树中最小值 T nodemax; //节点代表子树中最大值 &#125;; struct memory &#123; BPlusTreeNode&lt;T&gt;* p; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator direction; temp minmax; memory(BPlusTreeNode&lt;T&gt;* p, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d) :p(p), direction(d) &#123;&#125; &#125;; T max_value_pre_leaf; BPlusTreeNode&lt;T&gt;* leaf_list_run = head; BPlusTreeNode&lt;T&gt;* ptr = root; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator d; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) d = ptr-&gt;keyptrmap-&gt;end(); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator t; BPlusTreeNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; int level = 0; int beforelevel = 0; while (true) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf ? true : (t = SearchBPlusTreeNode(ptr, d)) == ptr-&gt;keyptrmap-&gt;end()) &#123; if (ptr == dest) &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; if (1 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) return true; else &#123; cout &lt;&lt; "当前树只有根节点,但根节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (ptr-&gt;keyptrmap-&gt;size() &gt; 1) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; return true; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; return true; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "根节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树根节点子树数量不符合要求,非B+树"; return false; &#125; &#125; &#125; else &#123; if (ptr-&gt;NodeFlag == BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; ++level; if (TF == false) &#123; beforelevel = level; TF = true; &#125; else &#123; if (level != beforelevel) &#123; cout &lt;&lt; "叶节点不在同一层,非B+树" &lt;&lt; endl; return false; &#125; beforelevel = level; &#125; if ((M + 1) / 2 &lt;= ptr-&gt;keyandptr-&gt;first.size() &amp;&amp; ptr-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = *(ptr-&gt;keyandptr-&gt;first.begin()); arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); //改 arrange.top().minmax.max = getMaxValueForLeaf(ptr); &#125; else &#123; arrange.top().minmax.min = *(ptr-&gt;keyandptr-&gt;first.begin()); typename vector&lt;T&gt;::iterator it = ptr-&gt;keyandptr-&gt;first.end(); --it; arrange.top().minmax.max = *it; &#125; &#125; else &#123; cout &lt;&lt; "当前树叶节点关键码数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; if (leaf_list_run != nullptr &amp;&amp; ptr == leaf_list_run) &#123; if (leaf_list_run != head) &#123; if (*(leaf_list_run-&gt;keyandptr-&gt;first.begin()) &lt;= max_value_pre_leaf) &#123; cout &lt;&lt; "叶节点链表关键码非从小到大排列,非B+树" &lt;&lt; endl; return false; &#125; &#125; max_value_pre_leaf = getMaxValueForLeaf(leaf_list_run); leaf_list_run = leaf_list_run-&gt;keyandptr-&gt;second; &#125; else &#123; cout &lt;&lt; "叶节点链表没有顺序链接所有叶节点,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if ((M + 1) / 2 &lt;= ptr-&gt;keyptrmap-&gt;size() &amp;&amp; ptr-&gt;keyptrmap-&gt;size() &lt;= M) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end(); --temp; if (d == temp) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; --temp; if (arrange.top().minmax.min &gt; temp-&gt;first) &#123; T key1 = arrange.top().minmax.nodemin; arrange.pop(); arrange.top().minmax.min = key1; ++temp; arrange.top().minmax.max = temp-&gt;first; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp2 = arrange.top().p-&gt;keyptrmap-&gt;end(); --temp2; if (arrange.top().direction == arrange.top().p-&gt;keyptrmap-&gt;begin()) &#123; arrange.top().minmax.nodemin = arrange.top().minmax.min; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点也非根节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "当前树分支节点子树数量不符合要求,非B+树" &lt;&lt; endl; return false; &#125; &#125; --level; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; BPlusTreeNode&lt;T&gt;* interval = nullptr; if (d == ptr-&gt;keyptrmap-&gt;end()) &#123; if (t != ptr-&gt;keyptrmap-&gt;begin()) &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.push(memory(ptr, ptr-&gt;keyptrmap-&gt;begin())); interval = ptr-&gt;keyptrmap-&gt;begin()-&gt;second; ++level; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = t; --temp; if (temp == d) &#123; if (arrange.top().minmax.max == temp-&gt;first) &#123; if (temp != ptr-&gt;keyptrmap-&gt;begin()) &#123; --temp; if (!(arrange.top().minmax.min &gt; temp-&gt;first)) &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树不是" &lt;&lt; M &lt;&lt; "路搜索树,非B+树" &lt;&lt; endl; return false; &#125; &#125; else &#123; cout &lt;&lt; "非叶节点的分支节点存在空子树,非B+树" &lt;&lt; endl; return false; &#125; arrange.top().direction = t; interval = t-&gt;second; &#125; ptr = interval; if (ptr-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; d = ptr-&gt;keyptrmap-&gt;end(); &#125; &#125; &#125; if (leaf_list_run != nullptr) &#123; cout &lt;&lt; "叶节点链表中叶节点数大于B+树中叶节点数,非B+树" &lt;&lt; endl; return false; &#125;&#125;template &lt;typename T&gt;bool compare(const pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&amp; left, const pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&amp; right)&#123; return left.first &lt; right.first;&#125;template &lt;typename T&gt;void updatemax(stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt;&amp; stackforback, T key) //向上更新父节点索引项关键码&#123; while (stackforback.empty() == false) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; if (temp == stackforback.top().first-&gt;keyptrmap-&gt;end()) --temp; temp-&gt;first = key; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; break; &#125; stackforback.pop(); &#125;&#125;template &lt;typename T&gt;pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; BinarySearch(vector&lt;T&gt; &amp;list, typename vector&lt;T&gt;::iterator left, typename vector&lt;T&gt;::iterator right, const T&amp; key)&#123; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;T&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt; *mid) &#123; if (mid == list.begin()) &#123; return &#123; false, left &#125;; &#125; right = mid - 1; &#125; else if (key &gt; * mid) &#123; left = mid + 1; &#125; else &#123; return &#123; true, mid &#125;; &#125; &#125; return &#123; false, left &#125;;&#125;template &lt;typename T&gt; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator Upper_Bound(const T &amp;key, vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt; &amp;list)&#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator left = list.begin(); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator right = list.end() - 1; while (left &lt;= right) &#123; int d = right - left + 1; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator mid; if (d % 2 == 1) &#123; mid = left + d / 2; &#125; else &#123; mid = left + (d / 2 - 1); &#125; if (key &lt;= (*mid).first) &#123; if (mid == list.begin()) &#123; return left; &#125; right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusInsert(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, const T &amp;key) //B+树插入函数&#123; if (root == nullptr) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); head = root; root-&gt;keyandptr-&gt;first.push_back(key); return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; BPlusTreeNode&lt;T&gt;* p = nullptr; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, *(current-&gt;keyptrmap)); if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; stackforback.push(make_pair(current, scankey)); --scankey; p = scankey-&gt;second; ++scankey; while (p-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = p-&gt;keyptrmap-&gt;end(); stackforback.push(make_pair(p, temp)); --temp; p = temp-&gt;second; &#125; current = p; break; &#125; stackforback.push(make_pair(current, scankey)); current = scankey-&gt;second; &#125; &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; result = BinarySearch(current-&gt;keyandptr-&gt;first, current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end() - 1, key); if (result.first == false) &#123; current-&gt;keyandptr-&gt;first.insert(result.second, key); if (current-&gt;keyandptr-&gt;first.size() &lt;= M) &#123; if (current != root &amp;&amp; key == current-&gt;keyandptr-&gt;first.back()) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::leaf); ptr-&gt;keyandptr-&gt;first.insert(ptr-&gt;keyandptr-&gt;first.end(), current-&gt;keyandptr-&gt;first.end() - (M + 1) / 2, current-&gt;keyandptr-&gt;first.end()); current-&gt;keyandptr-&gt;first.erase(current-&gt;keyandptr-&gt;first.end() - (M + 1) / 2, current-&gt;keyandptr-&gt;first.end()); ptr-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; current-&gt;keyandptr-&gt;second = ptr; if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); root-&gt;keyptrmap-&gt;push_back(make_pair(current-&gt;keyandptr-&gt;first.back(), current)); root-&gt;keyptrmap-&gt;push_back(make_pair(ptr-&gt;keyandptr-&gt;first.back(), ptr)); return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;T&gt;::iterator temp = ptr-&gt;keyandptr-&gt;first.end() - 1; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second, make_pair(*temp, ptr)); stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;end(); (stackforback.top().second - 2)-&gt;first = *(current-&gt;keyandptr-&gt;first.end() - 1); &#125; else &#123; stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second + 1, make_pair(*temp, ptr)); --stackforback.top().second; stackforback.top().second-&gt;first = *(current-&gt;keyandptr-&gt;first.end() - 1); &#125; if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.pop(); updatemax(stackforback, ptr-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); while (true) &#123; BPlusTreeNode&lt;T&gt;* ptr = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); ptr-&gt;keyptrmap-&gt;insert(ptr-&gt;keyptrmap-&gt;end(), current-&gt;keyptrmap-&gt;end() - (M + 1) / 2, current-&gt;keyptrmap-&gt;end()); current-&gt;keyptrmap-&gt;erase(current-&gt;keyptrmap-&gt;end() - (M + 1) / 2, current-&gt;keyptrmap-&gt;end()); if (stackforback.empty() == true) &#123; root = new BPlusTreeNode&lt;T&gt;(BPlusTreeNode&lt;T&gt;::flag::branch); root-&gt;keyptrmap-&gt;push_back(make_pair(current-&gt;keyptrmap-&gt;back().first, current)); root-&gt;keyptrmap-&gt;push_back(make_pair(ptr-&gt;keyptrmap-&gt;back().first, ptr)); return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = ptr-&gt;keyptrmap-&gt;end() - 1; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second, make_pair(temp-&gt;first, ptr)); stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;end(); (stackforback.top().second - 2)-&gt;first = current-&gt;keyptrmap-&gt;back().first; &#125; else &#123; stackforback.top().second = stackforback.top().first-&gt;keyptrmap-&gt;insert(stackforback.top().second + 1, make_pair(temp-&gt;first, ptr)); --stackforback.top().second; stackforback.top().second-&gt;first = current-&gt;keyptrmap-&gt;back().first; &#125; if (stackforback.top().first-&gt;keyptrmap-&gt;size() &lt;= M) &#123; if (stackforback.top().second == stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; stackforback.pop(); updatemax(stackforback, ptr-&gt;keyptrmap-&gt;back().first); &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; cout &lt;&lt; "关键码" &lt;&lt; key &lt;&lt; "已存在,无法插入" &lt;&lt; endl; return &#123; root, head &#125;; &#125; &#125; &#125;&#125;template &lt;typename T&gt;pair&lt;BPlusTreeNode&lt;T&gt;*, BPlusTreeNode&lt;T&gt;*&gt; BPlusDelete(BPlusTreeNode&lt;T&gt;* root, BPlusTreeNode&lt;T&gt;* head, const T &amp;key) //B+树删除函数,root根节点指针,head叶节点顺序链头节点指针&#123; BPlusTreeNode&lt;T&gt;* current = root; stack&lt;pair&lt;BPlusTreeNode&lt;T&gt;*, vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator&gt;&gt; stackforback; while (current-&gt;NodeFlag != BPlusTreeNode&lt;T&gt;::flag::leaf) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator scankey = Upper_Bound(key, *(current-&gt;keyptrmap)); if (scankey == current-&gt;keyptrmap-&gt;end()) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; stackforback.push(make_pair(current, scankey)); current = scankey-&gt;second; &#125; &#123; pair&lt;bool, typename vector&lt;T&gt;::iterator&gt; result = BinarySearch(current-&gt;keyandptr-&gt;first, current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end() - 1, key); if (result.first == false) &#123; cout &lt;&lt; "关键码不存在删除失败" &lt;&lt; endl; return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.erase(result.second); &#125; &#125; if (stackforback.empty() == true) &#123; if (current-&gt;keyandptr-&gt;first.empty() == true) &#123; delete current; return &#123; nullptr, nullptr &#125;; &#125; else &#123; return &#123; current, current &#125;; &#125; &#125; else &#123; if (current-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2) &#123; if (current-&gt;keyandptr-&gt;first.back() &lt; key) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.push_back(temp-&gt;second-&gt;keyandptr-&gt;first.front()); stackforback.top().second-&gt;first = temp-&gt;second-&gt;keyandptr-&gt;first.front(); temp-&gt;second-&gt;keyandptr-&gt;first.erase(temp-&gt;second-&gt;keyandptr-&gt;first.begin()); return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.end(), temp-&gt;second-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.end()); current-&gt;keyandptr-&gt;second = temp-&gt;second-&gt;keyandptr-&gt;second; delete temp-&gt;second; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); stackforback.top().second-&gt;first = current-&gt;keyandptr-&gt;first.back(); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; temp = temp - 2; if (temp-&gt;second-&gt;keyandptr-&gt;first.size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyandptr-&gt;first.insert(current-&gt;keyandptr-&gt;first.begin(), temp-&gt;second-&gt;keyandptr-&gt;first.back()); BPlusTreeNode&lt;T&gt;* pre = temp-&gt;second; pre-&gt;keyandptr-&gt;first.pop_back(); temp-&gt;first = pre-&gt;keyandptr-&gt;first.back(); if (current-&gt;keyandptr-&gt;first.back() &lt; key) &#123; updatemax(stackforback, current-&gt;keyandptr-&gt;first.back()); &#125; return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyandptr-&gt;first.insert(temp-&gt;second-&gt;keyandptr-&gt;first.end(), current-&gt;keyandptr-&gt;first.begin(), current-&gt;keyandptr-&gt;first.end()); temp-&gt;second-&gt;keyandptr-&gt;second = current-&gt;keyandptr-&gt;second; temp-&gt;first = temp-&gt;second-&gt;keyandptr-&gt;first.back(); delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; else &#123; if (temp-&gt;second-&gt;keyandptr-&gt;first.back() &lt; key) &#123; stackforback.pop(); updatemax(stackforback, temp-&gt;second-&gt;keyandptr-&gt;first.back()); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125; &#125; while (true) &#123; typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator temp = stackforback.top().second; ++temp; if (temp != stackforback.top().first-&gt;keyptrmap-&gt;end()) &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;push_back(temp-&gt;second-&gt;keyptrmap-&gt;front()); stackforback.top().second-&gt;first = temp-&gt;second-&gt;keyptrmap-&gt;front().first; temp-&gt;second-&gt;keyptrmap-&gt;erase(temp-&gt;second-&gt;keyptrmap-&gt;begin()); return &#123; root, head &#125;; &#125; else &#123; current-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;end(), temp-&gt;second-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;end()); delete temp-&gt;second; stackforback.top().second-&gt;first = current-&gt;keyptrmap-&gt;back().first; stackforback.top().first-&gt;keyptrmap-&gt;erase(temp); if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; else &#123; temp = temp - 2; if (temp-&gt;second-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2 + 1) &#123; current-&gt;keyptrmap-&gt;insert(current-&gt;keyptrmap-&gt;begin(), temp-&gt;second-&gt;keyptrmap-&gt;back()); BPlusTreeNode&lt;T&gt;* pre = temp-&gt;second; pre-&gt;keyptrmap-&gt;pop_back(); temp-&gt;first = pre-&gt;keyptrmap-&gt;back().first; if (current-&gt;keyptrmap-&gt;back().first &lt; key) &#123; updatemax(stackforback, current-&gt;keyptrmap-&gt;back().first); &#125; return &#123; root, head &#125;; &#125; else &#123; temp-&gt;second-&gt;keyptrmap-&gt;insert(temp-&gt;second-&gt;keyptrmap-&gt;end(), current-&gt;keyptrmap-&gt;begin(), current-&gt;keyptrmap-&gt;end()); temp-&gt;first = temp-&gt;second-&gt;keyptrmap-&gt;back().first; delete current; stackforback.top().first-&gt;keyptrmap-&gt;erase(stackforback.top().second); typename vector&lt;pair&lt;T, BPlusTreeNode&lt;T&gt;*&gt;&gt;::iterator it = temp-&gt;second-&gt;keyptrmap-&gt;end() - 1; if (stackforback.top().first == root || stackforback.top().first-&gt;keyptrmap-&gt;size() &gt;= (M + 1) / 2) &#123; if (stackforback.top().first == root &amp;&amp; root-&gt;keyptrmap-&gt;size() == 1) &#123; BPlusTreeNode&lt;T&gt;* temp_ptr = root-&gt;keyptrmap-&gt;front().second; delete root; root = temp_ptr; &#125; else &#123; if (temp-&gt;second-&gt;keyptrmap-&gt;back().first &lt; key) &#123; stackforback.pop(); updatemax(stackforback, temp-&gt;second-&gt;keyptrmap-&gt;back().first); &#125; &#125; return &#123; root, head &#125;; &#125; else &#123; current = stackforback.top().first; stackforback.pop(); &#125; &#125; &#125; &#125;&#125;int main()&#123; const int N = 56; vector&lt;int&gt; seq(N); for (int i = 0; i &lt; N; ++i) &#123; seq[i] = i + 1; &#125; shuffle(seq.begin(), seq.end(), default_random_engine()); BPlusTreeNode&lt;int&gt;* root = nullptr; BPlusTreeNode&lt;int&gt;* head = nullptr; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusInsert(root, head, *p); root = temp.first; head = temp.second; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; cout &lt;&lt; endl; &#125; for (vector&lt;int&gt;::const_iterator p = seq.cbegin(); p != seq.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; pair&lt;BPlusTreeNode&lt;int&gt;*, BPlusTreeNode&lt;int&gt;* &gt; temp = BPlusDelete(root, head, *p); root = temp.first; head = temp.second; if (root == nullptr &amp;&amp; head == nullptr) cout &lt;&lt; "NULL"; else &#123; if (isBPlusTree(root, head)) &#123; cout &lt;&lt; "当前树为B+树" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; "错误,当前树不为B+树!" &lt;&lt; endl; exit(-1); &#125; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>B+树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带附加头节点的广义表运算c++源码分享]]></title>
    <url>%2Fpost%2F16698.html</url>
    <content type="text"><![CDATA[之前文章里给出的基于广义表链表表示的运算中用链表表示的广义表除广义表本身外的其他所有子表都是没有附加头节点的，即utype==1的节点(在同一层子表中表示为该子表的子表的表元素)的hlink指针直接指向下一层子表的表头，而不是附加头节点，这是一个疏忽。所以我把所有适用于广义表没有附加头节点的链表表示的相关运算的c++实现进行了修改，修改后的源码可以适用于有附加头节点的情形，完成的功能保持不变。 找出所有子表及相关属性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth = 0; int flag = 0; int sign = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; sign = 0; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; //栈中存有完整位置信息,输出之 emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 在广义表中搜索给定值 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; bool TF = true; char key; vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; depth++; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; depth++; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) &#123; if (stack[stack.size() - 1].position.size()!=0) &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; key &lt;&lt; "是其中第"; for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 删除广义表链表表示 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; delete ptr; ptr = nullptr; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; delete ptr; stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 求指定深度的所有子表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; if (depth == maxdepth) &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; ++emptycount; //栈中存有完整位置信息,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; &#125; else &#123; ++emptycount; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 计算各子表在广义表字符串中的起始终止位置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position&#123;public: int place; int index; position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; int left = 0, right = 0, total = 0; Gen *ptr = strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype != 0 || ptr-&gt;info.ref == 0) &#123; ++left; ++total; position temp(total, left); match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出之,输出函数直接套用扫描链表输出广义表,最后要输出换行符 cout &lt;&lt; ":"; &#125; else &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示拷贝广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 基于链表表示比较广义表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2);Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2 = strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; ptr2 = ptr2-&gt;info.hlink-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2)&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen *strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 广义表字符串形式和链表表示的转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 广义表的链表表示和多叉树的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; int ref = 0; Gen *p = new Gen(0, ref); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); &#125; else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, ++ref); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, ++ref); ptr-&gt;info.hlink = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构备忘录：保证AVL树删除插入操作正确性的原理的讨论及插入删除操作的实现]]></title>
    <url>%2Fpost%2F56925.html</url>
    <content type="text"><![CDATA[对AVL树首先要弄清它的定义:AVL树是一棵高度平衡的二叉搜索树,它要么是一棵空树，要么是一棵左右子树均为AVL树,且左右子树高度差的绝对值不大于一的二叉搜索树 数据结构教科书介绍的AVL树平衡化旋转共有四种方式:LR左单旋转,RR右单旋转,LRR先左后右双旋转,RLR先右后左双旋转,LR和RR，LRR和RLR互为镜像,若不熟悉请参看数据结构教科书,下面要对保证AVL树插入删除操作正确性的原理进行简单的讨论。 当在AVL树中删除一个节点时(删除没有子树的单一根节点是平凡的，这里不予考虑)，按对二叉搜索树执行删除节点操作时采用的方式找到待删除节点，但由二叉搜索树删除算法(请参看数据结构教科书)可知，待删除节点不一定是实际删除节点，在某些情况下待删除节点没有被实际删除，而是将非待删除节点的实际删除节点的数据域替换带删除节点的数据域，此后删除的是实际被删除的节点而不是带删除节点，当然在另一些情况下,待删除节点就是实际删除节点。这样每当按对二叉搜索树执行删除操作的方式成功删除(注意待删除节点未必被实际删除)AVL树中的待删除节点后,通过指针定位到实际被删除节点的父节点及该父节点的原先为被实际删除节点所在的子树的子树的根节点,设指向该父节点的指针为parent，指向该父节点的原先为实际被删除节点所在的子树的子树的根节点的指针为q(可能为NULL)，那么分别讨论可知,无论在AVL树中对待删除节点执行的删除操作对应删除二叉搜索树中节点时可能出现的哪一种情形,以parent为根的子树总满足以下条件A： 1.以parent指向的节点为根节点的子树在执行删除操作前是AVL树(由AVL树定义) 2.以q指向的节点为根节点的子树在被删除一个节点后经过一系列或不经过平衡化旋转后,其高度相比删除前下降一,并且仍然为AVL树 以此为基础我们来寻找循环不变量 现假设在删除的过程中存在一棵以parent指向的节点为根节点的二叉搜索树,在对它的子树执行删除操作前它是AVL树且该树是执行删除操作前原AVL树的一棵子树， 若在parent的左子树或右子树上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,该左子树或右子树的高度相比于删除前下降一并且仍然为AVL树(即parent树满足条件A),q为指向此时该左子树或右子树根节点的指针,则对parent树而言有如下几种情形: 情形A 以parent指向的节点为根节点的原AVL子树A在执行删除前根节点平衡因子为0,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为1,由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树,当然其高度相比于删除前没有任何变化,于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，于是可以结束平衡化过程 情形A* 和情形A对称,分析是类似的,此时对树A不做任何平衡化旋转,原树已平衡,结束平衡化过程 情形B 以parent指向的节点为根节点的原AVL树子树A在执行删除前根节点平衡因子为-1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为0，由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证这时parent树仍然为AVL树，且其高度相比于删除节点前下降一,此时不对A做任何平衡化旋转，这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话,没有平衡化过程结束),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形B* 和情形B对称,分析是类似的,此时不做平衡化旋转,回溯至上一层(如果上一层父节点存在，没有则结束平衡化)继续平衡化 情形C 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为0，在执行删除前根节点平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2,树A失衡于是对树A做左单旋转，由于作删除操作的原AVL树子树A满足条件A，以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树,且其高度相比于删除前没有任何变化，于是从树A根节点到原AVL树根节点的路径上各节点(除树A根节点)的平衡因子仍然和删除前相同,即这些节点仍然平衡,于是按AVL树的定义从A的根节点的父节点到原树根节点逐层向上递推,最后即得以A根节点到原树父节点的路径上的节点为根节点的子树均为AVL树,当然原树仍然为AVL树，这样就可以结束平衡化过程 情形C* 和情形C对称,分析是类似的,此时对树A做右单旋转,然后原树已平衡,结束平衡化过程 &nbsp;情形D 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为1，在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做左单旋转。由于作删除操作的原AVL树子树A满足条件A,以此为依据根据AVL树定义不难验证左单旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形D* 和情形D对称,分析是类似的,此时对树A做右单旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 情形E 以parent指向的节点为根节点的原AVL树子树A右子树根节点平衡因子为-1,在执行删除前根节点parent平衡因子为1,在parent的左子树上删除一个节点并做或不做平衡化旋转调整后左子树高度下降一,此时parent平衡因子变为2，树A失衡于是对树A做先右后左双旋转。由于作删除操作的AVL树A满足条件A,以此为依据根据AVL树定义不难验证先右后左双旋转后的树A仍然为AVL树，且其高度相比于删除节点前下降一,这样就可以发现树A满足在树A上按对二叉搜索树执行删除的方式删除一个节点后经过一系列或不经过平衡化旋转后,树A的高度相比于删除前下降一并且仍然为AVL树，注意到树A高度降一影响到其根节点父节点(如果存在)平衡因子有可能使其失衡，所以令parent为树A根节点的父节点(如果有的话，没有则结束平衡化),q为树A根节点回溯至上一层再按各种情形进行相应的处理。这样做是合理的，因为此时以q为根的子树(q为parent左子树或右子树根节点)刚好满足条件A，这样就能就各种情形以相同的方式进行同样的处理 情形E* 和情形E对称,分析是类似的,此时对树A做先左后右双旋转,然后回溯至上一层(如果上一层父节点存在,没有则结束平衡化)继续平衡化 &nbsp; 从以上讨论就可以看出循环不变量了,它就是删除过程中当前parent子树满足的条件A,如果parent子树满足条件A且对应A,A&nbsp;两种情形，则不做平衡化旋转并结束平衡化,如果对应C,C两种情形，则做单旋转并结束平衡化,如果对应B，B两种情形则不做平衡化旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A),若对应D,D两种情形则做单旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A)，若对应E，E*两种情形，则做双旋转并回溯至上一层(如果上一层父节点存在)平衡化(以parent父节点为根的子树满足条件A).由此可以总结出删除AVL树某节点过程中经历的平衡化过程如下： 从本文开头提及的最初的parent子树开始,该parent子树满足条件A,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL). AVL树删除算法(调整平衡因子的细节没有给出,请参考下方代码): (1)在AVL树上执行二叉搜索树删除算法之后令parent为实际被删除节点的父节点,q为指向以parent的子女为根节点的原先为被实际删除节点的子树的子树的根节点指针(可能为NULL) (2) if(parent子树对应于A,A C,C情形) &nbsp; &nbsp; &nbsp; &nbsp; A,A*情形,直接转3 &nbsp; &nbsp; &nbsp; &nbsp; C情形 parent子树左单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp; &nbsp; C*情形 parent子树右单旋转,&nbsp;然后转3 &nbsp; &nbsp; &nbsp;else &nbsp; &nbsp; &nbsp; &nbsp; B,B*情形&nbsp;如果&nbsp;parent为根节点转3&nbsp;否则 q=parent&nbsp; &nbsp; parent=parent父节点转2 &nbsp; &nbsp; &nbsp; &nbsp; D情形 parent子树左单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; D*情形 parent子树右单旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E情形 parent子树先右后左双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 &nbsp; &nbsp; &nbsp; &nbsp; E*情形 parent子树先左后右双旋转&nbsp;随后如果&nbsp;parent为根节点转3&nbsp;否则q=parent&nbsp; &nbsp; parent=parent父节点&nbsp;转2 (3)结束 在这里发表一些个人看法,一些数据结构教科书上(如数据结构与算法分析:java语言描述)提到AVL树删除算法的正确编写有一定难度,实际上并非如此.从以上算法来看,编程实现时思路的推进完全是线性的，根本没有难度。非要说实现难度大，那也只能是琐碎的编码细节令人抓狂，事实上从 以上算法来看删除算法本质上非常简单,并不复杂,编写代码只需用心就能正确实现删除算法 &nbsp; 下面讨论AVL树的插入 插入操作和删除相比更为简单,实现难度更低，分析插入操作还是要先寻找循环不变量 &nbsp;首先插入新节点后只有新节点父节点至根节点的路径上的节点的平衡因子受影响,以路径上各节点为根的子树的高度要么加一要么不变，即平衡因子要么加减一要么不变。因此路径上各节点的平衡因子在插入新节点后的范围在-2至2之间 按最一般情形考虑(在空树中插入是最平凡的情形，这里不予考虑)，按二叉搜索树插入方式插入新节点后,令parent为新插入节点父节点,q为新插入节点。若插入后parent平衡因子(不是为+-1就是为0)为0,则根据定义不难验证原树已平衡为AVL树,这样就可以结束平衡化过程,若平衡因子为+-1(插入前parent为叶节点),则令q=parent,parent为其父节点,这样子树q满足条件B: &nbsp; &nbsp; q为AVL树&nbsp; &nbsp; 插入前q平衡因子为0,插入后绝对值为1,q高度相比于插入前加一,且此时没有对q或其子树做平衡化旋转 这样设插入过程中当前存在一棵原AVL树的子树,根节点为parent,parent的按二叉搜索树插入方式插入节点的子树根节点为q,子树q满足条件B。根据节点插入parent右子树或左子树加减parent平衡因子,调整parent平衡因子为插入后平衡因子。然后， 如果parent平衡因子为+-1,则插入前为0，且parent高度相比于插入前加一，插入后parent仍然为AVL树，此时不对parent进行平衡化旋转,由于parent插入后高度加一parent父节点(如果存在)的平衡因子受到影响,因此令q=parent,parent=parent父节点，回溯到上一层(如果上一层父节点存在，否则结束平衡化)按所列各情形进行平衡化操作。这样做是合理的,因为根据上述分析回溯到上一层后子树q满足条件B，所以完全可以按照各情形以相同方式进行相同处理 如果parent平衡因子为0,则插入前parent平衡因子绝对值为1,即新节点在较矮的子树上插入，插入后parent左右子树等高，不难看出插入后parent子树仍为AVL树且高度相比于插入前不变，于是沿从parent父节点到原AVL树根节点的路径层层向上递推即可验证插入后原树仍为AVL树，故此时可结束平衡化过程 若parent平衡因子绝对值为2,则有以下几种情形: 情形一： &nbsp; 插入后parent平衡因子为-2,q平衡因子为-1,即在q的左子树上插入,左子树在插入后高度加一,q为parent左子树，此时直接对parent做右单旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形一* 和情形一对称，插入后parent平衡因子为2,q平衡因子为1,即在q的右子树上插入,右子树在插入后高度加一，q为parent右子树,此时对parent做左单旋转并结束平衡化过程 情形二： 插入后parent平衡因子为-2,q平衡因子为1,即在q的右子树上插入,q为parent左子树，q的右子树插入后高度增一，故必有q的右子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先左后右双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 情形二* 和情形二对称，分析是类似的，插入后parent平衡因子为2,q平衡因子为-1,即在q的左子树上插入,q为parent右子树，q的左子树插入后高度增一，故必有q的左子女p(树C的根)。由于是在子树p上插入,所以p一定为从最初的parent子树的根节点至q的回溯路径上的一个节点，因此插入后p的平衡因子为+-1,插入前为0，因此一定为在p的两棵等高子树之一上插入,插入后子树p的高度状况如上图所示，此时直接对parent做先右后左双旋转，根据做平衡化旋转前的parent树满足条件B和AVL树定义可验证旋转后parent仍然为AVL树，且高度相比于插入前不变，这样原树已平衡，直接结束平衡化过程 由以上讨论可以看出循环不变量就是子树q满足的条件B,如果插入过程中如上述检查parent子树发现其满足条件B,那么若parent在插入后的平衡因子绝对值为1，则令q=parent&nbsp; &nbsp;parent=parent父节点&nbsp; 回溯到上一层继续按文中列出的情形进行平衡化,若parent在插入后的平衡因子为0,则直接结束平衡化过程,若parent在插入后的平衡因子绝对值为2，此时若parent子树对应情形一则对parent子树执行右单旋转并结束平衡化过程,对应情形一则对parent子树执行左单旋转并结束平衡化过程，对应情形二则对parent子树执行先左后右双旋转并结束平衡化过程，对应情形二则对parent子树执行先右后左双旋转并结束平衡化过程。 根据上述分析按和分析删除操作类似的方式就可以总结出AVL树的插入算法，可以自行分析，这里就不赘述了。 下面是删除与插入操作的具体代码实现，代码中加入判断是否为AVL树的代码(非递归)以检验删除操作的正确性，也就是每次删除插入成功后用判断函数检验删除插入后的二叉树是否为AVL树，从而检验插入删除算法的正确性 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;random&gt;#include &lt;ctime&gt;using namespace std;#define TYPE inttemplate &lt;typename T&gt;struct AVLNode //AVL树节点类&#123; int bf; //节点平衡因子 T data; //节点数据域 AVLNode* left; AVLNode* right; AVLNode(int b, T d) :bf(b), data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;template &lt;typename T&gt;void RotateLR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先左后右双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; AVLNode&lt;T&gt;* q = p-&gt;right; p-&gt;right = q-&gt;left; q-&gt;left = p; ptr-&gt;left = q-&gt;right; q-&gt;right = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 0; ptr-&gt;bf = 1; &#125; else &#123; p-&gt;bf = -1; ptr-&gt;bf = 0; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateRL(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行先右后左双旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; AVLNode&lt;T&gt;* q = p-&gt;left; p-&gt;left = q-&gt;right; q-&gt;right = p; ptr-&gt;right = q-&gt;left; q-&gt;left = ptr; if (q-&gt;bf == 0) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; if (q-&gt;bf == -1) &#123; p-&gt;bf = 1; ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 0; ptr-&gt;bf = -1; &#125; q-&gt;bf = 0; &#125; ptr = q;&#125;template &lt;typename T&gt;void RotateR(AVLNode&lt;T&gt;*&amp; ptr) //对以ptr为根的子树执行右单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;left; ptr-&gt;left = p-&gt;right; p-&gt;right = ptr; if (p-&gt;bf == -1) &#123; p-&gt;bf = ptr-&gt;bf = 0; &#125; else &#123; p-&gt;bf = 1; &#125; ptr = p;&#125;template &lt;typename T&gt;void RotateL(AVLNode&lt;T&gt;*&amp; ptr) ////对以ptr为根的子树执行左单旋转,ptr成为旋转后新树根节点指针&#123; AVLNode&lt;T&gt;* p = ptr-&gt;right; ptr-&gt;right = p-&gt;left; p-&gt;left = ptr; if (p-&gt;bf == 0) &#123; p-&gt;bf = -1; ptr-&gt;bf = 1; &#125; else &#123; ptr-&gt;bf = p-&gt;bf = 0; &#125; ptr = p;&#125;template &lt;typename T&gt;bool isAVL(AVLNode&lt;T&gt;* root) //判断以root为根节点的二叉树是否为AVL树&#123; struct temp &#123; T lmin; //节点左子树中最小节点值 T lmax; //节点左子树中最大节点值 T rmin; //节点右子树中最小节点值 T rmax; //节点右子树中最大节点值 &#125;; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; temp minmax; int lh = 0; //节点左子树高度 int rh = 0; //节点右子树高度 memory(AVLNode&lt;T&gt;* p, int d) :p(p), direction(d) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* ptr = root; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; bool TF = false; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) return true; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; if (abs(arrange.top().rh - arrange.top().lh) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; arrange.pop(); &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; return true; &#125; &#125; else &#123; if (d == 0) &#123; if (arrange.top().direction == 1) &#123; arrange.top().lh = 1; arrange.top().minmax.lmin = ptr-&gt;data; arrange.top().minmax.lmax = ptr-&gt;data; &#125; else &#123; arrange.top().rh = 1; arrange.top().minmax.rmin = ptr-&gt;data; arrange.top().minmax.rmax = ptr-&gt;data; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr || ptr-&gt;right != nullptr) &#123; if (ptr-&gt;data &lt; arrange.top().minmax.rmin) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.lmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.lmin = temp1.lmin; &#125; arrange.top().minmax.lmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; if (ptr-&gt;left == nullptr) &#123; arrange.top().minmax.rmin = ptr-&gt;data; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; &#125; arrange.top().minmax.rmax = temp1.rmax; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; else &#123; if (ptr-&gt;data &gt; arrange.top().minmax.lmax) &#123; temp temp1 = arrange.top().minmax; int leftheight = arrange.top().lh; int rightheight = arrange.top().rh; arrange.pop(); if (arrange.top().direction == 1) &#123; arrange.top().minmax.lmin = temp1.lmin; arrange.top().minmax.lmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().lh = max(leftheight, rightheight) + 1; &#125; &#125; else &#123; arrange.top().minmax.rmin = temp1.lmin; arrange.top().minmax.rmax = ptr-&gt;data; if (abs(rightheight - leftheight) &gt; 1) &#123; cout &lt;&lt; "存在左右子树高度差绝对值大于一的子树,原树非AVL树" &lt;&lt; endl; return false; &#125; else &#123; arrange.top().rh = max(leftheight, rightheight) + 1; &#125; &#125; &#125; else &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; &#125; &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; arrange.push(memory(ptr, Searchd(ptr, d))); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; if (!(ptr-&gt;data &gt; arrange.top().minmax.lmax)) &#123; cout &lt;&lt; "当前树非二叉搜索树,也非AVL树" &lt;&lt; endl; return false; &#125; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;template &lt;typename T&gt;void linkWithUpper(AVLNode&lt;T&gt;* parent, AVLNode&lt;T&gt;* original, AVLNode&lt;T&gt;* _new)&#123; if (original == parent-&gt;left) &#123; parent-&gt;left = _new; &#125; else &#123; parent-&gt;right = _new; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* DelAVL(AVLNode&lt;T&gt;* root, T key) //在以root为根节点的AVL树中删除关键码key&#123; //AVL树的删除 AVLNode&lt;T&gt;* p = root; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; while (p != nullptr) //搜索被删除节点,同时将回溯路径记录在栈中 &#123; if (p-&gt;data == key) break; else &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) &#123; p = p-&gt;left; &#125; else &#123; p = p-&gt;right; &#125; &#125; &#125; if (p != nullptr) //被删除节点存在,被p指向 &#123; AVLNode&lt;T&gt;* parent = nullptr; AVLNode&lt;T&gt;* q = nullptr; if (p-&gt;left != nullptr &amp;&amp; p-&gt;right != nullptr) //被删节点左右子树均存在 &#123; q = p-&gt;right; if (q-&gt;left != nullptr) //被删节点右子树根节点有左子树 &#123; parent = p; stackforflashback.push(parent); while (q-&gt;left != nullptr) //在被删节点右子树根节点左子树中搜索中序遍历的第一个节点,同时用栈记录回溯路径 &#123; parent = q; q = q-&gt;left; if (q-&gt;left != nullptr) stackforflashback.push(parent); &#125; parent-&gt;left = q-&gt;right; //用该节点数据域替换被删节点数据域,将其右子树链接至其父节点左链指针,随后删除该节点 p-&gt;data = q-&gt;data; delete q; q = parent-&gt;left; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; p-&gt;right = q-&gt;right; //用被删节点右子女数据域替换被删节点指针域,将右子女右子树链接至被删节点右链指针,并删除右子女 p-&gt;data = q-&gt;data; delete q; parent = p; q = p-&gt;right; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; &#125; else &#123; if (p-&gt;left != nullptr) //被删节点左子树不空,右子树空 &#123; if (stackforflashback.empty() == false) //被删节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;left; delete p; q = parent-&gt;left; &#125; //将被删节点左子树链接至被删节点父节点相应链指针，并删除被删节点 else &#123; parent-&gt;right = p-&gt;left; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;left; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else if (p-&gt;right != nullptr) //处理过程和以上情形完全对称 &#123; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = p-&gt;right; delete p; q = parent-&gt;left; &#125; else &#123; parent-&gt;right = p-&gt;right; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = p-&gt;right; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; else //被删节点为叶节点 &#123; if (stackforflashback.empty() == false) //被删叶节点有父节点 &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; parent-&gt;left = nullptr; delete p; q = parent-&gt;left; &#125; else //删除叶节点并将其父节点对应指针域置空 &#123; parent-&gt;right = nullptr; delete p; q = parent-&gt;right; &#125; //parent为需要做或不做平衡化旋转的第一棵子树根节点指针,q为该子树左子树根节点指针 &#125; else &#123; parent = nullptr; delete p; //删除被删节点后原AVL树恢复平衡,parent为根节点结束 return parent; &#125; &#125; &#125; bool TF = false; do &#123; if (TF == true) stackforflashback.pop(); else TF = true; if ((parent-&gt;bf == 1 || parent-&gt;bf == -1) &amp;&amp; q == nullptr &amp;&amp; parent-&gt;right == nullptr &amp;&amp; parent-&gt;left == nullptr) &#123; parent-&gt;bf = 0; if (stackforflashback.empty() == false) &#123; q = parent; parent = stackforflashback.top(); continue; &#125; else &#123; return root; &#125; &#125; if (parent-&gt;left == q) &#123; if (parent-&gt;bf == 0) &#123; parent-&gt;bf = 1; //情形a return root; &#125; else if (parent-&gt;bf == -1) &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;right; q = parent; if (p-&gt;bf == 0) &#123; //情形c if (stackforflashback.empty() == false) &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == 1) //情形d &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 &#125; else //情形e &#123; RotateRL(parent);//对以parent为根的子树执行先右后左双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; else &#123; if (parent-&gt;bf == 0) //情形a* &#123; parent-&gt;bf = -1; return root; &#125; else if (parent-&gt;bf == 1) //情形b* &#123; parent-&gt;bf = 0; q = parent; if (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); //情形b &#125; &#125; else &#123; p = parent-&gt;left; q = parent; if (p-&gt;bf == 0) //情形c* &#123; if (stackforflashback.empty() == false) &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 linkWithUpper(stackforflashback.top(), q, parent); &#125; else &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; if (q == root) &#123; return parent; &#125; else &#123; return root; &#125; &#125; else if (p-&gt;bf == -1) //情形d* &#123; RotateR(parent);//对以parent为根的子树执行右单旋转 &#125; else //情形e* &#123; RotateLR(parent);//对以parent为根的子树执行先左后右双旋转 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); q = parent; parent = stackforflashback.top(); &#125; else &#123; q = parent; &#125; &#125; &#125; &#125; while (stackforflashback.empty() == false); return q; //原AVL树已恢复平衡,返回根节点 &#125; else &#123; cout &lt;&lt; "AVL树中不存在要删除的数据元素,删除失败" &lt;&lt; endl; return nullptr; &#125;&#125;template &lt;typename T&gt;AVLNode&lt;T&gt;* InsertAVL(AVLNode&lt;T&gt;* root, T key)&#123; //AVL树的插入 if (root == nullptr) return new AVLNode&lt;T&gt;(0, key); else &#123; stack&lt;AVLNode&lt;T&gt;*&gt; stackforflashback; AVLNode&lt;T&gt;* p = root; while (p != nullptr) //搜索插入位置 &#123; stackforflashback.push(p); if (key &lt; p-&gt;data) p = p-&gt;left; else if (key &gt; p-&gt;data) p = p-&gt;right; else &#123; cout &lt;&lt; "要插入的关键字在AVL树中已存在,插入失败" &lt;&lt; endl; return nullptr; &#125; &#125; p = new AVLNode&lt;T&gt;(0, key); if (key &lt; stackforflashback.top()-&gt;data) &#123; stackforflashback.top()-&gt;left = p; //新节点插入并调整父节点平衡因子 &#125; else &#123; stackforflashback.top()-&gt;right = p; &#125; AVLNode&lt;T&gt;* parent = nullptr; while (stackforflashback.empty() == false) &#123; parent = stackforflashback.top(); stackforflashback.pop(); if (parent-&gt;left == p) &#123; --parent-&gt;bf; if (parent-&gt;bf == 0) &#123; return root;//已平衡,返回根节点 &#125; else if (parent-&gt;bf == -2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == 1) &#123; RotateLR(parent);//对parent为根的子树执行先左后右双旋转 //已平衡 &#125; else &#123; RotateR(parent);//对以parent为根子树执行右单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; else &#123; ++parent-&gt;bf; if (parent-&gt;bf == 0) &#123; //已平衡,返回根节点 return root; &#125; else if (parent-&gt;bf == 2) &#123; AVLNode&lt;T&gt;* q = parent; if (p-&gt;bf == -1) &#123; RotateRL(parent);//对parent为根的子树执行先右后左双旋转 //已平衡 &#125; else &#123; RotateL(parent);//对以parent为根的子树执行左单旋转 //已平衡 &#125; if (stackforflashback.empty() == false) &#123; linkWithUpper(stackforflashback.top(), q, parent); &#125; if (q == root) //返回恢复平衡的AVL树根节点 return parent; else return root; &#125; else &#123; p = parent; //以parent为根的子树已平衡其高度加一回溯至父节点 &#125; &#125; &#125; return p; //原AVL树已平衡,返回根节点 &#125;&#125;template &lt;typename T&gt;int Searchd(AVLNode&lt;T&gt;* ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;template &lt;typename T&gt;void output(AVLNode&lt;T&gt;* ptr) //输出以ptr为根的AVL树对应的广义表形式&#123; struct memory &#123; AVLNode&lt;T&gt;* p; int direction; int last; memory(AVLNode&lt;T&gt;* p, int d, int l) :p(p), direction(d), last(l) &#123;&#125; &#125;; int d = 0; AVLNode&lt;T&gt;* const dest = ptr; stack&lt;memory&gt; arrange; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; else &#123; if (arrange.top().last == 1) cout &lt;&lt; ", "; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data; arrange.top().last = 2; &#125; &#125; else &#123; if (arrange.top().last == 2) cout &lt;&lt; ")"; else &#123; cout &lt;&lt; ", )"; &#125; arrange.pop(); &#125; ptr = arrange.top().p; d = arrange.top().direction; &#125; &#125; else &#123; AVLNode&lt;T&gt;* interval = nullptr; if (d == 0) &#123; if (arrange.empty() == false) &#123; if (arrange.top().last == 0) &#123; if (arrange.top().direction == 1) &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 1; &#125; else &#123; cout &lt;&lt; " ," &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ","; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; arrange.top().last = 2; &#125; &#125; else &#123; cout &lt;&lt; ptr-&gt;data &lt;&lt; "("; &#125; arrange.push(memory(ptr, Searchd(ptr, d), 0)); if (arrange.top().direction == 1) interval = ptr-&gt;left; else interval = ptr-&gt;right; &#125; else &#123; arrange.top().direction = 2; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125;&#125;int main()&#123; const int N = 20; //vector&lt;TYPE&gt; insertvalue&#123; 13, 5, 3, 2, 1, 4, 10, 8, 7, 6, 9, 11, 12, 16, 14, 15, 18, 17, 20, 19 &#125;; vector&lt;TYPE&gt; insertvalue; for (int i = 1; i &lt;= N; ++i) &#123; insertvalue.push_back(i); &#125; shuffle(insertvalue.begin(), insertvalue.end(), default_random_engine(time(nullptr))); AVLNode&lt;TYPE&gt;* root = nullptr; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "插入节点" &lt;&lt; *p &lt;&lt; endl; root = InsertAVL(root, *p); output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; "插入完成后删除前AVL树对应的广义表形式为:" &lt;&lt; endl; output(root); cout &lt;&lt; endl; cout &lt;&lt; endl; for (vector&lt;TYPE&gt;::const_iterator p = insertvalue.cbegin(); p != insertvalue.cend(); ++p) &#123; cout &lt;&lt; "删除节点" &lt;&lt; *p &lt;&lt; endl; root = DelAVL(root, *p); if (root != nullptr) &#123; output(root); cout &lt;&lt; endl; if (isAVL(root) == true) &#123; cout &lt;&lt; "当前树是AVL树"; cout &lt;&lt; endl; &#125; else &#123; cerr &lt;&lt; "错误当前树不是AVL树!" &lt;&lt; endl; exit(0); &#125; &#125; else cout &lt;&lt; "NULL"; cout &lt;&lt; endl; &#125; return 0;&#125; &nbsp;运行结果:]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据广义表建立对应二叉树(子女兄弟链表表示)并由二叉树输出对应广义表(子女兄弟链表表示)的C++非递归算法]]></title>
    <url>%2Fpost%2F63787.html</url>
    <content type="text"><![CDATA[根据输入的广义表建立子女右兄弟链的二叉树表示，该二叉树对应于广义表对应的普通树。先考虑更复杂的情形，如果广义表中存在共享表，则将其转换为带共享子树的二叉树表示，每一共享子树带有附加头节点，其左链指针指向共享子树，最后输出带共享子树的子女右兄弟链表示(广义表形式) C++代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;class Dnode //二叉树节点类&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Searchd(Dnode *ptr, int d);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; //输入广义表 map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, info&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) //由广义表建子女右兄弟链二叉树 &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;left = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;left = temp; &#125; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) //输出子女右兄弟链二叉树对应广义表形式 &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first=="()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 广义表无共享表情形相对简单： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; Dnode *left; Dnode *right; Dnode(char d = '\0') :data(d), left(nullptr), right(nullptr) &#123;&#125;&#125;;int Searchd(Dnode *ptr, int d);int main()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;left=temp; &#125; else &#123; ptr-&gt;right = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;left = temp; else ptr-&gt;right = temp; ptr = temp; &#125; &#125; &#125; &#125; //ptr指向二叉树根节点 cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; int d = 0; Dnode *const dest = ptr; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d==0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;left != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;left; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;right; &#125; d = 0; ptr = interval; &#125; &#125; return 0;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;right == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;left != nullptr) return 1; else &#123; if (ptr-&gt;right != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树，广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将二叉树(子女兄弟链表)调整为树然后将树转换为二叉树(直接修改) 非递归算法]]></title>
    <url>%2Fpost%2F21071.html</url>
    <content type="text"><![CDATA[将子女兄弟链表调整为普通树然后将普通树调整为子女兄弟链表，注意是在原树上直接进行调整，不是根据原树创建转换后的新树，为了操作方便，树指针域用vector表示 C++代码： 子女兄弟链表存在共享子树情形： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Dnode //二叉树和多叉树节点类&#123;public: char data; //树节点数据域 vector&lt;Dnode *&gt; p; //指针域vector Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode //遍历树时记录回退路径的栈节点&#123;public: Dnode *ptr; //树节点指针 int direction; //回退方向 dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;class info //映射表中关键字对应的值类型&#123;public: int count = 0; //同一子树的引用计数 Dnode *p = nullptr; //子树附加头节点指针 info(int c, Dnode *ptr) :count(c), p(ptr) &#123;&#125;&#125;;class infoshare&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Dnode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Dnode *strtodtree(); //广义表转换为子女右兄弟链表示的二叉树，返回二叉树根节点指针int Searchd(Dnode *ptr, int d); //选择二叉树下一路径方向的函数int Search(Dnode *ptr, int d); //选择多叉树下一路径方向的函数void suboutput(Dnode *ptr); //输出子女右兄弟链表示int Reversesearchd(Dnode *ptr, int d); //反向遍历二叉树时选择下一路径的函数void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist);map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist);int main()&#123; Dnode *ptr = strtodtree(); //由广义表创建二叉树 const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; //记录遍历回退路径的栈 stack&lt;Dnode *&gt; tstack; //记录已遍历二叉树层次结构的栈 map&lt;Dnode *, info&gt; share; //映射表，保存子树第一个节点-对应info对象的键值对 int d = 3; while (true) //遍历子女右兄弟链二叉树建表 &#123; int interval; if ((interval = Reversesearchd(ptr, d)) == 0) &#123; if (ptr == dest) &#123; if (d != 3) dstack.pop(); break; &#125; else &#123; if (d == 1) &#123; dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *dir = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (interval == 2) &#123; dir = ptr-&gt;p[1]; if (ptr-&gt;p[0] == nullptr) &#123; d = 3; ptr = dir; continue; &#125; &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; &#125; &#125; &#125; else &#123; dir = ptr-&gt;p[0]; &#125; dtreestacknode temp(interval, ptr); dstack.push(temp); &#125; else &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; ++p-&gt;second.count; dstack.pop(); ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; else &#123; info temp(1, ptr); share.insert(make_pair(ptr-&gt;p[0], temp)); dir = ptr-&gt;p[0]; dstack.top().direction = interval; &#125; &#125; d = 3; ptr = dir; &#125; &#125; &#123; auto m = share.begin(); //删除非共享子表对应的记录 while (m != share.end()) &#123; if (m-&gt;second.count == 1) m = share.erase(m); else ++m; &#125; &#125; d = 3; int flag = 0; //重要变量,记录最近二叉树分支节点左链指针域是否被修改过 while (true) //循环,将vector容器实现指针域的子女右兄弟链二叉树直接修改为普通树，不是另外新建等价地普通树 &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else &#123; dstack.pop(); if (!tstack.empty()) tstack.pop(); &#125; break; &#125; else &#123; if (d == 3) //////// &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) || dstack.top().ptr-&gt;p[0] != ptr) &#123; tstack.top()-&gt;p.push_back(ptr); if ((dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1) &amp;&amp; dstack.top().ptr-&gt;p[0] != ptr) tstack.pop(); &#125; else &#123; tstack.pop(); &#125; ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (--p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[1] = ptr-&gt;p[1]; delete ptr; tstack.top()-&gt;p.push_back(p-&gt;second.p); if (dstack.top().ptr-&gt;p[1] != nullptr) &#123; ptr = dstack.top().ptr-&gt;p[1]; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) /////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; tstack.top()-&gt;p.push_back(ptr); &#125; else &#123; if (ptr-&gt;p[0] != nullptr) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; --p-&gt;second.count; if (dstack.top().ptr-&gt;p[0] == ptr) &#123; if (p-&gt;second.count != 0) &#123; dstack.top().ptr-&gt;p[0] = p-&gt;second.p; flag = 1; &#125; else &#123; if (flag==1) dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; &#125; else &#123; dstack.top().ptr-&gt;p.push_back(p-&gt;second.p); &#125; if (p-&gt;second.count != 0) &#123; Dnode *temp = ptr-&gt;p[1]; delete ptr; if (temp != nullptr) &#123; ptr = temp; d = 3; &#125; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) ////// &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; &#125; else &#123; flag = 0; ptr-&gt;p.pop_back(); tstack.push(ptr); dtreestacknode temp(1, ptr); dstack.push(temp); ptr = ptr-&gt;p[0]; d = 3; &#125; &#125; continue; &#125; &#125; if (dstack.top().ptr-&gt;p[0] != ptr) tstack.top()-&gt;p.push_back(ptr); &#125; if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); ptr = ptr-&gt;p[1]; d = 3; continue; &#125; &#125; dtreestacknode temp(1, ptr); dstack.push(temp); &#125; else &#123; dstack.top().direction = 1; &#125; flag = 0; ptr-&gt;p.pop_back(); interval = ptr-&gt;p[0]; tstack.push(ptr); ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树" &lt;&lt; endl; d = 0; while (true) //循环，将普通树直接修改为子女右兄弟链二叉树，非另外新建 &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) &#123; auto p = share.find(ptr-&gt;p[0]); if (p != share.end()) &#123; if (p-&gt;second.count == 0) &#123; p-&gt;second.count = 1; &#125; else &#123; Dnode *temp = new Dnode(); temp-&gt;p[0] = ptr-&gt;p[0]; dstack.top().ptr-&gt;p[dstack.top().direction - 1] = temp; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = temp; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; continue; &#125; &#125; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为子女右兄弟链表示" &lt;&lt; endl; cout &lt;&lt; "转换后的子女右兄弟莲表示对应的广义表为" &lt;&lt; endl; suboutput(ptr); //输出最终转换结果 return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; map&lt;string, infoshare&gt; sharelist; creatsharelist(glist, sharelist); stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; map&lt;string, infoshare&gt;::iterator p; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; if (arrange.size() != 1) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; &#125; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; if (glist[i + 1] != ')') &#123; p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; temp-&gt;p[0] = p-&gt;second.share; continue; &#125; &#125; &#125; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) &#123; if (p != sharelist.end()) &#123; p-&gt;second.share = temp; &#125; ptr-&gt;p[0] = temp; &#125; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125;void creatsharelist(string &amp;glist, map&lt;string, infoshare&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; infoshare m; auto q = sharelist.insert(make_pair(temp, m)); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1 || m-&gt;first == "()") m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, infoshare&gt;::iterator Searchshare(int left, map&lt;string, infoshare&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 运行结果： 子女右兄弟链无共享子树情形(相对简单)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386#include "stdafx.h"#include &lt;iostream&gt;#include &lt;stack&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Dnode&#123;public: char data; vector&lt;Dnode *&gt; p; Dnode(char d = '\0') :data(d) &#123; p.push_back(nullptr); p.push_back(nullptr); &#125;&#125;;class dtreestacknode&#123;public: Dnode *ptr; int direction; dtreestacknode(int d, Dnode *p) :direction(d), ptr(p) &#123;&#125;&#125;;Dnode *strtodtree();int Searchd(Dnode *ptr, int d);int Search(Dnode *ptr, int d);void suboutput(Dnode *ptr);int Reversesearchd(Dnode *ptr, int d);int main()&#123; Dnode *ptr = strtodtree(); const Dnode *const dest = ptr; stack&lt;dtreestacknode&gt; dstack; stack&lt;Dnode *&gt; tstack; int d = 3; while (true) &#123; if (Reversesearchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 3) ptr-&gt;p.clear(); else dstack.pop(); break; &#125; else &#123; if (d == 3) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); ptr-&gt;p.clear(); &#125; else &#123; if (d == 1) tstack.pop(); else ptr-&gt;p.clear(); dstack.pop(); &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 3) &#123; if (ptr != dest) &#123; if (!(dstack.top().ptr-&gt;p[0] != nullptr &amp;&amp; dstack.top().direction == 1)) tstack.top()-&gt;p.push_back(ptr); if (ptr-&gt;p[1] != nullptr) &#123; dtreestacknode temp(2, ptr); dstack.push(temp); interval = ptr-&gt;p[1]; ptr = interval; d = 3; continue; &#125; &#125; ptr-&gt;p.pop_back(); dtreestacknode temp(1, ptr); dstack.push(temp); interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; else &#123; ptr-&gt;p.pop_back(); dstack.top().direction = 1; interval = ptr-&gt;p[0]; tstack.push(ptr); &#125; ptr = interval; d = 3; &#125; &#125; cout &lt;&lt; "已将子女右兄弟链表示转换为普通树"&lt;&lt;endl; d = 0; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (d == 0) &#123; ptr-&gt;p.push_back(nullptr); ptr-&gt;p.push_back(nullptr); if (ptr == dest) &#123; break; &#125; else &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; else &#123; if (ptr-&gt;p.size() == 1) &#123; ptr-&gt;p.push_back(nullptr); &#125; else &#123; if (ptr-&gt;p.size() &gt; 2) &#123; while (ptr-&gt;p.size() &gt; 2) ptr-&gt;p.pop_back(); &#125; ptr-&gt;p[1] = nullptr; &#125; dstack.pop(); if (ptr == dest) break; else &#123; ptr = dstack.top().ptr; d = dstack.top().direction; &#125; &#125; &#125; else &#123; Dnode *interval=nullptr; if (d == 0) &#123; if (ptr != dest) &#123; if (dstack.top().direction != 1) &#123; dstack.top().ptr-&gt;p[dstack.top().direction - 2]-&gt;p[1] = ptr; &#125; &#125; dtreestacknode temp(Search(ptr, d), ptr); dstack.push(temp); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; else &#123; dstack.top().direction = Search(ptr, d); interval= ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout&lt;&lt;"已将普通树转换为子女右兄弟链表示"&lt;&lt;endl; suboutput(ptr); return 0;&#125;Dnode *strtodtree()&#123; cout &lt;&lt; "请输入广义表字符串形式" &lt;&lt; endl; string glist; cin &gt;&gt; glist; stack&lt;Dnode *&gt; arrange; Dnode *ptr = nullptr; for (string::size_type i = 0; i != glist.size(); i++) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Dnode(); arrange.push(ptr); &#125; else &#123; Dnode *temp = new Dnode(); if (arrange.top() == ptr) &#123; ptr-&gt;p[0] = temp; &#125; else &#123; ptr-&gt;p[1] = temp; &#125; ptr = temp; arrange.push(ptr); &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = arrange.top(); arrange.pop(); &#125; else &#123; if (glist[i] != ',') &#123; Dnode *temp = new Dnode(glist[i]); if (ptr == arrange.top()) ptr-&gt;p[0] = temp; else ptr-&gt;p[1] = temp; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将广义表字符串形式转化为子女右兄弟链表示" &lt;&lt; endl; return ptr;&#125;int Searchd(Dnode *ptr, int d)&#123; if (d == 2) return 0; else &#123; if (d == 1) &#123; if (ptr-&gt;p[1] == nullptr) return 0; else return 2; &#125; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else return 0; &#125; &#125; &#125;&#125;int Reversesearchd(Dnode *ptr, int d)&#123; if (d == 1) return 0; else &#123; if (d == 2) &#123; if (ptr-&gt;p[0] == nullptr) return 0; else return 1; &#125; else &#123; if (ptr-&gt;p[1] != nullptr) return 2; else &#123; if (ptr-&gt;p[0] != nullptr) return 1; else return 0; &#125; &#125; &#125;&#125;int Search(Dnode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Dnode *ptr)&#123; stack&lt;Dnode *&gt; arrange; int d = 0; Dnode *const dest = ptr; cout &lt;&lt; "转换后的子女右兄弟链表示对应的广义表形式为:"; cout &lt;&lt; "("; while (true) &#123; if (Searchd(ptr, d) == 0) &#123; if (ptr == dest) &#123; if (d == 0) cout &lt;&lt; ')'; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') cout &lt;&lt; "()"; else cout &lt;&lt; ptr-&gt;data; cout &lt;&lt; ")"; &#125; else &#123; cout &lt;&lt; ")"; &#125; ptr = arrange.top(); d = 1; arrange.pop(); &#125; &#125; else &#123; Dnode *interval = nullptr; if (d == 0) &#123; if (ptr-&gt;p[0] != nullptr) &#123; if (ptr != dest) cout &lt;&lt; "("; arrange.push(ptr); interval = ptr-&gt;p[0]; &#125; else &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; &#125; else &#123; cout &lt;&lt; ","; interval = ptr-&gt;p[1]; &#125; d = 0; ptr = interval; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>子女右兄弟链</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表的非递归深度优先遍历及相关运算的c++实现]]></title>
    <url>%2Fpost%2F42578.html</url>
    <content type="text"><![CDATA[对广义表的链表表示的深度优先遍历的实现要点是,从广义表的附加头节点开始向后顺序访问，对原子节点，访问结束后递进至下一节点，每遇到子表的附加头节点就进入该子表所在的下一层继续向下遍历，在下一层的子表中同样也是访问并经过原子节点，一遇到子表附加头节点就立即向下进入子表继续遍历，就这样不断向下遍历，最终进入空表或没有子表的非空表并遍历完成后就立即回溯至上一层子表并按照上述规则继续向后遍历，子表遍历完成就再回溯至上上层子表，然后继续遍历，就这样反复不断地回溯和向下遍历，直到最后一次回溯至原广义表并向后完成遍历后整个广义表的深度优先遍历也就结束了。 &nbsp; 利用广义表的深度优先遍历可以完成诸多有实用价值的运算，如：找出所有子表及对应的深度，长度，在广义表中的位置；求出子表数目；找出最长最短子表，深度最深子表；找出所有空表的深度，位置，数目；在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置；找出所有空表以及不包含子表的子表；确定各个子表左右括号的起始终止位置以及序数；找出给定深度的所有子表等等。下面就来讨论以上部分运算的实现： （1）找出所有子表及对应的深度，长度，在广义表中的位置和子表的数目 用栈实现，栈节点保存子表附加头节点的指针,及已统计到的子表表元素数目。遍历过程中每遇到子表附加头节点就把子表对应栈节点入栈，遍历完子表后将对应栈节点出栈,遇到原子项将原子项所在子表的栈节点的表元素计数变量加一，遇到下一层子表的附加头节点也要将本层子表的栈节点计数变量加一。最后遍历完广义表后栈中只剩下广义表本身对应的栈节点，取出其中指针赋予指针变量使其指向广义表附加头节点，然后出栈，就完成了遍历。遍历过程中需要使用指针变量指向并访问广义表各个链表节点，指针的动作方式和深度优先遍历要点所述是一致的，指针从子表表尾继续前进时会成为空指针，此时就遍历完子表，栈顶节点的计数变量就是子表长度，栈大小就是子表深度，栈中节点序列指出了子表在广义表中的位置，栈顶节点指针就是指向子表附加头节点的指针，利用该指针可输出子表。至于子表数目用计数变量进行简单统计就可以得到。具体C++代码实现如下(本文所有代码在visual studio 2017编译环境下调试通过)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen //广义表链表表示的节点结构体类型&#123; int utype; //节点类型,0表示广义表附加头结点,1表示子表附加头结点,2表示原子数据项 union &#123; int ref; //联合体类型,utype==0时ref为引用计数,==1时hlink为指向子表第一个节点指针,==2时value为原子项的数据值 struct Gen *hlink; char value; &#125;info; //联合体变量info struct Gen *tlink; //指向该节点所在链表下一节点的指针 Gen(int u); Gen(int u, char v); //构造函数声明&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr) //utype=0或1时初始化节点&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr) //utype==2,value==v时初始化节点&#123; info.value = v;&#125;class Gennode //深度优先遍历广义表链表表示时辅助遍历过程的类型&#123;public: int numnode; //子表中当前已统计的节点数,遍历完子表后即为子表长度 Gen *ptr; //指向子表附加头节点的指针 Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125; //初始化&#125;;void output(vector&lt;Gennode&gt; &amp;stack); //输出stack栈中存放的子表位置信息void suboutput(Gen *head); //输出head指向的子表Gen * strtogen(); //将字符串形式的广义表转换为链表表示int main()&#123; int depth = 0; int maxdepth = 0; //子表深度，最大深度初始化 int flag = 0; int sign = 0; //flag用于在找到子表后标志当前子表是非空表，非空子表还是为空的广义表本身,sign标志当前子表是否还有子表,0没有1有 int subcount = 0; //子表计数 int emptycount = 0; //空表计数 bool TF = true; //true递进至新的一层,false从上一层回溯至本层 vector&lt;Gennode&gt; stack; //辅助遍历过程的栈 Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //ptr指向广义表或子表附加头节点 &#123; if (TF == true) //新进至本层 &#123; sign = 0; depth++; if (ptr-&gt;utype == 0) //从广义表附加头节点开始 &#123; Gennode temp(ptr); stack.push_back(temp); //附加头节点指针入栈 flag = 0; ptr = ptr-&gt;tlink; //ptr递进至下一节点 &#125; else //到达本层子表附加头节点 &#123; ++stack[stack.size() - 1].numnode; //子表为表元素，所以将本层子表的已统计节点数加一 Gennode temp(ptr); stack.push_back(temp); //子表附加头节点入栈 flag = 2; ptr = ptr-&gt;info.hlink; //递进至子表第一个表元素 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //ptr指针回溯至广义表附加头节点，遍历完成退出 break; else //从子表回溯至本层上该子表的附加头节点 &#123; sign = 1; ptr = ptr-&gt;tlink; //继续递进至本层下一下一节点 flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //找到一个子表 &#123; subcount++; if (flag == 2) //找到一个子空表 &#123; emptycount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()"&lt;&lt;endl; //输出子表信息 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); //栈中存有完整位置信息，输出 &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出该子表 cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身"&lt;&lt;endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; emptycount++; //找到子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; "深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; if (sign == 0) //该子表为空表或没有子表的子表 &#123; if (depth &gt; maxdepth) maxdepth = depth; //比较确定最大深度 &#125; depth--; ptr = stack[stack.size() - 1].ptr; //ptr回溯至上一层 stack.pop_back(); TF = false; &#125; else //找到本层的一个原子数据项 &#123; ++stack[stack.size() - 1].numnode; //本层子表节点计数加一 ptr = ptr-&gt;tlink; //ptr向后递进 flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; //输出子表数目，空表数目，广义表深度 cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) //遍历stack栈输出子表位置信息 &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 运行示例： 以上代码调用了两个函数suboutput和strtogen，分别用来输出广义表链表表示对应的字符串表示和将字符串形式的广义表转化为链表表示 (2)在广义表中搜索给定关键字，找出包含关键字的所有子表及其在子表中的位置:这里需要在Gennode类型中新增一个vector对象position用来存放关键字在子表中的位置,每在子表中找到一个关键字就要把其位置存入position尾端。遍历子表后根据position是否为空可断定子表是否含关键字，不为空的话顺序输出关键字位置即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; vector&lt;int&gt; position; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int flag = 0; int subcount = 0; //含指定值的子表计数 bool TF = true; char key; //待搜索的关键字 vector&lt;Gennode&gt; stack; Gen *ptr= strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入要搜索的值:" &lt;&lt; endl; //输入要搜索的关键字 cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //搜索完毕退出 break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (flag != 2 &amp;&amp; flag!=0) //当前找到的子表非空，这样才可能包含关键字 &#123; if (stack[stack.size() - 1].position.size()!=0) //当前非空子表包含关键字 &#123; subcount++; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个含" &lt;&lt; key &lt;&lt; "的非空子表:"; suboutput(stack[stack.size() - 1].ptr); //输出含关键字的非空子表 cout &lt;&lt; key &lt;&lt; "是其中第"; //输出关键字在非空子表中的位置 for (auto i = stack[stack.size() - 1].position.begin(); i &lt; stack[stack.size() - 1].position.end(); ++i) &#123; if (i == stack[stack.size() - 1].position.begin()) cout &lt;&lt; *i; else cout &lt;&lt; "," &lt;&lt; *i; &#125; cout &lt;&lt; "个表元素" &lt;&lt; endl; cout &lt;&lt; "该表深度:" &lt;&lt; depth &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身 cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出之 output(stack); &#125; cout &lt;&lt; endl; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; if (ptr-&gt;info.value == key) //搜索到关键字 &#123; stack[stack.size() - 1].position.push_back(stack[stack.size() - 1].numnode); //关键字在其所在子表的下一位置压入记录子表关键字位置的stack栈顶的position栈 &#125; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个子表含有" &lt;&lt; key &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (3)在广义表中搜索指定深度子表: 每进入新的一层子表先检查下一层子表是否超过指定深度，若超过不进入下一层子表，直接跳过。每找到新子表，检验深度即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;void output(vector&lt;Gennode&gt; &amp;stack);void suboutput(Gen *head);Gen * strtogen();int main()&#123; int depth = 0; int maxdepth; int flag = 0; int subcount = 0; int emptycount = 0; bool TF = true; vector&lt;Gennode&gt; stack; Gen *ptr=strtogen();//ptr初始化为指向广义表附加头节点的指针 cout &lt;&lt; "请输入指定深度:" &lt;&lt; endl; //输入想要求出的相同深度子表的深度 cin &gt;&gt; maxdepth; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (depth == maxdepth) //下一层深度大于指定深度，不进入下一层，继续递进至本层下一节点 &#123; ptr = ptr-&gt;tlink; flag = 1; ++stack[stack.size() - 1].numnode; continue; &#125; depth++; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (depth == maxdepth) //找到指定深度子表 &#123; subcount++; if (flag == 2) //找到一个指定深度子空表 &#123; ++emptycount; cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; output(stack); &#125; else &#123; if (flag == 1) &#123; //找到一个指定深度非空子表 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表(非空):"; suboutput(stack[stack.size() - 1].ptr); //输出之该指定深度子表 cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; if (stack[stack.size() - 1].ptr-&gt;utype == 0) &#123; //当前非空子表为广义表本身, cout &lt;&lt; "该非空子表为广义表本身" &lt;&lt; endl; &#125; else &#123; //当前非空子表为真子表，栈中存有完整位置信息,输出 output(stack); &#125; &#125; else &#123; ++emptycount; //找到指定深度子空表,即为广义表本身,输出之 cout &lt;&lt; "第" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,为空表:()" &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; 0 &lt;&lt; endl; cout &lt;&lt; "位置:" &lt;&lt; endl; cout &lt;&lt; "该子空表为广义表本身" &lt;&lt; endl; &#125; &#125; &#125; depth--; ptr = stack[stack.size() - 1].ptr; stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ptr = ptr-&gt;tlink; flag = 1; &#125; &#125; &#125; cout &lt;&lt; "共有" &lt;&lt; subcount &lt;&lt; "个指定深度的子表,其中有" &lt;&lt; emptycount &lt;&lt; "个空表" &lt;&lt; endl; return 0;&#125;void output(vector&lt;Gennode&gt; &amp;stack)&#123; for (auto i = stack.begin(); i != stack.end() - 1; ++i) &#123; if (i == stack.begin()) &#123; cout &lt;&lt; "广义表的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; else &#123; cout &lt;&lt; "的第" &lt;&lt; (*i).numnode &lt;&lt; "个表元素"; &#125; &#125; cout &lt;&lt; endl;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; (4)确定各个子表左右括号的起始终止位置以及序数 需要栈position记录入栈左括号序数位置，left,right分别记录左右括号序数,遇到左括号left增一,右括号right增一，扫描到附加头节点即左括号时左括号序数位置进栈，遍历完子表后栈顶元素存放子表左括号位置叙述，右括号位置序数由right,total给出,输出即可，然后出栈 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(0) &#123;&#125;&#125;;class position //位置节点，记录入栈左括号的序数和在字符串中的位置&#123;public: int place; //位置 int index; //序数 position(int p, int i) :place(p), index(i) &#123;&#125;&#125;;void suboutput(Gen *head);Gen * strtogen();int main()&#123; int flag = 0; bool TF = true; vector&lt;Gennode&gt; stack; vector&lt;position&gt; match; //记录左括号位置序数的栈 int left = 0, right = 0, total = 0; //初始化左括号序数,右括号序数,和当前在字符串广义表中遍历到的位置 Gen *ptr = strtogen();//ptr初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; ++left; //扫描到附加头节点，对应左括号，因此left,total加一 ++total; position temp(total, left); //入栈 match.push_back(temp); if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); stack.push_back(temp); flag = 0; ptr = ptr-&gt;tlink; &#125; else &#123; ++stack[stack.size() - 1].numnode; Gennode temp(ptr); stack.push_back(temp); flag = 2; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; flag = 1; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; ++right; //子表遍历完毕，对应右括号，因此right,total加一 ++total; if (flag == 2) //找到一个子空表 &#123; cout &lt;&lt; "子表 ():"; &#125; else &#123; if (flag == 1) &#123; //找到一个非空子表 cout &lt;&lt; "子表 "; suboutput(stack[stack.size() - 1].ptr); //输出非空子表 cout &lt;&lt; ":"; &#125; else //找到空表，为广义表本身 &#123; cout &lt;&lt; "子表 ():"; &#125; &#125; cout &lt;&lt; endl; cout &lt;&lt; " 长度:" &lt;&lt; stack[stack.size() - 1].numnode &lt;&lt; endl; cout &lt;&lt; "(为从左至右数起第" &lt;&lt; match[match.size() - 1].index &lt;&lt; "个 "; //输出当前子表左右括号序数位置 cout &lt;&lt; ")为第" &lt;&lt; right &lt;&lt; "个 "; cout &lt;&lt; "(下标为" &lt;&lt; match[match.size() - 1].place &lt;&lt; " )下标为" &lt;&lt; total &lt;&lt; endl; cout &lt;&lt; endl; match.pop_back(); //出栈 ptr = stack[stack.size() - 1].ptr; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) ++total; //当前子表右括号后应跟逗号，故total加一 stack.pop_back(); TF = false; &#125; else &#123; ++stack[stack.size() - 1].numnode; ++total; //对原子项total应加一 ptr = ptr-&gt;tlink; if (ptr != nullptr) ++total; //原子项后跟逗号，total加一 flag = 1; &#125; &#125; &#125; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr==head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; return ptr;&#125; 还有其他诸多未在上方给出实现的运算都很容易实现，有兴趣可以自己尝试]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用非递归方法实现共享表运算]]></title>
    <url>%2Fpost%2F11638.html</url>
    <content type="text"><![CDATA[这里把无共享表的广义表的运算代码(基于附加头节点的链表表示)稍作修改，得到了基于附加头节点链表表示的共享表运算代码，这里就不详细注释了，可以参考之前发布的无共享表运算代码的注释来帮助理解，在共享表运算代码里映射表标准库类型map起到了重要作用 广义表(包括共享表情形)字符串形式和链表表示的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) :utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Search(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position-1]-1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将广义表的字符串形式转换为带附加头节点的链表形式" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; TF = true; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Search(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表(包括共享表情形)字符串形式和多叉树（包括共享树） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode=0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen=0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s!=',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 广义表（包括共享表情形）链表表示和多叉树（包括共享树情形）的相互转换： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist, int &amp;k);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Gen *ptr = strtogen(glist, k);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; map&lt;Gen *, Knode *&gt; sharelist; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k, 0); treestack.push_back(dest); &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharelist.find(ptr-&gt;info.hlink); if (p != sharelist.end()) &#123; dest-&gt;p[++genstack[genstack.size() - 1].numnode] = p-&gt;second; ++p-&gt;second-&gt;ref; TF = false; continue; &#125; &#125; Knode *temp = new Knode(k, 1); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; dest = temp; treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; if (ptr-&gt;info.ref &gt; 1) sharelist.insert(make_pair(ptr, dest)); &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, 1, ptr-&gt;info.value); dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; map&lt;Knode *, Gen *&gt; sharetree; Gen *p = new Gen(0, 0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref&gt;1) &#123; auto q = sharetree.find(ptr1); temp = new Gen(1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp = new Gen(1); temp-&gt;info.hlink = new Gen(0, 1); &#125; &#125; else &#123; temp = new Gen(2, ptr1-&gt;data); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (ptr1-&gt;ref &gt; 1) &#123; auto q = sharetree.find(ptr1); if (q != sharetree.end()) &#123; temp-&gt;info.hlink = q-&gt;second; ++q-&gt;second-&gt;info.ref; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); sharetree.insert(make_pair(ptr1, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, 1); &#125; if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink-&gt;tlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; if (p-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; continue; &#125; else &#123; genstack2.push_back(p); TF = true; &#125; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; k=creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享树链表表示的删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (--ptr-&gt;info.hlink-&gt;info.ref &gt; 0) &#123; TF = false; continue; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;tlink == nullptr) &#123; delete ptr-&gt;info.hlink; ptr-&gt;info.hlink = nullptr; TF = false; &#125; else &#123; ptr = ptr-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; delete ptr; ptr = nullptr; &#125; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; break; &#125; else &#123; stack.pop_back(); delete ptr; ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 共享表链表表示复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen * strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 map&lt;Gen *, Gen *&gt; share; Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; Gen *temp = new Gen(0, ptr1-&gt;info.ref); if (ptr1-&gt;info.ref == 0) &#123; stack1.push_back(ptr1); stack2.push_back(temp); &#125; else &#123; ptr2-&gt;info.hlink = temp; &#125; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; else &#123; Gen *temp = new Gen(1); if (ptr1-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = share.find(ptr1-&gt;info.hlink); if (p != share.end()) &#123; temp-&gt;info.hlink = p-&gt;second; TF = false; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); share.insert(make_pair(ptr1-&gt;info.hlink, temp-&gt;info.hlink)); &#125; &#125; else &#123; temp-&gt;info.hlink = new Gen(0, ptr1-&gt;info.hlink-&gt;info.ref); &#125; if (ptr2-&gt;utype == 1) &#123; if (ptr2 == stack2[stack2.size() - 1]) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; &#125; else &#123; ptr2-&gt;tlink = temp; &#125; ptr2 = temp; if (TF==false) &#123; ptr1 = ptr1-&gt;tlink; TF = true; &#125; else &#123; stack2.push_back(ptr2); stack1.push_back(ptr1); ptr1 = ptr1-&gt;info.hlink-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink-&gt;tlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 带共享子树的多叉树删除： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; stack.pop_back(); break; &#125; else &#123; if (d == 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; if (ptr-&gt;data != '\0' || --ptr-&gt;ref == 0) &#123; delete ptr; &#125; &#125; else &#123; stack.pop_back(); stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; delete ptr; &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; if (ptr-&gt;ref != 0) &#123; if (--ptr-&gt;ref &gt; 0) &#123; stack[stack.size() - 1].ptr-&gt;p[stack[stack.size() - 1].num - 1] = nullptr; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; continue; &#125; &#125; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 带共享子树的多叉树复制： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;class Knode&#123;public: char data; int ref; Knode **p; Knode(int k, int r, char ch);&#125;;Knode::Knode(int k, int r, char ch = '\0')&#123; ref = r; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Knode *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);Knode *strtoktree(string &amp;glist, int &amp;k);void treetostr(Knode *ptr, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; int k; Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; map&lt;Knode *, Knode *&gt; sharetree; while (true) &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (ptr1-&gt;data == '\0') &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; continue; &#125; &#125; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; if (ptr1-&gt;ref &gt; 1) &#123; auto p = sharetree.find(ptr1); if (p != sharetree.end()) &#123; stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = p-&gt;second; ptr2 = p-&gt;second; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; continue; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); sharetree.insert(make_pair(ptr1, ptr2)); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;ref, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; stack2.push_back(ptr2); &#125; &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; class node &#123; public: int left; int numnode = 0; node(int l) :left(l) &#123;&#125; &#125;; vector&lt;node&gt; stack; int total = 0, maxlen = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1].numnode; ++total; stack.push_back(*(new node(total))); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1].left - 1, total - stack[stack.size() - 1].left + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; if (stack[stack.size() - 1].numnode&gt;maxlen) maxlen = stack[stack.size() - 1].numnode; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1].left); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1].left); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; if (s != ',') ++stack[stack.size() - 1].numnode; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125; return maxlen;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;Knode *strtoktree(string &amp;glist, int &amp;k)&#123; map&lt;string, info&gt; sharelist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; k = creatsharelist(glist, sharelist); for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Knode(k, 0); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end()) &#123; if (p-&gt;second.share != nullptr) &#123; ptr-&gt;p[++stack[stack.size() - 1].numnode] = p-&gt;second.share; ++p-&gt;second.share-&gt;ref; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; &#125; Knode *temp = new Knode(k, 1); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); if (p != sharelist.end()) p-&gt;second.share = ptr; &#125; &#125; else &#123; if (glist[i] == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (glist[i] != ',') &#123; Knode *temp = new Knode(k, 1, glist[i]); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 求链表表示的共享表深度： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;void suboutput(Gen *head);Gen * strtogen();void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; int depth = 0; int maxdepth = 0; int sign = 0; bool TF = true; vector&lt;Gen *&gt; stack; map&lt;Gen *, int&gt; sharemaxdep; Gen *ptr=strtogen();//ptr应初始化为指向广义表附加头节点的指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; sign = 0; stack.push_back(ptr); ++depth; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; sign = 0; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = sharemaxdep.find(ptr-&gt;info.hlink); if (p != sharemaxdep.end()) &#123; if (depth + 1 &gt; p-&gt;second) p-&gt;second = depth + 1; else &#123; sign = 1; ptr = ptr-&gt;tlink; continue; &#125; &#125; else &#123; sharemaxdep.insert(make_pair(ptr-&gt;info.hlink, depth+1)); &#125; &#125; stack.push_back(ptr); ++depth; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; sign = 1; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (sign == 0) &#123; if (depth &gt; maxdepth) maxdepth = depth; &#125; depth--; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; ptr = ptr-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "广义表深度:"&lt;&lt; maxdepth&lt;&lt;endl; return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125; 从共享表中搜索并删除指定值： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;algorithm&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v); Gen(int u, int r);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; info.hlink = nullptr;&#125;Gen::Gen(int u, int r) : utype(u), tlink(nullptr)&#123; info.ref = r;&#125;Gen::Gen(int u, char v) : utype(u), tlink(nullptr)&#123; info.value = v;&#125;class info&#123;public: vector&lt;int&gt; left; vector&lt;int&gt; right; Gen *share = nullptr; vector&lt;int&gt;::size_type position = 0;&#125;;Gen *strtogen();void suboutput(Gen *head);void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist);map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist);int main()&#123; bool TF = true; char key; vector&lt;Gen *&gt; stack; vector&lt;Gen *&gt; share; Gen *ptr= strtogen();//ptr应初始化为指向广义表附加头节点的指针 Gen *before = ptr; cout &lt;&lt; "请输入要删除的值:" &lt;&lt; endl; cin &gt;&gt; key; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); &#125; else &#123; before = before-&gt;info.hlink; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink-&gt;info.ref &gt; 1) &#123; auto p = find(share.begin(), share.end(), ptr-&gt;info.hlink); if (p != share.end()) &#123; ptr = ptr-&gt;tlink; before = before-&gt;tlink; continue; &#125; else &#123; share.push_back(ptr-&gt;info.hlink); &#125; &#125; stack.push_back(ptr); before = before-&gt;tlink; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; before = ptr; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; before = before-&gt;tlink; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (ptr-&gt;info.value == key) &#123; before-&gt;tlink = ptr-&gt;tlink; delete ptr; ptr = before-&gt;tlink; &#125; else &#123; before = before-&gt;tlink; ptr = ptr-&gt;tlink; &#125; &#125; &#125; &#125; cout &lt;&lt; "删除后的广义表为:"; suboutput(ptr); return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) //注意 &#123; if (ptr-&gt;info.ref == 0) &#123; stack.push_back(ptr); cout &lt;&lt; "("; &#125; ptr = ptr-&gt;tlink; &#125; else &#123; stack.push_back(ptr); cout &lt;&lt; "("; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;tlink != nullptr &amp;&amp; ptr != head) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; map&lt;string, info&gt; sharelist; creatsharelist(glist, sharelist); Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; int ref = 0; for (string::size_type i = 0; i != glist.size(); ++i) &#123; if (glist[i] == '(') &#123; if (i == 0) &#123; ptr = new Gen(0, 0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; auto p = Searchshare(i + 1, sharelist); if (p != sharelist.end() &amp;&amp; p-&gt;second.share != nullptr) &#123; temp-&gt;info.hlink = p-&gt;second.share; ++p-&gt;second.share-&gt;info.ref; TF = false; ptr = temp; i = p-&gt;second.right[p-&gt;second.position - 1] - 1; continue; &#125; else &#123; stack.push_back(temp); TF = true; ptr = temp; temp = new Gen(0, 1); ptr-&gt;info.hlink = temp; if (p != sharelist.end()) p-&gt;second.share = ptr-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (glist[i] == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (glist[i] != ',') &#123; Gen *temp = new Gen(2, glist[i]); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink-&gt;tlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125;void creatsharelist(string &amp;glist, map&lt;string, info&gt; &amp;sharelist)&#123; vector&lt;int&gt; stack; int total = 0; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; ++total; stack.push_back(total); &#125; else if (s == ')') &#123; ++total; string temp = glist.substr(stack[stack.size() - 1] - 1, total - stack[stack.size() - 1] + 1); auto p = sharelist.find(temp); if (p == sharelist.end()) &#123; auto q = sharelist.insert(make_pair(temp, *(new info))); q.first-&gt;second.left.push_back(stack[stack.size() - 1]); q.first-&gt;second.right.push_back(total); &#125; else &#123; p-&gt;second.left.push_back(stack[stack.size() - 1]); p-&gt;second.right.push_back(total); &#125; stack.pop_back(); &#125; else &#123; ++total; &#125; &#125; auto m = sharelist.begin(); while (m != sharelist.end()) &#123; if (m-&gt;second.left.size() == 1) m = sharelist.erase(m); else ++m; &#125;&#125;map&lt;string, info&gt;::iterator Searchshare(int left, map&lt;string, info&gt; &amp;sharelist)&#123; auto p = sharelist.begin(); for (; p != sharelist.end(); ++p) &#123; if (p-&gt;second.left.size() != p-&gt;second.position &amp;&amp; p-&gt;second.left[p-&gt;second.position] == left) &#123; ++p-&gt;second.position; return p; &#125; &#125; return p;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多叉树和普通树的复制，删除和比较的非递归实现（深度优先遍历)]]></title>
    <url>%2Fpost%2F55547.html</url>
    <content type="text"><![CDATA[多叉树的复制 很简单深度优先遍历要拷贝的树，要拷贝的树的遍历指针刚好比目标树拷贝指针快一步，这样就能实现要拷贝的树的子节点副本和拷入的目标树的父节点的连接 代码:(所有运算均用c++实现)&nbsp; 程序接受广义表字符串输入，将其转化为多叉树，然后复制多叉树并转换为广义表输出 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);void treetostr(Knode *ptr, const int k); //输出拷贝后K叉树的函数int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr1 = strtoktree(glist, k); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2=nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) //循环开始，将源K叉树拷贝为目标K叉树 &#123; if (Search(ptr1, d1, k) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //直接拷贝根节点 &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; //拷贝成功,退出 &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(k, ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1] = ptr2; //拷贝并链接叶子 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); //以父节点为根节点的子树拷贝完成,ptr1,ptr2均向上回溯 ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝根节点 stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(k, ptr1-&gt;data); //拷贝子节点并链接至父节点 stack2[stack2.size() - 1]-&gt;p[stack1[stack1.size() - 1].num - 1]=ptr2; stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1, k)); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) //ptr1所指父节点的一个子分支拷贝完成,因此ptr2回溯 stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1, k); interval = ptr1-&gt;p[Search(ptr1, d1, k) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "K叉树拷贝成功!" &lt;&lt; endl; treetostr(ptr2, k); //输出拷贝出的K叉树,ptr2为目标K叉树根节点 return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; return ptr; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl;&#125;void treetostr(Knode *ptr, const int k)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "拷贝后的K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果: 普通树复制：程序接受广义表字符串输入，将其转化为普通树，然后复制普通树并转换为广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);void treetostr(Knode *ptr);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr1 = strtoktree(glist); //初始化为源K叉树根节点指针 Knode *root1 = ptr1; Knode *ptr2 = nullptr; //目标K叉树指针 int d1 = 0; vector&lt;Path&gt; stack1; vector&lt;Knode *&gt; stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; &#125; break; &#125; else &#123; if (d1 == 0) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; &#125; else &#123; stack1.pop_back(); ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; if (ptr2 == stack2[stack2.size() - 1]) &#123; stack2.pop_back(); &#125; ptr2 = stack2[stack2.size() - 1]; &#125; &#125; &#125; else &#123; Knode *interval; if (d1 == 0) &#123; if (ptr1 == root1) &#123; ptr2 = new Knode(ptr1-&gt;data); stack2.push_back(ptr2); &#125; else &#123; ptr2 = new Knode(ptr1-&gt;data); stack2[stack2.size() - 1]-&gt;p.push_back(ptr2); stack2.push_back(ptr2); &#125; Path temp(ptr1, Search(ptr1, d1)); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp); &#125; else &#123; if (ptr2 == stack2[stack2.size() - 1]) stack2.pop_back(); ptr2 = stack2[stack2.size() - 1]; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval = ptr1-&gt;p[Search(ptr1, d1) - 1]; &#125; ptr1 = interval; d1 = 0; &#125; &#125; cout &lt;&lt; "普通树拷贝成功!" &lt;&lt; endl; treetostr(ptr2); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;void treetostr(Knode *ptr)&#123; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].ptr; d = treestack[treestack.size() - 1].num; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.num - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].num - 1]; &#125; ptr = interval; d = 0; &#125; &#125;&#125; 运行结果同上 K叉树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path //辅助遍历K叉树的类类型&#123;public: Knode *ptr; //指向父节点的指针 int num; //父节点前进至子节点的方向 Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode //辅助创建K叉树的类类型&#123;public: int numnode; //父节点已创建的子树数目减一的值 Knode *ptr; //父节点指针 Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist1; cout &lt;&lt; "请输入K叉树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; const int k1 = maxlength(glist1); Knode *ptr1 = strtoktree(glist1, k1), *root1=ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入K叉树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; const int k2 = maxlength(glist2); Knode *ptr2 = strtoktree(glist2, k2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag=1; //flag==0表示两树不等,==1相反 vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1, k1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) != 0) //树1根节点结构或值是否和树2对应节点不相同 &#123; flag = 0; //不同,flag置位 &#125; &#125; break; //比较完成，退出 &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2, k2) != 0 || ptr1-&gt;data != ptr2-&gt;data) //树1叶子值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2, k2) != 0) //子节点结构是否不同 &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2, k2) == 0) //树一有分支节点的值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1, k1)); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2, k2)); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2, k2) == 0) //树一多分支节点值或结构是否和树2对应节点不同 &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1, k1); interval1 = ptr1-&gt;p[Search(ptr1, d1, k1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2, k2); interval2 = ptr2-&gt;p[Search(ptr2, d2, k2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "K叉树1和K叉树2相等"; else cout &lt;&lt; "K叉树1和K叉树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr;&#125; 运行结果： 普通树的比较： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist1; cout &lt;&lt; "请输入普通树1的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist1; Knode *ptr1 = strtoktree(glist1), *root1 = ptr1;//初始化为树1根节点指针 string glist2; cout &lt;&lt; "请输入普通树2的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist2; Knode *ptr2 = strtoktree(glist2); //初始化为树2根节点指针 int d1 = 0, d2 = 0, flag = 1; vector&lt;Path&gt; stack1, stack2; while (true) &#123; if (Search(ptr1, d1) == 0) &#123; if (ptr1 == root1) &#123; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) != 0) &#123; flag = 0; &#125; &#125; break; &#125; else &#123; if (d1 == 0) &#123; if (Search(ptr2, d2) != 0 || ptr1-&gt;data != ptr2-&gt;data) &#123; flag = 0; break; &#125; &#125; else &#123; if (Search(ptr2, d2) != 0) &#123; flag = 0; break; &#125; stack1.pop_back(); stack2.pop_back(); &#125; ptr1 = stack1[stack1.size() - 1].ptr; d1 = stack1[stack1.size() - 1].num; ptr2 = stack2[stack2.size() - 1].ptr; d2 = stack2[stack2.size() - 1].num; &#125; &#125; else &#123; Knode *interval1, *interval2; if (d1 == 0) &#123; if (ptr1-&gt;data != ptr2-&gt;data || Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; Path temp1(ptr1, Search(ptr1, d1)); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack1.push_back(temp1); Path temp2(ptr2, Search(ptr2, d2)); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; stack2.push_back(temp2); &#125; else &#123; if (Search(ptr2, d2) == 0) &#123; flag = 0; break; &#125; stack1[stack1.size() - 1].num = Search(ptr1, d1); interval1 = ptr1-&gt;p[Search(ptr1, d1) - 1]; stack2[stack2.size() - 1].num = Search(ptr2, d2); interval2 = ptr2-&gt;p[Search(ptr2, d2) - 1]; &#125; ptr1 = interval1; d1 = 0; ptr2 = interval2; d2 = 0; &#125; &#125; if (flag == 1) cout &lt;&lt; "普通树1和普通树2相等"; else cout &lt;&lt; "普通树1和普通树2不等"; cout &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125; 运行结果类似 K叉树的删除： 对于K叉树来说父子节点从顶层至底层单向链接,所以用广度优先遍历删除的话需要从底层开始向上删除，如果从顶层开始删除会造成子节点的丢失和不可访问。从底层叶子开始删除，删除后回溯至上一层，如果上一层父节点还有未删除分支，则进入该分支继续从底层开始删除，如果父节点所有分支均删除完毕就删除父节点并回溯至上上层父节点继续删除其他分支，以此类推直到根节点的所有分支均被删除，最后删除根节点即可。这一过程其实就是树的深度优先遍历，只不过是边遍历边删除而已，c++代码实现如下（相对来说比较简单）：程序读入K叉树广义表形式转化为K叉树，并将K叉树删除 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);int maxlength(string &amp;glist);Knode *strtoktree(string &amp;glist, const int k);int main()&#123; string glist; cout &lt;&lt; "请输入K叉树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; const int k = maxlength(glist); Knode *ptr=strtoktree(glist, k), *root=ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d, k) == 0) &#123; if (ptr == root) &#123; delete ptr; //删除根节点，删除成功，退出 break; &#125; else &#123; delete ptr; //删除叶子或有分支子节点 if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; //ptr和d回退至被删除节点的父节点 d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d, k); interval = ptr-&gt;p[Search(ptr, d, k) - 1]; &#125; ptr = interval; //前进至下一层子节点 d = 0; &#125; &#125; cout &lt;&lt; "K叉树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125;Knode *strtoktree(string &amp;glist, const int k)&#123; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(k); Gennode temp(ptr); stack.push_back(temp); &#125; else &#123; Knode *temp = new Knode(k); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; ptr = temp; Gennode temp2(ptr); stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(k, *i); ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; return ptr; &#125; 类似的，我们有普通树的删除算法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *ptr; int num; Path(Knode *ptr, int d) :ptr(ptr), num(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d);Knode *strtoktree(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入普通树的广义表形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = strtoktree(glist), *root = ptr;//初始化为根节点指针 int d = 0; vector&lt;Path&gt; stack; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == root) &#123; delete ptr; break; &#125; else &#123; delete ptr; if (d != 0) &#123; stack.pop_back(); &#125; ptr = stack[stack.size() - 1].ptr; d = stack[stack.size() - 1].num; &#125; &#125; else &#123; Knode *interval; if (d == 0) &#123; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[Search(ptr, d) - 1]; stack.push_back(temp); &#125; else &#123; stack[stack.size() - 1].num = Search(ptr, d); interval = ptr-&gt;p[Search(ptr, d) - 1]; &#125; ptr = interval; d = 0; &#125; &#125; cout &lt;&lt; "普通树删除成功!" &lt;&lt; endl; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;Knode *strtoktree(string &amp;glist)&#123; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; return ptr;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[广义表链表表示的复制删除比较运算的非递归实现(c++)]]></title>
    <url>%2Fpost%2F40916.html</url>
    <content type="text"><![CDATA[广义表链表表示的删除：从广义表附加头节点开始，逐一分离表头元素，是原子项就直接删除,是子表附加头节点则暂不删除，直接进入子表，再分离表头元素，然后用相同的方法删除，子表删除完成后向上回溯，继续删除上一层子表，如此不断进行直到整个广义表被删除为止代码（C++） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include&lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();int main()&#123; Gen *ptr = strtogen(); //ptr初始化为广义表附加头结点指针 bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); if (ptr-&gt;utype == 0) &#123; if (ptr-&gt;tlink == nullptr) &#123; stack.pop_back(); TF = false; continue; &#125; ptr = ptr-&gt;tlink; //拉链，分理出广义表附加头节点的下一待删除节点 stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; else &#123; if (ptr-&gt;info.hlink == nullptr) TF = false; else &#123; ptr = ptr-&gt;info.hlink; //拉链，分离出ptr指向的子表附加头节点在子表中的下一节点 stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) &#123; delete ptr; //删除附加头节点，至此删除成功，退出 break; &#125; else &#123; delete ptr; //删除子表附加头节点，子表删除成功 stack.pop_back(); ptr = nullptr; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size() - 1]; stack.pop_back(); &#125; else //广义表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; TF = true; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点全部删除完毕 &#123; TF = false; ptr = stack[stack.size()-1]; &#125; else //子表附加头节点下一子表附加头节点及子表删除完毕 &#123; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;utype == 0) &#123; if (stack[stack.size() - 1]-&gt;tlink == nullptr) //广义表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; //删除之 ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else //广义表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;tlink; stack[stack.size() - 1]-&gt;tlink = ptr-&gt;tlink; &#125; &#125; else &#123; if (stack[stack.size() - 1]-&gt;info.hlink == nullptr) //子表除附加头节点外还剩一个原子项待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]; TF = false; &#125; else //子表头节点后的原子项待删除,其后还有节点待删除 &#123; delete ptr; ptr = stack[stack.size() - 1]-&gt;info.hlink; stack[stack.size() - 1]-&gt;info.hlink = ptr-&gt;tlink; &#125; &#125; &#125; &#125; &#125; //运行结束后ptr成为野指针,栈空,删除成功 cout &lt;&lt; "链表形式的广义表删除成功!"&lt;&lt; endl; return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 广义表链表表示的复制： 就是按广度优先遍历的次序逐一复制，为方便复制，目标表指针总比原表遍历指针慢一步，原表遍历完成后复制就结束了 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;Gen * strtogen();void suboutput(Gen *head);int main()&#123; vector&lt;Gen *&gt; stack1;//源栈 vector&lt;Gen *&gt; stack2;//目标栈 Gen *ptr1=strtogen(); //ptr1初始化为源广义表附加头节点指针 Gen *ptr2=nullptr; //ptr2为目标广义表拷贝指针 bool TF = true; while (true) //循环开始,将源广义表链表表示拷贝为目标广义表链表表示 &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; stack1.push_back(ptr1); if (ptr1-&gt;utype == 0) &#123; ptr2 = new Gen(0); //拷贝广义表附加头节点,完成后ptr1递进 ptr2-&gt;info.ref = ptr1-&gt;info.ref; stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; &#125; else &#123; if (ptr2-&gt;utype == 1) //需要把子表附加头节点拷贝至ptr2所指附加头节点后 &#123; Gen *temp = new Gen(1); if (ptr2 == stack2[stack2.size() - 1]) //ptr2新进至子表头节点,源广义表子表头节点链接至ptr2所指子表中头节点后 ptr2-&gt;info.hlink = temp; else ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; else &#123; Gen *temp = new Gen(1); //由于ptr2指向目标广义表头节点或原子项，所以直接把待拷贝子表头节点链接于其后 ptr2-&gt;tlink = temp; ptr2 = temp; stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); break; //拷贝完毕，退出，ptr2为目标广义表头节点 &#125; else &#123; ptr2 = stack2[stack2.size() - 1]; stack2.pop_back(); ptr1 = ptr1-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) //子表拷贝完毕 &#123; ptr2 = nullptr; ptr1 = stack1[stack1.size() - 1]; stack1.pop_back(); TF = false; &#125; else &#123; Gen *temp = new Gen(2, ptr1-&gt;info.value); //拷贝原子项 if (ptr2-&gt;utype == 1 &amp;&amp; stack2[stack2.size() - 1] == ptr2) ptr2-&gt;info.hlink = temp; //如果ptr2新进至子表头节点，操作和上述相同 else ptr2-&gt;tlink = temp; //操作和上述相同 ptr2 = temp; ptr1 = ptr1-&gt;tlink; &#125; &#125; &#125; cout &lt;&lt; "复制完成,复制后的广义表为:"; suboutput(ptr2); //输出复制后的广义表 return 0;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125; 运行结果： 基于广义表链表表示的比较： 两表指针同步动作，按广度优先遍历逐一比较，比较到某一处节点不等则广义表不等，否则会一直比较至遍历完整个广义表，此时两广义表相等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;bool equals(Gen *ptr1, Gen *ptr2); //判断ptr1和ptr2指向的广义表节点是否相等的函数Gen * strtogen();int main()&#123; vector&lt;Gen *&gt; stack1; vector&lt;Gen *&gt; stack2; Gen *ptr1 = strtogen(); //指向广义表1附加头节点 Gen *ptr2= strtogen(); //指向广义表2附加头节点 //两指针同步动作 bool TF = true; int isequals = 1; //=1两广义表相等，否则不等 while (true) &#123; if (ptr1 != nullptr &amp;&amp; (ptr1-&gt;utype == 0 || ptr1-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr1-&gt;utype == 0) &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;tlink; //附加头节点不必比较，跳过 ptr2 = ptr2-&gt;tlink; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较表1子表头节点或指针和表2对应位置节点或指针 &#123; stack1.push_back(ptr1); stack2.push_back(ptr2); ptr1 = ptr1-&gt;info.hlink; ptr2 = ptr2-&gt;info.hlink; &#125; else &#123; isequals = 0; //不等,isequals置位，退出 break; &#125; &#125; &#125; else &#123; if (ptr1-&gt;utype == 0) //比较完成,退出 break; else &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr1 == nullptr) &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向节点和ptr2或其指向节点 &#123; ptr1 = stack1[stack1.size() - 1]; ptr2 = stack2[stack2.size() - 1]; stack1.pop_back(); stack2.pop_back(); TF = false; &#125; else &#123; isequals = 0; break; &#125; &#125; else &#123; if (equals(ptr1, ptr2) == true) //比较ptr1或其指向的原子项和表2对应位置指针ptr2或其指向的节点 &#123; ptr1 = ptr1-&gt;tlink; ptr2 = ptr2-&gt;tlink; &#125; else &#123; isequals = 0; break; &#125; &#125; &#125; &#125; if (isequals) cout &lt;&lt; "两广义表相等"; else cout &lt;&lt; "两广义表不等"; cout &lt;&lt; endl; return 0;&#125;bool equals(Gen *ptr1, Gen *ptr2) //ptr1和ptr2所指节点相等返回true否则返回false&#123; if (ptr1 == nullptr &amp;&amp; ptr2 == nullptr) return true; else &#123; if (ptr1 != nullptr &amp;&amp; ptr2 != nullptr) &#123; if (ptr1-&gt;utype != ptr2-&gt;utype) return false; else &#123; if (ptr1-&gt;utype == 1) return true; else &#123; if (ptr1-&gt;info.value == ptr2-&gt;info.value) return true; else return false; &#125; &#125; &#125; else &#123; return false; &#125; &#125;&#125;Gen * strtogen()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式的广义表转换为链表形式" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手牛刀小试之提取相同字符组成的子串]]></title>
    <url>%2Fpost%2F27677.html</url>
    <content type="text"><![CDATA[给定一个字符串和子串特征标记，要求从源字符串中提取特征标记代表的所有子串，如： 给定源字符串:AaaBbb,和子串特征标记ab，要求提取出符合特征标记的所有相同字符组成的子串aa和bb JAVA代码如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import java.util.ArrayList;import java.util.Scanner;import static java.lang.System.*;import java.lang.String;public class FindSub&#123; public static void main(String[] args) &#123; String src; String sublable; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); out.println("Please input the source string"); Scanner input=new Scanner(System.in); src=input.nextLine(); out.println("please input the lable of substring"); sublable=input.nextLine(); list=getSub(src, sublable); out.println("All substring is:"); for(String s: list) &#123; out.println(s); &#125; &#125; public static ArrayList&lt;String&gt; getSub(String src, String sublable) &#123; int flag=0; int low=0, high=0; char sign='\u0000'; ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;(); for (int i=0; i&lt;src.length(); i++) &#123; if (sublable.contains(src.substring(i, i+1))) &#123; if (flag==0) &#123; low=i; high=i; flag=1; sign=src.charAt(i); &#125; else &#123; if (src.charAt(i)==sign) &#123; high=i; &#125; else &#123; list.add(src.substring(low, high+1)); low=i; high=i; sign=src.charAt(i); &#125; &#125; &#125; else &#123; if (flag==1) &#123; list.add(src.substring(low, high+1)); flag=0; &#125; &#125; &#125; if (flag==1) list.add(src.substring(low, high+1)); return list; &#125;&#125; 运行结果 该程序可以改进，在输出提取出的子串的同时打印子串在源字符串中的起止标号，这样可以区分相同特征标记的不同子串，如： 源字符串AaaBaa特征标记a 输出aa 1, 2 aa 5,6 懒得改了，有兴趣可以自己尝试]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串广义表和多叉树、普通树以及多叉树、普通树和广义表链表表示的相互转换(非共享表情形)]]></title>
    <url>%2Fpost%2F23619.html</url>
    <content type="text"><![CDATA[程序用string对象接受广义表字符串的输入并将其转换为多叉树，然后将该多叉树转换为字符串广义表输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode //k叉树节点&#123;public: char data; //节点数据域 Knode **p; //指向各子节点指针数组 Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch = '\0') //节点初始化,k即为分叉数&#123; data = ch; p = new Knode *[k]();&#125;class Gennode&#123;public: int numnode; Knode *ptr; Gennode(Knode *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;class Path //辅助k叉树遍历过程的类型&#123;public: Knode *current; //已遍历路径上k叉树节点的指针 int direction; //从当前节点前往其子节点的方向 Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m); //参考我之前写的K叉树运算的文章int maxlength(string &amp;glist); //求广义表glist子表最大长度,即为k叉树分叉树kint main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Gennode&gt; stack; int k = maxlength(glist); for (auto i = glist.cbegin(); i != glist.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == glist.cbegin()) //第一个左括号 &#123; ptr = new Knode(k); //新建根节点入栈 Gennode temp(ptr); stack.push_back(temp); &#125; else //子表左括号 &#123; Knode *temp = new Knode(k); //新建非叶子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //连接至父节点 ptr = temp; Gennode temp2(ptr); //ptr指向新建节点并入栈 stack.push_back(temp2); &#125; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; stack.pop_back(); //直接出栈 if (stack.size() != 0) ptr = stack[stack.size() - 1].ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',') //原子数据 &#123; Knode *temp = new Knode(k, *i); //建立与原子数据对应子节点 ptr-&gt;p[++stack[stack.size() - 1].numnode] = temp; //链接至父节点 &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该K叉树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d, k) == 0) //遍历K叉树(参考我写的K叉树运算文章) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; //遍历完成输出最后的右括号 break; &#125; else &#123; if (d == 0) //叶子 &#123; if (ptr-&gt;data == '\0') //K叉树该叶子对应空表 &#123; cout &lt;&lt; "()"; //输出空表 &#125; else &#123; cout &lt;&lt; ptr-&gt;data; //普通原子项，输出之 &#125; &#125; else &#123; cout &lt;&lt; ")"; //以当前父节点为根节点的子树已转化为字符串广义表输出，所以输出最后的右括号 treestack.pop_back(); //父节点对应的Path节点出栈 &#125; ptr = treestack[treestack.size() - 1].current; //ptr回溯至当前父节点的父节点 d = treestack[treestack.size() - 1].direction; //d更新为父节点的父节点的对应于当前父节点的方向 &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) //抵达新的节点，该节点有子节点 &#123; if (ptr != dest) //该节点不是根节点,其对应子表的左括号为输出，输出之 cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d, k)); interval = ptr-&gt;p[temp.direction-1]; //参考我写的K叉树运算文章 treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; //回溯至的父节点还有下一个子节点，输出下一子节点和其相邻子节点对应表元素之间的逗号 treestack[treestack.size() - 1].direction = Search(ptr, d, k); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; //参考我写的K叉树运算文章 &#125; ptr = interval; ////参考我写的K叉树运算文章 d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; //记录每层子表长度的栈 for (const auto &amp;s : glist) //遍历广义表 &#123; if (s == '(') &#123; if (stack.size() != 0) //遇到非广义表本身的子表的左括号 ++stack[stack.size() - 1]; //该子表所属父表的表元素计数应加一 stack.push_back(0); //计数该子表表元素个数栈节点入栈 &#125; else if (s == ')') //找到子表 &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; //stack栈顶为子表表长，利用其更新子表最大长度 stack.pop_back(); //出栈 &#125; else if (s != ',') //原子项 &#123; ++stack[stack.size() - 1]; //原子项所属子表的表元素计数加一 &#125; &#125; return maxlen; //返回最大长度&#125; 运行结果： 另有字符串广义表和多叉树相互转换的程序如下：C++ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194#include "pch.h"#include &lt;vector&gt;#include &lt;stack&gt;#include &lt;string&gt;#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;struct MultiTreeNode&#123; T *data_field; vector&lt;MultiTreeNode *&gt; sub_node_ptr; MultiTreeNode(size_t n, T *d) :sub_node_ptr(n, nullptr), data_field(d) &#123;&#125; ~MultiTreeNode() &#123; delete data_field; &#125;&#125;;template &lt;typename T&gt;size_t searchD(MultiTreeNode&lt;T&gt; *current, size_t search_pos)&#123; size_t temp = search_pos; for (++temp; temp &lt;= current-&gt;sub_node_ptr.size(); ++temp) &#123; if (current-&gt;sub_node_ptr[temp-1] != nullptr) return temp; &#125; return 0;&#125;void outPutComma(size_t before_num)&#123; for (size_t i = 1; i &lt;= before_num; ++i) &#123; cout &lt;&lt; ", "; &#125;&#125;string charToStr(char t)&#123; string s = " "; s[0] = t; return s;&#125;template &lt;typename T&gt;class Gennode&#123;public: int numnode; MultiTreeNode&lt;T&gt; *ptr; Gennode(MultiTreeNode&lt;T&gt; *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;template &lt;typename T&gt;MultiTreeNode&lt;T&gt; *strGenToTree(string &amp;gen, int k)&#123; MultiTreeNode&lt;T&gt; *ptr = nullptr; stack&lt;Gennode&lt;T&gt;&gt; work_stack; char cur_char = '\0'; auto test = gen.cbegin(); ++test; for (auto i = gen.cbegin(); i != gen.cend(); ++i) //从左至右扫描广义表 &#123; if (*i == '(') //左括号 &#123; if (i == test) //第一个左括号 &#123; ptr = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建根节点入栈 Gennode&lt;T&gt; temp(ptr); work_stack.push(temp); &#125; else //子表左括号 &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //新建非叶子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //连接至父节点 ptr = temp; Gennode&lt;T&gt; temp2(ptr); //ptr指向新建节点并入栈 work_stack.push(temp2); &#125; cur_char = '\0'; &#125; else &#123; if (*i == ')') //右括号，父节点在本层子节点建立并链接完毕 &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt; *temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; work_stack.pop(); //直接出栈 if (work_stack.size() != 0) ptr = work_stack.top().ptr; //ptr回溯至父节点 &#125; else &#123; if (*i != ',' &amp;&amp; *i != ' ') //原子数据 &#123; cur_char = *i; &#125; else if (*i == ',') &#123; if (cur_char != '\0') &#123; MultiTreeNode&lt;T&gt;* temp = new MultiTreeNode&lt;T&gt;(k, new T(cur_char)); //建立与原子数据对应子节点 ptr-&gt;sub_node_ptr[++work_stack.top().numnode] = temp; //链接至父节点 cur_char = '\0'; &#125; &#125; else if (*i == ' ') &#123; ++work_stack.top().numnode; &#125; &#125; &#125; &#125;//扫描完后ptr即为k叉树根节点指针 return ptr;&#125;template &lt;typename T&gt;void output(MultiTreeNode&lt;T&gt; *root) //输出多叉树对应广义表形式&#123; struct StackNode &#123; MultiTreeNode&lt;T&gt; *ptr; size_t index; StackNode(MultiTreeNode&lt;T&gt;* p, size_t i) :ptr(p), index(i) &#123;&#125; &#125;; MultiTreeNode&lt;T&gt; *run = root; size_t d = 0; stack&lt;StackNode&gt; work_stack; while (true) &#123; size_t temp; if ((temp = searchD(run, d)) == 0) &#123; if (run == root) &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; &#125; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)); &#125; else &#123; outPutComma(run-&gt;sub_node_ptr.size() - d); cout &lt;&lt; ")"; work_stack.pop(); &#125; run = work_stack.top().ptr; d = work_stack.top().index; &#125; &#125; else &#123; if (d == 0) &#123; cout &lt;&lt; charToStr(*(run-&gt;data_field)) &lt;&lt; "("; for (size_t q = 1; q &lt;= temp - 1; ++q) &#123; cout &lt;&lt; " ,"; &#125; work_stack.push(StackNode(run, temp)); &#125; else &#123; outPutComma(temp - d - 1); cout &lt;&lt; ","; work_stack.top().index = temp; &#125; run = run-&gt;sub_node_ptr[temp - 1];; d = 0; &#125; &#125;&#125;int main()&#123; int k = 3; string glist = "a(b,c,d( , ,f(t,n, )))"; //每个子表必须包含k项，每项要么是子表，要么是原子项,要么是空格即空表，子表必须以单个字符开头,原子项必须为单个字符，括号要匹配，否则程序无法正确运行 MultiTreeNode&lt;char&gt;* ptr = strGenToTree&lt;char&gt;(glist, k); cout &lt;&lt; "已将字符串广义表转换为多叉树" &lt;&lt; endl; cout &lt;&lt; "多叉树的字符串广义表形式为:"; output(ptr); cout &lt;&lt; endl; return 0;&#125; 运行结果 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为K叉树,再将K叉树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; Knode **p; Knode(int k, char ch);&#125;;Knode::Knode(int k, char ch='\0')&#123; data = ch; p = new Knode *[k]();&#125;class Path &#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;class Gennode&#123;public: int numnode; Gen *ptr; Gennode(Gen *p) :ptr(p), numnode(-1) &#123;&#125;&#125;;int Search(Knode *ptr, int d, const int k);int Enable(Knode *ptr, int m);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 int k = maxlength(glist); bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gennode&gt; genstack; Knode *dest = nullptr; //建树过程中指向树节点指针 while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; Gennode temp(ptr); genstack.push_back(temp); dest = new Knode(k); //当前节点为广义表附加头节点,建立对应K叉树根节点并将其指针入栈 treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(k); //子表头节点,建立对应K叉树子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //将子节点链接至其父节点 dest = temp; //dest递进至子节点，并入栈 treestack.push_back(dest); Gennode temp2(ptr); genstack.push_back(temp2); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //建树完毕退出 break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //子表对应子树创建完毕 &#123; treestack.pop_back(); //出栈 if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; //栈不空则dest指针回溯至父节点 ptr = genstack[genstack.size() - 1].ptr; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(k, ptr-&gt;info.value); //建立与原子数据项对应的叶子节点 dest-&gt;p[++genstack[genstack.size() - 1].numnode] = temp; //叶子节点链接至父节点 ptr = ptr-&gt;tlink; &#125; &#125; &#125; //此时dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为K叉树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); //先分配广义表附加头节点并将其指针入栈 genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d, k) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; //K叉树对应的广义表链表表示建立完毕,取栈顶指针赋予p break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); //叶子对应子空表 else temp = new Gen(2, ptr1-&gt;data); //叶子对应原子数据项 if (p-&gt;utype == 1) &#123; if (TF == true) //为true表示从有分支的子节点前进至新的有分支子节点 &#123; //然后从该子节点前进至的第一个节点就是当前ptr指向的树节点 p-&gt;info.hlink = temp; //这种情况下直接把叶子对应的链表节点链接在其父节点对应的子表中附加头节点后面 if (temp-&gt;utype == 1) //链接的链表节点代表空表，TF应置flase TF = false; &#125; else //为false表示从有分支的子节点或表示空表的子节点回溯至父节点，然后再从父节点前进至当前叶子节点，两种情况下 &#123; //链接链表节点的方式是不同的 p-&gt;tlink = temp; //此时叶子对应的链表节点应该直接连接在同一层子表的最后一个节点后面 &#125; &#125; else &#123; p-&gt;tlink = temp; //此时p要么指向广义表附加头节点要么指向同一层子表的最后一个原子节点，故链表节点直接链接在p后面 if (temp-&gt;utype == 1) //同上 TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) //只有ptr1不指向根节点下面的操作才有意义 &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; //具体说明同上 &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d, k)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d, k); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将K叉树转换为广义表链表表示"&lt;&lt;endl; cout &lt;&lt; "链表表示对应的广义表形式为:"&lt;&lt;endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d, const int k)&#123; int m = d; for (m++; m &lt;= k; m++) &#123; if (Enable(ptr, m) == 1) return m; &#125; return 0;&#125;int Enable(Knode *ptr, int m)&#123; if (ptr-&gt;p[m - 1] != nullptr) return 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示"&lt;&lt;endl; return ptr;&#125;int maxlength(string &amp;glist)&#123; int maxlen = 0; vector&lt;int&gt; stack; for (const auto &amp;s : glist) &#123; if (s == '(') &#123; if (stack.size() != 0) ++stack[stack.size() - 1]; stack.push_back(0); &#125; else if (s == ')') &#123; if (stack[stack.size() - 1] &gt; maxlen) maxlen = stack[stack.size() - 1]; stack.pop_back(); &#125; else if (s != ',') &#123; ++stack[stack.size() - 1]; &#125; &#125; return maxlen;&#125; 运行结果： 广义表字符串形式和链表表示的相互转换 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; //stack辅助广义表遍历栈，存放子表附加头节点指针，TF标志返回上一层还是前进至本层 for (auto i = glist.cbegin(); i != glist.cend(); ++i) //遍历广义表 &#123; if (*i == '(') &#123; if (i == glist.cbegin()) //广义表左括号 &#123; ptr = new Gen(0); //建立广义表附加头节点并入栈 stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); //子表左括号，建立子表附加头节点 if (ptr-&gt;utype == 1) //上一个链接的广义表节点是子表附加头节点 &#123; if (TF == true) ptr-&gt;info.hlink = temp; //此时应链接至上一个子表中，其附加头节点之后 else ptr-&gt;tlink = temp; //否则是从上一子表回溯至本层子表，应链接至本层子表中上一子表附加头节点后 &#125; else &#123; ptr-&gt;tlink = temp; //如果上一次链接的是原子项或分配广义表附加头节点，则直接链接到之后 &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') //本层子表已转换为链表表示 &#123; ptr = stack[stack.size() - 1]; //ptr回退至上一层中本层子表附加头节点 stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); //新建与原子项对应的广义表链表节点 if (ptr-&gt;utype == 1) &#123; if (TF == true) //同上 ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; //扫描完毕此时ptr指向广义表链表表示的附加头结点,栈空 TF = true; while (true) //遍历广义表链表形式 &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; //找到子表或广义表附加头节点，此时应对应输出左括号 if (ptr-&gt;utype == 0) &#123; ptr = ptr-&gt;tlink; //当前节点为广义表附加头节点,直接前进至本层下一节点 &#125; else &#123; ptr = ptr-&gt;info.hlink; //为子表附加头节点,前进至子表中下一节点 &#125; &#125; else &#123; if (ptr-&gt;utype == 0) //遍历完毕退出 break; else &#123; ptr = ptr-&gt;tlink; //从下一层子表回溯至本层子表，故继续让ptr前进至本层下一节点 TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) //已输出完子表除)外的所有项 &#123; cout &lt;&lt; ")"; //应输出右括号 ptr = stack[stack.size() - 1]; //ptr回溯至本层子表上一层子表附加头节点 if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意,ptr不指向广义表附加头节点且有后继节点时应输出逗号 cout &lt;&lt; ","; stack.pop_back(); //出栈 TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; //输出原子项数据值 ptr = ptr-&gt;tlink; if (ptr != nullptr) //有后继节点输出逗号 cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl; return 0;&#125; 程序用string对象接受广义表字符串的输入并将其转换为普通树，然后将该普通树转换为字符串广义表输出 这里将树节点指针域改为vector对象，子节点链接至父节点的操作相应变为向vector对象添加指针的操作&nbsp;这样做的好处是节省内存空间，简化代码，而且无需实现计算树的分叉数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142#include "stdafx.h"#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;vector&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; //这里由于为普通树，故树节点指针域改为存放knode指针的vector对象 Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;int Search(Knode *ptr, int d); //该函数有变动int maxlength(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Knode *ptr = nullptr; vector&lt;Knode *&gt; stack; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Knode(); stack.push_back(ptr); &#125; else &#123; Knode *temp = new Knode(); ptr-&gt;p.push_back(temp); //链接操作改用push_back实现 ptr = temp; stack.push_back(ptr); &#125; &#125; else &#123; if (*i == ')') &#123; stack.pop_back(); if (stack.size() != 0) ptr = stack[stack.size() - 1]; &#125; else &#123; if (*i != ',') &#123; Knode *temp = new Knode(*i); ptr-&gt;p.push_back(temp); &#125; &#125; &#125; &#125;//扫描完后ptr即为普通树根节点指针 cout &lt;&lt; "已将字符串形式的广义表转换为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack; Knode *const dest = ptr; int d = 0; cout &lt;&lt; "该普通树对应的广义表形式为:" &lt;&lt; endl; cout &lt;&lt; "("; while (true) &#123; if (Search(ptr, d) == 0) &#123; if (ptr == dest) &#123; cout &lt;&lt; ")"; break; &#125; else &#123; if (d == 0) &#123; if (ptr-&gt;data == '\0') &#123; cout &lt;&lt; "()"; &#125; else &#123; cout &lt;&lt; ptr-&gt;data; &#125; &#125; else &#123; cout &lt;&lt; ")"; treestack.pop_back(); &#125; ptr = treestack[treestack.size() - 1].current; d = treestack[treestack.size() - 1].direction; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr != dest) cout &lt;&lt; "("; Path temp(ptr, Search(ptr, d)); interval = ptr-&gt;p[temp.direction - 1]; treestack.push_back(temp); &#125; else &#123; cout &lt;&lt; ","; treestack[treestack.size() - 1].direction = Search(ptr, d); interval = ptr-&gt;p[treestack[treestack.size() - 1].direction - 1]; &#125; ptr = interval; d = 0; &#125; &#125; return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) //如果方向d小于ptr节点p对象容量，说明存在下一个可走方向，就是d+1 return d + 1; else return 0;&#125; 运行结果： 程序接受字符串广义表的输入将其转化为链表表示,然后将链表表示转化为普通树,再将普通树转换为链表表示，最后将链表表示转换为字符串形式输出 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356#include "stdafx.h"#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;class Knode&#123;public: char data; vector&lt;Knode *&gt; p; Knode(char ch);&#125;;Knode::Knode(char ch = '\0')&#123; data = ch;&#125;class Path&#123;public: Knode *current; int direction; Path(Knode *ptr, int d) :current(ptr), direction(d) &#123;&#125;&#125;;struct Gen&#123; int utype; union &#123; int ref; struct Gen *hlink; char value; &#125;info; struct Gen *tlink; Gen(int u); Gen(int u, char v);&#125;;Gen::Gen(int u) :utype(u), tlink(nullptr)&#123; if (u == 0) info.ref = 0; else info.hlink = nullptr;&#125;Gen::Gen(int u, char v) :utype(u), tlink(nullptr)&#123; info.value = v;&#125;int Search(Knode *ptr, int d);void suboutput(Gen *head);Gen * strtogen(string &amp;glist);int main()&#123; string glist; cout &lt;&lt; "请输入广义表的字符串形式" &lt;&lt; endl; cin &gt;&gt; glist; Gen *ptr = strtogen(glist);//ptr初始化为指向广义表附加头结点的指针 bool TF = true; vector&lt;Knode *&gt; treestack; vector&lt;Gen *&gt; genstack; Knode *dest = nullptr; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) &#123; if (TF == true) &#123; if (ptr-&gt;utype == 0) &#123; genstack.push_back(ptr); dest = new Knode(); treestack.push_back(dest); ptr = ptr-&gt;tlink; &#125; else &#123; Knode *temp = new Knode(); dest-&gt;p.push_back(temp); dest = temp; treestack.push_back(dest); genstack.push_back(ptr); ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr-&gt;utype == 0) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; treestack.pop_back(); if (treestack.size() != 0) dest = treestack[treestack.size() - 1]; ptr = genstack[genstack.size() - 1]; genstack.pop_back(); TF = false; &#125; else &#123; Knode *temp = new Knode(ptr-&gt;info.value); dest-&gt;p.push_back(temp); ptr = ptr-&gt;tlink; &#125; &#125; &#125; //dest即为根节点指针 cout &lt;&lt; "已将广义表链表表示转化为普通树" &lt;&lt; endl; vector&lt;Path&gt; treestack2; vector&lt;Gen *&gt; genstack2; Gen *p = new Gen(0); genstack2.push_back(p); Knode *ptr1 = dest; int d = 0; while (true) &#123; if (Search(ptr1, d) == 0) &#123; if (ptr1 == dest) &#123; p = genstack2[genstack2.size() - 1]; break; //p即为广义表附加头结点指针 &#125; else &#123; if (d == 0) &#123; Gen *temp; if (ptr1-&gt;data == '\0') temp = new Gen(1); else temp = new Gen(2, ptr1-&gt;data); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; if (temp-&gt;utype == 1) TF = false; &#125; p = temp; d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; &#125; else &#123; p = genstack2[genstack2.size() - 1]; genstack2.pop_back(); treestack2.pop_back(); d = treestack2[treestack2.size() - 1].direction; ptr1 = treestack2[treestack2.size() - 1].current; TF = false; &#125; &#125; &#125; else &#123; Knode *interval = nullptr; if (d == 0) &#123; if (ptr1 != dest) &#123; Gen *temp = new Gen(1); if (p-&gt;utype == 1) &#123; if (TF == true) &#123; p-&gt;info.hlink = temp; &#125; else &#123; p-&gt;tlink = temp; &#125; &#125; else &#123; p-&gt;tlink = temp; &#125; p = temp; genstack2.push_back(p); TF = true; &#125; Path temp = Path(ptr1, Search(ptr1, d)); interval = ptr1-&gt;p[temp.direction - 1]; treestack2.push_back(temp); &#125; else &#123; treestack2[treestack2.size() - 1].direction = Search(ptr1, d); interval = ptr1-&gt;p[treestack2[treestack2.size() - 1].direction - 1]; &#125; ptr1 = interval; d = 0; &#125; &#125; cout &lt;&lt; "已将普通树转换为广义表链表表示" &lt;&lt; endl; cout &lt;&lt; "链表表示对应的广义表形式为:" &lt;&lt; endl; suboutput(p); return 0;&#125;int Search(Knode *ptr, int d)&#123; if (d &lt; ptr-&gt;p.size()) return d + 1; else return 0;&#125;void suboutput(Gen *head)&#123; Gen *ptr = head; bool TF = true; vector&lt;Gen *&gt; stack; while (true) &#123; if (ptr != nullptr &amp;&amp; (ptr-&gt;utype == 0 || ptr-&gt;utype == 1)) //注意 &#123; if (TF == true) &#123; stack.push_back(ptr); cout &lt;&lt; "("; if (ptr-&gt;utype == 0) //注意 &#123; ptr = ptr-&gt;tlink; &#125; else &#123; ptr = ptr-&gt;info.hlink; &#125; &#125; else &#123; if (ptr == head) break; else &#123; ptr = ptr-&gt;tlink; TF = true; &#125; &#125; &#125; else &#123; if (ptr == nullptr) &#123; cout &lt;&lt; ")"; ptr = stack[stack.size() - 1]; if (ptr-&gt;utype != 0 &amp;&amp; ptr-&gt;tlink != nullptr) //注意 cout &lt;&lt; ","; stack.pop_back(); TF = false; &#125; else &#123; cout &lt;&lt; ptr-&gt;info.value; ptr = ptr-&gt;tlink; if (ptr != nullptr) cout &lt;&lt; ","; &#125; &#125; &#125; cout &lt;&lt; endl;&#125;Gen * strtogen(string &amp;glist)&#123; Gen *ptr = nullptr; vector&lt;Gen *&gt; stack; bool TF; for (auto i = glist.cbegin(); i != glist.cend(); ++i) &#123; if (*i == '(') &#123; if (i == glist.cbegin()) &#123; ptr = new Gen(0); stack.push_back(ptr); TF = true; &#125; else &#123; Gen *temp = new Gen(1); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; stack.push_back(temp); TF = true; ptr = temp; &#125; &#125; else &#123; if (*i == ')') &#123; ptr = stack[stack.size() - 1]; stack.pop_back(); TF = false; &#125; else &#123; if (*i != ',') &#123; Gen *temp = new Gen(2, *i); if (ptr-&gt;utype == 1) &#123; if (TF == true) ptr-&gt;info.hlink = temp; else ptr-&gt;tlink = temp; &#125; else &#123; ptr-&gt;tlink = temp; &#125; ptr = temp; &#125; &#125; &#125; &#125; cout &lt;&lt; "已将字符串形式转换为链表表示" &lt;&lt; endl; return ptr;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>广义表，多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串模式匹配的KMP算法中next数组计算方法详解]]></title>
    <url>%2Fpost%2F38063.html</url>
    <content type="text"><![CDATA[使用KMP算法匹配字符串的关键就是正确计算出next数组(不清楚何为模式匹配，何为KMP算法，什么是next数组可以自行百度或参考数据结构教科书)。next数组的计算是一大难点，殷人昆的数据结构教科书中对此问题的论述不够清晰，所列代码和说明部分关联性不强，看了让人似懂非懂。自己花了很长时间琢磨next数组计算的问题，现在总算从头到尾弄明白了，于是就在这里将自己的思考所得与大家分享。 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;现有长为M的模式串P=a0 a1 —– aM-1,记P在索引i，j之间的部分(包括i,j)为P[i,j],要求模式串P[0,M-1]的next数组的各元素next[0]—-next[M-1]。 &nbsp; &nbsp; &nbsp; 首先next[0]=-1(为什么取-1下面有说明),根据next数组的定义，对j&gt;=1,next[j]为串P[0,j-1]的最长相等前后缀子串的长度(对串b0,b1,–,bn,满足b0,–,bk=bn-k,–,bn-1,bn 0&lt;=k&lt;n 的所有相等前后缀子串中的最长者b0,–,bk和bn-k,–,bn-1,bn即为串b0,b1,–,bn的最长相等前后缀子串，其长度为k+1)，若串P[0,j-1]不存在相等的前后缀子串(当然也就不存在最长相等前后缀子串)则令next[j]=0。 &nbsp; &nbsp; &nbsp; 由于我们最先知道next[0]=-1,所以自然就可以考虑在next[0],—,next[j]已知的情况下推算next[j+1]的值，我们来看下图： 这幅图可以给我们一些启发。如图所示，假定j&gt;=1,我们先考虑K1=next[j],若K1=0，则串P[0,j-1]中不存在相等前后缀子串，这意味着串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前缀最后一个元素和后缀最后一个元素P[j]，剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，矛盾。于是串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0,如果K1！=0，则K1就为串P[0,j-1]的最长相等前后缀子串A1，B1的长度，也是A1最末元素下一位置的索引。我们检查P[K1]是否和P[j]匹配，若匹配则A1和P[K1]构成的子串和B1和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A1，B1矛盾。于是串P[0,j]的最长相等前后缀子串的长度就是K1+1,因而next[j+1]=K1+1,这样我们就求出了next[j+1].如果P[K1]和P[j]不匹配,我们令K2=next[K1],若K2=0，则A1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A1,B1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A1的相等前后缀子串，矛盾。这样A1，B1构成了串P[0,j-1]的唯一的相等前后缀子串，但P[K1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1，B1，但假设存在的P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀和后缀的最末元素相互匹配，于是A1，B1下一位置上的元素相互匹配，即P[K1]和P[j]匹配，矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K2！=0，则K2就是A1的最长相等前后缀子串A2，C2的长度，也是A2最末元素下一位置的索引.C2在B1中有相应的镜像B2，则A2，B2构成了串P[0,j-1]第二长的相等前后缀子串，这是因为假若A2，B2不是串P[0,j-1]第二长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A1，B1和A2，B2之间，其前后缀构成了A1的一对相等前后缀子串，注意其长度长于A2，B2和A2，C2，于是矛盾。下面我们检查P[K2]是否和P[j]匹配，若匹配，则A2和P[K2]构成的子串和B2和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A2，B2，因而它只能是A1，B1，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1的下一位置的元素相互匹配，即P[K1]和P[j]相互匹配，矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K2+1,因而next[j+1]=K2+1,这样我们就求出了next[j+1].如果P[K2]和P[j]不匹配,我们令K3=next[K2],若K3=0，则A2中不存在相等前后缀子串，于是串P[0,j-1]中不存在比A2,B2更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了A2的相等前后缀子串，矛盾。注意P[K2]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1和A2，B2中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1和A2，B2中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若K3！=0，则K3就是A2的最长相等前后缀子串A3，C3的长度，也是A3最末元素下一位置的索引.C3在B2中有相应的镜像B3，则A3，B3构成了串P[0,j-1]第三长的相等前后缀子串，这是因为假若A3，B3不是串P[0,j-1]第三长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于A2，B2和A3，B3之间，其前后缀构成了A2的一对相等前后缀子串，注意其长度长于A3，B3和A3，C3，于是矛盾。下面我们检查P[K3]是否和P[j]匹配，若匹配，则A3和P[K3]构成的子串和B3和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于A3，B3，因而它只能是A1，B1，A2，B2中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K2]和P[j]以及P[K1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是K3+1,因而next[j+1]=K3+1,这样我们就求出了next[j+1].如果P[K3]和P[j]不匹配,我们令K4=next[K3]，若K4=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;&hellip;我们令Km=next[Km-1],若Km=0，则Am-1中不存在相等前后缀子串，于是串P[0,j-1]中不存在比Am-1,Bm-1更小的相等前后缀子串，因为如果存在，则后缀与前缀构成了Am-1的相等前后缀子串，矛盾。注意P[Km-1]和P[j]不匹配，故串P[0,j]中不存在长度大于2小于等于j的相等前后缀子串，因为假若存在，去掉前后缀最末元素得到串P[0,j-1]的一对相等前后缀子串，它只能是A1,B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中的一个，而我假设存在的串P[0,j]中长度大于2小于等于j的相等前后缀子串的前缀后缀的最末元素相互匹配，这意味着A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;Am-1,Bm-1中必有一个其前后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]唯一可能存在的相等前后缀子串只能是p[0]和p[j]，下面我们检查是否有p[0]=p[j],若是则p[0]和p[j]就是串P[0,j]唯一的相等前后缀子串，因而就为串P[0,j]的最大相等前后缀子串，其长度为1，故next[j+1]=1.若不是,则说明p[0,j]中不存在相等前后缀子串，从而next[j+1]=0，若Km！=0，则Km就是Am-1的最长相等前后缀子串Am，Cm的长度，也是Am最末元素下一位置的索引.Cm在Bm-1中有相应的镜像Bm，则Am，Bm构成了串P[0,j-1]第m长的相等前后缀子串，这是因为假若Am，Bm不是串P[0,j-1]第m长的相等前后缀子串，那么必有串P[0,j-1]的相等前后缀子串，其长度介于Am-1，Bm-1和Am，Bm之间，其前后缀构成了Am-1的一对相等前后缀子串，注意其长度长于Am，Bm和Am，Cm，于是矛盾。下面我们检查P[Km]是否和P[j]匹配，若匹配，则Am和P[Km]构成的子串和Bm和P[j]构成的子串就是串P[0,j]的最长相等前后缀子串，这是因为假若还存在更长的串P[0,j]的相等前后缀子串，去掉前缀最末元素和后缀最末元素P[j]，则剩下的部分刚好是串P[0,j-1]的一对相等前后缀子串，其长度大于Am，Bm，因而它只能是A1，B1，A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中的一个，注意我假设存在的更长的串P[0,j]的相等前后缀子串的前后缀的最末元素相互匹配，因此A1，B1,A2，B2,&hellip;&hellip;&hellip;&hellip;,Am-1,Bm-1中必有一个其前缀后缀的最末元素的下一位置上的元素相互匹配，这和P[K1]和P[j],P[K2]和P[j],&hellip;&hellip;&hellip;&hellip;,P[Km-1]和P[j]不匹配矛盾。这样串P[0,j]的最长相等前后缀子串的长度就是Km+1,因而next[j+1]=Km+1,这样我们就求出了next[j+1].如果P[Km]和P[j]不匹配,我们令Km+1=next[Km]，若Km+1=0&hellip;&hellip;&hellip;&hellip;&hellip;&hellip; &nbsp; &nbsp; 以此类推，按照上述步骤不断进行下去，注意到j&gt;K1&gt;K2&gt;&hellip;&hellip;&gt;Km&gt;&hellip;&hellip; 所以我们在上述过程中得到的前缀子串A1,A2,——-,Am—-的长度严格递减，由于长度不能为负，所以上述过程不可能无限进行下去，必然在有限步后终止。也就是说，在操作有限步后，要么遇到下图所示的情况： 这里我们最终得到串P[0,j-1]的最短相等前后缀子串An,Bn,但p[Kn]和P[j]无法匹配,于是仿照以上分析令Kn+1=next[Kn],由于An,Bn为最短相等前后缀子串，所以这里必有Kn+1=0.这样我们检查p[0]和p[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0。这样next[j+1]就求出了。 要么遇到下图所示情况： 这里我们最终得到串P[0,j-1]的第m长相等前后缀子串Am,Bm，p[Km]和P[j]能够相互匹配，根据以上分析知next[j+1]=Km+1,这样next[j+1]就求出了。 要么遇到下图所示情况： 按照以上分析，此时检查P[0]和P[j]是否相等，若是则next[j+1]=1,否则next[j+1]=0,这样next[j+1]就求出了。 &nbsp; 综上，可以总结出在已知next[0],next[1],—,next[j]的情况下计算next[j+1]的算法如下(j&gt;=1): (1)将j赋值给k (2)如果next[k]等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;1&gt;如果模式串在索引0处的字符和在索引j处的字符匹配：1赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;如果模式串在索引0处的字符和在索引j处的字符不匹配：0赋值给next[j+1] &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;2&gt;算法结束 &nbsp; &nbsp; 如果next[k]不等于0： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;1&gt;如果模式串在索引next[k]处的字符和在索引j处的字符匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1} next[k]加一赋值给next[j+1]&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2} 算法结束 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 如果模式串在索引next[k]处的字符和在索引j处的字符不匹配： &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{1}next[k]赋值给k &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{2}转(2)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 上述用自然语言描述的算法的JAVA代码是(pat表示模式串P)： 123456789101112131415161718192021222324int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; 以上在已知next[0],next[1],–,next[j]的情况下求next[j+1]的代码对j&gt;=1是适用的，但在j=0时(即已知next[0]求next[1])无效，因为以上代码在首次进入循环后运行到11行时出现了pat.charAt(-1)这样的字符串越界访问，解决这个问题也很简单，把11行改写为 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 就可以了。这样j=0时next[1]的值能正确求出(就是0),这也是为什么next[0]=-1的原因，因为此时若next[0]=-1,则next[1]的值就能正确求出。此外这样改写对j&gt;=1时next[j+1]的求解没有任何影响，这是因为j&gt;=1时代码运行到11行时表达式next[k]==-1的值总为false,这样 1if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) 等价于 1if (pat.charAt(next[k])==pat.charAt(j)) 匹配判断是能够正常进行的 &nbsp; 现在我们可以写出完整的计算next数组的代码了: 代码一 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package nextcompute; import java.util.*; public class nextcom &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; next[0]=-1; for (int j=0; j&lt;pat.length()-1; j++) &#123; int k=j; while(true) &#123; if (next[k]==0) &#123; if (pat.charAt(0)==pat.charAt(j)) next[j+1]=1; else next[j+1]=0; break; &#125; else &#123; if (next[k]==-1 || pat.charAt(next[k])==pat.charAt(j)) &#123; next[j+1]=next[k]+1; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 程序将模式串读入String对象pat，然后计算pat对应的next数组。外层for循环的每一轮循环根据next数组前j+1个值计算next[j+1],内层while循环用于next[j+1]的具体计算 运行结果： 可以验证这是正确的 &nbsp; 为了得到数据结构教科书上给出的简洁形式，我们还需要将代码一进行等价转换。设想，如果每次进入内层while循环前k=next[j],那么代码一20行，30行，32行的next[k]完全可以用k替换,第17行代码可以删除,代码一的k=next[k]保持不变，这是因为在代码一中执行k=next[k]后访问next[k]和在修改的代码中执行k=next[k]后访问k实际上是一样的，此外还需要保证内层while循环结束前(也就是next[j+1]算出时)k=next[j+1],j变为j+1(为下一轮计算next[j+2]作准备),因此代码一可以等价地改写如下： 代码二 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package nextcompute; import java.util.*; public class nextcom2 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; while(true) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[j+1]=1; j++; k=1; &#125; else &#123; next[j+1]=0; j++; k=0; &#125; break; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[j+1]=k+1; k++; j++; break; &#125; else &#123; k=next[k]; &#125; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 注意初始条件 1next[0]=-1; j=0; k=-1; j=0是因为要先由next[0]推算next[1],再由next[0],—,next[j]推算nextj+1,k=-1是因为首次进入外层while循环后第一次进入内层while循环前k应等于next[0]==-1 可以验证代码二的运行结果和代码一是一样的 进一步分析代码二可以发现，代码二中内层嵌套的while循环，34行43行的break完全可以去掉，并且24-26行，30-32行，40-42行可以写成更紧凑的形式，这样我们可以把代码二改写成等价的代码三: 代码三 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package nextcompute; import java.util.*; public class nextcom3 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==0) &#123; if (pat.charAt(0)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; next[++j]=0; &#125; &#125; else &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 可以验证运行结果和代码一一致进一步地，我们很容易就可以把代码三等价地改写成代码四： 代码四 1234567891011121314151617181920212223242526272829303132333435363738package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; if (k==0) next[++j]=0; else k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 运行结果仍然和代码一相同。代码四形式非常简洁，但是仍然可以继续化简，注意到代码四第25行k==0为真时完全可以继续执行k=next[k],最后会在21行执行next[++j]==0,效果和第25行为真时执行next[++j]=0完全相同，故25-28行可统一写为k=next[k],从而得到形式最为简洁的代码五 1234567891011121314151617181920212223242526272829303132333435package nextcompute; import java.util.*; public class nextcom4 &#123; public static void main(String[] args) &#123; String pat; Scanner input=new Scanner(System.in); System.out.println("请输入模式串"); pat=input.nextLine(); int[] next=new int[pat.length()]; int j, k; next[0]=-1; j=0; k=-1; while (j&lt;pat.length()-1) &#123; if (k==-1 || pat.charAt(k)==pat.charAt(j)) &#123; next[++j]=++k; &#125; else &#123; k=next[k]; &#125; &#125; for (int s: next) &#123; System.out.print(s+" "); &#125; System.out.println(); &#125; &#125; 这(代码五)就是数据结构教科书上给出的next数组计算的代码实现，这样通过层层分析我们就确定了next数组计算代码的最简形式，也就是在各类文献资料书籍中最常见的形式。字符串模式匹配的KMP算法中next数组计算方法的详细分析到此结束，笔者水平有限，若有错误和纰漏恳请指正，谢谢。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>KMP算法，模式匹配，字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[K叉树的运算]]></title>
    <url>%2Fpost%2F25312.html</url>
    <content type="text"><![CDATA[以以下4叉树为例(K=4)结点旁的数字代表结点数据域中存放的值，ROOT表示根结点，根结点数据域为0 问题：求K叉树叶子结点的数目和深度 解答(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4 //树的最大分叉数struct TreeNode //表示K叉树节点的结构体类型&#123; int data; //节点数据域 struct TreeNode *Link[K]; //节点指针域,结构体指针数组&#125;;typedef struct TreeNode TreeNode1;struct Path //遍历K叉树过程中链表栈的节点&#123; TreeNode1 *current; //指向链表节点代表的K叉树节点的指针 int direction; //指向由链表节点代表的K叉树节点的下一个节点的Link数组元素的下标加一后的值 struct Path *pnext, *pbefore; //双向链表的左链指针和右链指针&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int *depth); //计算K叉树叶子数目和深度的函数int Search(TreeNode1 *ptr, int d); //寻找ptr指向的K叉树节点上从d开始下一可走方向int Enable(TreeNode1 *ptr, int m); //判定在ptr指向的K叉树节点上方向m是否可走void main()&#123; int i, depth; //depth为K叉树深度 TreeNode1 *temp1, *temp2; //创建4叉树 TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf ("K叉树的叶子结点数目为%d\n", ComputeLeaf(root, &amp;depth)); //计算叶子数目和深度，输出叶子数目 printf ("K叉树的深度为%d\n", depth-1); //输出深度&#125;int ComputeLeaf(TreeNode1 *root, int *depth)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //K叉树为只有根节点的空树 &#123; *depth=0; return 1; //深度为0,叶子数为1 &#125; else &#123; int d, k, flag; //d为当前方向,k为K叉树层数 int count; //计数变量，统计叶子数目 TreeNode1 *ptr, *interval; //ptr指向遍历过程中的当前节点 ptr=root; //ptr初始化，指向根节点 d=0; //方向初始化为0 count=0; //计数变量初始化 k=1; //层数初始化 flag=0; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; //路径链表初始化 psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) //在根节点无下一可走方向，遍历结束，退出循环 break; else &#123; if (d==0) //找到一个叶子 &#123; count++; //计数变量加一 if (flag==0) &#123; *depth=k; flag=1; //通过比较确定叶子深度最大值，求出K叉树深度 &#125; else &#123; if (*depth&lt;k) *depth=k; &#125; k--; ptr=psnewaf-&gt;current; //回溯 d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; //回溯 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); //找到下一个节点，当前节点加入路径链表 current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); //在当前节点找到新方向，更新当前节点方向 interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //递进至下一节点 d=0; k++; continue; &#125; &#125; return count; //返回叶子总数 &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果： 以上程序有多个变体，详见下文 问题：求K叉树m层节点总数 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;int ComputeLeaf(TreeNode1 *root, int m); //函数，求第m层节点总数int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m; //m指定要搜索结点数目的层数 TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; printf("请输入想求节点数目的K叉树层数\n"); scanf("%d", &amp;m); //输入想求结点数目的层数 if ((i=ComputeLeaf(root, m))==0) //m层不存在 printf("%d超出K叉树深度,第%d层不存在\n", m, m); printf ("K叉树第%d层的结点数目为%d\n", m, i); //输出m层结点总数&#125;int ComputeLeaf(TreeNode1 *root, int m)&#123; int i; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (m==1) return 1; //第一层一个节点，即根节点 else return 0; //其余各层不存在 &#125; else &#123; if (m==1) return 1; //同上 else &#123; int d, k; int count; //计数变量，统计m层结点数 TreeNode1 *ptr, *interval; ptr=root; d=0; count=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==m) //到达第m层 &#123; count++; //计数变量加一 ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; //回溯 k--; &#125; continue; &#125; &#125; return count; //返回m层结点总数 &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 问题：在K叉树中搜索给定值m 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode //用于存放搜索到的为给定值m项的结构体类型&#123; int plies; //所在层数 TreeNode1 *goal; //指向该项的指针 TreeNode1 *before; //指向该项父结点的指针 struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count); //函数，在K叉树中搜索给定值m，统计K叉树中值为m的结点个数，返回SearchNode1链表头结点void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location); //函数，输出以*Location为起点,before为终点的SearchNode1链表段中各结点项位置int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, m, count=0, number=0; //m为要搜索的值,count为m项总数 TreeNode1 *temp1, *temp2; SearchNode1 *head, *before, *after, *Location; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=5; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) &#123; break; &#125; &#125; printf("请输入要在K叉树中搜索的值\n"); scanf("%d", &amp;m); //输入要搜索的值 if ((head=ComputeLeaf(root, m, &amp;count))-&gt;next==NULL) //m项不存在 &#123; printf("%d在K叉树中不存在\n", m); printf("K叉树中共有%d个%d项\n", count, m); &#125; else &#123; before=head; after=head-&gt;next; Location=after; while(after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数由小到大,每层从左至右的顺序输出所有m项位置 &#123; if (before!=head) &#123; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; Order(i, m, &amp;number, before, root, before-&gt;plies, &amp;Location); printf("K叉树中共有%d个%d项\n", count, m); //输出m项总数 &#125; &#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int m, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; //链表初始化 head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; if (i&gt;K) //空树 &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //只有根节点需要加入SearchNode1链表中 psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; return head1; &#125; else &#123; if (root-&gt;data==m) &#123; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;plies=1; psnew1-&gt;goal=root; psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; (*count)++; &#125; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (ptr-&gt;data==m) //找到一个m项 &#123; (*count)++; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); //建立该m项对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; &#125; continue; &#125; &#125; return head1; &#125;&#125;void Order(int i, int m, int *number, SearchNode1 *before, TreeNode1 *root, int plies, SearchNode1 **Location)&#123; if (i&gt;K) //空树 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); //SearchNode1链表中只有一个结点需要输出 return; &#125; else &#123; if (plies==1) //要处理链表块只有一个结点,层数1,即为根节点 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, 1, 1); *Location=(*Location)-&gt;next; return; &#125; else &#123; int d, k, count; TreeNode1 *ptr, *interval; ptr=root; count=0; d=0; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; d=0; k++; if (k==plies) //抵达第plies层 &#123; count++; if (ptr-&gt;data==m) //在plies层找到m项 &#123; (*number)++; printf("第%d个%d结点位于第%d层上从左自由数起第%d个位置\n", *number, m, plies, count); //输出找到的m项位置 if (*Location==before) //到达链表块尾部，链表块中结点位置输出完毕 &#123; *Location=(*Location)-&gt;next; //*Location指向下一链表块第一个结点 return; &#125; *Location=(*Location)-&gt;next; //递进至本链表块下一结点 &#125; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; k--; &#125; continue; &#125; &#125; &#125; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 输入及运行结果： 问题:求K叉树结点总数并输出所有结点值 解答(C语言)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define K 4struct TreeNode&#123; int data; struct TreeNode *Link[K];&#125;;typedef struct TreeNode TreeNode1;struct Path&#123; TreeNode1 *current; int direction; struct Path *pnext, *pbefore;&#125;;typedef struct Path Path1;struct SearchNode&#123; int value; int plies; TreeNode1 *goal; TreeNode1 *before; struct SearchNode *next;&#125;;typedef struct SearchNode SearchNode1;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count); //函数用于求节点总数，返回SearchNode1链表头结点int Search(TreeNode1 *ptr, int d);int Enable(TreeNode1 *ptr, int m);void main()&#123; int i, count; //count记录结点总数 SearchNode1 *head, *before, *after; TreeNode1 *temp1, *temp2; TreeNode1 *root=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;data=0; root-&gt;Link[0]=NULL; for(i=1; i&lt;=3; i++) &#123; root-&gt;Link[i]=(TreeNode1 *) malloc(sizeof(TreeNode1)); root-&gt;Link[i]-&gt;data=i; &#125; for (i=1; i&lt;=4; i++) root-&gt;Link[1]-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[2]; for (i=1; i&lt;=4; i++) &#123; temp1-&gt;Link[i-1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp1-&gt;Link[i-1]-&gt;data=i+3; &#125; temp2=temp1-&gt;Link[0]; temp2-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[1]-&gt;data=10; for (i=1; i&lt;=4; i++) temp2-&gt;Link[1]-&gt;Link[i-1]=NULL; temp2-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[3]-&gt;data=11; for (i=1; i&lt;=4; i++) temp2-&gt;Link[3]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[2]=NULL; temp2=temp1-&gt;Link[2]; temp2-&gt;Link[2]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2-&gt;Link[2]-&gt;data=12; for (i=1; i&lt;=4; i++) temp2-&gt;Link[2]-&gt;Link[i-1]=NULL; temp2-&gt;Link[0]=temp2-&gt;Link[1]=temp2-&gt;Link[3]=NULL; temp2=temp1-&gt;Link[1]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp2=temp1-&gt;Link[3]; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1=root-&gt;Link[3]; temp1-&gt;Link[1]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[1]; temp2-&gt;data=8; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[3]=(TreeNode1 *) malloc(sizeof(TreeNode1)); temp2=temp1-&gt;Link[3]; temp2-&gt;data=9; for (i=1; i&lt;=4; i++) temp2-&gt;Link[i-1]=NULL; temp1-&gt;Link[0]=temp1-&gt;Link[2]=NULL; head=ComputeLeaf(root, &amp;count); before=head; after=head-&gt;next; i=0; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) //按层数有小到大每层从左至右顺序输出所有结点值 &#123; if (before!=head) &#123; printf("\n"); &#125; i++; printf("K叉树的第%d行从左至右为:", i); printf(" %d", after-&gt;value); &#125; else &#123; printf(" %d", after-&gt;value); &#125; after=after-&gt;next; before=before-&gt;next; &#125; printf("\n"); printf("K叉树中共有%d个节点\n", count); //输出结点总数&#125;SearchNode1 *ComputeLeaf(TreeNode1 *root, int *count)&#123; int i; SearchNode1 *head1, *psnew1, *after, *before; head1=(SearchNode1 *) malloc(sizeof(SearchNode1)); head1-&gt;next=NULL; head1-&gt;plies=0; for (i=1; i&lt;=K; i++) &#123; if (root-&gt;Link[i-1]!=NULL) break; &#125; psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=root-&gt;data; psnew1-&gt;plies=1; psnew1-&gt;goal=root; //将根节点插入SearchNode1链表 psnew1-&gt;before=NULL; psnew1-&gt;next=NULL; head1-&gt;next=psnew1; if (i&gt;K) //空树 &#123; (*count)=1; //节点总数为1 return head1; &#125; else &#123; int d, k; TreeNode1 *ptr, *interval; ptr=root; d=0; *count=1; k=1; Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; head-&gt;pnext=NULL; head-&gt;pbefore=NULL; while(1) &#123; if (Search(ptr, d)==0) &#123; if (ptr==root) break; else &#123; if (d==0) &#123; k--; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; else &#123; k--; free(psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; psnewbe=psnewbe-&gt;pbefore; ptr=psnewaf-&gt;current; d=psnewaf-&gt;direction; continue; &#125; &#125; &#125; else &#123; if (d==0) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;current=ptr; current-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[current-&gt;direction-1]; current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;direction=Search(ptr, d); interval=ptr-&gt;Link[psnewaf-&gt;direction-1]; &#125; ptr=interval; //找到K叉树中新节点 d=0; k++; (*count)++; //计数变量加一 psnew1=(SearchNode1 *) malloc(sizeof(SearchNode1)); psnew1-&gt;value=ptr-&gt;data; //建立与新节点对应的SearchNode1结点 psnew1-&gt;plies=k; psnew1-&gt;goal=ptr; psnew1-&gt;before=psnewaf-&gt;current; before=head1; after=head1-&gt;next; while (after!=NULL) &#123; if (before-&gt;plies&lt;after-&gt;plies) &#123; if (psnew1-&gt;plies&lt;after-&gt;plies) &#123; psnew1-&gt;next=before-&gt;next; //将SearchNode1结点插入至SearchNode1链表中，确保插入后链表中相同层数的结点所属的块按层数大小以从小到大顺序从左至右排列，且每个块中各节点排列顺序与他们在树的同一层中出现的顺序一致 before-&gt;next=psnew1; break; &#125; &#125; after=after-&gt;next; before=before-&gt;next; &#125; if(after==NULL) &#123; psnew1-&gt;next=NULL; before-&gt;next=psnew1; &#125; continue; &#125; &#125; return head1; &#125;&#125;int Search(TreeNode1 *ptr, int d)&#123; int m=d; for(m++; m&lt;=K; m++) &#123; if (Enable(ptr, m)==1) return m; &#125; return 0;&#125;int Enable(TreeNode1 *ptr, int m)&#123; if (ptr-&gt;Link[m-1]!=NULL) return 1; else return 0;&#125; 运行结果：]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>多叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dijkstra调度场算法介绍]]></title>
    <url>%2Fpost%2F51421.html</url>
    <content type="text"><![CDATA[Dijkstra发明的调度场算法用于将中缀表达式转为前缀或后缀表达式，本文目的是简要介绍调度场算法并给出分析和说明 网上众多作者采用自然语言描述转换算法，因此对转换算法的描述不够清晰直观。这里花费了一点时间绘制了中缀转后缀前缀的算法流程图，用流程图描述转换算法更直观易懂，便于读者学习，绘制的流程图如下。为简化问题，假设要处理的中缀表达式只由算术运算符+-*/和圆括号()组合而成。中缀转前缀算法和中缀转后缀完全类似，只不过转后缀需要从左至右扫描表达式，转前缀正好相反，此外后缀算法中左右括号为前缀算法的右左括号，优先级判断条件前缀算法为大于等于，后缀算法为大于，前缀后缀算法再最后输出中间结果栈中的转换结果时输出顺序正好相反，后缀为从栈底到栈顶，前缀为从栈顶到栈底。（流程图中把操作符和操作数统称为词）本文中圆括号不是运算符，仅用于改变运算顺序 &nbsp; &nbsp; 为了方便读者学习，制作了一张中缀转后缀算法执行过程的示意表格。中缀转前缀执行过程完全类似，读者可拿来练手 &nbsp; &nbsp; 以上算法仅考虑二元运算符，若优先级相同则具有左结合性，如果同时考虑相同优先级具有右结合性的二元运算符，则求后缀表达式的流程图中右下角的方框内应该改为:如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有右结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到左括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。以上论述用到的不变量：没有对操作符栈操作的任何时刻，从操作符栈底到栈顶的操作符执行优先级依次升高，即更靠近栈顶的操作符的执行次序一定先于栈中其下的操作符 对于求前缀表达式的算法,注意算法输出前缀表达式应该从栈顶到栈底输出，这意味着前缀表达式中执行优先级较高的运算符应当更靠近中间结果栈栈底，较低的更靠近栈顶，由于算法执行过程中需要从操作符栈中弹出操作符压入中间结果栈，因此执行优先级高的运算符应当靠近操作符栈栈顶，较低的靠近栈底，这意味着求前缀表达式算法所用不变量和求后缀表达式算法所用不变量(见以上红字部分)是一致的(PS:后缀表达式的分析是类似的)。 如果求前缀表达式也要考虑相同优先级具有右结合性的运算符，则应把前缀表达式算法流程图最右下菱形红框中的大于等于改为大于，最右下角蓝色矩形方框中的内容应该改为： 如果当前操作符优先级小于栈顶操作符优先级，则将栈顶操作符弹出操作符栈压入中间结果栈，否则 如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有右结合性，则将栈顶操作符弹出操作符栈压入中间结果栈，若具有左结合性，则将当前操作符压入操作符栈，然后操作结束。如果操作始终未结束，则不断重复以上操作，直到操作符栈空，遇到右括号或 栈顶操作符优先级小于当前操作符优先级为止，然后将当前操作符压入操作符栈，然后操作结束。 &nbsp; 下面对以上论述做一点说明： 1:为什么只考虑左结合二元运算符情况下后缀表达式算法中流程图最右下红色菱形方框判断操作是大于，而在前缀表达式算法中最右下角红色菱形方框中的判断操作是大于等于? 因为为了使输出的前缀和后缀表达式能够严格反映优先级和结合性决定的运算符执行次序，我们在操作中需要维持上文红字部分的不变量(详见红字下方分析)。后缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从左至右扫描表达式，当前操作符在表达式右边，栈顶操作符在左边，这意味着栈顶操作符执行优先级高，此时若将当前操作符压入操作符栈会破坏不变量，所以应当转入NO对应情形处理。而在前缀表达式算法中，如果当前操作符优先级等于栈顶操作符优先级而当前操作符和栈顶操作符具有左结合性，注意我们从右向左扫描表达式，当前操作符在表达式左边，栈顶操作符在右边，这意味着当前操作符执行优先级高，故可压栈而不会破坏不变量 2:在考虑相同优先级具有右结合性的二元运算符的情形下，对算法流程图所做修改的含义是什么? 考虑后缀表达式算法流程图右下角方框，如果当前操作符优先级小于栈顶操作符优先级，此时直接压入当前操作符会破坏不变量，所以我们把栈顶操作符弹出压入中间结果栈(这样能使执行优先级高的靠近中间结果栈栈底)。如果当前操作符优先级等于栈顶操作符优先级，若当前操作符和栈顶操作符具有左结合性，由上文分析知栈顶操作符优先级高，所以要做的和上一情形相同。若当前操作符和栈顶操作符具有右结合性，根据扫描顺序(从左往右)当前操作符执行优先级高，但是当前操作符的操作数(子表达式)尚未全部进入中间结果栈，所以我们直接将当前操作符压入操作符栈，这样也不会破坏不变量 考虑前缀表达式流程图，之所以要把最右下菱形红框中的大于等于改为大于，是因为如果当前操作符和栈顶操作符优先级相同且具有右结合性，根据扫描顺序(从右至左)，栈顶操作符执行优先级高，此时将当前操作符压入操作符栈会破坏不变量，所以应当改为大于，并把等于情形转入NO对应情形(小于等于)处理，右下角蓝色矩形方框修改理由和后缀表达式流程图是类似的，可自行分析 &nbsp; &nbsp;调度场算法的C++实现(中缀转后缀和表达式树构建): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;map&gt;#include &lt;vector&gt;using namespace std;struct OperatorInfo&#123; int priority; //运算符优先级，值越小优先级越高 bool isLeftUnion; //运算符是否为左结合 bool isBinaryOperator; //是否为二元运算符&#125;;struct ExprTreeNode //表达式树节点&#123; char operator_or_atomic_operand; //运算符或原子操作数 ExprTreeNode* left = nullptr; ExprTreeNode* right = nullptr; ExprTreeNode(char o) :operator_or_atomic_operand(o) &#123;&#125;&#125;;bool checkLackOperand(size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info) //检查运算符是否缺少运算分量&#123; if (op_info.isBinaryOperator) &#123; if (num_of_cur_operand &lt; 2) &#123; return false; &#125; else &#123; num_of_cur_operand -= 2; ++num_of_cur_operand; &#125; &#125; else &#123; if (num_of_cur_operand == 0) &#123; return false; &#125; &#125; return true;&#125;void check(const char _operator, size_t&amp; num_of_cur_operand, const OperatorInfo&amp; op_info)&#123; if (checkLackOperand(num_of_cur_operand, op_info) == false) &#123; cout &lt;&lt; "ERROR:运算符" &lt;&lt; _operator &lt;&lt; "缺少运算分量" &lt;&lt; endl; exit(-1); &#125;&#125;void buildExprTree(vector&lt;ExprTreeNode*&gt; &amp;work_stack, const char _operator, const OperatorInfo &amp;op_info)&#123; ExprTreeNode* _new = new ExprTreeNode(_operator); if (op_info.isBinaryOperator) &#123; _new-&gt;right = work_stack.back(); work_stack.pop_back(); &#125; _new-&gt;left = work_stack.back(); work_stack.pop_back(); work_stack.push_back(_new);&#125;void PostorderTraversal(ExprTreeNode *root)&#123; if (root != nullptr) &#123; PostorderTraversal(root-&gt;left); PostorderTraversal(root-&gt;right); cout &lt;&lt; root-&gt;operator_or_atomic_operand; &#125;&#125;int main() //本程序假定所有一元运算符是右结合的且具有相同优先级，且相同优先级的所有二元运算符具有相同的结合性&#123; map&lt;char, OperatorInfo&gt; operator_info_list = &#123; &#123;'~', &#123;1, false, false&#125;&#125;, &#123;'!', &#123;1, false, false&#125;&#125;, &#123;'&amp;', &#123;1, false, false&#125;&#125;, &#123;'=', &#123;9, false, true&#125;&#125;, &#123;'|', &#123;9, false, true&#125;&#125;, &#123;'&gt;', &#123;8, false, true&#125;&#125;, &#123;'&lt;', &#123;8, false, true&#125;&#125;, &#123;'^', &#123;1, false, false&#125;&#125;, &#123;'+', &#123;3, true, true&#125;&#125;, &#123;'-', &#123;3, true, true&#125;&#125;, &#123;'*', &#123;2, true, true&#125;&#125;, &#123;'/', &#123;2, true, true&#125;&#125; &#125;; //初始化运算符信息 vector&lt;char&gt; operator_stack; //操作符栈 vector&lt;char&gt; operand_stack; //操作数栈(中间结果栈) vector&lt;ExprTreeNode *&gt; expr_tree_build; //用于构建表达式树的栈 size_t num_of_cur_operand = 0; string expr = "w*(v*!(m+n-u)-~!&amp;^a+!b-c*d/e=f|g&gt;h&lt;i)+x"; //中缀表达式 string::size_type index = 0; while (index &lt; expr.size()) &#123; map&lt;char, OperatorInfo&gt;::iterator it; if ((it = operator_info_list.find(expr[index])) == operator_info_list.end() &amp;&amp; expr[index]!='(' &amp;&amp; expr[index] != ')') &#123; operand_stack.push_back(expr[index]); expr_tree_build.push_back(new ExprTreeNode(expr[index])); ++num_of_cur_operand; &#125; else &#123; if (operator_stack.empty() == true || expr[index] == '(') &#123; operator_stack.push_back(expr[index]); &#125; else if (expr[index] == ')') &#123; while (operator_stack.back() != '(') &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); if (operator_stack.empty()) &#123; cout &lt;&lt; "ERROR:没有与右括号匹配的左括号" &lt;&lt; endl; exit(-1); &#125; &#125; operator_stack.pop_back(); &#125; else if (operator_stack.back() == '(' || operator_info_list[operator_stack.back()].priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); &#125; else &#123; while (true) &#123; map&lt;char, OperatorInfo&gt;::iterator p = operator_info_list.find(operator_stack.back()); if (p-&gt;second.priority == it-&gt;second.priority) &#123; if (it-&gt;second.isBinaryOperator == false) &#123; operator_stack.push_back(expr[index]); break; &#125; else &#123; if (it-&gt;second.isLeftUnion) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; else &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; else if (p-&gt;second.priority &lt; it-&gt;second.priority) &#123; check(operator_stack.back(), num_of_cur_operand, p-&gt;second); buildExprTree(expr_tree_build, operator_stack.back(), p-&gt;second); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; if (operator_stack.empty() || operator_stack.back() == '(' || p-&gt;second.priority &gt; it-&gt;second.priority) &#123; operator_stack.push_back(expr[index]); break; &#125; &#125; &#125; &#125; ++index; &#125; while (!operator_stack.empty()) &#123; check(operator_stack.back(), num_of_cur_operand, operator_info_list[operator_stack.back()]); buildExprTree(expr_tree_build, operator_stack.back(), operator_info_list[operator_stack.back()]); operand_stack.push_back(operator_stack.back()); operator_stack.pop_back(); &#125; cout &lt;&lt; "后缀表达式为" &lt;&lt; endl; //输出后缀表达式 for (size_t i = 0; i &lt; operand_stack.size(); ++i) &#123; cout &lt;&lt; operand_stack[i]; &#125; cout &lt;&lt; endl; ExprTreeNode* root = expr_tree_build.back(); //root为表达式树根节点 cout &lt;&lt; "表达式树的后序遍历结果为:"; PostorderTraversal(root); //后序遍历表达式树输出后缀表达式 cout &lt;&lt; endl;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>后缀表达式，中缀表达式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[南理工2016考研复试上机题男女程序员排队]]></title>
    <url>%2Fpost%2F21022.html</url>
    <content type="text"><![CDATA[题目： 输入一个由男女程序员组成的序列FFMMFMMMFF，现要通过适当的交换操作让女程序员全部排在男程序员前面，即使原序列变成FFFFFMMMMM，问至少需要交换多少次,交换次数最少的交换操作是什么？ &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define MALE 5 //队列中男程序员位数#define FEMALE 5 //队列中女程序员位数struct swap //记录交换操作的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct swap *next; //后继指针 struct swap *front; //前驱指针&#125;;typedef struct swap swap1;struct image //保存找到的交换操作序列的结构体类型&#123; int k; //右交换下标 int i; //左交换下标 struct image *next;&#125;;typedef struct image image1;int number(int i, char que[]); //函数，寻找当前序列索引下标i后的第一位女程序员下标,找到返回下标，没有找到返回-1void copy(swap1 *head, image1 *head1); //释放head1指向的线性链表,并将head指向的交换序列链表拷贝至链表head1中void main()&#123; int start; //从队列开头起连续排列的女程序员序列中最后一位女程序员下标,若队列第一位是男程序员,start为-1 char que[MALE+FEMALE]; //存放男女程序员队列的数组,字符'0'代表男程序员,'1'代表女程序员 printf("输入男女程序员序列,0男1女\n"); //输入男女程序员序列 scanf("%s", que); start=0; while(que[start]!='0') &#123; if (que[start]=='0') //确定从队列开头起连续排列的女程序员序列中最后一位女程序员下标 break; start++; &#125; start-=1; if (start==FEMALE-1) //女程序员已全部放到男程序员前面，无需交换 &#123; printf("最小交换次数为0\n"); &#125; else &#123; swap1 *head, *psnew, *before, *after; //after指向head链表最后一个结点,before指向倒数第二个 image1 *head1, *psnew1; int i, k, count, flag, minswap; //i为回溯过程中前进深度，任何时候下标i及i前面下标位置的元素均为女程序员，k为在某下标之后找到的第一位女程序员标号 char temp; //count用于统计交换次数,minswap为最小交换次数 bool TF; //TF为true表示从上一轮回溯至本轮,为false表示从上一轮前进至本轮 head=(swap1 *) malloc(sizeof(swap1)); //初始化交换序列链表,用于保存找到的可行交换序列 head-&gt;next=NULL; head-&gt;front=NULL; before=head; after=head; head1=(image1 *) malloc(sizeof(image1)); //初始化head1链表，用于保存交换次数最少的交换序列 head1-&gt;next=NULL; i=start; TF=false; count=0; flag=0; while (1) &#123; if (i==start) //从start处开始试探 &#123; if (TF==false) //第一次试探 &#123; k=number(i, que); &#125; else &#123; k=number(k, que); if (k==-1) //在start处已无法找到下一个可交换女程序员，试探结束 break; &#125; temp=que[i+1]; que[i+1]=que[k]; //找到可交换女程序员k，交换i+1,,和k que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; //交换操作(i+1, k)加入链表 psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; i++; //递进至下一层 TF=false; &#125; else &#123; if (TF==false) //进至新的一层i&gt;start,从i后开始寻找第一个女程序员位置 k=number(i, que); else k=number(k, que); //回溯至本层，从上一次找到的女程序员位置后寻找第一个女程序员 if (k==-1) &#123; if (TF==false) &#123; if (flag==0) //所有女程序员均已排到男程序员前面,判断flag值，比较count以决定是否更新count和head1链表 &#123; copy(head, head1); minswap=count; flag=1; &#125; else &#123; if (minswap&gt;count) &#123; copy(head, head1); minswap=count; &#125; &#125; &#125; k=after-&gt;k; //找到最后一轮交换操作(i,k) i=after-&gt;i; temp=que[i]; que[i]=que[k]; //,回溯交换que[i],que[k] que[k]=temp; count--; free(after); before-&gt;next=NULL; //删掉head链表尾节点 after=before; before=before-&gt;front; i--; //回溯至上一层 TF=true; &#125; else &#123; if (k!=i+1) //进入本层时TF==false,此时从i后寻找第一个女程序员下标，由于找到的女程序员要和i+1位置交换 &#123; temp=que[i+1]; //所以，若该女程序员就位于i+1位置，该段语句不执行，否则就应 que[i+1]=que[k]; //将找到的女程序员k和i+1交换，并将交换操作放入head链表 que[k]=temp; count++; psnew=(swap1 *) malloc(sizeof(swap1)); psnew-&gt;k=k; psnew-&gt;i=i+1; psnew-&gt;next=NULL; after-&gt;next=psnew; psnew-&gt;front=after; before=after; after=psnew; &#125; i++; //递进至下一层 TF=false; &#125; &#125; &#125; printf ("把女程序员交换至最前面所需最小交换次数为%d\n", minswap); //输出最小交换次数 printf("交换次数最小的交换方式为:\n"); i=start+1; for (psnew1=head1-&gt;next; psnew1!=NULL; psnew1=psnew1-&gt;next) //输出交换操作 &#123; printf("交换序列中第%d个和第%d个程序员\n", psnew1-&gt;i+1, psnew1-&gt;k+1); &#125; &#125;&#125;int number(int i, char que[])&#123; for (int j=++i; j&lt;MALE+FEMALE; j++) &#123; if (que[j]=='1') return j; &#125; return -1;&#125;void copy(swap1 *head, image1 *head1)&#123; image1 *p, *tail; swap1 *psnew; while(head1-&gt;next!=NULL) //释放head1链表 &#123; p=head1-&gt;next; head1-&gt;next=p-&gt;next; free(p); &#125; tail=head1; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; p=(image1 *) malloc(sizeof(image1)); //拷贝 p-&gt;k=psnew-&gt;k; p-&gt;i=psnew-&gt;i; p-&gt;next=NULL; tail-&gt;next=p; tail=p; &#125;&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>序列交换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA新手小试牛刀之遍历递归树求递推数列通项]]></title>
    <url>%2Fpost%2F47482.html</url>
    <content type="text"><![CDATA[考虑K阶变系数线性递推方程： 现给定初值a1,a2,—,ak和n&gt;k,要求编程打印an,an-1,—,ak+1的值 该问题用常规的迭代法非常容易解决，现在要考虑的是用遍历递归调用树的方法求解。n=7,k=3时，递归调用树为 &nbsp; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157package programm; //遍历递归树中所有节点，相同值会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); temp.setSum(temp.getSum()+temp.getIndex()); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 以上方法的问题是，相同的项会被重复计算多次，如a4被重复计算了三次，所以以上方法需要改进。用数组保存已求出项的值，遍历到相同项时直接从数组中找到并使用其值即可。要实现这一点，需要修改源程序41行，48行，60-61行。修改后的代码如下：程序二： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161package programm; //不遍历递归树中所有节点,相同值不会重复计算import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=3; //递推方程阶数 final int N=7; //要求的部分数列中下标最大的项的下标 int[] initial=new int[K]; //初值a1----ak for (int i=0; i&lt;K; i++) //令初值a1----ak分别为1,2---,k initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); //建立Node类型栈对象 stack.push(new Node(0, 0, N)); //递归树根节点压入栈，该节点flag=sum=0，index=N boolean TF=true; //true向前进至下一层,false回溯至上一层 int sign=0, n=stack.getTop().getIndex(); //sign记录当前已遍历节点中下标最大的节点,n初始化为根节点下标 int[] result=new int[N-K]; //记录ak+1---aN项值的数组 while(!stack.isEmpty()) //栈不空 &#123; if (1&lt;=n&amp;&amp;n&lt;=K) //到达递归树中可直接写出值的叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //将叶子结点值乘以系数累加至父节点 TF=false; n=stack.getTop().getIndex(); //回溯 &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //当前节点flag增一，试探下一子节点 if (stack.getTop().getFlag()&gt;K) //当前节点所有子节点均试探完毕 &#123; Node temp=stack.pop(); //从栈中弹出当前节点 temp.setSum(temp.getSum()+temp.getIndex()); //加上尾数f(n),得到当前节点的值 if (stack.isEmpty()) //栈空,temp引用根节点，根节点值已求出，存放在temp的sum中 &#123; result[N-K-1]=temp.getSum(); //在数组result中存放根节点即aN的值 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印aN的值 &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) //找到当前已遍历节点中下标最大节点 &#123; sign=temp.getIndex(); //设置新的最大下标 result[temp.getIndex()-K-1]=temp.getSum(); //当前节点值存放至result数组中 System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); //打印当前节点值 &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) //前进至非叶子结点 &#123; stack.getTop().setSum(stack.getTop().getSum()+result[n-K-1]*(stack.getTop().getIndex()+stack.getTop().getFlag())); //当前节点值之前已算出，从数组result中找出该值乘以系数累加至父节点 n=stack.getTop().getIndex(); TF=false; //回溯 &#125; else &#123; continue; //直接进至下一轮循环，累加叶子节点值和系数乘积至父节点 &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); //进至新的一层,当前节点flag增一试探下一层节点 if ((n=stack.getTop().getIndex()-1)&gt;K) //下一层第一个节点非叶子 &#123; stack.push(new Node(0, 0, n)); //该节点压入栈 TF=true; &#125; else &#123; continue; //同上 &#125; &#125; &#125; &#125; &#125;&#125;class Node //递归树节点类&#123; private int sum; //当前节点值 private int flag; //当前节点的父节点下标和当前节点下标之差 private int index; //当前节点下标 public Node(int sum, int flag, int index) //构造方法 &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; //访问器和修改器 public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt; //泛型栈类&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 可以验证运行结果和程序一相同，但是节省了运行时间删掉程序一37行，修改24行和51行可以得到程序三，用于计算递推数列an=an-1+—an-kn&gt;k a1=1—ak=k当给定n&gt;k时an,—,ak+1的值。程序三(n=7, k=2, a1=1, a2=2)： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156package programm; //an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class RecursionTree &#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, 0, N)); boolean TF=true; int sign=0, n=stack.getTop().getIndex(); while(!stack.isEmpty()) &#123; if (1&lt;=n&amp;&amp;n&lt;=K) &#123; stack.getTop().setSum(stack.getTop().getSum()+initial[n-1]); TF=false; n=stack.getTop().getIndex(); &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; Node temp=stack.pop(); if (stack.isEmpty()) &#123; System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; else &#123; if (stack.getTop().getFlag()==1 &amp;&amp; temp.getIndex()&gt;sign) &#123; sign=temp.getIndex(); System.out.println("The "+temp.getIndex()+"nd item is "+temp.getSum()); &#125; stack.getTop().setSum(stack.getTop().getSum()+temp.getSum()); n=stack.getTop().getIndex(); TF=false; &#125; &#125; else &#123; if ((n=stack.getTop().getIndex()-stack.getTop().getFlag())&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if ((n=stack.getTop().getIndex()-1)&gt;K) &#123; stack.push(new Node(0, 0, n)); TF=true; &#125; else &#123; continue; &#125; &#125; &#125; &#125; &#125;&#125;class Node&#123; private int sum; private int flag; private int index; public Node(int sum, int flag, int index) &#123; this.sum=sum; this.flag=flag; this.index=index; &#125; public int getSum() &#123; return sum; &#125; public void setSum(int sum) &#123; this.sum=sum; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 运行结果： 显然，所求得的即为斐波那契数列的第4-8项为了便于读者理解程序一二三，下面给出一个经过简化的程序四，实现思想和程序一二三基本相同且功能和程序三相同程序四（n=7, k=2, a1=1, a2=2）: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112package RecursionTree; //简化版的an=an-1+---an-k型递归式求解，遍历所有节点import java.util.*;public class recursiontree&#123; public static void main(String[] args) &#123; final int K=2; final int N=7; int[] initial=new int[K]; for (int i=0; i&lt;K; i++) initial[i]=i+1; Stack&lt;Node&gt; stack=new Stack&lt;Node&gt;(); stack.push(new Node(0, N)); boolean TF=true; int sum=0; while (!stack.isEmpty()) &#123; if (1&lt;=stack.getTop().getIndex() &amp;&amp; stack.getTop().getIndex()&lt;=K) &#123; sum+=initial[stack.getTop().getIndex()-1]; stack.pop(); TF=false; &#125; else &#123; if (TF==false) &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); if (stack.getTop().getFlag()&gt;K) &#123; stack.pop(); TF=false; &#125; else &#123; stack.push(new Node(0, stack.getTop().getIndex()-stack.getTop().getFlag())); TF=true; &#125; &#125; else &#123; stack.getTop().setFlag(stack.getTop().getFlag()+1); stack.push(new Node(0, stack.getTop().getIndex()-1)); TF=true; &#125; &#125; &#125; System.out.println("The "+N+"nd item is "+sum); &#125;&#125;class Node&#123; private int flag; private int index; public Node(int flag, int index) &#123; this.flag=flag; this.index=index; &#125; public int getFlag() &#123; return flag; &#125; public void setFlag(int flag) &#123; this.flag=flag; &#125; public int getIndex() &#123; return index; &#125;&#125;class Stack&lt;E&gt;&#123; ArrayList&lt;E&gt; list=new ArrayList&lt;E&gt;(); public boolean isEmpty() &#123; return list.isEmpty(); &#125; public int getSize() &#123; return list.size(); &#125; public E getTop() &#123; return list.get(getSize()-1); &#125; public E pop() &#123; E interval=list.get(getSize()-1); list.remove(getSize()-1); return interval; &#125; public void push(E Ob) &#123; list.add(Ob); &#125;&#125; 不难验证运行结果和程序三是一致的]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归，树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程分拆正整数]]></title>
    <url>%2Fpost%2F2882.html</url>
    <content type="text"><![CDATA[先求正整数J拆分为K个正整数的所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int K = 2; const int J = 4; int a[K] = &#123; 0 &#125;; int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == K - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;K; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; return 0;&#125; 然后便可算出所有分拆方案 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include "stdafx.h"#include &lt;iostream&gt;using namespace std;int main()&#123; const int J = 8; //要分拆的正整数 int m = 2; while (m &lt;= J) &#123; int *a = new int[m](); int i, j, t; bool TF = true; t = 0; i = 0; while (1) &#123; if (i == 0) &#123; a[i]++; if (a[i] &gt;= J) break; t += a[i]; i++; TF = true; continue; &#125; else &#123; if (TF == true) &#123; a[i] = a[i - 1]; &#125; else &#123; ++a[i]; &#125; if (a[i]&gt;J - t) &#123; a[i] = 0; t -= a[i - 1]; i--; TF = false; continue; &#125; if (i == m - 1) &#123; if (t + a[i] == J) &#123; for (j = 0; j&lt;m; j++) &#123; cout &lt;&lt; a[j]; &#125; cout &lt;&lt; endl; &#125; TF = false; continue; &#125; t += a[i]; i++; TF = true; continue; &#125; &#125; delete[] a; ++m; &#125; return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>整数分拆</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[两排列组合问题的非递归求解]]></title>
    <url>%2Fpost%2F49616.html</url>
    <content type="text"><![CDATA[问题一： 打印1,2—n中所有满足1&lt;=i1&lt;i2&lt;–&lt;ik&lt;=n(k&lt;=n)的有序数组(i1, i2,—ik)并输出，要求用非递归方法解决. 代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#define N 6#define K 4void main()&#123; int a[K]; bool TF; int i, j; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (TF==false) &#123; a[i]=1; &#125; else &#123; a[i]++; &#125; if (a[i]&gt;N-K+1) break; i++; TF=false; continue; &#125; else &#123; if (TF==false) a[i]=a[i-1]+1; else &#123; a[i]++; if ((a[i]-a[i-1])&gt;(N-a[i-1])-(K-i)+1) &#123; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); TF=true; continue; &#125; i++; TF=false; continue; &#125; &#125;&#125; &nbsp; 问题二:打印所有n元排列,非递归解决代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;stdio.h&gt;#define N 5int first(int index, int number[]);void main()&#123; int a[N]=&#123;0&#125;; int number[N]=&#123;0&#125;; int i, j, temp; bool TF; i=0; TF=false; while(1) &#123; if (i==0) &#123; if (a[i]!=0) number[a[i]-1]=0; a[i]++; if (a[i]&gt;N) break; number[a[i]-1]=1; i++; TF=false; continue; &#125; else &#123; temp=first(a[i], number); if (temp==0) &#123; number[a[i]-1]=0; a[i]=0; i--; TF=true; continue; &#125; if (TF) &#123; number[a[i]-1]=0; &#125; a[i]=temp; number[a[i]-1]=1; if (i==N-1) &#123; for (j=0; j&lt;N; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); continue; &#125; i++; TF=false; continue; &#125; &#125;&#125;int first(int index, int number[])&#123; int i; for (i=index; i&lt;N; i++) &#123; if (number[i]==0) return i+1; &#125; return 0;&#125; &nbsp;问题一的递归代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void DY(int *p, int k, int n);int C(int n, int k);void L(int **p1, int *p2, int k, int n);void main ()&#123; int a[5]=&#123;1, 2, 3, 4, 5&#125;; DY(a, 4 , 5);&#125;void DY(int *p, int k, int n)&#123; int **p1; int i, j, m; j=C(n, k); p1=(int **) malloc(j*sizeof(int *)); for (i=0; i&lt;j; i++) p1[i]=(int *) malloc(k*sizeof(int)); L(p1, p, k, n); for (i=0; i&lt;j; i++) &#123; for (m=0; m&lt;k; m++) printf ("%d", *(p1[i]+m)); printf ("\n"); &#125;&#125;int C(int n, int k)&#123; if (k==0 || k==n) return (1); return (C(n-1, k)+C(n-1, k-1));&#125;void L(int **p1, int *p2, int k, int n)&#123; int i; if (k==1) &#123; for (i=0; i&lt;n; i++) *p1[i]=*(p2+i); &#125; else &#123; if (k==n) &#123; for (i=0; i&lt;n; i++) *(p1[0]+i)=*(p2+i); &#125; else &#123; int j, c, d, z1, z2; int **p; j=0; d=1; c=1; for (i=n-k; i&gt;=0; i--) &#123; p=(int **) malloc(c*sizeof(int *)); for (z1=0; z1&lt;c; z1++) p[z1]=(int *) malloc((k-1)*sizeof(int)); L(p, p2+i+1, k-1, n-i-1); for (z1=0; z1&lt;c; z1++) for (z2=0; z2&lt;(k-1); z2++) *(p1[z1+j]+z2+1)=*(p[z1]+z2); while (j&lt;d) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=0) &#123; c=(c*(n-i))/(n-i-k+1); d=d+c; &#125; &#125; &#125; &#125;&#125;/*用单一函数实现*/]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求不定方程整数解]]></title>
    <url>%2Fpost%2F7203.html</url>
    <content type="text"><![CDATA[求不定方程x1+—xk=J的非负整数解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;#define K 3#define J 5void main()&#123; int a[K]=&#123;0&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体一：求不定方程x1+—xk=J的正整数解 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125; 变体二：求不定方程x1+—xk=J在约束条件0&lt;=x1&lt;=m1—-0&lt;=xk&lt;=mk下的非负整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;#define K 2#define J 5void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; bool TF; int i, j, t; TF=false; t=0; i=0; while(1) &#123; if (i==0) &#123; if (TF) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;J) break; &#125; t+=a[i]; i++; TF=false; continue; &#125; else &#123; if (TF) &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; TF=true; continue; &#125; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; TF=true; continue; &#125; t+=a[i]; i++; TF=false; continue; &#125; &#125;&#125; 变体三:求不定方程x1+—xk=J在约束条件1&lt;=x1&lt;=m1—-1&lt;=xk&lt;=mk下的正整数解 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;#define K 2#define J 4void main()&#123; int a[K]=&#123;0&#125;; int m[K]=&#123;2, 3&#125;; int i, j, t; t=0; i=0; while(1) &#123; if (i==0) &#123; a[i]++; if (a[i]&gt;m[i] || a[i]&gt;=J) break; t+=a[i]; i++; continue; &#125; else &#123; a[i]++; if (a[i]&gt;J-t || a[i]&gt;m[i]) &#123; a[i]=0; t-=a[i-1]; i--; continue; &#125; if (i==K-1) &#123; if (t+a[i]==J) &#123; for (j=0; j&lt;K; j++) &#123; printf("%d ", a[j]); &#125; printf("\n"); &#125; continue; &#125; t+=a[i]; i++; continue; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>不定方程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多项式相乘另一解法]]></title>
    <url>%2Fpost%2F40679.html</url>
    <content type="text"><![CDATA[多项式相乘的另一解法是利用公式： 该图可以辅助说明算法思想 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define M 5 //第一个多项式阶数#define N 3 //第二个多项式阶数struct Po //多项式节点结构体&#123; int coef; //项的系数 int exp; //项的幂 struct Po *next;&#125;;typedef struct Po Po1;struct Podual //多项式双向链表结构体&#123; int coef; //系数 int exp; //幂 struct Podual *next; struct Podual *before;&#125;;typedef struct Podual Podual1;void print(Po1 *head1); //重载函数,打印多项式void print(Podual1 *head2);void main()&#123; Po1 *p1before, *q1after, *p1, *head1; Podual1 *q2after, *p2, *head2; int i, temp; head1=(Po1 *)malloc(sizeof(Po1)); head1-&gt;next=NULL; q1after=head1; for(i=0; i&lt;=M; i++) //建立第一个多项式 &#123; p1=(Po1 *)malloc(sizeof(Po1)); p1-&gt;coef=i+1; p1-&gt;exp=i; p1-&gt;next=NULL; q1after-&gt;next=p1; q1after=p1; &#125; printf("第一个多项式为:\n"); //输出第一个多项式 print(head1); head2=(Podual1 *)malloc(sizeof(Podual1)); head2-&gt;next=NULL; head2-&gt;before=NULL; q2after=head2; for(i=0; i&lt;=N; i++) //建立第二个多项式 &#123; p2=(Podual1 *)malloc(sizeof(Podual1)); p2-&gt;coef=i+1; p2-&gt;exp=i; p2-&gt;next=NULL; q2after-&gt;next=p2; p2-&gt;before=q2after; q2after=p2; &#125; printf("第二个多项式为:\n"); //输出第二个多项式 print(head2); Po1 *head3, *psnew3, *tail3; head3=(Po1 *)malloc(sizeof(Po1)); head3-&gt;next=NULL; //初始化第三个多项式 tail3=head3; p1before=head1-&gt;next; q1after=head1-&gt;next; q2after=head2-&gt;next; for(i=0; i&lt;=M+N; i++) //依次求乘积多项式各项系数 &#123; temp=0; for(p1=p1before, p2=q2after; q1after-&gt;next!=p1; p1=p1-&gt;next, p2=p2-&gt;before) &#123; temp+=p1-&gt;coef*p2-&gt;coef; //累加求次数为i的项的系数 &#125; psnew3=(Po1 *)malloc(sizeof(Po1)); psnew3-&gt;coef=temp; psnew3-&gt;exp=i; psnew3-&gt;next=NULL; //将求得的次数为i的项加入链表3 tail3-&gt;next=psnew3; tail3=psnew3; if (i!=M+N) &#123; if(q1after-&gt;next!=NULL) &#123; q1after=q1after-&gt;next; //q1after未指向尾节点时继续向后递进 &#125; if(q2after-&gt;next!=NULL) &#123; q2after=q2after-&gt;next; //q2after未指向尾节点时继续向后递进 &#125; else &#123; p1before=p1before-&gt;next; //q2after指向尾节点时p1before向后递进 &#125; &#125; &#125; printf("多项式一和多项式二的乘积为:\n"); //输出乘积多项式 print(head3);&#125;void print(Po1 *head1)&#123; Po1 *psnew1; psnew1=head1-&gt;next; while(psnew1!=NULL) &#123; if(psnew1!=head1-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew1-&gt;coef, psnew1-&gt;exp); &#125; else &#123; printf("%d", psnew1-&gt;coef); &#125; psnew1=psnew1-&gt;next; &#125; printf("\n\n");&#125;void print(Podual1 *head2)&#123; Podual1 *psnew2; psnew2=head2-&gt;next; while(psnew2!=NULL) &#123; if(psnew2!=head2-&gt;next) &#123; printf("+"); printf("%dX^%d", psnew2-&gt;coef, psnew2-&gt;exp); &#125; else &#123; printf("%d", psnew2-&gt;coef); &#125; psnew2=psnew2-&gt;next; &#125; printf("\n\n");&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>多项式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的一个小扩展]]></title>
    <url>%2Fpost%2F7866.html</url>
    <content type="text"><![CDATA[之前的博文谈到了蚂蚁问题，现在考虑其变形，要求输出从开始到所有蚂蚁离杆这段时间内的各时间段内的碰撞情况，有碰撞输出所有碰撞，没有则提示未发生碰撞，最后输出碰撞总次数，若整个过程没有发生任何碰撞则提示没有发生碰撞。 &nbsp;&nbsp;代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; int number, sign; short *p1; int *p2; struct collision //碰撞节点 &#123; int sign; //参与碰撞的蚂蚁标号 float t; //碰撞时间 float p; //碰撞位置 struct collision *next; &#125;; struct collision *head1, *psnew1, *q1, *t1; typedef struct collision node1; struct ant //蚂蚁节点 &#123; struct ant *next; struct ant *before; short direction; //当前时间点的蚂蚁方向 int position; //当前时间点的蚂蚁位置 short direction1; //上一时间点的蚂蚁方向 int position1; //上一时间点的蚂蚁位置 int sign; //蚂蚁标号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左,不允许出现t=0时刻即一开始就有蚂蚁离开木杆的情况,即最左端蚂蚁方向向左,最右端蚂蚁方向向右*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为0cm,1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; //初始化存放各蚂蚁节点的链表 head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; psnew-&gt;direction1=p1[i]; //创建存放各蚂蚁节点的链表 psnew-&gt;position=p2[i]; psnew-&gt;position1=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head1=(node1 *)malloc (sizeof(node1)); q1=head1; //初始化碰撞链表 head1-&gt;next=NULL; number=0; //初始化碰撞计数变量 sign=0; //标志是否发生碰撞的变量的初始化 t=0; //时间初始化 while (1) &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; if (head-&gt;next==NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; printf("time%d to time%d not including time%d\n", t-1, t, t-1); printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); break; &#125; else &#123; q=head-&gt;next; if (q-&gt;next==NULL) &#123; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; sign=1; number++; if ((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position-0.5, t-0.5, q-&gt;sign-1, q-&gt;sign); printf ("\n"); &#125; else &#123; printf("The %dnd collision happens at position%.1f at time%.1f between the%dnd ant and the%dnd ant\n", number, q-&gt;position+0.5, t-0.5, q-&gt;sign, q-&gt;sign+1); printf ("\n"); &#125; &#125; else &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; &#125; else //当前蚂蚁链表有两个以上蚂蚁节点，开始创建碰撞链表 &#123; while (1) &#123; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((!(q-&gt;direction1))&amp;&amp;(q-&gt;direction)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&gt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=q-&gt;sign; if (q-&gt;direction1) &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; else &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position-0.5); &#125; &#125; &#125; if (psnew1!=NULL)//生成了新的碰撞节点，按碰撞时间对碰撞节点执行插入排序，将碰撞节点插入到碰撞链表中 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; q1=psnew1; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; q1=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; if (q-&gt;next==NULL) break; q=q-&gt;next; &#125; psnew1=NULL; if ((q-&gt;direction)!=(q-&gt;direction1)) //处理蚂蚁链表中尾节点代表的蚂蚁的碰撞 &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; if((q-&gt;direction1)&amp;&amp;(!(q-&gt;direction))) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; &#125; else &#123; if ((q-&gt;position1)&lt;(q-&gt;position)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; else &#123; if ((q-&gt;position)==(q-&gt;position1)) &#123; psnew1=(node1 *)malloc (sizeof(node1)); psnew1-&gt;sign=(q-&gt;sign+1); if (q-&gt;direction1) &#123; psnew1-&gt;t=(t-0.5); psnew1-&gt;p=(q-&gt;position+0.5); &#125; else &#123; psnew1-&gt;t=t; psnew1-&gt;p=q-&gt;position; &#125; &#125; &#125; if (psnew1!=NULL) //新的碰撞节点生成，和以上操作类似，对碰撞节点执行插入排序 &#123; if (head1-&gt;next==NULL) &#123; head1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; t1=head1-&gt;next; if ((psnew1-&gt;t)&lt;(t1-&gt;t)) &#123; psnew1-&gt;next=head1-&gt;next; head1-&gt;next=psnew1; &#125; else &#123; if ((psnew1-&gt;t)&gt;(t1-&gt;t)) &#123; if (q1-&gt;next==NULL) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; while (q1-&gt;next!=NULL) &#123; q1=q1-&gt;next; &#125; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; if (psnew1-&gt;t==t) &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; else &#123; if (q1-&gt;next==NULL) &#123; if (q1-&gt;t==t) &#123; q1=head1-&gt;next; t1=q1-&gt;next; while ((q1-&gt;t)==(t1-&gt;t)) &#123; q1=q1-&gt;next; t1=t1-&gt;next; &#125; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; else &#123; q1-&gt;next=psnew1; psnew1-&gt;next=NULL; &#125; &#125; else &#123; psnew1-&gt;next=q1-&gt;next; q1-&gt;next=psnew1; &#125; &#125; &#125; &#125; &#125; &#125; printf ("time%d to time%d not including time%d\n", t-1, t, t-1); //碰撞链表生成完毕输出(t-1 t] 时间段内的碰撞 if (head1-&gt;next!=NULL)//碰撞链表不空 &#123; sign=1; q1=head1-&gt;next; while (q1!=NULL) //输出当前时间段内的所有碰撞 &#123; number++; printf ("The %dnd collosion happens at position%.1f at time%.1f between the %dnd ant and the %dnd ant\n", number, q1-&gt;p, q1-&gt;t, q1-&gt;sign-1, q1-&gt;sign); q1=q1-&gt;next; &#125; printf ("\n"); q1=head1; //清空碰撞链表 while (q1-&gt;next!=NULL) &#123; t1=q1-&gt;next; q1-&gt;next=t1-&gt;next; free (t1); &#125; &#125; else //碰撞链表为空，当前时间段内没有碰撞 &#123; printf ("There is no collision happening from time%d to time%d not including time%d\n", t-1, t, t-1); printf ("\n"); &#125; q=head-&gt;next; while (q!=NULL) //用当前时间点的位置方向更新上一时间点的位置方向 &#123; q-&gt;direction1=q-&gt;direction; q-&gt;position1=q-&gt;position; q=q-&gt;next; &#125; &#125; &#125; &#125; if (sign==0) //没有发生任何碰撞 printf ("No collsion happens at the whole process\n"); printf ("There are %d collisions in total\n", number); //输出碰撞总数&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 若初始时刻杆上共有三只蚂蚁，第一第二第三只蚂蚁初始方向位置分别为：1(右),2 &nbsp;1(右),3 &nbsp;0(左),4,则程序运行结果如下:]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搜索图中任意两点间的所有路径(DFS完全非递归实现)]]></title>
    <url>%2Fpost%2F10422.html</url>
    <content type="text"><![CDATA[从我之前写过的单源最短路径程序中把路径搜索函数分离出来就得到了搜索非负权重无环无向单边图中两顶点间所有路径的程序。这个程序稍作修改就可以适用于有向图，对两顶点间有多条边相连的图暂时没想到解决办法，望高手给出解答,对之前写的单源最短路径程序也是如此。 搜索图中两顶点间的所有路径的代码如下(C语言): 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#define N 5 //无环单边非负权重无向图顶点数struct Path //路径节点结构体类型&#123; int sign; //节点代表的顶点的标号 int next; //当前顶点的下一可达顶点标号 struct Path *pnext; struct Path *pbefore;&#125;;typedef struct Path Path1;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N]); //路径搜索函数,寻找start和end间的所有路径int Enable(int i, int j, int p[][N], int z[][N], int node[]); //检查j是否是i的下一可达顶点,是返回1否则返回0int Search(int k, int option, int p[][N], int z[][N], int node[]); //在顶点k上搜索顶点option后的第一个可达顶点,搜索成功返回顶点标号，否则返回-1void main()&#123; int i, j, m, n; //m为起始顶点,n为终点 int p[N][N]=&#123;0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0&#125;; //初始化邻接矩阵p int q[N][N]=&#123;0, 3, 0, 7, 8, 3, 0, 4, 0, 9, 0, 4, 0, 9, 2, 7, 0, 9, 0, 9, 8, 9, 2, 9, 0&#125;; //初始化权重矩阵q,q[i][j]为连接i和j的边的权重 int z[N][N]; //标志连接i和j的边是否已被访问的矩阵,z[i][j]=0表示未访问,=1表示已访问 printf("请输入要搜索的路径的起始顶点标号:\n"); scanf("%d", &amp;m); //输入起始顶点标号 printf("请输入要搜索的路径的终点标号:\n"); scanf("%d", &amp;n); //输入终点标号 for (i=0; i&lt;N; i++) /*建立z矩阵并初始化为0*/ &#123; for (j=0; j&lt;N; j++) z[i][j]=0; &#125; FindRoad(m-1, n-1, p, q, z); //搜索m和n之间的所有路径并输出&#125;void FindRoad(int start, int end, int p[][N], int q[][N], int z[][N])&#123; int i, k; //i为当前顶点,k为下一可达顶点 int interval; int RoadLength; //路径长度 int count; //路径计数 int node[N]=&#123;0&#125;; //Node数组标记各顶点在搜索过程中是否已被访问,Node[i]=0表示i+1顶点未被访问,Node[i]=1表示i+1顶点已被访问，这里首先初始化Node数组 Path1 *psnewbe, *psnewaf, *head, *current; head=(Path1 *) malloc(sizeof(Path1)); psnewbe=head; psnewaf=head; //初始化路径链表 head-&gt;pnext=NULL; head-&gt;pbefore=NULL; count=0; //计数变量初始化 node[start]=1; //start标记为已访问 i=start; k=-1; //i初始化为起始顶点 while (1) &#123; if (Search(i, k, p, z, node)==-1) //搜索从k起的下一个可达顶点失败 &#123; if (i==start) //路径搜索完毕，退出 break; else &#123; if (k==-1) &#123; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; node[i]=0; i=psnewaf-&gt;sign; //回溯 k=psnewaf-&gt;next; continue; &#125; else &#123; z[psnewbe-&gt;sign][i]=z[i][psnewbe-&gt;sign]=0; node[i]=0; RoadLength-=q[psnewbe-&gt;sign][i]; free (psnewaf); psnewbe-&gt;pnext=NULL; psnewaf=psnewbe; //回溯 psnewbe=psnewbe-&gt;pbefore; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; continue; &#125; &#125; &#125; else //搜索出下一可达顶点 &#123; if (k==-1) &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示当前顶点i的路径节点 current-&gt;next=interval=Search(i, k, p, z, node); if (i==start) RoadLength=0; else //更新路径长度 &#123; RoadLength+=q[psnewaf-&gt;sign][i]; &#125; z[current-&gt;next][i]=z[i][current-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[current-&gt;next]=1; //下一可达顶点标记为已访问 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; current-&gt;pbefore=psnewaf; //当前节点插入路径链表 psnewbe=psnewaf; psnewaf=current; &#125; else &#123; psnewaf-&gt;next=interval=Search(i, k, p, z, node); //更新下一可达节点标号 z[psnewaf-&gt;next][i]=z[i][psnewaf-&gt;next]=1; //连接i和下一可达顶点的边标记为已访问 node[psnewaf-&gt;next]=1; //下一可达顶点标记为已访问 &#125; i=interval; //更新i为下一可达顶点 k=-1; //k重置 if (i==end) //到达终点 &#123; current=(Path1 *) malloc(sizeof(Path1)); current-&gt;sign=i; //建立表示终点的路径节点即路径链表尾节点 RoadLength+=q[psnewaf-&gt;sign][i]; //更新路径长度 current-&gt;pnext=NULL; psnewaf-&gt;pnext=current; //尾节点插入路径链表 current-&gt;pbefore=psnewaf; count++; //路径计数变量自增 printf("第%d条路径:\n", count); current=head-&gt;pnext; /*输出找到的路径*/ while (1) &#123; if (current-&gt;pnext==NULL) &#123; printf("V%d", current-&gt;sign+1); break; &#125; else &#123; printf("V%d-&gt;", current-&gt;sign+1); &#125; current=current-&gt;pnext; &#125; printf(" 路径长度%d\n", RoadLength); //输出找到的路径长度 free (current); //删除尾节点 psnewaf-&gt;pnext=NULL; RoadLength-=q[psnewaf-&gt;sign][i]; z[psnewaf-&gt;sign][i]=z[i][psnewaf-&gt;sign]=0; //回溯 node[i]=0; i=psnewaf-&gt;sign; k=psnewaf-&gt;next; &#125; continue; &#125; &#125; printf("共有%d条从V%d到V%d的路径\n", count, start+1, end+1); //输出找到的路径总数 if (head-&gt;pnext!=NULL) free(psnewaf); //完全删除路径链表 free(head);&#125;int Enable(int i, int j, int p[][N], int z[][N], int node[])&#123; if (p[i][j]==0) return 0; else &#123; if (node[j]==1) return 0; else &#123; if (z[i][j]==1) return 0; else return 1; &#125; &#125;&#125;int Search(int k, int option, int p[][N], int z[][N], int node[])&#123; int m=option; for (m++; m&lt;N; m++) &#123; if (Enable(k, m, p, z, node)==1) return m; &#125; return -1;&#125; 对于如下的图： 其邻接矩阵和权重矩阵已在程序中数组的初始化列表中给出，程序运行时起始顶点输入为V1,终点输入为V3,则程序运行结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[N皇后问题非递归求解]]></title>
    <url>%2Fpost%2F50971.html</url>
    <content type="text"><![CDATA[N皇后问题是一个老掉牙的问题了，随便翻一本算法书籍都能看到对它的介绍，其实N皇后问题可以用非递归方法解决，有效避免N过大时的递归工作栈溢出，且占用的存储空间较小，运行速度也较快，达到运行速度和空间合理利用的两全,代码很简单，并不复杂，有时简单也是一种美，意味着可靠和高效。追求程序的复杂和难以理解的编程者不会认同这一点，但对用简单的设计就可以解决的问题用复杂的数据表示加以描述是没有必要的。 代码如下(C语言):123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int *p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int *p, int k); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int *p); //输出n皇后问题的一个解void main()&#123; int k, n; int m; int *p; printf("you want to solve n queens problem\n"); printf("n="); scanf("%d", &amp;n); //输入问题规模 p=(int *) malloc(n*sizeof(int)); //p[k]表示k+1行皇后所在列 for (k=0; k&lt;n; k++) &#123; p[k]=0; //初始化数组p &#125; k=0; //初始化为第一行 m=0; //记录解的个数变量初始化loop: if (k==0) //进入或回溯至第一行 &#123; p[k]=p[k]+1; //试探下一列 if (p[k]&gt;n) //第一行所有列试探完毕，回溯结束 &#123; goto exit; &#125; k++; //试探下一行 goto loop; &#125; else &#123; if (find(n, p, k)==0) //k+1行没有找到可放置皇后的位置 &#123; p[k]=0; //必要的清理 k--; //回溯 goto loop; &#125; else &#123; p[k]=find(n, p, k); //在k+1行找到的位置赋予p[k] if (k!=(n-1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 goto loop; &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 goto loop; //回溯 &#125; &#125; &#125;exit: ; printf ("There are %d solutions in total\n", m); //输出解的个数&#125;int place(int i, int k, int *p)&#123; int m; for (m=0; m&lt;k; m++) &#123; if ((p[m]==i)||(abs(m-k)==abs(p[m]-i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125; int find(int n, int *p, int k)&#123; int i; i=p[k]; for (i++; i&lt;=n; i++) &#123; if (place(i, k, p)==1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int *p)&#123; int i, j; for (i=0; i&lt;n; i++) &#123; for (j=1; j&lt;=n; j++) &#123; if (j==p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; &nbsp;利用对称性解决N皇后问题： 对于n皇后问题的任意解，把它相对于棋盘中线做对称变换，即让N皇后解中任意一个皇后的列c变为n-c,得到的仍然是n皇后问题的一个解。所以剪枝时对第一行剪枝，让第一行皇后列依次取1, 2,3,–,[n/2],若n为偶数，第一行[n/2]+1,[n/2]+2–n列均不用考虑，直接剪掉,若n为奇数,[n/2]+2,—,n列不用考虑直接剪掉,皇后除放置于第一行1,2–,[n/2]列外还可放置于第一行[n/2]+1列，此时剪掉第二行[n/2]+1,—,n列即可也就是对第二行而言，在第一行已放置在最中间列的皇后限制下第二行1,2–，[n/2]列中所有可放置列关于中线的对称列全部剪掉。 用改进的剪枝策略优化N皇后问题所得代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;int place(int i, int k, int* p); //检查k+1行i列能否放置皇后,能返回1，否则返回0int find(int n, int* p, int k, bool n_is_odd); //在k+1行搜索可以放置皇后的位置，找到位置后返回列标，否则返回0void output(int n, int* p); //输出n皇后问题的一个解int main()&#123; int k, n; int m; int* p; printf("you want to solve n queens problem\n"); printf("n="); scanf_s("%d", &amp;n); //输入问题规模 p = (int*)malloc(n * sizeof(int)); //p[k]表示k+1行皇后所在列 for (k = 0; k &lt; n; k++) &#123; p[k] = 0; //初始化数组p &#125; k = 0; //初始化为第一行 m = 0; //记录解的个数变量初始化 bool n_is_odd = false; if (n % 2 != 0) &#123; n_is_odd = true; &#125; int max_col; if (n_is_odd) &#123; max_col = n / 2 + 1; &#125; else &#123; max_col = n / 2; &#125; while (true) &#123; if (k == 0) //进入或回溯至第一行 &#123; p[k] = p[k] + 1; //试探下一列 if (p[k] &gt; max_col) ////利用max_col剪枝，如果n为奇数,第一行第n/2+1列试探完毕后终止，否则n/2列试探完毕后终止 &#123; break; &#125; k++; //试探下一行 &#125; else &#123; int temp; if ((temp = find(n, p, k, n_is_odd)) == 0) //k+1行没有找到可放置皇后的位置 &#123; p[k] = 0; //必要的清理 k--; //回溯 &#125; else &#123; p[k] = temp; //在k+1行找到的位置赋予p[k] if (k != (n - 1)) //皇后没有全部放置完毕 &#123; k++; //试探下一行 &#125; else //皇后全部放置成功，找到解 &#123; m++; printf("The %dnd solution\n", m); output(n, p); //输出解 &#125; &#125; &#125; &#125; printf("There are %d solutions in total\n", m); //输出解的个数 return 0;&#125;int place(int i, int k, int* p)&#123; int m; for (m = 0; m &lt; k; m++) &#123; if ((p[m] == i) || (abs(m - k) == abs(p[m] - i))) //k+1行i列不是合法位置 return (0); &#125; return (1); //k+1行i列是合法位置 &#125;int find(int n, int* p, int k, bool n_is_odd)&#123; int i; i = p[k]; int max_col = n; if (k == 1) //如果当前行为第二行且n为奇数，同时第一行皇后位置为正中间，则第二行最多试探到n/2列终止 &#123; if (n_is_odd &amp;&amp; p[0] == n / 2 + 1) &#123; if (i + 1 &lt; n / 2) return i + 1; else &#123; return 0; &#125; &#125; &#125; for (i++; i &lt;= max_col; i++) &#123; if (place(i, k, p) == 1) //在k+1行找到可放置皇后的列 return (i); //返回该列 &#125; return (0); //在k+1行没有找到可放置皇后的列&#125;void output(int n, int* p)&#123; int i, j; for (i = 0; i &lt; n; i++) &#123; for (j = 1; j &lt;= n; j++) &#123; if (j == p[i]) printf("1 "); else printf("0 "); &#125; printf("\n"); &#125; printf("\n");&#125; 运行结果 附n皇后问题的递归代码： 该程序段为自己的创作(教科书上现成的代码没必要复制粘贴)，意义不是很大，因为比较繁琐，当n&lt;=8时能输出正确结果,n&gt;8时直接STACKOVERFLOW，所以大家看看就好，并不实用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void print(int n);void put(int k, int n, int *q, int *p);void output(int n, int *p);int law(int k ,int i, int *p);void main ()&#123; int n; printf ("you want to solve the problem of n queens the n=?\n"); scanf ("%d", &amp;n); print(n);&#125;void print(int n)&#123; int number, i; int *p; number=0; p=(int *)malloc(n*sizeof(int)); for (i=0; i&lt;n; i++) *(p+i)=0; put(1, n, &amp;number, p); printf("There are %d solutions in total\n", number); free(p);&#125;void put(int k, int n, int *q, int *p)&#123; int i; if (k==1) &#123; (*p)++; if ((*p)&gt;n) return; put(k+1, n, q, p); &#125; else &#123; i=*(p+k-1); i++; while (i&lt;=n) &#123; if (law(k, i, p)) &#123; *(p+k-1)=i; if (k==n) &#123; (*q)++; printf ("The %dnd solution\n", *q); output(n, p); put(k, n, q, p); &#125; else &#123; put(k+1, n, q, p); &#125; break; &#125; i++; &#125; if (i&gt;n) &#123; *(p+k-1)=0; put(k-1, n, q, p); &#125; &#125;&#125;void output(int n, int *p)&#123; int j, c; for (j=1; j&lt;=n; j++) &#123; for (c=1; c&lt;=n; c++) &#123; if (c==*(p+j-1)) printf ("%d", 1); else printf ("%d", 0); &#125; printf ("\n"); &#125; printf ("\n");&#125;int law(int k ,int i, int *p)&#123; int m; for (m=1; m&lt;k; m++) &#123; if ((*(p+m-1)==i)||(abs(m-k)==abs(*(p+m-1)-i))) return(0); &#125; return(1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[蚂蚁问题的编程解决]]></title>
    <url>%2Fpost%2F8809.html</url>
    <content type="text"><![CDATA[有一根27厘米的细木杆，在杆上某些位置上各有一只蚂蚁。木杆很细，不能同时通过一只以上蚂蚁。开始时，蚂蚁的头朝左还是朝右是任意的，它们只会朝前走或调头，但不会后退。当任意两只蚂蚁碰头时，两只蚂蚁会同时调头朝反方向走。假设蚂蚁们每秒钟可以走一厘米的距离。编写程序，输出各时刻杆上蚂蚁的位置和方向，每个时刻离杆的蚂蚁的编号，所有蚂蚁的离杆时间。最后输出各蚂蚁离杆时间。 代码如下(C语言)：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;stdlib.h&gt;void main()&#123; int t, i, flag; short *p1; int *p2; struct ant //保存蚂蚁信息的结构体类型 &#123; struct ant *next; struct ant *before; short direction; //蚂蚁位置 int position; //蚂蚁方向 int sign; //蚂蚁编号 &#125;; struct ant *psnew, *q, *head, *front, *after; typedef struct ant node; struct ant2 &#123; int time; int sign; struct ant2 *next; &#125;; struct ant2 *t2, *q2, *head2, *psnew2; typedef struct ant2 node2; struct ant3 &#123; int sign; struct ant3 *next; &#125;; struct ant3 *head3, *psnew3, *q3; typedef struct ant3 node3; printf ("please input the number of ants in stick\n"); /*输入位于杆上的蚂蚁个数,不能为0,数量不超过27*/ scanf ("%d", &amp;t); p1=(short *)malloc (t*sizeof(short)); p2=(int *)malloc (t*sizeof(int)); for (i=0; i&lt;t; i++) &#123; printf ("please input the direction of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始方向,1表示向右,0表示向左*/ scanf ("%d", p1+i); printf ("pleaase input the position of %dnd ant\n", i+1); /*输入第i+1个蚂蚁的初始位置,杆长27cm,位置为蚂蚁所在处距杆左端的长度,只能为正整数,即位置只能为1cm,2cm,3cm---,26cm,27cm,位置需按照蚂蚁编号从小到大输入*/ scanf ("%d", p2+i); &#125; head=(node *)malloc (sizeof(node)); q=head; head-&gt;next=NULL; head-&gt;before=NULL; for (i=0; i&lt;t; i++) &#123; psnew=(node *)malloc (sizeof(node)); psnew-&gt;next=NULL; psnew-&gt;direction=p1[i]; //初始化蚂蚁队列和各蚂蚁刚开始的位置方向 psnew-&gt;position=p2[i]; psnew-&gt;sign=i+1; q-&gt;next=psnew; psnew-&gt;before=q; q=psnew; &#125; head3=(node3 *)malloc (sizeof(node3)); head3-&gt;next=NULL; q3=head3; head2=(node2 *)malloc (sizeof(node2)); head2-&gt;next=NULL; q2=head2; t=0; while (head-&gt;next!=NULL) /*判断线性链表是否为空链表,从而判断是否全部的蚂蚁都爬下了杆子,若是退出循环输出t,否则继续循环*/ &#123; t++; /*时间进一过度到下一个时间点*/ q=head-&gt;next; while (q!=NULL) /*检测当前节点对应的蚂蚁的方向,根据方向调整蚂蚁的位置*/ &#123; if (q-&gt;direction) q-&gt;position=q-&gt;position+1; /*这种位置调整方式存在漏洞.若某时刻前一蚂蚁与后一蚂蚁位置相隔1,前一蚂蚁向右运动,后一蚂蚁向左运动,则按这种方式时间进一后前一蚂蚁将爬到后一蚂蚁前面一格,换言之两只蚂蚁位置交换了*/ else /*换言之两只蚂蚁互相穿过了对方,这是不可能的,实际上时间进一后两只蚂蚁仍在原来的位置,两只蚂蚁在他们原来两个位置的中点相碰又回到了原来的位置,并且此时他们的方向应该和原来方向相反*/ q-&gt;position=q-&gt;position-1; /*因此需要对两只蚂蚁的位置方向进行修正,此外若时间进一所有蚂蚁按照各自的方向移动一格后,两只蚂蚁位置相同,即他们相对碰撞,则碰撞后蚂蚁运动方向和原来相反,因此也需要修正方向.*/ q=q-&gt;next; &#125; psnew=head-&gt;next; /*psnew指向第一个节点*/ if (psnew-&gt;next!=NULL) /*判断第一个节点是否为尾节点,若不是说明有两只以上蚂蚁,则进行碰撞检测,修正蚂蚁运动方向,以及对发生相互穿越错误的一对蚂蚁的位置方向进行修正*/ &#123; q=psnew; psnew=head; flag=1; do &#123; psnew=psnew-&gt;next; q=q-&gt;next; if ((psnew-&gt;position)&gt;(q-&gt;position)) /*检测发生相互穿越错误的一对蚂蚁并对其位置和方向进行修正*/ &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; i=psnew-&gt;position; psnew-&gt;position=q-&gt;position; q-&gt;position=i; front=psnew-&gt;before; if (front-&gt;before!=NULL) &#123; if(front-&gt;position==psnew-&gt;position) /*进行碰撞检测,对碰撞后蚂蚁的方向进行修正*/ &#123; i=front-&gt;direction; front-&gt;direction=psnew-&gt;direction; psnew-&gt;direction=i; if (q-&gt;next!=NULL) &#123; after=q-&gt;next; if(after-&gt;position==q-&gt;position) &#123; i=after-&gt;direction; after-&gt;direction=q-&gt;direction; q-&gt;direction=i; flag=0; &#125; &#125; &#125; &#125; &#125; else &#123; if (((psnew-&gt;position)==(q-&gt;position))&amp;&amp;flag) &#123; i=psnew-&gt;direction; psnew-&gt;direction=q-&gt;direction; q-&gt;direction=i; &#125; else flag=1; &#125; &#125; while (q-&gt;next!=NULL); &#125; psnew=head; q=psnew-&gt;next; while (q!=NULL) &#123; if ((q-&gt;position&lt;1) || (q-&gt;position&gt;=27)) /*蚂蚁的方向位置都修正完毕后对当前节点对应的蚂蚁的位置进行检测,判断蚂蚁是否爬下杆子*/ &#123; psnew3=(node3 *)malloc (sizeof(node3)); psnew3-&gt;sign=q-&gt;sign; //保存越界的蚂蚁节点 psnew3-&gt;next=NULL; q3-&gt;next=psnew3; q3=psnew3; psnew2=(node2 *)malloc (sizeof(node2)); psnew2-&gt;sign=q-&gt;sign; //建立另一个越界的蚂蚁节点，保存该蚂蚁离杆的时间 psnew2-&gt;time=t; if (head2-&gt;next==NULL) &#123; psnew2-&gt;next=NULL; q2-&gt;next=psnew2; &#125; else &#123; t2=head2; q2=q2-&gt;next; while (1) &#123; if ((psnew2-&gt;sign)&lt;(q2-&gt;sign)) //对越界的蚂蚁节点执行插入排序 &#123; psnew2-&gt;next=q2; t2-&gt;next=psnew2; q2=head2; break; &#125; else &#123; if (q2-&gt;next==NULL) &#123; q2-&gt;next=psnew2; psnew2-&gt;next=NULL; q2=head2; break; &#125; else &#123; t2=t2-&gt;next; q2=q2-&gt;next; &#125; &#125; &#125; &#125; if (q-&gt;next!=NULL) /*蚂蚁爬下杆子故需对节点进行删除,先判断删除的节点是否为尾节点,若不是尾节点,按照非尾节点释放该节点,释放后被释放节点的指针指向被释放节点后一节点*/ &#123; psnew-&gt;next=q-&gt;next; after=q-&gt;next; after-&gt;before=q-&gt;before; free (q); q=psnew-&gt;next; &#125; else &#123; free (q); /*若释放的节点是尾节点,直接删除尾节点,尾节点前一节点指针域置空指针,被释放节点的指针置空指针*/ psnew-&gt;next=NULL; q=psnew-&gt;next; &#125; &#125; else &#123; psnew=q; /*检测到当前节点对应的蚂蚁没有爬下杆子,故前驱节点的指针指向当前节点,当前节点的指针指向下一节点,为下一蚂蚁爬下杆子的判断与处理做准备*/ q=q-&gt;next; &#125; &#125; q=head; while(q-&gt;next!=NULL) &#123; q=q-&gt;next; printf ("at the time%d,the%dnd ant is at the position%d,in the direction%d\n", t, q-&gt;sign, q-&gt;position, q-&gt;direction); /*输出当前时刻杆上所有蚂蚁的编号,位置,方向*/ &#125; if (head3-&gt;next!=NULL) &#123; q3=head3-&gt;next; while (q3!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q3-&gt;sign, t); //输出当前时间t离杆的蚂蚁编号 q3=q3-&gt;next; &#125; q3=head3; while (q3-&gt;next!=NULL) &#123; psnew3=q3-&gt;next; q3-&gt;next=psnew3-&gt;next; free (psnew3); &#125; &#125; &#125; printf ("the time of all ants need to be off the stick is %d\n", t); /*输出全部蚂蚁爬下杆子所对应时刻(蚂蚁均位于初始位置时视为t=0时刻),也就是蚂蚁全部爬出杆子所需时间*/ printf ("\n"); q2=q2-&gt;next; while (q2!=NULL) &#123; printf ("The %dnd ant is off the stick at time%d\n", q2-&gt;sign, q2-&gt;time); //输出各蚂蚁离杆时间 q2=q2-&gt;next; &#125;&#125;/*用线性链表实现解决蚂蚁问题,若干蚂蚁位于一长杆上,杆长27cm,蚂蚁初始方向可以任意,运动速度1cm/s,蚂蚁从初始位置出发,两蚂蚁若相碰不能穿过对方,只能相碰后各自掉头,求蚂蚁全部爬出杆子所需时间*/ 当初始时刻木杆有三只蚂蚁，从左至右数第一只蚂蚁位置方向为3,1，第二只为4,0，第三只为5,0时输出结果如下：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>蚂蚁问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言重解经典回溯算法案例-迷宫问题]]></title>
    <url>%2Fpost%2F49617.html</url>
    <content type="text"><![CDATA[迷宫问题是一道经典的回溯算法问题，给定一个迷宫矩阵，矩阵中的1表示障碍，0表示可走通路，给定迷宫入口出口，要求寻找从入口穿过迷宫到达出口的所有路径，有则输出，无则给出提示。一本合格的数据结构教科书一般都会介绍迷宫问题，网上的分析也是铺天盖地，这里就不再赘述重复的内容了。废话不多说，简单介绍一下程序，然后上代码。 &nbsp; &nbsp;&nbsp;该程序用二维数组表示迷宫，用另一个二维数组记录迷宫中的位置是否已经走过，同时用一个链式栈存放搜索出的临时路径。程序从迷宫入口开始试探，随着回溯试探过程的进行，链式栈的长度不断变化，当试探到迷宫出口时，链表中存放的就是一条完整的穿过迷宫的路径了，输出路径后回溯，继续试探下一条路径，当回溯到入口时没有新的可走方向时整个回溯试探的过程也就结束了。链表节点中除了存放被路径连接的各单元的行列标外，还存放有由该节点代表的单元前往该节点的后继节点代表的单元的方向，这么做是为了方便回溯操作的进行。 &nbsp; &nbsp;为方便起见，程序中迷宫的入口是固定的，为左上角单元，出口同样固定，为右下角单元。这并不妨碍程序的普适性，只要稍加修改就可以使程序适用于任意给定的出口和入口的情形。 &nbsp;&nbsp;啰嗦了这么半天，下面该上代码了，代码用C语言编写，具体如下。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;void convert(int *i, int *j, int k); //将当前单元行标列标i,j更新为方向k所指向的相邻单元的行标列标int boundary(int i, int j, int d, int n, int m); //检查(i,j)单元在d方向上是否为迷宫边界,是返回0，不是返回1int barrier(int i, int j, int d, int **p); //检查(i,j)单元在d方向上是否遇到障碍，是返回0，不是返回1int visit(int i, int j, int d, int **t); //检查(i,j)单元在d方向上的相邻单元是否已走过，是返回0，不是返回1int direction(int i, int j, int d, int n, int m, int **p, int **t); //检查(i,j)单元在d方向上是否可走,可走返回1，否则返回0int trial(int i, int j, int k, int n, int m, int **p, int **t); //在(i,j)单元上从k方向的下一个方向起寻找下一个可走方向,找到返回方向号，否则返回0void main ()&#123; int i, j, k; //i,j为单元位置标识,k为方向参数 int m, n; //m为迷宫行数,n为迷宫列数 int flag, Num; //flag标志是否存在走出迷宫的路径,Num为找到的路径序号 int min, max; char *q; int **p, **t; //p指向表示迷宫的二维数组,t指向记录迷宫中的每个位置是否已走过的二维数组 struct Record //表示路径节点的结构体类型 &#123; int x; int y; //节点对应单元的行列标 int sign; int mark; //记录当前节点的后继节点对应的单元相对于当前节点对应的单元的方向 struct Record *next; struct Record *before; &#125;; struct Record *head, *psnewbe, *psnewaf, *current; typedef struct Record Record1; struct Long &#123; int Num; int length; struct Long *next; &#125;; struct Long *head1, *psnew1, *p1; typedef struct Long Long1; printf ("please input the number of row and col of the Maze matrix\n"); printf ("please enter the row\n"); printf ("row="); scanf ("%d", &amp;m); //输入迷宫矩阵行列数 printf ("please enter the col\n"); printf ("col="); scanf ("%d", &amp;n); q=(char *) malloc((n+1)*sizeof(char)); p=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; p[i]=(int *) malloc(n*sizeof(int)); printf("please input the %dnd row of Maze matrix\n", i+1); //初始化迷宫矩阵,0表示可走,1表示障碍 scanf ("%s", q); for (j=0; j&lt;n; j++) *(p[i]+j)=q[j]-48; &#125; t=(int **) malloc(m*sizeof(int *)); for (i=0; i&lt;m; i++) &#123; t[i]=(int *) malloc(n*sizeof(int)); //初始化标志迷宫矩阵每一位置是否已走过的矩阵 for (j=0; j&lt;n; j++) *(t[i]+j)=0; &#125; head=(Record1 *) malloc(sizeof(Record1)); psnewbe=head; psnewaf=head; //初始化双向链表栈 head-&gt;next=NULL; head-&gt;before=NULL; head1=(Long1 *) malloc(sizeof(Long1)); head1-&gt;next=NULL; psnew1=head1; flag=0; //初始化标志是否存在走出迷宫路径的标志变量 Num=0; i=0; j=0; //初始化当前单元行列标,将迷宫左上角单元作为出发点 k=0; //方向参数初始化为0,对左上角单元从头开始试探可走方向loop: if (trial(i, j, k, n, m, p, t)==0) //回溯试探开始 &#123; if (i==0&amp;&amp;j==0) //在起始点已无方向可走,回溯结束 &#123; goto exit; &#125; else &#123; if (k==0) //(i,j)元的所有方向均不可走,回溯 &#123; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; else //在(i,j)元上沿k方向后的所有方向均不可走,回溯 &#123; *(t[i]+j)=0; free (psnewaf); psnewbe-&gt;next=NULL; psnewaf=psnewbe; //(i,j)元节点弹出栈 psnewbe=psnewbe-&gt;before; i=psnewaf-&gt;x; j=psnewaf-&gt;y; k=psnewaf-&gt;mark; goto loop; &#125; &#125; &#125; else &#123; if (k==0) //从头开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; //建立(i,j)元节点 current-&gt;mark=trial(i, j, k, n, m, p, t); if (i==0&amp;&amp;j==0) &#123; current-&gt;sign=1; &#125; else &#123; current-&gt;sign=psnewaf-&gt;sign+1; &#125; current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; //(i,j)元作为节点压入栈 psnewbe=psnewaf; psnewaf=current; *(t[i]+j)=1; //(i,j)元标志为已走 &#125; else //从k方向的下一方向开始为(i,j)元找到了可走方向trial(i, j, k, n, m, p, t) &#123; psnewaf-&gt;mark=trial(i, j, k, n, m, p, t); //相应更新(i,j)元节点中的方向 &#125; convert(&amp;i, &amp;j, trial(i, j, k, n, m, p, t)); //沿找到的方向从(i,j)元递进至下一单元 k=0; //为为下一单元从头开始寻找新方向作准备 if (i==(m-1)&amp;&amp;j==(n-1)) //抵达迷宫出口 &#123; flag=1; //标志变量置1 current=(Record1 *) malloc(sizeof(Record1)); current-&gt;x=i; current-&gt;y=j; current-&gt;sign=psnewaf-&gt;sign+1; //建立并压入代表迷宫出口的尾节点 current-&gt;next=NULL; psnewaf-&gt;next=current; current-&gt;before=psnewaf; Num++; //找到路径数增1 printf("\nThe %dnd possible route:\n", Num); //输出路径序号 current=head-&gt;next; while (current!=NULL) &#123; if (current-&gt;next!=NULL) &#123; printf ("(%d,%d)-&gt;", current-&gt;x+1, current-&gt;y+1); //输出找到的路径 &#125; else &#123; printf ("(%d,%d) ", current-&gt;x+1, current-&gt;y+1); printf ("long %d", current-&gt;sign); p1=(Long1 *) malloc(sizeof(Long1)); p1-&gt;Num=Num; p1-&gt;length=current-&gt;sign; p1-&gt;next=NULL; psnew1-&gt;next=p1; psnew1=p1; if (Num==1) &#123; min=current-&gt;sign; max=current-&gt;sign; &#125; else &#123; if (current-&gt;sign&lt;min) min=current-&gt;sign; if (current-&gt;sign&gt;max) max=current-&gt;sign; &#125; &#125; current=current-&gt;next; &#125; printf ("\n"); current=psnewaf-&gt;next; free (current); //尾节点弹出栈 psnewaf-&gt;next=NULL; i=psnewaf-&gt;x; j=psnewaf-&gt;y; //回溯 k=psnewaf-&gt;mark; &#125; goto loop; &#125;exit: ; if (flag==0) &#123; printf ("There is no possible route\n"); &#125; else &#123; printf ("There are %d routes in total\n", Num); printf ("The length of shortest route is %d shortest routes include:\n", min); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==min) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; printf ("The length of longest route is %d longest routes include:\n", max); psnew1=head1-&gt;next; while (psnew1!=NULL) &#123; if (psnew1-&gt;length==max) printf ("The %dnd route\n", psnew1-&gt;Num); psnew1=psnew1-&gt;next; &#125; &#125;&#125;void convert(int *i, int *j, int k)&#123; int *p1, *p2; p1=i; p2=j; if (k==1) &#123; *p1=*p1-1; &#125; else &#123; if (k==2) &#123; *p1=*p1-1; *p2=*p2+1; &#125; else &#123; if (k==3) &#123; *p2=*p2+1; &#125; else &#123; if (k==4) &#123; *p1=*p1+1; *p2=*p2+1; &#125; else &#123; if (k==5) &#123; *p1=*p1+1; &#125; else &#123; if (k==6) &#123; *p1=*p1+1; *p2=*p2-1; &#125; else &#123; if (k==7) &#123; *p2=*p2-1; &#125; else &#123; *p1=*p1-1; *p2=*p2-1; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125;int boundary(int i, int j, int d, int n, int m)&#123; if (i==0||i==m-1||j==0||j==n-1) &#123; if (i==0&amp;&amp;j!=0) &#123; if (j!=n-1) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==6||d==5||d==4) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==3||d==4) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (j==n-1&amp;&amp;i!=0) &#123; if (i!=m-1) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==2||d==3||d==4||d==5||d==6) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i==m-1&amp;&amp;j!=n-1) &#123; if (j!=0) &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6) return (0); else return (1); &#125; else &#123; if (d==4||d==5||d==6) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; else &#123; if (i!=0) &#123; if (n==1) &#123; if (d==8||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==6||d==7||d==8) return (0); else return (1); &#125; &#125; else &#123; if (m==1) &#123; if (d==8||d==1||d==2||d==4||d==5||d==6||d==7) return (0); else return (1); &#125; else &#123; if (n==1) &#123; if (d==8||d==1||d==2||d==3||d==4||d==6||d==7) return (0); else return (1); &#125; else &#123; if (d==8||d==1||d==2||d==6||d==7) return (0); else return (1); &#125; &#125; &#125; &#125; &#125; &#125; &#125; else &#123; return (1); &#125;&#125;int barrier(int i, int j, int d, int **p)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(p[m]+n)==0) return (1); else return (0);&#125;int visit(int i, int j, int d, int **t)&#123; int m, n; m=i; n=j; convert (&amp;m, &amp;n, d); if (*(t[m]+n)==0) return (1); else return (0);&#125;int direction(int i, int j, int d, int n, int m, int **p, int **t)&#123; if (boundary(i, j, d, n, m)==0) //(i,j)元在d方向为边界 &#123; return (0); //d方向不可走 &#125; else &#123; if (barrier(i, j, d, p)==0) //(i,j)元在d方向遇到障碍 &#123; return (0); //d方向不可走 &#125; else &#123; if (visit(i, j, d, t)==0) //(i,j)元在d方向上的相邻单元已经走过 return (0); //d方向不可走 else return (1); //d方向可走 &#125; &#125;&#125;int trial(int i, int j, int k, int n, int m, int **p, int **t)&#123; int q; q=k; for (q++; q&lt;=8; q++) //从k方向的下一方向开始寻找从(i,j)元可走的方向 &#123; if (direction(i, j, q, n, m, p, t)==1) return (q); //找到可走方向，将其返回 &#125; return (0); //没有可走方向，返回0&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c语言编程构造拉丁方阵和正交拉丁方阵组]]></title>
    <url>%2Fpost%2F20917.html</url>
    <content type="text"><![CDATA[将1,2,–,n这n个数填入n*n矩阵，使得每行每列的数两两不同(都是1,2,–,n的全排列)，这样的n阶方阵是拉丁方阵。如果一对n阶拉丁方阵对应的元素构成的有序对两两不同,则称这一对n阶拉丁方阵是正交的。现要编程用计算机构造出所有的n阶拉丁方阵和n阶正交拉丁方阵组，该怎么做？ &nbsp; &nbsp;一个显然的事实是,n阶拉丁方阵中各行i元素（i=1,2—n）是两两不同列的。所以按a1,—,an(为1,2–n的置换)顺序向各行填入ai(i=1,2,–,n)，使其两两不同列,就能得到一个正交拉丁方阵。我们可以按1,2,—,n的顺序填入各数得到一系列正交拉丁方阵,然后从中剔除可以由其中的其他拉丁方阵置换得到的拉丁方阵，经剔除后剩下拉丁方阵姑且叫基拉丁方阵。各基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}就能得到所有n阶拉丁方阵。且每个基拉丁方阵通过置换得到的所有拉丁方阵（包括基拉丁方阵在内）两两不成交,若两个不同的基拉丁方阵相互正交,则对于由这两个基拉丁方阵通过置换{1,2,–,n}-&gt;{a1,a2,–,an}衍生出的所有拉丁方阵（包括这两个基拉丁方阵）来说，衍生自其中一个拉丁方正的拉丁方阵和衍生自另一基拉丁方阵的拉丁方阵相互正交，反之亦然。因此只要找出所有的正交基拉丁方阵对就可找出所有的正交拉丁方阵组。 具体实现时，我们需要一个存放找到的拉丁方阵的二维数组Lad(回溯试探操作就对它进行),二维数组position-其第i行第j列的元素表示试探过程中数字j在Lad第i行的位置的列标，我称它为占位矩阵，以及二维数组hold，其第i行第j列的元素为1时表示Lad的第i行第j列已被填充,为0时表示Lad的第i行第j列未被填充。我们用回溯法反复试探，将n个数字全部填入Lad中，使其为拉丁方阵。通过回溯法找到的拉丁方阵及对应的占位矩阵被存放在B1类型的链表中。随后，根据以上分析，我们从找到的的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵,从而得到存放在B1类型链表中的所有基拉丁方阵,剔除过程中用到了一条性质:若两拉丁方阵对应的占位矩阵的所有列构成的集合相等,则两拉丁方阵中的每一个可以通过置换得到另一个。 &nbsp;&nbsp;得到基拉丁方阵后，就可以轻而易举地通过置换输出所有的n阶拉丁方阵，然后通过判断任意两个基拉丁方阵是否正交来求得并输出（对两个基拉丁方阵作置换）正交拉丁方阵组，问题就解决了。 以下是构造拉丁方阵和正交拉丁方阵组的C语言代码。程序还是有一些问题的,n超过4后等了一段时间后仍然没有结果输出。经过调试发现n=5时回溯操作能顺利完成,但当我越过剔除操作运行至输出操作时发现等了一段时间后程序还是无法运行至输出操作。按步进方式执行剔除操作时没有遇到程序崩溃出错等问题，但无论我按住按键多长时间剔除操作都无法执行完，所以推测是n=5时找出的拉丁方阵过多,程序运行的时间开销太大，短时间内无法执行完毕，没办法。笔者智商捉急，想不到好的方法能解决这个问题，希望有大神能提出改进方案，优化程序，缩短运行时间,目前这个程序至多对n=4能输出正确结果,n&gt;=5时等了一段时间就是不出结果,仔细检查觉得应该不是死循环导致这个问题，暂时也只能这样了，郁闷123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;#define N 4struct B&#123; int **Pa; //结构体B中Pa指针用于指向找到的拉丁方阵 int **Pb; //结构体B中Pb指针用于指向该拉丁方阵对应的占位矩阵 struct B *next;&#125;;typedef struct B B1;void L(int **p1, int *p2, int n); //求所有全排列的递归函数void output(B1 *psnew, int fac, int **factor); //输出基拉丁方阵对应的所有拉丁方阵的函数int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF); //将i填充入方阵的函数,填充成功返回1，否则返回0int find(int i, int position[][N], int hold[][N], int k); //寻找方阵的k+1行可以放置i的位置,找到返回列标，否则返回0int place(int i, int j, int position[][N], int hold[][N], int k); //函数，判断方阵的k+1行,j列是否可以放置i，可以返回1，否则返回0int B(int n); //求阶乘的递归函数void main()&#123; int Lad[N][N]=&#123;0&#125;, position[N][N]=&#123;0&#125;, hold[N][N]=&#123;0&#125;; //回溯试探针对Lad方阵进行，试探成功后Lad中保存有找到的拉丁方阵.position为占位矩阵,hold为标志方阵中各位置是否已被填充的矩阵 int que[N]; int **factor; //指向存放所有全排列的方阵 int fac; bool TF; //为true代表上一个数填充成功，应该开始填充下一个，为false表示当前数填充失败,应该返回上一个数进行回溯 int i, j, k, flag; //i在第一个while循环中表示填充的数字,flag表示两占位矩阵列集合是否相等 B1 *head, *tail, *psnew, *pm; head=(B1 *) malloc(sizeof(B1)); tail=head; head-&gt;next=NULL; for (i=0; i&lt;N; i++) que[i]=i+1; factor=(int **) malloc((fac=B(N))*sizeof(int *)); for (i=0; i&lt;fac; i++) factor[i]=(int *) malloc(N*sizeof(int)); //建立用来保存所有全排列的矩阵 L(factor, que, N); //将所有全排列填入上述矩阵 TF=true; i=1; //TF,i初始化 while (1) //回溯试探开始,往Lad方阵中按一定规则填充各数 &#123; if (i==1) //回溯至或开始填充第一个数 &#123; if (fill(Lad, position, hold, i, TF)==0) &#123; break; //第一个数填充失败,所有依次填1,2,--n的拉丁方阵均已找到，循环结束 &#125; i++; //自增1，准备填充第二个数 TF=true; //准备填充第二个数 continue; //开始新一轮循环 &#125; else &#123; if (fill(Lad, position, hold, i, TF)==0) //第i个数填充失败 &#123; i--; TF=false; //回溯至上一个数 continue; &#125; else &#123; if (i!=N) //第i个数填充成功,但所有数没有填完 &#123; i++; TF=true; //准备填充下一个数 continue; &#125; else //所有数填充成功，找到一个拉丁方阵 &#123; psnew=(B1 *) malloc(sizeof(B1)); psnew-&gt;next=NULL; psnew-&gt;Pa=(int **) malloc(N*sizeof(int *)); //建立B1类型节点,令节点的Pa,Pb指向该拉丁方阵和对应的占位矩阵 psnew-&gt;Pb=(int **) malloc(N*sizeof(int *)); for (j=0; j&lt;N; j++) &#123; psnew-&gt;Pa[j]=(int *) malloc(N*sizeof(int)); psnew-&gt;Pb[j]=(int *) malloc(N*sizeof(int)); for (k=0; k&lt;N; k++) &#123; *(psnew-&gt;Pa[j]+k)=Lad[j][k]; //用找到的拉丁方阵和占位矩阵填充Pa,Pb指向的拉丁方阵和占位矩阵 *(psnew-&gt;Pb[j]+k)=position[j][k]; &#125; &#125; tail-&gt;next=psnew; tail=psnew; TF=false; //回溯 continue; &#125; &#125; &#125; &#125; if (head-&gt;next!=NULL) //从找到的依次填入1,2---n的拉丁方阵中剔除可由其中其他拉丁方阵置换得到的拉丁方阵 &#123; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) &#123; for (tail=psnew-&gt;next, pm=psnew; tail!=NULL; tail=tail-&gt;next, pm=pm-&gt;next) &#123; flag=0; loop: for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; for (k=0; k&lt;N; k++) &#123; if (*(psnew-&gt;Pb[k]+i)!=*(tail-&gt;Pa[k]+j)) &#123; flag=1; break; //判断B1类型链表中两拉丁方阵对应的占位矩阵的所有列构成的两个集合是否相等 &#125; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==1) &#123; flag=0; continue; &#125; flag=1; break; &#125; if (flag==0) // flag==1 则两占位矩阵列集合不相等，否则相等 &#123; for (i=0; i&lt;N; i++) //两占位矩阵的列集合相等，相应的两拉丁方阵可以通过置换相互得到,故删除tail指向的拉丁方阵，占位矩阵和节点 &#123; free(tail-&gt;Pa[i]); free(tail-&gt;Pb[i]); &#125; free(tail-&gt;Pa); free(tail-&gt;Pb); pm-&gt;next=tail-&gt;next; //让pm的指针域指向tail所指节点的后继节点 free(tail); //删除tail所指节点 if (pm-&gt;next!=NULL) &#123; tail=pm-&gt;next; //tail指向被删节点的后继节点 goto loop; //立即开始该后继节点和psnew指向的节点的比较 &#125; else &#123; tail=pm; if (psnew-&gt;next==NULL) goto exit; //所有比较删除工作均已完成，退出循环 &#125; &#125; &#125; &#125;exit: ; if (head-&gt;next==NULL) //没有基拉丁方阵,所以没有拉丁方阵 &#123; printf("不存在N阶拉丁方阵\n"); printf("不存在N阶正交拉丁方阵组\n"); &#125; else &#123; printf("所有N阶拉丁方阵为:\n"); for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) //输出所有拉丁方阵 &#123; output(psnew, fac, factor); &#125; psnew=head-&gt;next; if (psnew-&gt;next==NULL) //只有一个基拉丁方阵，所以不存在正交拉丁方阵组 printf("不存在N阶正交拉丁方阵组\n"); else &#123; k=0; for (psnew=head-&gt;next; psnew-&gt;next!=NULL; psnew=psnew-&gt;next) //判断正交拉丁方阵组的存在性,并输出正交拉丁方阵组 &#123; for (tail=psnew-&gt;next; tail!=NULL; tail=tail-&gt;next) &#123; memset(hold[0], 0, N*N*sizeof(int)); //判断正交前把计数矩阵清零 flag=0; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) &#123; hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]++; if (hold[*(psnew-&gt;Pa[i]+j)-1][*(tail-&gt;Pa[i]+j)-1]&gt;1) //判断基拉丁方阵是否正交 &#123; flag=1; break; &#125; &#125; if (flag==1) break; &#125; if (flag==0) //找到一对正交拉丁方阵组输出 &#123; k=1; printf("正交拉丁组:\n"); printf("第一组\n"); output(psnew, fac, factor); printf("第二组\n"); output(tail, fac, factor); &#125; &#125; &#125; if (k==0) printf("不存在N阶正交拉丁方阵组\n"); &#125; &#125; &#125;&#125;int fill(int Lad[][N], int position[][N], int hold[][N], int i, bool TF)&#123; int k, j; if (TF==true) k=0; //从头开始填充i,行号置1 else k=N-1; //在当前数字i回溯,行号置尾行号 while (1) //对i的回溯试探开始 &#123; if (k==0) //回溯至或开始填充第一行 &#123; for (j=position[k][i-1]+1; j&lt;=N; j++) //寻找第一行填充位置 &#123; if (hold[k][j-1]==0) break; &#125; if (j&gt;N) //第一行没有填充位置,填充失败，作必要的清理，返回0 &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; position[k][i-1]=0; return 0; &#125; if (position[k][i-1]!=0) //第一行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=j; Lad[k][position[k][i-1]-1]=i; hold[k][position[k][i-1]-1]=1; //填充i k++; continue; //试探下一行 &#125; else &#123; if (find(i, position, hold, k)==0) //在k+1行找不到i的填充位置 &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 position[k][i-1]=0; &#125; k--; //回溯至上一行 continue; &#125; else &#123; if (position[k][i-1]!=0) //第k+1行已填充i &#123; Lad[k][position[k][i-1]-1]=0; hold[k][position[k][i-1]-1]=0; //必要的清理 &#125; position[k][i-1]=find(i, position, hold, k); Lad[k][position[k][i-1]-1]=i; //填充i hold[k][position[k][i-1]-1]=1; if (k!=N-1) //还未将i填充完毕 &#123; k++; //继续试探下一行 continue; &#125; else &#123; return (1); //i已填好，填充成功，返回1 &#125; &#125; &#125; &#125;&#125;int find(int i, int position[][N], int hold[][N], int k) &#123; int j=position[k][i-1]; for (j++; j&lt;=N; j++) //搜索k+1行下一个可以填充i的位置 if (place(i, j, position, hold, k)==1) return (j); //找到返回该位置的列标 &#125; return (0); //没有下一个可以填充i的位置,返回0 &#125;int place(int i, int j, int position[][N], int hold[][N], int k)&#123; int m, flag=0; for (m=0; m&lt;k; m++) //检查k+1行以上各行的i是否都和k+1行j列不在同一列 &#123; if (position[m][i-1]==j) flag=1; //有i在同一列,k+1行j列位置不合法 &#125; if (hold[k][j-1]==1) //k+1行j列已被填充,位置不合法 flag=1; if (flag==1) return (0); //位置不合法 else return (1); //位置合法&#125;void L(int **p1, int *p2, int n) //将p2指向的数组中的n个数的所有全排列存放在p1所指向的二维数组中&#123; if (n==1) *p1[0]=*p2; else &#123; int **p3; int *p4; int c, d, f, k, m, i, j; d=n-1; c=B(d); p4=(int *) malloc(d*sizeof(int)); p3=(int **) malloc(c*sizeof(int *)); for (i=0; i&lt;c; i++) p3[i]=(int *) malloc(d*sizeof(int)); j=0; f=c; for (i=0; i&lt;n; i++) &#123; m=0; for (k=0; k&lt;n; k++) &#123; if (k==i) continue; *(p4+m)=*(p2+k); m++; &#125; L(p3, p4, d); for (k=0; k&lt;c; k++) for (m=0; m&lt;d; m++) *(p1[k+j]+m+1)=*(p3[k]+m); while (j&lt;f) &#123; *p1[j]=*(p2+i); j++; &#125; if (i!=d) f=f+c; &#125; &#125;&#125;int B(int n) //计算n的阶乘&#123; if (n==0) return (1); else return (n*B(n-1));&#125; void output(B1 *psnew, int fac, int **factor) //输出psnew指向的节点指向的基拉丁方阵和置换得到的所有其他拉丁方阵&#123; int i, j, k; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(psnew-&gt;Pa[i]+j)); //输出基拉丁方阵 printf("\n"); &#125; printf("\n"); for (k=1; k&lt;fac; k++) &#123; for (i=0; i&lt;N; i++) &#123; for (j=0; j&lt;N; j++) printf("%d ", *(factor[k]+(*(psnew-&gt;Pa[i]+j)-1))); //输出置换得到的所有其他拉丁方阵 printf("\n"); &#125; printf("\n"); &#125;&#125; &nbsp;附一个有趣的小算法,判定一个给定方阵是否为拉丁方阵：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;void main()&#123; int n; int i, j; int flag; char *str; int **b, **a; printf("请输入要判断的方阵的阶数\n"); scanf("%d", &amp;n); str=(char *) malloc(n*sizeof(char)); a=(int **) malloc(n*sizeof(int *)); for (i=0; i&lt;n; i++) &#123; a[i]=(int *) malloc(n*sizeof(int)); printf("请输入%d阶方阵的第%d行\n", n, i+1); scanf("%s", str); for (j=0; j&lt;n; j++) *(a[i]+j)=str[j]-48; &#125; b=(int **) malloc(2*sizeof(int *)); for (i=0; i&lt;2; i++) &#123; b[i]=(int *) malloc(n*sizeof(int)); for (j=0; j&lt;n; j++) *(b[i]+j)=0; &#125; flag=0; for (i=0; i&lt;n; i++) &#123; for (j=0; j&lt;n; j++) &#123; b[0][a[i][j]-1]++; b[1][a[j][i]-1]++; if (b[0][a[i][j]-1]&gt;1||b[1][a[j][i]-1]&gt;1) &#123; flag=1; break; &#125; &#125; if (flag==1) break; memset(b[0], 0, n*sizeof(int)); memset(b[1], 0, n*sizeof(int)); &#125; if (flag==0) printf("您输入的%d阶方阵是拉丁方阵\n", n); else printf("您输入的%d阶方阵不是拉丁方阵\n", n);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>拉丁方阵，回溯法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言求解线性方程组]]></title>
    <url>%2Fpost%2F52120.html</url>
    <content type="text"><![CDATA[经典问题用高斯约当算法求解线性方程组。这里要求对任意形式的线性方程组都能够妥善处理，不能只适用于方程个数和未知量数目相等的特殊情形。 &nbsp;&nbsp;先用循环结构将增广矩阵转换为阶梯形矩阵，循环结束时得到阶梯型矩阵非零行行数，同时得到一个链表其中存放有各非零行主元的列标，列标在链表中按从左到右的顺序依次递减。然后根据线性代数中线性方程组的解的情况及判别准则判断方程是否有解，有多少个解。当线性方程组有解时，需要用convert函数将其转换为简化行阶梯型矩阵，然后输出唯一解或一般解 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;math.h&gt;#define N 5 //增广矩阵列数#define M 3 //增广矩阵行数struct maincol&#123; int col; //存放各主元下标的结构体类型 struct maincol *next;&#125;;typedef struct maincol mc1;int test(int s, int t, float a[][N]); //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标void add(mc1 *head, int col, mc1 **tail); //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表void convert(float a[][N], int row, mc1 *head); //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵void main()&#123; float a[M][N]; //增广矩阵 char str[N+1]; int i, j; int s, t; //子矩阵左上角元素行列下标 int row, col; //row用于存放阶梯形矩阵非零行行数 float swap; mc1 *head, *tail, *psnew; for (i=0; i&lt;M; i++) //输入并初始化增广矩阵 &#123; printf("请输入增广矩阵第%d行\n", i+1); scanf("%s", str); for (j=0; j&lt;N; j++) a[i][j]=str[j]-48; &#125; head=(mc1 *) malloc(sizeof(mc1)); head-&gt;next=NULL; tail=head; s=t=1; //子矩阵即为增广矩阵本身，用增广矩阵左上角元素行列标初始化s,t while((col=test(s, t, a))!=0) //子矩阵不为零矩阵 &#123; if (s==M) //增广矩阵已化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; else &#123; j=s-1; for (i=s; i&lt;M; i++) &#123; if (fabs(a[j][col-1])&lt;fabs(a[i][col-1])) //列选主元 j=i; &#125; if (s-1!=j) &#123; for (i=col-1; i&lt;N; i++) &#123; swap=a[j][i]; a[j][i]=a[s-1][i]; //列选主元 a[s-1][i]=swap; &#125; &#125; if (col==N) //增广矩阵已经化为阶梯形矩阵 &#123; row=s; //记录非零行行数 add(head, col, &amp;tail); //最后一个非零行主元列标放入maincol类型链表 break; //结束循环 &#125; for (i=s; i&lt;M; i++) a[i][col-1]=-(a[i][col-1]/a[s-1][col-1]); for (i=col; i&lt;N; i++) //消元 &#123; for (j=s; j&lt;M; j++) a[j][i]=a[j][col-1]*a[s-1][i]+a[j][i]; &#125; add(head, col, &amp;tail); //将消元后得到的主元列标col放入maincol类型链表 s++; t=col+1; //更新s,t,使s,t成为消元后得到的新的子矩阵的左上角元素行列标,为test函数操作新的子矩阵作准备 continue; //开始新一轮循环 &#125; &#125; if (col==0) //从循环控制条件退出循环 row=s-1; //此时增广矩阵已成为阶梯形矩阵,非零行函数就是s-1 if (row==0) //利用线性方程组解的判别准则判断是否有解，有多少个解 &#123; printf("线性方程组有无穷多组解\n"); //增广矩阵为零矩阵，无穷多组解 printf("一般解:\n"); for (i=1; i&lt;N; i++) printf("x%d=t%d\n", i, i); //输出解 &#125; else &#123; psnew=head-&gt;next; if (psnew-&gt;col==N) //阶梯形矩阵最后一主元在最后一列，无解 printf("线性方程组无解\n"); else &#123; convert(a, row, head); //用convert函数将阶梯形矩阵进一步化为简化行阶梯形矩阵 if (row==N-1) //非零行行数等于未知量个数，有唯一解 &#123; printf("线性方程组有唯一解:\n"); for (i=1; i&lt;=row; i++) //输出唯一解 printf("x%d=%f\n", i, a[i-1][N-1]); &#125; else //非零行行数小于未知量个数，有无穷多组解 &#123; int *m; m=(int *) malloc((N-1-row)*sizeof(int)); i=N-1-row; for (j=N-1; j&gt;=1; j--) &#123; if (j!=psnew-&gt;col) &#123; m[--i]=j; //从所有未知量标号中筛选出自由未知量标号 if (i==0) break; &#125; else &#123; if (psnew-&gt;next!=NULL) psnew=psnew-&gt;next; &#125; &#125; printf("线性方程组有无穷多组解\n"); printf("一般解:\n"); i=row; for (psnew=head-&gt;next; psnew!=NULL; psnew=psnew-&gt;next) &#123; printf("x%d=%f", psnew-&gt;col, a[i-1][N-1]); //输出一般解 for (j=0; j&lt;N-1-row; j++) &#123; if(m[j]&lt;psnew-&gt;col) &#123; printf("-%dx%d", 0, m[j]); &#125; else &#123; printf("-%fx%d", a[i-1][m[j]-1], m[j]); &#125; &#125; printf("\n"); i--; &#125; &#125; &#125; &#125;&#125;int test(int s, int t, float a[][N]) //判断增广矩阵的s行至M行与t列至N列相交形成的子矩阵是否为零矩阵，若是返回0，若不是返回第一个不为零的列的列标&#123; int i, j; for (j=t-1; j&lt;N; j++) &#123; for (i=s-1; i&lt;M; i++) &#123; if (a[i][j]!=0) return (j+1); &#125; &#125; return (0);&#125;void add(mc1 *head, int col, mc1 **tail) //函数，用于新建一节点，其中保存有主元col列标，然后按递减顺序将其插入maincol类型的链表&#123; mc1* psnew; psnew=(mc1 *) malloc(sizeof(mc1)); psnew-&gt;col=col; if(head-&gt;next==NULL) &#123; psnew-&gt;next=NULL; head-&gt;next=psnew; *tail=psnew; &#125; else &#123; psnew-&gt;next=head-&gt;next; head-&gt;next=psnew; &#125;&#125;void convert(float a[][N], int row, mc1 *head) //函数，用于将阶梯型矩阵转化为简化行阶梯形矩阵&#123; mc1 *psnew, *pq; int i, j, k, m; psnew=head-&gt;next; for (i=row-1; i&gt;=0; i--) &#123; if (a[i][psnew-&gt;col-1]!=1) //各非零行主元化为1 &#123; for (j=psnew-&gt;col; j&lt;N; j++) a[i][j]=a[i][j]/a[i][psnew-&gt;col-1]; &#125; psnew=psnew-&gt;next; &#125; psnew=head-&gt;next; //向上消元把除第一个主元外其余主元所在列中在主元上方的部分变为零 for (i=row-1; i&gt;=1; i--) &#123; m=N-psnew-&gt;col-(row-i); //获取未知量标号1,2,--,N-1中位于i+1非零行主元列标号右边的自由未知量标号个数 for (j=i-1; j&gt;=0; j--) &#123; pq=head-&gt;next; //pq指向存放最后一个非零行主元列标号的节点 for (k=N; k&gt;psnew-&gt;col; k--) &#123; if (k!=pq-&gt;col) &#123; a[j][k-1]=-(a[i][k-1]*a[j][psnew-&gt;col-1])+a[j][k-1]; //从右向左作初等行变换直至i+1行主元所在列右边的列位置，期间跳过i+2----row行主元所在的列 m--; if (m==0) break; &#125; else &#123; if (pq-&gt;next!=psnew) pq=pq-&gt;next; &#125; &#125; &#125; psnew=psnew-&gt;next; //递进至上一行主元，为新一轮向上消元作准备 &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>线性方程组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿拉伯数字到中文大写数字的转换]]></title>
    <url>%2Fpost%2F2773.html</url>
    <content type="text"><![CDATA[将阿拉伯数字转化为中文大写是很简单很实用的功能，但由于0这个特殊数字的存在使得实现起来并非那么容易，实现这一功能的关键就是对0的正确处理。该程序是我几个月之前写成的，当时没有加注释，现在程序的实现细节基本忘光了，难以写出注释。只能凭自己模糊的印象大致部分地介绍一下思路和方法，当初思路中的细节已经无法回忆了，没有注释的代码大家只能将就看一下，能看懂最好看不懂也没办法 我当初的想法是现将输入的阿拉伯数字的每一位单独分离出来，按从低位到高位的顺序存放在线性链表里，然后从低位到高位扫描链表。将数字从低位至高位每四位分为一组，最左边的组可以不足位。用Re代表每组中某数字相对于该组最低位的偏移量，di代表每组中最低起始位从数字最低位数起的的位数，从低位至高位从1起以4为间隔依次增大。用mark表示前一位是否为0，用sign表示某数右边低位部分是否全为0，flag表示每组中某数右边在该组中的低位部分是否全为0。程序中用字符型二维数组存放中文大写数字单位，并用三个函数分别完成单位阿拉伯数字到中文大写数字，每组内的数字单位到中文大写，以及每组的最低起始位的数字单位到中文大写的转化 &nbsp; 程序的主体部分就是用循环结构从左到右扫描存放数字各位的链表，扫描过程中把转化出的中文大写数字按由高位至低位的顺序插入另一个链表，扫描完毕后新链表中存放的就是转换结果，可以直接输出。 C语言代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;struct output //存放中文大写单位或数字的结构体类型&#123; char ch[3]; struct output *next;&#125;;struct output *head1, *psnew1, *p1;typedef struct output output1;void Num(output1 *p1, char *N, int wei); //函数注释见main后的函数定义部分void Re(output1 *p1, char *R, int re);void Di(output1 *p1, char *D, int di);void main ()&#123; int t; int sign, flag, mark; int re, di; char N[10][3]=&#123;"零", "壹", "贰", "叁", "肆", "伍", "陆", "柒", "捌", "玖"&#125;; //用字符串数组存放中文大写数字和单位 char R[3][3]=&#123;"拾", "佰", "仟"&#125;; char D[3][3]=&#123;"万", "亿", "兆"&#125;; struct number //存放每一位数字的结构体类型 &#123; int wei; struct number *next; &#125;; struct number *head, *psnew, *p; typedef struct number number1; printf ("please input the number which you want to convert\n"); scanf ("%d", &amp;t); //输入要转换的阿拉伯数字 head=(number1 *)malloc (sizeof(number1)); psnew=head; head-&gt;next=NULL; head1=(output1 *)malloc (sizeof(output1)); psnew1=head1; head1-&gt;next=NULL; while (t!=0) //将输入的阿拉伯数字的各位分离，按从低位至高位的顺序从左至右存放在线性链表中 &#123; p=(number1 *)malloc (sizeof(number1)); p-&gt;wei=t%10; p-&gt;next=NULL; psnew-&gt;next=p; psnew=p; t=t/10; &#125; psnew=head-&gt;next; sign=0; flag=0; if (psnew-&gt;wei) mark=1; //重要变量的必要初始化 else mark=0; re=0; di=1; while (psnew!=NULL) //从左到右扫描链表，进行到中文大写的转化，转换结果存放在ouput类型的链表中 &#123; if (re==0) &#123; if (psnew-&gt;wei==0) &#123; if (sign==1) &#123; if (flag==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; flag=0; if (mark==1) mark=0; re=re+1; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=NULL; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=re+1; &#125; &#125; else &#123; if (psnew-&gt;wei==0) &#123; if (mark==1) mark=0; re=(re+1)%4; if (re==0) di=di+4; &#125; else &#123; if (sign==0) &#123; if (di==1) &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=NULL; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; else &#123; if (flag==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Di(p1, &amp;D[0][0], di); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; if (mark==0) &#123; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], 0); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; else &#123; p1=(output1 *)malloc (sizeof(output1)); Re(p1, &amp;R[0][0], re); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; p1=(output1 *)malloc (sizeof(output1)); Num(p1, &amp;N[0][0], psnew-&gt;wei); p1-&gt;next=head1-&gt;next; head1-&gt;next=p1; &#125; &#125; &#125; sign=1; flag=1; if (mark==0) mark=1; re=(re+1)%4; if (re==0) di=di+4; &#125; &#125; psnew=psnew-&gt;next; &#125; psnew1=head1-&gt;next; while (psnew1!=NULL) //输出转换结果 &#123; printf("%s", &amp;psnew1-&gt;ch[0]); psnew1=psnew1-&gt;next; &#125; printf("\n");&#125;void Num(output1 *p1, char *N, int wei) //将wei表示的阿拉伯数字转化为中文大写，存放在p1指向的ouput1类型的节点中&#123; int i; for (i=0; i&lt;=2; i++) p1-&gt;ch[i]=N[wei*3+i];&#125;void Re(output1 *p1, char *R, int re) //将re表示的组内数字单位转换为中文大写，存放在p1指向的ouput1类型的节点中&#123; int j; for (j=0; j&lt;=2; j++) p1-&gt;ch[j]=R[(re-1)*3+j];&#125;void Di(output1 *p1, char *D, int di) //将di表示的每组的最低起始位的数字单位转换为中文大写&#123; int k, m; m=(di-5)/4; for (k=0; k&lt;=2; k++) p1-&gt;ch[k]=D[m*3+k];&#125; 运行结果：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数字转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用回溯法和栈解决阿里面试题排队问题]]></title>
    <url>%2Fpost%2F62843.html</url>
    <content type="text"><![CDATA[最近在网上搜索有关Catalan number的资料时发现了一道有关Catalan number的很有趣的问题。题目为有12位高矮不同的人，将他们排成两排，每排六人，要求每排六人均从矮到高排列且第二排每个人的身高均大于第一排对应的人的身高，问满足要求的排列方法有多少种。关于这个问题，不妨直接考虑一般情形，12人为2n人，网上对此的分析已经铺天盖地，答案就是Catalan number n+1/C(n,2n)，具体的分析过程这里就不再重复赘述了，这里我们主要考虑用计算机解决排队问题，不仅要用高效的算法求出排法总数，还要逐一输出所有的排法。这一编程问题网上已有众多大神给出解答，个个漂亮，但我个人认为我所能搜到的解法还是稍显繁琐，循环套循环，循环接循环，一些一维二维数组，运行效率较低，而且还用到了递归，这样在n非常大，也就是递归深度较深时容易引起堆栈溢出问题。这里我自己考虑了一个算法，避免使用递归，用简单的以循环实现回溯法就可以解决，用到的体积最大的数据结构也就是一个长度为2*n的一维数组，这样就能尽可能降低空间复杂度和时间复杂度，先讲一下求解思路：这篇文章http://blog.csdn.net/jiyanfeng1/article/details/8036007 的分析给出一种可能的求解思路。试想将2n个人按从矮到高的顺序排成一个序列，每个人若在第一排就以1表示，若在第二排就以2表示，这样在2n个人中选取n个人视为1，剩下的n个人视为2，这样就得到了一个候选解，这个候选解中第一排的n个人和第二排的n个人都是从矮到高排列。现在我们的任务是从所有候选解中选出可行解。满足第二排每个人的身高均大于第一排对应的人的身高的候选解就是可行解。那么由n个1n个2组成的候选解满足什么条件时就是可行解呢？ &nbsp; 考察第m个2，为了满足可行解的要求，第m个1必须在第m个2的前面，这样第二排第m个人的身高才能高于第一排第m个人的身高，于是很自然的第m个2前面的1的个数必须大于等于第m个2前面且包括第m个2在内的2的个数m。这样满足以下条件的候选解就是可行解： 候选解中的每个2前面的1的个数大于等于该2前面的所有2且包括该2本身的个数 &nbsp; 于是接下来只要编写算法利用以上条件从候选解中筛选出所有可行解就可以了 &nbsp; 怎么筛选？ &nbsp; 想筛选出可行解，需要按一定的先后次序将n个1和n个2依次放入保存可行解的栈，由于是从栈底起依次放入，因此这是典型的入栈操作，每当一个2被放入后，需要检查栈中包含这个2的部分序列是否是可行解的一部分，若是则继续按一定的规则执行入栈的操作，若不是需要将该2弹出栈(回溯过程)，然后若新的队尾为1，则将1换为2，若为2则继续回溯，将2弹出栈，然后对栈中剩下的部分序列继续判断执行回溯或入栈操作。每次入栈时，一般以1优先入栈，如果n个1已全部入栈或2n-1个0和1已全部入栈(这意味着还有最后一个数需要入栈，这个数只能为2)，则以2入栈。需要注意的是，首先入栈的必须是1(如果为2则为不合法解的一部分),此外，如果检测到栈中只剩下位于栈底的一个元素1，则所有结果均已求出，终止回溯过程。如果检测到栈满，则找到一个候选解，再检查该候选解是否为可行解，如果是输出找到的一个可行解，否则不做操作。然后再将栈底的2弹出栈，继续向后回溯。值得注意的是，以下实现上述算法的代码不仅能够保证回溯过程中的任意时刻入栈的1不超过n，也能保证入栈的2不超过n，各位看官可以想想为什么。 &nbsp; 这就是回溯法求解排队问题的算法实现思路。代码实现过程中需要两个计数变量x1和x2记录回溯过程中某一时刻栈中序列中1和2的个数，通过对命题x1&gt;=x2的真值的判断就可判断栈中的部分序列是否合法，还需要计数变量count记录可行解的个数。另外需要用一个重要的布尔变量TF表示新一轮回溯操作开始时上一轮回溯操作中是否已经将栈顶的2弹出使得弹出后的栈顶即为本轮回溯操作的栈顶，从而为本轮操作是继续入栈还是弹出回溯提供依据。最后，我们需要声明重要的标志变量i记录栈顶位置，在整个回溯过程中，i会不断变动，利用i可以方便地判定栈是否只剩栈底元素以及是否栈满，同时需要利用i操作栈顶，执行压入弹出操作。 以下就是具体的C语言代码实现：（代码中部分TF赋值语句可删去，但为了逻辑和结构清晰仍予以保留） &nbsp; 以下代码在VC6.0编译环境下运行通过，n=6时可行解总数为132 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int *p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf("%d", &amp;n); //输入问题的规模 p=(int *) malloc(2*n*sizeof(int)); //创建栈 memset(p, 0, 2*n*sizeof(int)); //初始化栈 i=-1; x1=x2=0; TF=false; count=0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count while (1) &#123; if (i!=2*n-1) //栈未满 &#123; if (i==-1) //首次入栈，栈空 &#123; i++; p[i]=1; x1++; //1首先入栈,x1自增1 &#125; else //非首次入栈栈不空 &#123; if (p[i]==1) //栈顶为1 &#123; if (TF==true) //之前将2弹出栈 &#123; if (i==0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i]=2; x2++; x1--; TF=false; //2压入栈取代1,x1自减1,x2自增1 &#125; &#125; else &#123; if ((x1!=n)&amp;&amp;(x1+x2+1!=2*n)) //1未全部入栈,栈中空位大于1 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //栈顶为2 &#123; if (TF==true) &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; else &#123; if (x2&lt;=x1) //部分序列合法执行入栈操作 &#123; if (x1+x2+1==2*n) &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; else &#123; if (x1!=n) //1未全部入栈 &#123; p[++i]=1; x1++; TF=false; //1入栈 &#125; else &#123; p[++i]=2; x2++; TF=false; //2入栈 &#125; &#125; &#125; else //部分序列不合法,回溯 &#123; p[i]=0; x2--; i--; TF=true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2&lt;=x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j=0; j&lt;2*n; j++) &#123; if (p[j]==2) printf("%d ", j+1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j=0; j&lt;2*n; j++) &#123; if (p[j]==1) printf("%d ", j+1); &#125; printf("\n"); &#125; p[i]=0; x2--; i--; TF=true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数&#125; 运行结果： 2018.11.4更新 原先写的代码冗余部分太多，精简了一下，如下(编译环境变更为vs2017) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include &lt;stdio.h&gt;#include &lt;malloc.h&gt;#include &lt;string.h&gt;void selectPushedObject(int &amp;x1, int &amp;x2, int ScaleOfProblems, int *&amp;p, int &amp;i)&#123; if ((x1 != ScaleOfProblems) &amp;&amp; (x1 + x2 + 1 != 2 * ScaleOfProblems)) //1未全部入栈,栈中空位大于1 &#123; p[++i] = 1; //1入栈 x1++; &#125; else //1全部入栈或栈中只有一个空位 &#123; p[++i] = 2; //2入栈 x2++; &#125;&#125;int main()&#123; int x1, x2; int i, n; //n表示排队问题中问题的规模 int count; bool TF; //为true表明上一轮弹出2否则上一轮为入栈操作 int* p; //用于指向动态创建的一维数组,也就是保存可行解的栈 printf("请输入n\n"); scanf_s("%d", &amp;n); //输入问题的规模 p = (int*)malloc(2 * n * sizeof(int)); //创建栈 memset(p, 0, 2 * n * sizeof(int)); //初始化栈 i = 0; x1 = 1; x2 = 0; TF = false; count = 0; //初始化栈顶标志i,部分序列1,2个数x1,x2,弹出标志TF和可行解的计数变量count p[i] = 1; //首次入栈，栈空,关键变量值已在上方确定,1首先入栈,x1自增1 while (1) &#123; if (i != 2 * n - 1) //栈未满 &#123; //非首次入栈栈不空 if (p[i] == 1) //栈顶为1 &#123; if (TF == true) //之前将2弹出栈 &#123; if (i == 0) //只剩下栈底元素1,回溯结束 break; else //栈中元素个数大于1 &#123; p[i] = 2; //2压入栈取代1,x1自减1,x2自增1 x2++; x1--; TF = false; &#125; &#125; else &#123; selectPushedObject(x1, x2, n, p, i); &#125; &#125; else //栈顶为2 &#123; if (TF == true) &#123; //2弹出栈,回溯 x2--; i--; &#125; else &#123; if (x2 &lt;= x1) //部分序列合法执行入栈操作 &#123; selectPushedObject(x1, x2, n, p, i); &#125; else //部分序列不合法,回溯 &#123; x2--; i--; TF = true; //2弹出栈,回溯 &#125; &#125; &#125; &#125; else //栈满，找到候选解 &#123; if (x2 &lt;= x1) //判断候选解是否为可行解 &#123; count++; printf("第%d个排列:\n", count); int j; for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 2) printf("%d ", j + 1); &#125; printf("\n"); //候选解为可行解,输出,count自增1 for (j = 0; j &lt; 2 * n; j++) &#123; if (p[j] == 1) printf("%d ", j + 1); &#125; printf("\n"); &#125; x2--; i--; TF = true; //栈底2弹出栈回溯 &#125; &#125; printf("总共有%d个排列\n", count); //输出可行解总数 return 0;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯法，栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[试解2014ACM大赛赛题守望者逃离荒岛问题]]></title>
    <url>%2Fpost%2F15349.html</url>
    <content type="text"><![CDATA[题目如下： 恶魔猎手尤迫安野心勃勃.他背叛了暗夜精灵，率深藏在海底的那加企图叛变：守望者在与尤迪安的交锋中遭遇了围杀.被困在一个荒芜的大岛上。为了杀死守望者，尤迪安开始对这个荒岛施咒，这座岛很快就会沉下去，到那时，刀上的所有人都会遇难：守望者的跑步速度，为17m/s，&nbsp;以这样的速度是无法逃离荒岛的。庆幸的是守望者拥有闪烁法术，可在1s内移动60m，不过每次使用闪烁法术都会消耗魔法值10点。守望者的魔法值恢复的速度为4点/s，只有处在原地休息状态时才能恢复。现在已知守望者的魔法初值M，他所在的初始位置与岛的出口之间的距离L，岛沉没的时间T。你的任务是写一个程序帮助守望者计算如何在最短的时间内逃离荒岛，若不能逃出，则输出守望者在剩下的时间内能走的最远距离。注意:守望者跑步、闪烁或休息活动均以秒(s)为单位。且每次活动的持续时间为整数秒。距离的单位为米(m)。 题解：这道题很有意思，仔细想想其实不难，每单位时间守望者只能有三种动作：施法瞬移，原地休息和向前移动，我们用1表示先前移动，用2表示施法瞬移，3表示原地休息。根据题意，我们需要把沉没时间T划分为T等分：[0 1],[12]&hellip;&hellip;[T-1 T],并建立一个长度为T的双栈，这里用第一维大小为T，第二维大小为2的二维数组a[T][2]表示。a[i][0]代表i-i+1时间段内守望者的动作，可以为1,2或3,a[i][1],代表i时间点守望者的魔法值。按照一定规则利用栈逐层向下试探或向上回溯，寻找守望者可以逃离荒岛的动作序列。如果试探到t时间点守望者移动的距离l大于等于L，则守望者成功逃离荒岛，此时双栈的左侧部分a[0][0]–a[t-1][0]就存放着逃离荒岛的动作序列,利用t通过min函数做相应的计算可以得到此时守望者逃离荒岛的时间，用if语句进行简单的比较可以在试探结束时获得守望者逃离荒岛的最短时间。如果试探到T时间点守望者移动的距离l小于L，此时守望者无法逃离荒岛，而若此前一直没有试探到可行的动作序列，就通过if语句进行简单的比较以确定无法逃离荒岛时能移动的最远距离(如果之后试探到了可行动作序列，那么这种比较没有必要，但由于无法事先获知可行动作序列的存在性，所以这里只能进行比较) 我在编写程序时添加了一个附加条件：守望者的魔法初值M就是魔法上限，以上是大致的思路下面是具体的代码实现(本题很自然的想法是用贪心算法求解，但这里要求出所有解，而贪心算法用于逼近和求取最优解，所以这里没有采用贪心算法，对本程序进行适当修改可得贪心算法的版本) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257#include &lt;stdio.h&gt;#define T 9 //荒岛沉没时间#define M 7 //守望者魔法初值，也为魔法上限#define L 180 //初始位置和岛出口的距离#define R 4 //魔法值恢复速度#define Vf 17 //守望者跑步速度#define Vs 60 //守望者施法瞬移速度#define F 10 //施法消耗魔法值量void move(int a[][2], int i, int* l, int* m); //在单位时间内移动守望者，并记录守望者的状态变化void fmove(int a[][2], int i, int* l, int* m); //回溯至上一个时间点的函数，守望者状态还原至上一个时间点float min(float* tmin, int t, int l, int a[][2], int i, int* sign); //函数，计算守望者按已找到的可行动作序列逃离荒岛所需的时间void output(int a[][2], int i, int count, float interval); //输出逃出方案bool Try(int a[][2], int* fartest, float* tmin); //回溯试探函数，判断有无逃出方案，寻找逃出方案int main()&#123; int j; int fartest; //无法逃离荒岛能移动的最远距离 float tmin; //逃离荒岛最短时间 int a[T][2]; //用于回溯的双栈 bool TF; //标志能否逃出荒岛 for (j = 0; j &lt; T; j++) //双栈初始化 &#123; a[j][0] = 0; a[j][1] = -1; &#125; TF = Try(a, &amp;fartest, &amp;tmin); //试探和回溯 if (TF) &#123; printf("可以逃离荒岛\n"); printf("逃离荒岛的最短时间:%f\n", tmin); &#125; else &#123; printf("无法逃离荒岛\n"); printf("所能移动的最远距离:%d\n", fartest); &#125; return 0;&#125;bool Try(int a[][2], int* fartest, float* tmin)&#123; float interval; int i, t, l, m; int flag, sign, count; t = 1; //计时变量初始化 i = 1; //初始化栈顶标志 flag = 0; sign = 0; count = 0; while (1) &#123; if (i == 1) &#123; l = 0; m = M; a[0][1] = m; //守望者状态还原至初始值 if (T &gt;= 2 &amp;&amp; a[1][1] != -1) a[1][1] = -1; //回溯至初始状态，将t=1时的魔力值清空 a[i - 1][0]++; //试探下一种动作 if (a[i - 1][0] &gt; 3) &#123; break; //试探完毕，退出循环 &#125; if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) a[i - 1][0]++; //魔法值不够进行施法,考虑下一种动作 move(a, i, &amp;l, &amp;m); //移动守望者 if (l &gt;= L) //找到可行动作序列 &#123; count++; //方案计数变量增一 interval = min(tmin, t, l, a, i, &amp;sign); //计算当前可行逃出方案的逃出时间，进行相应比较，以确定最短逃出时间 output(a, i, count, interval); //输出可行逃出方案 continue; //开始新一轮循环,回溯 &#125; t++; i++; //向前试探 &#125; else &#123; if (a[i - 1][0] + 1 &gt; 3) //当前时间段已无动作可供尝试，回溯 &#123; fmove(a, i, &amp;l, &amp;m); //回溯，恢复守望者状态至前一时间点 a[i - 1][0] = 0; //本时间段动作清零 t--; i--; //向后回溯 &#125; else &#123; if (a[i - 1][0] != 0) //回溯至本时间段后需要改变原有动作尝试下一个新动作 &#123; fmove(a, i, &amp;l, &amp;m); //同上 &#125; a[i - 1][0]++; //同上 if (a[i - 1][0] == 1 &amp;&amp; F &gt; m) //同上 a[i - 1][0]++; move(a, i, &amp;l, &amp;m); //同上 if (l &gt;= L) //同上 &#123; count++; interval = min(tmin, t, l, a, i, &amp;sign); output(a, i, count, interval); continue; &#125; else &#123; if (i == T) //逃离荒岛失败 &#123; if (sign == 0) //之前没有找到可行动作序列 &#123; if (flag == 0) &#123; *fartest = l; flag = 1; &#125; //简单的比较,以找出不能逃离荒岛时可移动最远距离 else &#123; if (l &gt; * fartest) * fartest = l; &#125; continue; //开始新一轮循环，回溯 &#125; &#125; else &#123; t++; //当前时间点既未逃出荒岛，时间也未用尽，继续向前试探 i++; continue; &#125; &#125; &#125; &#125; &#125; printf("总共有%d种逃出方案\n", count); //输出逃出方案总数 if (sign == 1) return true; //返回标志是否可以逃离荒岛的布尔常量 else return false;&#125;void move(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按第一种动作移动时状态变化 &#123; *l = Vf + *l; &#125; else if (a[i - 1][0] == 1) //按第二种动作施法瞬移移动时状态变化 &#123; *l = Vs + *l; *m = *m - F; &#125; else //按第三种动作原地休息时的状态变化 &#123; if (*m + R &lt;= M) &#123; *m = *m + R; &#125; else &#123; *m = M; &#125; &#125; if (i != T) a[i][1] = *m; //更新状态变化后的本时间点的魔法值，为回溯时还原魔法值作准备&#125;void fmove(int a[][2], int i, int* l, int* m)&#123; if (a[i - 1][0] == 2) //按向前移动还原状态 &#123; *l = *l - Vf; &#125; else if (a[i - 1][0] == 1) //按施法瞬移还原状态 &#123; *l = *l - Vs; *m = *m + F; &#125; else &#123; *m = a[i - 1][1]; //按原地休息还原状态 &#125; if (i != T) a[i][1] = -1; //记录本时间点魔法值的存储单元清空&#125;float min(float* tmin, int t, int l, int a[][2], int i, int* sign)&#123; if (l == L) //时间点i正好已移动了距离L &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t; //逃离时间为t,比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t) * tmin = t; &#125; return (float)t; //逃离时间就为t,返回 &#125; else //时间点i移动距离超过L &#123; if (a[i - 1][0] == 2) //按向前移动计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vf; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vf) * tmin = t - (l - L) / (float)Vf; &#125; return t - (l - L) / (float)Vf; //逃出荒岛时间为t-(l-L)/(float)Vf，返回 &#125; else //按施法瞬移计算真实的逃出荒岛时间 &#123; if (*sign == 0) &#123; *sign = 1; *tmin = t - (l - L) / (float)Vs; //作简单的比较确定最短逃离时间 &#125; else &#123; if (*tmin &gt; t - (l - L) / (float)Vs) * tmin = t - (l - L) / (float)Vs; &#125; return t - (l - L) / (float)Vs; //逃出荒岛时间为t-(l-L)/(float)Vs，返回 &#125; &#125;&#125;void output(int a[][2], int i, int count, float interval)&#123; int j; printf("第%d种逃出方案\n", count); for (j = 1; j &lt;= i; j++) &#123; printf("time%d to time%d\n", j - 1, j); if (a[j - 1][0] == 1) printf("施法瞬移\n"); //逃出方案和逃出时间输出 else if (a[j - 1][0] == 2) printf("向前移动\n"); else printf("原地休息\n"); &#125; printf("逃离荒岛所用时间:%f\n", interval);&#125; 运行结果： 可以验证以上运行结果是正确的，因为魔法上限为7，守望者无法施法，只能跑步和休息，就算充分利用逃出时间，只跑步不休息最多只能移动9*17=153米的距离，因此无法逃出荒岛且最多只能移动153米远的距离。 &nbsp;更新：使用贪心算法对源代码进行修改，每次总是优先尝试施法，其次移动，然后才是原地休息，这样能更快得到结果]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>ACM竞赛，贪心算法</tag>
      </tags>
  </entry>
</search>
